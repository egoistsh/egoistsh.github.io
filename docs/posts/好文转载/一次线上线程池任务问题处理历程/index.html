<!DOCTYPE html>
<html lang="zh-CN">
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="robots" content="noodp" />
        <meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1">
        <title>一次线上线程池任务问题处理历程 - Kaze Site</title><meta name="Description" content="关于自我"><meta property="og:title" content="一次线上线程池任务问题处理历程" />
<meta property="og:description" content="一、前言 在一次新功能上线过程中，出现线程池提交任务抛出 RejectedExecutionException 异常，即任务提交执行了拒绝策略的操作。查看业务情况和线程池配置，发现并行执行的任务数" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://example.org/posts/%E5%A5%BD%E6%96%87%E8%BD%AC%E8%BD%BD/%E4%B8%80%E6%AC%A1%E7%BA%BF%E4%B8%8A%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%BB%BB%E5%8A%A1%E9%97%AE%E9%A2%98%E5%A4%84%E7%90%86%E5%8E%86%E7%A8%8B/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-03-21T10:20:04&#43;08:00" />
<meta property="article:modified_time" content="2022-03-21T10:20:04&#43;08:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="一次线上线程池任务问题处理历程"/>
<meta name="twitter:description" content="一、前言 在一次新功能上线过程中，出现线程池提交任务抛出 RejectedExecutionException 异常，即任务提交执行了拒绝策略的操作。查看业务情况和线程池配置，发现并行执行的任务数"/>
<meta name="application-name" content="Kaze">
<meta name="apple-mobile-web-app-title" content="Kaze"><meta name="theme-color" content="#ffffff"><meta name="msapplication-TileColor" content="#da532c"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico" />
        <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
        <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"><link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5"><link rel="manifest" href="/site.webmanifest"><link rel="canonical" href="http://example.org/posts/%E5%A5%BD%E6%96%87%E8%BD%AC%E8%BD%BD/%E4%B8%80%E6%AC%A1%E7%BA%BF%E4%B8%8A%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%BB%BB%E5%8A%A1%E9%97%AE%E9%A2%98%E5%A4%84%E7%90%86%E5%8E%86%E7%A8%8B/" /><link rel="prev" href="http://example.org/posts/%E5%A5%BD%E6%96%87%E8%BD%AC%E8%BD%BD/%E4%B8%80%E5%B9%B4-40-%E4%B8%87%E6%AC%A1%E5%AE%9E%E9%AA%8C%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A8-ab-%E6%B5%8B%E8%AF%95%E5%B9%B3%E5%8F%B0%E6%98%AF%E6%80%8E%E4%B9%88%E7%82%BC%E5%87%BA%E6%9D%A5%E7%9A%84/" /><link rel="next" href="http://example.org/posts/%E7%94%9F%E6%B4%BB/%E6%97%A5%E8%AF%AD%E8%AF%AD%E6%B3%95%E7%AC%94%E8%AE%B0%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0ing/" /><link rel="stylesheet" href="/lib/normalize/normalize.min.css"><link rel="stylesheet" href="/css/style.min.css"><link rel="stylesheet" href="/lib/fontawesome-free/all.min.css"><link rel="stylesheet" href="/lib/animate/animate.min.css"><script type="application/ld+json">
    {
        "@context": "http://schema.org",
        "@type": "BlogPosting",
        "headline": "一次线上线程池任务问题处理历程",
        "inLanguage": "zh-CN",
        "mainEntityOfPage": {
            "@type": "WebPage",
            "@id": "http:\/\/example.org\/posts\/%E5%A5%BD%E6%96%87%E8%BD%AC%E8%BD%BD\/%E4%B8%80%E6%AC%A1%E7%BA%BF%E4%B8%8A%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%BB%BB%E5%8A%A1%E9%97%AE%E9%A2%98%E5%A4%84%E7%90%86%E5%8E%86%E7%A8%8B\/"
        },"genre": "posts","keywords": "问题排查, 线程池","wordcount":  3002 ,
        "url": "http:\/\/example.org\/posts\/%E5%A5%BD%E6%96%87%E8%BD%AC%E8%BD%BD\/%E4%B8%80%E6%AC%A1%E7%BA%BF%E4%B8%8A%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%BB%BB%E5%8A%A1%E9%97%AE%E9%A2%98%E5%A4%84%E7%90%86%E5%8E%86%E7%A8%8B\/","datePublished": "2022-03-21T10:20:04+08:00","dateModified": "2022-03-21T10:20:04+08:00","license": "This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.","publisher": {
            "@type": "Organization",
            "name": "Billy"},"author": {
                "@type": "Person",
                "name": "Billy"
            },"description": ""
    }
    </script></head>
    <body header-desktop="" header-mobile=""><script type="text/javascript">(window.localStorage && localStorage.getItem('theme') ? localStorage.getItem('theme') === 'dark' : ('' === 'auto' ? window.matchMedia('(prefers-color-scheme: dark)').matches : '' === 'dark')) && document.body.setAttribute('theme', 'dark');</script>

        <div id="mask"></div><div class="wrapper"><header class="desktop" id="header-desktop">
    <div class="header-wrapper">
        <div class="header-title">
            <a href="/" title="Kaze Site">Kaze Site</a>
        </div>
        <div class="menu">
            <div class="menu-inner"><a class="menu-item" href="/posts/"> 所有文章 </a><a class="menu-item" href="/tags/"> 标签 </a><a class="menu-item" href="/categories/"> 分类 </a><a class="menu-item" href="/" title="GitHub"><i class='fab fa-github fa-fw'></i>  </a><span class="menu-item delimiter"></span><span class="menu-item search" id="search-desktop">
                        <input type="text" placeholder="搜索文章标题或内容..." id="search-input-desktop">
                        <a href="javascript:void(0);" class="search-button search-toggle" id="search-toggle-desktop" title="搜索">
                            <i class="fas fa-search fa-fw"></i>
                        </a>
                        <a href="javascript:void(0);" class="search-button search-clear" id="search-clear-desktop" title="清空">
                            <i class="fas fa-times-circle fa-fw"></i>
                        </a>
                        <span class="search-button search-loading" id="search-loading-desktop">
                            <i class="fas fa-spinner fa-fw fa-spin"></i>
                        </span>
                    </span><a href="javascript:void(0);" class="menu-item theme-switch" title="切换主题">
                    <i class="fas fa-adjust fa-fw"></i>
                </a>
            </div>
        </div>
    </div>
</header><header class="mobile" id="header-mobile">
    <div class="header-container">
        <div class="header-wrapper">
            <div class="header-title">
                <a href="/" title="Kaze Site">Kaze Site</a>
            </div>
            <div class="menu-toggle" id="menu-toggle-mobile">
                <span></span><span></span><span></span>
            </div>
        </div>
        <div class="menu" id="menu-mobile"><div class="search-wrapper">
                    <div class="search mobile" id="search-mobile">
                        <input type="text" placeholder="搜索文章标题或内容..." id="search-input-mobile">
                        <a href="javascript:void(0);" class="search-button search-toggle" id="search-toggle-mobile" title="搜索">
                            <i class="fas fa-search fa-fw"></i>
                        </a>
                        <a href="javascript:void(0);" class="search-button search-clear" id="search-clear-mobile" title="清空">
                            <i class="fas fa-times-circle fa-fw"></i>
                        </a>
                        <span class="search-button search-loading" id="search-loading-mobile">
                            <i class="fas fa-spinner fa-fw fa-spin"></i>
                        </span>
                    </div>
                    <a href="javascript:void(0);" class="search-cancel" id="search-cancel-mobile">
                        取消
                    </a>
                </div><a class="menu-item" href="/posts/" title="">所有文章</a><a class="menu-item" href="/tags/" title="">标签</a><a class="menu-item" href="/categories/" title="">分类</a><a class="menu-item" href="/" title="GitHub"><i class='fab fa-github fa-fw'></i></a><a href="javascript:void(0);" class="menu-item theme-switch" title="切换主题">
                <i class="fas fa-adjust fa-fw"></i>
            </a></div>
    </div>
</header>
<div class="search-dropdown desktop">
    <div id="search-dropdown-desktop"></div>
</div>
<div class="search-dropdown mobile">
    <div id="search-dropdown-mobile"></div>
</div>
<main class="main">
                <div class="container"><div class="toc" id="toc-auto">
            <h2 class="toc-title">目录</h2>
            <div class="toc-content" id="toc-content-auto"></div>
        </div><article class="page single"><h1 class="single-title animated flipInX">一次线上线程池任务问题处理历程</h1><div class="post-meta">
            <div class="post-meta-line"><span class="post-author"><a href="/" title="Author" rel=" author" class="author"><i class="fas fa-user-circle fa-fw"></i>Billy</a></span>&nbsp;<span class="post-category">收录于 <a href="/categories/%E5%A5%BD%E6%96%87%E8%BD%AC%E8%BD%BD/"><i class="far fa-folder fa-fw"></i>好文转载</a></span></div>
            <div class="post-meta-line"><i class="far fa-calendar-alt fa-fw"></i>&nbsp;<time datetime="2022-03-21">2022-03-21</time>&nbsp;<i class="fas fa-pencil-alt fa-fw"></i>&nbsp;约 3002 字&nbsp;
                <i class="far fa-clock fa-fw"></i>&nbsp;预计阅读 6 分钟&nbsp;</div>
        </div><div class="details toc" id="toc-static"  kept="">
                <div class="details-summary toc-title">
                    <span>目录</span>
                    <span><i class="details-icon fas fa-angle-right"></i></span>
                </div>
                <div class="details-content toc-content" id="toc-content-static"><nav id="TableOfContents">
  <ul>
    <li><a href="#一前言">一、前言</a></li>
    <li><a href="#二业务情景">二、业务情景</a>
      <ul>
        <li><a href="#21-任务描述">2.1. 任务描述</a></li>
        <li><a href="#22-任务提交流程">2.2. 任务提交流程</a></li>
        <li><a href="#23-线程池配置">2.3. 线程池配置</a></li>
      </ul>
    </li>
    <li><a href="#三出现问题">三、出现问题</a></li>
    <li><a href="#四问题排查">四、问题排查</a>
      <ul>
        <li><a href="#41-检查线程池配置">4.1. 检查线程池配置</a></li>
        <li><a href="#42-检查业务代码">4.2. 检查业务代码</a></li>
        <li><a href="#43-线下重现">4.3. 线下重现</a></li>
      </ul>
    </li>
    <li><a href="#五线程池源码阅读">五、线程池源码阅读</a>
      <ul>
        <li><a href="#51-线程池执行任务流程">5.1. 线程池执行任务流程</a></li>
        <li><a href="#52-execute-线程池提交任务源码">5.2. execute 线程池提交任务源码</a></li>
        <li><a href="#53-addworker-添加-worker-线程">5.3. addWorker 添加 worker 线程</a></li>
      </ul>
    </li>
    <li><a href="#六问题定位">六、问题定位</a>
      <ul>
        <li><a href="#61-定位执行拒绝策略入口">6.1. 定位执行拒绝策略入口</a></li>
        <li><a href="#62-定位执行拒绝策略原因">6.2. 定位执行拒绝策略原因</a></li>
      </ul>
    </li>
    <li><a href="#七问题确认">七、问题确认</a></li>
    <li><a href="#八定位原因">八、定位原因</a>
      <ul>
        <li><a href="#81-分析-execute-方法">8.1. 分析 execute 方法</a></li>
        <li><a href="#82-猜测原因">8.2. 猜测原因</a></li>
        <li><a href="#83-原因验证">8.3. 原因验证</a></li>
      </ul>
    </li>
    <li><a href="#九解决方式">九、解决方式</a>
      <ul>
        <li><a href="#91-使用-synchronousqueue">9.1. 使用 SynchronousQueue</a></li>
        <li><a href="#92-根据业务情况配置阻塞队列">9.2. 根据业务情况配置阻塞队列</a></li>
      </ul>
    </li>
  </ul>
</nav></div>
            </div><div class="content" id="content"><h2 id="一前言">一、前言</h2>
<p>在一次新功能上线过程中，出现线程池提交任务抛出 RejectedExecutionException 异常，即任务提交执行了拒绝策略的操作。查看业务情况和线程池配置，发现并行执行的任务数是小于线程池最大线程数的，为此展开了一次线程池问题排查历程。</p>
<h2 id="二业务情景">二、业务情景</h2>
<h3 id="21-任务描述">2.1. 任务描述</h3>
<p>每次执行一组任务，一组任务最多有 15 个，多线程执行，每个线程处理一个任务；每次执行完一组任务后，再执行下一组，不存在上一组的任务和下一组一起执行的情况。</p>
<h3 id="22-任务提交流程">2.2. 任务提交流程</h3>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0hvj075zcj20ua0q40th.jpg"
        data-srcset="https://tva1.sinaimg.cn/large/e6c9d24ely1h0hvj075zcj20ua0q40th.jpg, https://tva1.sinaimg.cn/large/e6c9d24ely1h0hvj075zcj20ua0q40th.jpg 1.5x, https://tva1.sinaimg.cn/large/e6c9d24ely1h0hvj075zcj20ua0q40th.jpg 2x"
        data-sizes="auto"
        alt="https://tva1.sinaimg.cn/large/e6c9d24ely1h0hvj075zcj20ua0q40th.jpg"
        title="image-20220321223003902" /></p>
<h3 id="23-线程池配置">2.3. 线程池配置</h3>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="o">&lt;</span><span class="n">bean</span> <span class="n">id</span><span class="o">=</span><span class="s">&#34;executor&#34;</span> <span class="n">class</span><span class="o">=</span><span class="s">&#34;org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor&#34;</span><span class="o">&gt;</span>
    <span class="o">&lt;</span><span class="n">property</span> <span class="n">name</span><span class="o">=</span><span class="s">&#34;corePoolSize&#34;</span> <span class="n">value</span><span class="o">=</span><span class="s">&#34;14&#34;</span><span class="o">/&gt;</span>
    <span class="o">&lt;</span><span class="n">property</span> <span class="n">name</span><span class="o">=</span><span class="s">&#34;maxPoolSize&#34;</span> <span class="n">value</span><span class="o">=</span><span class="s">&#34;30&#34;</span><span class="o">/&gt;</span>
    <span class="o">&lt;</span><span class="n">property</span> <span class="n">name</span><span class="o">=</span><span class="s">&#34;queueCapacity&#34;</span> <span class="n">value</span><span class="o">=</span><span class="s">&#34;1&#34;</span><span class="o">/&gt;</span>
<span class="o">&lt;/</span><span class="n">bean</span><span class="o">&gt;</span>
</code></pre></div><h2 id="三出现问题">三、出现问题</h2>
<p>执行过程中出现 RejectedExecutionException 异常，由于是采用的是默认拒绝策略 AbortPolicy，因此，可以明确知道任务是提交到线程池后，线程池资源已满，导致任务被拒绝。</p>
<h2 id="四问题排查">四、问题排查</h2>
<h3 id="41-检查线程池配置">4.1. 检查线程池配置</h3>
<p>任务最多 15 个一组，核心线程有 14 个，阻塞队列是 1，最大线程 30，理论上 14 个核心线程+1 个阻塞队列即可完成一组任务，连非核心线程都无需使用，为什么会出现线程被占满的情况？</p>
<h3 id="42-检查业务代码">4.2. 检查业务代码</h3>
<p>检查是否存在线程池被多处使用，或者有多批任务被同时执行的情况，并没有发现错误；</p>
<h3 id="43-线下重现">4.3. 线下重现</h3>
<ul>
<li>配置线程池</li>
</ul>
<pre><code>&lt;bean id=&quot;executor&quot; class=&quot;org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor&quot;&gt;
    &lt;property name=&quot;corePoolSize&quot; value=&quot;14&quot;/&gt;
    &lt;property name=&quot;maxPoolSize&quot; value=&quot;30&quot;/&gt;
    &lt;property name=&quot;queueCapacity&quot; value=&quot;1&quot;/&gt;
&lt;/bean&gt;
</code></pre><ul>
<li>建立 demo 代码</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="nd">@RunWith</span><span class="o">(</span><span class="n">SpringRunner</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
<span class="nd">@SpringBootTest</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">SpringBootStartApplicationTests</span> <span class="o">{</span>

    <span class="nd">@Resource</span>
    <span class="kd">private</span> <span class="n">ThreadPoolTaskExecutor</span> <span class="n">executor</span><span class="o">;</span>

    <span class="nd">@Test</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">contextLoads</span><span class="o">()</span> <span class="kd">throws</span> <span class="n">Exception</span> <span class="o">{</span>
        <span class="c1">// 一共 10 批任务
</span><span class="c1"></span>        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">10</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="c1">// 每次执行一批任务
</span><span class="c1"></span>            <span class="n">doOnceTasks</span><span class="o">();</span>
            <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;---------------------------------------&#34;</span> <span class="o">+</span> <span class="n">i</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="cm">/**
</span><span class="cm">     * 每次完成 15 个任务后，再进行下一次任务
</span><span class="cm">     */</span>
    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">doOnceTasks</span><span class="o">(){</span>
        <span class="n">List</span><span class="o">&lt;</span><span class="n">Future</span><span class="o">&gt;</span> <span class="n">futureList</span> <span class="o">=</span> <span class="n">Lists</span><span class="o">.</span><span class="na">newArrayListWithCapacity</span><span class="o">(</span><span class="n">15</span><span class="o">);</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">15</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="n">Future</span> <span class="n">future</span> <span class="o">=</span> <span class="n">executor</span><span class="o">.</span><span class="na">submit</span><span class="o">(()-&gt;{</span>
                <span class="c1">// 随机睡 0-5 秒
</span><span class="c1"></span>                <span class="kt">int</span> <span class="n">sec</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Double</span><span class="o">(</span><span class="n">Math</span><span class="o">.</span><span class="na">random</span><span class="o">()</span> <span class="o">*</span> <span class="n">5</span><span class="o">).</span><span class="na">intValue</span><span class="o">();</span>
                <span class="n">LockSupport</span><span class="o">.</span><span class="na">parkNanos</span><span class="o">(</span><span class="n">sec</span> <span class="o">*</span> <span class="n">1000</span> <span class="o">*</span> <span class="n">1000</span> <span class="o">*</span> <span class="n">1000</span><span class="o">);</span>
                <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">getName</span><span class="o">()</span> <span class="o">+</span> <span class="s">&#34;  end&#34;</span><span class="o">);</span>
            <span class="o">});</span>
            <span class="n">futureList</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">future</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="c1">// 等待所有任务执行结束
</span><span class="c1"></span>        <span class="k">for</span><span class="o">(</span><span class="n">Future</span> <span class="n">future</span> <span class="o">:</span> <span class="n">futureList</span><span class="o">){</span>
            <span class="k">try</span> <span class="o">{</span>
                <span class="n">future</span><span class="o">.</span><span class="na">get</span><span class="o">();</span>
            <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">Exception</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><ul>
<li>异常重现</li>
</ul>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://xiaomi-info.github.io/2019/12/19/theadpool-rejected-task/theadpool-rejected-task-06.png"
        data-srcset="https://xiaomi-info.github.io/2019/12/19/theadpool-rejected-task/theadpool-rejected-task-06.png, https://xiaomi-info.github.io/2019/12/19/theadpool-rejected-task/theadpool-rejected-task-06.png 1.5x, https://xiaomi-info.github.io/2019/12/19/theadpool-rejected-task/theadpool-rejected-task-06.png 2x"
        data-sizes="auto"
        alt="https://xiaomi-info.github.io/2019/12/19/theadpool-rejected-task/theadpool-rejected-task-06.png"
        title="img" /></p>
<h2 id="五线程池源码阅读">五、线程池源码阅读</h2>
<h3 id="51-线程池执行任务流程">5.1. 线程池执行任务流程</h3>
<ul>
<li>当工作线程数 &lt; corePoolSize 时，新创建一个新线程执行新提交任务，即使此时线程池中存在空闲线程；</li>
<li>当工作线程数 == corePoolSize 时，新提交任务将被放入 workQueue 中；</li>
<li>当 workQueue 已满，且工作线程数 &lt; maximumPoolSize 时，新提交任务会创建新的非核心线程执行任务；</li>
<li>当 workQueue 已满，且 工作线程数==maximumPoolSize 时，新提交任务由 RejectedExecutionHandler 处理；</li>
</ul>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0hvig6adrj20ux0u0dh5.jpg"
        data-srcset="https://tva1.sinaimg.cn/large/e6c9d24ely1h0hvig6adrj20ux0u0dh5.jpg, https://tva1.sinaimg.cn/large/e6c9d24ely1h0hvig6adrj20ux0u0dh5.jpg 1.5x, https://tva1.sinaimg.cn/large/e6c9d24ely1h0hvig6adrj20ux0u0dh5.jpg 2x"
        data-sizes="auto"
        alt="https://tva1.sinaimg.cn/large/e6c9d24ely1h0hvig6adrj20ux0u0dh5.jpg"
        title="image-20220321222931168" /></p>
<h3 id="52-execute-线程池提交任务源码">5.2. execute 线程池提交任务源码</h3>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">class</span> <span class="nc">ThreadPoolExecutor</span><span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">execute</span><span class="o">(</span><span class="n">Runnable</span> <span class="n">command</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 提交任务不能为 null
</span><span class="c1"></span>        <span class="k">if</span> <span class="o">(</span><span class="n">command</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="n">NullPointerException</span><span class="o">();</span>

        <span class="c1">// 获取控制位 ctl 的值
</span><span class="c1"></span>        <span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="n">ctl</span><span class="o">.</span><span class="na">get</span><span class="o">();</span>
        <span class="c1">// work 线程数 &lt; 核心线程数
</span><span class="c1"></span>        <span class="k">if</span> <span class="o">(</span><span class="n">workerCountOf</span><span class="o">(</span><span class="n">c</span><span class="o">)</span> <span class="o">&lt;</span> <span class="n">corePoolSize</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// 直接创建核心线程，执行任务
</span><span class="c1"></span>            <span class="k">if</span> <span class="o">(</span><span class="n">addWorker</span><span class="o">(</span><span class="n">command</span><span class="o">,</span> <span class="kc">true</span><span class="o">))</span>
                <span class="k">return</span><span class="o">;</span>

            <span class="cm">/*
</span><span class="cm">                因为没有使用锁，可能会出现并发创建核心线程；
</span><span class="cm">                走到这里，说明核心线程已经创建满了，此时，重新获取控制位 ctl 的值
</span><span class="cm">              */</span>
            <span class="n">c</span> <span class="o">=</span> <span class="n">ctl</span><span class="o">.</span><span class="na">get</span><span class="o">();</span>
        <span class="o">}</span>

        <span class="c1">// 如果线程池还是 RUNNING 状态，并且任务成功提交到阻塞队列中
</span><span class="c1"></span>        <span class="k">if</span> <span class="o">(</span><span class="n">isRunning</span><span class="o">(</span><span class="n">c</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="n">workQueue</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">command</span><span class="o">))</span> <span class="o">{</span>
            <span class="kt">int</span> <span class="n">recheck</span> <span class="o">=</span> <span class="n">ctl</span><span class="o">.</span><span class="na">get</span><span class="o">();</span>
            <span class="c1">// double-check，再检查一次线程池状态
</span><span class="c1"></span>            <span class="c1">// 如果线程池变成非 RUNNING 状态，则回滚刚才新加的任务
</span><span class="c1"></span>            <span class="k">if</span> <span class="o">(!</span> <span class="n">isRunning</span><span class="o">(</span><span class="n">recheck</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="n">remove</span><span class="o">(</span><span class="n">command</span><span class="o">))</span>
                <span class="c1">// 从阻塞队列中移除任务成功，使用拒绝策略执行任务
</span><span class="c1"></span>                <span class="n">reject</span><span class="o">(</span><span class="n">command</span><span class="o">);</span>

            <span class="c1">// 如果工作线程数==0，则添加一个线程
</span><span class="c1"></span>            <span class="c1">// 主要是兼容核心线程数==0 的情况
</span><span class="c1"></span>            <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">workerCountOf</span><span class="o">(</span><span class="n">recheck</span><span class="o">)</span> <span class="o">==</span> <span class="n">0</span><span class="o">)</span>
                <span class="n">addWorker</span><span class="o">(</span><span class="kc">null</span><span class="o">,</span> <span class="kc">false</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="cm">/*
</span><span class="cm">            到达这里，则说明核心线程数已满，且阻塞队列已满
</span><span class="cm">            尝试创建非核心线程执行任务
</span><span class="cm">        */</span>
        <span class="k">else</span> <span class="k">if</span> <span class="o">(!</span><span class="n">addWorker</span><span class="o">(</span><span class="n">command</span><span class="o">,</span> <span class="kc">false</span><span class="o">))</span>
            <span class="c1">// 非核心线程创建失败了，说明是线程数以达到 maximumPoolSize，此时执行拒绝策略
</span><span class="c1"></span>            <span class="n">reject</span><span class="o">(</span><span class="n">command</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><h3 id="53-addworker-添加-worker-线程">5.3. addWorker 添加 worker 线程</h3>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">class</span> <span class="nc">ThreadPoolExecutor</span><span class="o">{</span>
    <span class="cm">/**
</span><span class="cm">     * 添加一个 worker 线程
</span><span class="cm">     * @param firstTask 第一个要执行的 task
</span><span class="cm">     * @param core 是否是核心线程
</span><span class="cm">     * @return 创建成功还是失败
</span><span class="cm">     */</span>
    <span class="kd">private</span> <span class="kt">boolean</span> <span class="nf">addWorker</span><span class="o">(</span><span class="n">Runnable</span> <span class="n">firstTask</span><span class="o">,</span> <span class="kt">boolean</span> <span class="n">core</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 定义了一个 retry 标签
</span><span class="c1"></span>        <span class="n">retry</span><span class="o">:</span>
        <span class="k">for</span> <span class="o">(;;)</span> <span class="o">{</span>
            <span class="c1">// 获取控制位
</span><span class="c1"></span>            <span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="n">ctl</span><span class="o">.</span><span class="na">get</span><span class="o">();</span>
            <span class="c1">// 获取运行状态
</span><span class="c1"></span>            <span class="kt">int</span> <span class="n">rs</span> <span class="o">=</span> <span class="n">runStateOf</span><span class="o">(</span><span class="n">c</span><span class="o">);</span>

            <span class="cm">/**
</span><span class="cm">             * rs &gt;= SHUTDOWN：即非 RUNNING 状态，只有 RUNNING &lt; SHUTDOWN
</span><span class="cm">             * ! (rs == SHUTDOWN &amp;&amp; firstTask == null &amp;&amp; ! workQueue.isEmpty())
</span><span class="cm">             *      等价于 非 SHUTDOWN 态 ||  firstTask != null || workQueue.isEmpty()
</span><span class="cm">             *      非 SHUTDOWN 态 == true：SHUTDOWN 态之后的状态，都不允许再添加 worker 线程了，直接返回 false；
</span><span class="cm">             *      非 SHUTDOWN 态 == false || (firstTask != null) == true：SHUTDOWN 状态下，不允许再添加任务了，返回 false；
</span><span class="cm">             *      非 SHUTDOWN 态 == false || (firstTask != null) == false || workQueue.isEmpty() == true：SHUTDOWN 状态，没提交新任务，阻塞队列又是空的，没必要再添加线程了
</span><span class="cm">             */</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">rs</span> <span class="o">&gt;=</span> <span class="n">SHUTDOWN</span> <span class="o">&amp;&amp;</span>
                <span class="o">!</span> <span class="o">(</span><span class="n">rs</span> <span class="o">==</span> <span class="n">SHUTDOWN</span> <span class="o">&amp;&amp;</span>
                   <span class="n">firstTask</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span>
                   <span class="o">!</span> <span class="n">workQueue</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()))</span>
                <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>

            <span class="c1">// CAS 创建 worker 线程
</span><span class="c1"></span>            <span class="k">for</span> <span class="o">(;;)</span> <span class="o">{</span>
                <span class="c1">// 获取线程数
</span><span class="c1"></span>                <span class="kt">int</span> <span class="n">wc</span> <span class="o">=</span> <span class="n">workerCountOf</span><span class="o">(</span><span class="n">c</span><span class="o">);</span>
                <span class="cm">/*
</span><span class="cm">                当前线程数大于最大值
</span><span class="cm">                    或
</span><span class="cm">                当前创建的是核心线程，但线程数量已经&gt;=核心线程数
</span><span class="cm">                    或
</span><span class="cm">                当前创建非核心线程，但线程数量已经&gt;=maximumPoolSize
</span><span class="cm">                */</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">wc</span> <span class="o">&gt;=</span> <span class="n">CAPACITY</span> <span class="o">||</span>
                    <span class="n">wc</span> <span class="o">&gt;=</span> <span class="o">(</span><span class="n">core</span> <span class="o">?</span> <span class="n">corePoolSize</span> <span class="o">:</span> <span class="n">maximumPoolSize</span><span class="o">))</span>
                    <span class="c1">// 不创建，直接返回 false
</span><span class="c1"></span>                    <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>

                <span class="c1">// cas 修改 ctl 中的线程数，线程数+1
</span><span class="c1"></span>                <span class="k">if</span> <span class="o">(</span><span class="n">compareAndIncrementWorkerCount</span><span class="o">(</span><span class="n">c</span><span class="o">))</span>
                    <span class="c1">// cas 修改成功，break goto 结束循环（不会再进入标签下的循环）
</span><span class="c1"></span>                    <span class="k">break</span> <span class="n">retry</span><span class="o">;</span>

                <span class="c1">// 达到这里，说明 cas 增加线程数 1 失败了，此时进行尝试
</span><span class="c1"></span>                <span class="n">c</span> <span class="o">=</span> <span class="n">ctl</span><span class="o">.</span><span class="na">get</span><span class="o">();</span>
                <span class="c1">// 先判断一下线程池状态有没有改变，如果改变了，则 continue goto（会再进入标签下的循环）
</span><span class="c1"></span>                <span class="c1">// 跳转到最外层的循环，重新检测线程池的状态值
</span><span class="c1"></span>                <span class="k">if</span> <span class="o">(</span><span class="n">runStateOf</span><span class="o">(</span><span class="n">c</span><span class="o">)</span> <span class="o">!=</span> <span class="n">rs</span><span class="o">)</span>
                    <span class="k">continue</span> <span class="n">retry</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="kt">boolean</span> <span class="n">workerStarted</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
        <span class="kt">boolean</span> <span class="n">workerAdded</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
        <span class="n">Worker</span> <span class="n">w</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="c1">// 创建 worker 对象
</span><span class="c1"></span>            <span class="n">w</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Worker</span><span class="o">(</span><span class="n">firstTask</span><span class="o">);</span>
            <span class="c1">// 获取 worker 的线程
</span><span class="c1"></span>            <span class="kd">final</span> <span class="n">Thread</span> <span class="n">t</span> <span class="o">=</span> <span class="n">w</span><span class="o">.</span><span class="na">thread</span><span class="o">;</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">t</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                <span class="c1">// 加锁
</span><span class="c1"></span>                <span class="kd">final</span> <span class="n">ReentrantLock</span> <span class="n">mainLock</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">mainLock</span><span class="o">;</span>
                <span class="n">mainLock</span><span class="o">.</span><span class="na">lock</span><span class="o">();</span>
                <span class="k">try</span> <span class="o">{</span>
                    <span class="c1">// 获取线程池状态
</span><span class="c1"></span>                    <span class="kt">int</span> <span class="n">rs</span> <span class="o">=</span> <span class="n">runStateOf</span><span class="o">(</span><span class="n">ctl</span><span class="o">.</span><span class="na">get</span><span class="o">());</span>

                    <span class="cm">/*
</span><span class="cm">                     线程池是 RUNNING 状态
</span><span class="cm">                        或
</span><span class="cm">                     SHUTDOWN 态 且 firstTask == null（这种情况是需要创建线程，消费队列中剩余的任务）
</span><span class="cm">                      */</span>
                    <span class="k">if</span> <span class="o">(</span><span class="n">rs</span> <span class="o">&lt;</span> <span class="n">SHUTDOWN</span> <span class="o">||</span>
                        <span class="o">(</span><span class="n">rs</span> <span class="o">==</span> <span class="n">SHUTDOWN</span> <span class="o">&amp;&amp;</span> <span class="n">firstTask</span> <span class="o">==</span> <span class="kc">null</span><span class="o">))</span> <span class="o">{</span>
                        <span class="c1">// 线程是活动状态，则不合法，因为线程是刚创建的，应该是 NEW 状态
</span><span class="c1"></span>                        <span class="k">if</span> <span class="o">(</span><span class="n">t</span><span class="o">.</span><span class="na">isAlive</span><span class="o">())</span>
                            <span class="k">throw</span> <span class="k">new</span> <span class="n">IllegalThreadStateException</span><span class="o">();</span>

                        <span class="c1">// 将 worker 添加到 list 中
</span><span class="c1"></span>                        <span class="n">workers</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">w</span><span class="o">);</span>
                        <span class="c1">// largestPoolSize 记录该线程池使用过程中，达到最大的线程数
</span><span class="c1"></span>                        <span class="kt">int</span> <span class="n">s</span> <span class="o">=</span> <span class="n">workers</span><span class="o">.</span><span class="na">size</span><span class="o">();</span>
                        <span class="k">if</span> <span class="o">(</span><span class="n">s</span> <span class="o">&gt;</span> <span class="n">largestPoolSize</span><span class="o">)</span>
                            <span class="n">largestPoolSize</span> <span class="o">=</span> <span class="n">s</span><span class="o">;</span>
                        <span class="c1">// worker 添加成功，workerAdded 置为 true
</span><span class="c1"></span>                        <span class="n">workerAdded</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
                    <span class="o">}</span>
                <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
                    <span class="n">mainLock</span><span class="o">.</span><span class="na">unlock</span><span class="o">();</span>
                <span class="o">}</span>

                <span class="c1">// worker 添加成功，此时就可以启动线程
</span><span class="c1"></span>                <span class="k">if</span> <span class="o">(</span><span class="n">workerAdded</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">t</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
                    <span class="c1">// 启动线程成功，workerStarted 置为 true
</span><span class="c1"></span>                    <span class="n">workerStarted</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
            <span class="c1">// 如果 worker 启动失败，则移除它
</span><span class="c1"></span>            <span class="k">if</span> <span class="o">(!</span> <span class="n">workerStarted</span><span class="o">)</span>
                <span class="c1">// workers 移除新加的 worker，并在 ctl 中将 work 线程数量-1
</span><span class="c1"></span>                <span class="n">addWorkerFailed</span><span class="o">(</span><span class="n">w</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">workerStarted</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><h2 id="六问题定位">六、问题定位</h2>
<h3 id="61-定位执行拒绝策略入口">6.1. 定位执行拒绝策略入口</h3>
<p>执行拒绝策略的位置只有这两个地方，在这两个地方打上断点，执行 demo，结果发现拒绝策略是在第二处执行的；</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://xiaomi-info.github.io/2019/12/19/theadpool-rejected-task/theadpool-rejected-task-07.png"
        data-srcset="https://xiaomi-info.github.io/2019/12/19/theadpool-rejected-task/theadpool-rejected-task-07.png, https://xiaomi-info.github.io/2019/12/19/theadpool-rejected-task/theadpool-rejected-task-07.png 1.5x, https://xiaomi-info.github.io/2019/12/19/theadpool-rejected-task/theadpool-rejected-task-07.png 2x"
        data-sizes="auto"
        alt="https://xiaomi-info.github.io/2019/12/19/theadpool-rejected-task/theadpool-rejected-task-07.png"
        title="img" /></p>
<h3 id="62-定位执行拒绝策略原因">6.2. 定位执行拒绝策略原因</h3>
<p>进入 addWorker 方法，只有这两个地方返回 false，创建线程失败，打断点，执行 demo，发现是在第二处返回 false 的；</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://xiaomi-info.github.io/2019/12/19/theadpool-rejected-task/theadpool-rejected-task-08.png"
        data-srcset="https://xiaomi-info.github.io/2019/12/19/theadpool-rejected-task/theadpool-rejected-task-08.png, https://xiaomi-info.github.io/2019/12/19/theadpool-rejected-task/theadpool-rejected-task-08.png 1.5x, https://xiaomi-info.github.io/2019/12/19/theadpool-rejected-task/theadpool-rejected-task-08.png 2x"
        data-sizes="auto"
        alt="https://xiaomi-info.github.io/2019/12/19/theadpool-rejected-task/theadpool-rejected-task-08.png"
        title="img" /></p>
<h2 id="七问题确认">七、问题确认</h2>
<p>确实是创建的 worker 线程已经达到最大线程数，无法再创建，然后执行拒绝策略的，为什么会被创建到最大呢，每组任务最大只有 15 个，为什么会用到非核心线程？</p>
<h2 id="八定位原因">八、定位原因</h2>
<h3 id="81-分析-execute-方法">8.1. 分析 execute 方法</h3>
<p>在添加非核心线程前，先尝试将任务放到阻塞队列中，如果阻塞队列已满，则尝试添加非核心线程，也就是说，创建非核心线程时：workQueue.offer(command) == false，即阻塞队列已满；</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://xiaomi-info.github.io/2019/12/19/theadpool-rejected-task/theadpool-rejected-task-09.png"
        data-srcset="https://xiaomi-info.github.io/2019/12/19/theadpool-rejected-task/theadpool-rejected-task-09.png, https://xiaomi-info.github.io/2019/12/19/theadpool-rejected-task/theadpool-rejected-task-09.png 1.5x, https://xiaomi-info.github.io/2019/12/19/theadpool-rejected-task/theadpool-rejected-task-09.png 2x"
        data-sizes="auto"
        alt="https://xiaomi-info.github.io/2019/12/19/theadpool-rejected-task/theadpool-rejected-task-09.png"
        title="img" /></p>
<h3 id="82-猜测原因">8.2. 猜测原因</h3>
<p>因为我们阻塞队列只有 1，会不会提交任务的速度比线程从阻塞队列取任务的速度快，进而导致创建非核心线程执行任务，最终的结果就是：在多批任务之后，再无非核心线程可创建，导致执行拒绝策略。</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0hvhvifesj21jk0rqju2.jpg"
        data-srcset="https://tva1.sinaimg.cn/large/e6c9d24ely1h0hvhvifesj21jk0rqju2.jpg, https://tva1.sinaimg.cn/large/e6c9d24ely1h0hvhvifesj21jk0rqju2.jpg 1.5x, https://tva1.sinaimg.cn/large/e6c9d24ely1h0hvhvifesj21jk0rqju2.jpg 2x"
        data-sizes="auto"
        alt="https://tva1.sinaimg.cn/large/e6c9d24ely1h0hvhvifesj21jk0rqju2.jpg"
        title="image-20220321222858471" /></p>
<h3 id="83-原因验证">8.3. 原因验证</h3>
<h4 id="831-阻塞队列选择">8.3.1 阻塞队列选择</h4>
<p>查看 Spring 的 ThreadPoolTaskExecutor 源码，发现如果阻塞队列数量&gt;0，则使用 LinkedBlockingQueue，否则使用 SynchronousQueue。</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0hvhhhigpj21cy0d8myv.jpg"
        data-srcset="https://tva1.sinaimg.cn/large/e6c9d24ely1h0hvhhhigpj21cy0d8myv.jpg, https://tva1.sinaimg.cn/large/e6c9d24ely1h0hvhhhigpj21cy0d8myv.jpg 1.5x, https://tva1.sinaimg.cn/large/e6c9d24ely1h0hvhhhigpj21cy0d8myv.jpg 2x"
        data-sizes="auto"
        alt="https://tva1.sinaimg.cn/large/e6c9d24ely1h0hvhhhigpj21cy0d8myv.jpg"
        title="image-20220321222836192" /></p>
<h4 id="832-linkedblockingqueue">8.3.2 LinkedBlockingQueue</h4>
<ul>
<li>查看 LinkedBlockingQueue#take 方法，如果队列已空，则所有取元素的线程会阻塞在一个 Lock 的 notEmpty 等待条件上，等有元素入队时，只会调用 signal 方法唤醒一个线程取元素，而不是所有线程。</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">class</span> <span class="nc">LinkedBlockingQueue</span><span class="o">{</span>
    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">signalNotEmpty</span><span class="o">()</span> <span class="o">{</span>
        <span class="kd">final</span> <span class="n">ReentrantLock</span> <span class="n">takeLock</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">takeLock</span><span class="o">;</span>
        <span class="c1">// 加锁
</span><span class="c1"></span>        <span class="n">takeLock</span><span class="o">.</span><span class="na">lock</span><span class="o">();</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="c1">// 唤醒一个 take 线程
</span><span class="c1"></span>            <span class="n">notEmpty</span><span class="o">.</span><span class="na">signal</span><span class="o">();</span>
        <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
            <span class="n">takeLock</span><span class="o">.</span><span class="na">unlock</span><span class="o">();</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><ul>
<li>因为一个线程从唤醒到执行是有一段时间间隔的，阻塞被唤醒后，还要等待获取 cpu 时间片，而主线程一直在发布任务，此时就会造成队列中的元素来不及消费，只能创建非核心线程消费的现象。</li>
</ul>
<h2 id="九解决方式">九、解决方式</h2>
<h3 id="91-使用-synchronousqueue">9.1. 使用 SynchronousQueue</h3>
<p>使用 SynchronousQueue，即阻塞队列大小设置为 0，原因在于：SynchronousQueue 和 LinkedBlockingQueue 维度不一致，SynchronousQueue 是根据是否有等待线程而决定是否入队成功，而 LinkedBlockingQueue 是根据缓冲区，而不管是否已经有等待线程。</p>
<ul>
<li>SynchronousQueue</li>
</ul>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0hvgx8491j21es0gqab2.jpg"
        data-srcset="https://tva1.sinaimg.cn/large/e6c9d24ely1h0hvgx8491j21es0gqab2.jpg, https://tva1.sinaimg.cn/large/e6c9d24ely1h0hvgx8491j21es0gqab2.jpg 1.5x, https://tva1.sinaimg.cn/large/e6c9d24ely1h0hvgx8491j21es0gqab2.jpg 2x"
        data-sizes="auto"
        alt="https://tva1.sinaimg.cn/large/e6c9d24ely1h0hvgx8491j21es0gqab2.jpg"
        title="image-20220321222804049" /></p>
<ul>
<li>LinkedBlockingQueue</li>
</ul>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0hvgqezmij21g00csab9.jpg"
        data-srcset="https://tva1.sinaimg.cn/large/e6c9d24ely1h0hvgqezmij21g00csab9.jpg, https://tva1.sinaimg.cn/large/e6c9d24ely1h0hvgqezmij21g00csab9.jpg 1.5x, https://tva1.sinaimg.cn/large/e6c9d24ely1h0hvgqezmij21g00csab9.jpg 2x"
        data-sizes="auto"
        alt="https://tva1.sinaimg.cn/large/e6c9d24ely1h0hvgqezmij21g00csab9.jpg"
        title="image-20220321222750584" /></p>
<h3 id="92-根据业务情况配置阻塞队列">9.2. 根据业务情况配置阻塞队列</h3>
<p>对于我们的业务情况，因为任务最多只有 15 个，将阻塞队列大小设置为 15，这样就保证了不会出现任务被拒绝。</p>
<blockquote>
<p>原文地址：https://xiaomi-info.github.io/2019/12/19/theadpool-rejected-task/</p>
</blockquote>
</div><div class="post-footer" id="post-footer">
    <div class="post-info">
        <div class="post-info-line">
            <div class="post-info-mod">
                <span>更新于 2022-03-21</span>
            </div>
            <div class="post-info-license"></div>
        </div>
        <div class="post-info-line">
            <div class="post-info-md"></div>
            <div class="post-info-share">
                <span></span>
            </div>
        </div>
    </div>

    <div class="post-info-more">
        <section class="post-tags"><i class="fas fa-tags fa-fw"></i>&nbsp;<a href="/tags/%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/">问题排查</a>,&nbsp;<a href="/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/">线程池</a></section>
        <section>
            <span><a href="javascript:void(0);" onclick="window.history.back();">返回</a></span>&nbsp;|&nbsp;<span><a href="/">主页</a></span>
        </section>
    </div>

    <div class="post-nav"><a href="/posts/%E5%A5%BD%E6%96%87%E8%BD%AC%E8%BD%BD/%E4%B8%80%E5%B9%B4-40-%E4%B8%87%E6%AC%A1%E5%AE%9E%E9%AA%8C%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A8-ab-%E6%B5%8B%E8%AF%95%E5%B9%B3%E5%8F%B0%E6%98%AF%E6%80%8E%E4%B9%88%E7%82%BC%E5%87%BA%E6%9D%A5%E7%9A%84/" class="prev" rel="prev" title="一年 40 万次实验，字节跳动 A/B 测试平台是怎么炼出来的？"><i class="fas fa-angle-left fa-fw"></i>一年 40 万次实验，字节跳动 A/B 测试平台是怎么炼出来的？</a>
            <a href="/posts/%E7%94%9F%E6%B4%BB/%E6%97%A5%E8%AF%AD%E8%AF%AD%E6%B3%95%E7%AC%94%E8%AE%B0%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0ing/" class="next" rel="next" title="日语语法笔记">日语语法笔记<i class="fas fa-angle-right fa-fw"></i></a></div>
</div>
</article></div>
            </main><footer class="footer">
        <div class="footer-container"><div class="footer-line">Step by step
                </div><div class="footer-line"><i class="far fa-copyright fa-fw"></i><span itemprop="copyrightYear">2022</span><span class="author" itemprop="copyrightHolder">&nbsp;<a href="/" target="_blank">Billy</a></span></div>
        </div>
    </footer></div>

        <div id="fixed-buttons"><a href="#" id="back-to-top" class="fixed-button" title="回到顶部">
                <i class="fas fa-arrow-up fa-fw"></i>
            </a><a href="#" id="view-comments" class="fixed-button" title="查看评论">
                <i class="fas fa-comment fa-fw"></i>
            </a>
        </div><script type="text/javascript" src="/lib/smooth-scroll/smooth-scroll.min.js"></script><script type="text/javascript" src="/lib/autocomplete/autocomplete.min.js"></script><script type="text/javascript" src="/lib/algoliasearch/algoliasearch-lite.umd.min.js"></script><script type="text/javascript" src="/lib/lazysizes/lazysizes.min.js"></script><script type="text/javascript" src="/lib/clipboard/clipboard.min.js"></script><script type="text/javascript">window.config={"code":{"copyTitle":"复制到剪贴板","maxShownLines":10},"comment":{},"search":{"algoliaAppID":"B4Q47QCNK4","algoliaIndex":"index.zh-cn","algoliaSearchKey":"f8acf4ce02e3d592053c4fb7a6c1d7b4","highlightTag":"em","maxResultLength":10,"noResultsFound":"没有找到结果","snippetLength":50,"type":"algolia"}};</script><script type="text/javascript" src="/js/theme.min.js"></script></body>
</html>
