---
title: 索引
date: 2023-03-23 21:35:58
permalink: /pages/7ece7e/
---

## 索引是什么

**索引是一种数据结构**，它可以帮助我们快速查找和访问数据库中的数据。通过使用索引，数据库系统可以避免全表扫描，从而加快数据访问速度。

在数据库中，索引可以类比于书籍的目录，它可以告诉我们在哪里能够找到某个特定的条目。如果我们需要查找一个特定的记录，而没有索引，那么数据库系统就需要扫描整个表来查找这个记录，这会浪费大量的时间和资源。但是如果我们有了索引，数据库系统就可以快速地定位到存储记录的位置，从而更快地获取需要的数据。

索引可以根据其数据结构的不同分为多种类型，如B+树索引、哈希索引、全文索引等。其中，B-树索引是最常见的一种，它可以处理范围查询和排序操作，并且可以很好地支持高并发和多用户访问的环境。

## 索引的优点

- 大大减少了服务器需要扫描的数据行数。
- 帮助服务器避免进行排序和分组，也就不需要创建临时表(B+Tree 索引是有序的，可以用于 ORDER BY 和 GROUP BY 操作。临时表主要是在排序和分组过程中创建，因为不需要排序和分组，也就不需要创建临时表)。
- 将随机 I/O 变为顺序 I/O(B+Tree 索引是有序的，也就将相邻的数据都存储在一起)。

## 索引的使用场景

对于非常小的表、大部分情况下简单的全表扫描比建立索引更高效。

对于中到大型的表，索引就非常有效。

但是对于特大型的表，建立和维护索引的代价将会随之增长。这种情况下，需要用到一种技术可以直接区分出需要查询的一组数据，而不是一条记录一条记录地匹配，例如可以使用分区技术。

## MySQL 索引分类

按数据结构分类可分为：**B+tree索引、Hash索引、Full-text索引**。
按物理存储分类可分为：**聚簇索引、二级索引（辅助索引、非聚集索引）**。
按字段特性分类可分为：**主键索引、普通索引、前缀索引**。
按字段个数分类可分为：**单列索引、联合索引（复合索引、组合索引）**。

## 聚集索引和非聚集索引

每张表只能有一个聚集索引。

聚集索引是**叶子结点存储完整数据**，非聚集索引叶子结点存储聚集索引的地址。

聚集索引，在索引页里直接存放数据，而非聚集索引在索引页里存放的是索引，这些索引指向专门的数据页的数据。

聚集索引一般是表中的主键索引，如果表中没有显示指定主键，则会选择表中的第一个不允许为NULL的唯一索引，如果还是没有的话，就采用Innodb存储引擎为每行数据内置的6字节ROWID作为聚集索引。

聚集索引一定是唯一索引，但唯一索引不一定是聚集索引。

## MySQL 各种索引区别

普通索引 INDEX：最基本的索引，没有任何限制

唯一索引 UNIQUE：与"普通索引"类似，不同的就是：索引列的值必须唯一，但**允许有空值**。

主键索引 PRIMARY KEY：是一种特殊的唯一索引，**不允许有空值**。 

全文索引 FULLTEXT：InnoDB 5.6开始也支持了，针对较大的数据，生成全文索引很耗时好空间。

组合索引：为了更多的提高mysql效率可建立组合索引，遵循”最左前缀“原则。



### 唯一索引

- 唯一索引不允许两行具有相同的索引值
- 聚集索引一定是唯一索引，但唯一索引不一定是聚集索引。
- 一个表中可以有多个唯一性索引（Uniq Index），但只能有一个主键。
- 主键列不允许空值，而唯一性索引列（Uniq Index）允许空值。



### 哈希索引

InnoDB 支持的哈希索引是自适应的，InnoDB 会根据表的使用状况自动为其生成哈希索引，不能人为干预是否在一张表生成哈希索引。

## 索引的选择

业务写多读少的场景：由于唯一索引用不上change buffer的优化机制，从性能角度出发建议**优先考虑非唯一索引（即普通索引）**。

## 什么是change buffer

Change buffer是MySQL数据库引擎InnoDB用于优化写入性能的一种机制。在InnoDB存储引擎中，每次进行写入操作时，需要将数据写入到磁盘中的数据文件中，这个过程是比较耗时的。为了优化这个过程，InnoDB使用了Change buffer机制。通过使用Change buffer，InnoDB可以将多个修改操作合并成一个较大的操作，从而减少磁盘I/O的次数，提高写入性能。此外，Change buffer还可以减少磁盘上的随机写入操作，从而降低了磁盘的读写负载。

当需要更新一个数据页时，如果数据页在内存中就直接更新，而如果这个数据页还没有在内存中的话，InooDB会将这些更新操作缓存在change buffer中，这样就不需要从磁盘中读入这个数据页了，在后续的查询中再将这些操作应用到磁盘上的数据页中。在下次查询需要访问这个数据页的时候，将数据页读入内存，然后执行change buffer中与这个页有关的操作，保证数据逻辑的正确性。

将change buffer中的操作应用到原数据页，得到最新结果的过程称为merge。除了访问这个数据页会触发merge外，系统有后台线程会定期merge。在数据库正常关闭（shutdown）的过程中， 也会执行merge操作。

change buffer对更新过程有加速作用，change buffer**只限于用在普通索引**的场景下，而不适用于唯一索引。

change buffer 适合**写多读少**的业务，因为页面在写完以后马上被访问到的概率比较小。这种业务模型常见的就是账单类、日志类的系统。

反过来，假设一个业务的更新模式是写入之后马上会做查询，那么即使满足了条件，将更新先记录在change buffer，但之后由于马上要访问这个数据页，会立即触发merge过程。这样随机访问 IO的次数不会减少，反而增加了change buffer的维护代价。所以，对于这种业务模式来说，change buffer反而起到了副作用。

## 索引相关SQL

```sql
# 查看索引
SHOW INDEX FROM <tableName> [FROM <databaseName>]

# 创建索引
1.该语句不能创建主键
CREATE <索引名> ON <表名> (<列名> [<长度>] [ASC | DESC])

2.在创建表时创建，在CREATE TABLE语句中添加
CONSTRAINT PRIMARY KEY [索引类型] (<列名>...)
KEY | INDEX [<索引名>] (<列名>...)

3.在ALTER TABLE中添加
ADD PRIMARY KEY [索引类型] (<列名>...)
ADD INDEX [<索引名>] (<列名>...)
ADD UNIQUE [ INDEX | KEY] [<索引名>] [<索引类型>] (<列名>,…)

完整SQL：
CREATE INDEX <indexName> ON <tableName> (<columnName>)
ALTER TABLE <tableName> ADD INDEX <indexName> (<columnName>)
```

## B+ 树索引

索引是在存储引擎层实现的，而不是在服务器层实现的，所以不同存储引擎具有不同的索引类型和实现。

B+ 树索引是大多数 MySQL 存储引擎的默认索引类型。

B 代表 balance，B+ 树是平衡多路查找树。B+ 树中，**所有记录节点**都是按键值大小**顺序**存放在同一层的叶子节点上，各**叶子节点通过指针进行相连**。

B+树是高度平衡的，叶子节点存放着所有的数据。并且所有叶子节点位于同一层。

B+ Tree 是基于 B Tree 和叶子节点顺序访问指针进行实现，它具有 B Tree 的平衡性，并且通过顺序访问指针来提高区间查询的性能。



在数据库中，B+ 树高度一般在 2~4 层，即查询某一键值的行记录最多只需 2~4 次 IO。一般机械磁盘每秒可以做100次IO，2~4 次IO只需0.02~0.04秒。

B+ 树索引可以分为聚集索引（clustered index）和辅助索引（secondary index，也叫非聚集索引）。但不管是聚集还是辅助索引，底层都是B+树。区别在于，叶子节点存放的是否是一整行的数据。

聚集索引的优点在于，对主键的排序查找和范围查找速度非常快。

辅助索引的叶子节点不包含行记录的所有信息，只包含键值和对应行数据的聚集索引键。

<br/>

操作：

进行查找操作时，首先在根节点进行二分查找，找到一个 key 所在的指针，然后递归地在指针所指向的节点进行查找。直到查找到叶子节点，然后在叶子节点上进行二分查找，找出 key 所对应的 data。

插入删除操作记录会破坏平衡树的平衡性，因此在插入删除操作之后，需要对树进行一个分裂、合并、旋转等操作来维护平衡性。

## B树和B+树的对比

B+ 树在B树的基础上，为叶子节点增加了链表指针，所有数据都存储在叶子节点。非叶子节点作为叶子节点的索引。

B+ 树相对于 B树的优势在于：

- 只有叶子节点存储数据，单一节点可以存储的元素就更多了，使得查询的IO次数更少，因此更适合做为数据库底层数据结构。
- 所有的叶子节点形成了一个有序链表，更加便于查找。
- B+树支持range-query(区间查询)非常方便，而B树不支持。

## B+树和红黑树的对比

红黑树等平衡树也可以用来实现索引，但是文件系统及数据库系统普遍采用 B+ Tree 作为索引结构，主要有以下两个原因:

1. 更少的查找次数

平衡树查找操作的时间复杂度等于树高 h，而树高大致为 O(h)=O(logdN)，其中 d 为每个节点的出度。

红黑树的出度为 2，而 B+ Tree 的出度一般都非常大，所以红黑树的树高 h 很明显比 B+ Tree 大非常多，检索的次数也就更多。

2. 利用计算机预读特性

为了减少磁盘 I/O，磁盘往往不是严格按需读取，而是每次都会预读。预读过程中，磁盘进行顺序读取，顺序读取不需要进行磁盘寻道，并且只需要很短的旋转时间，因此速度会非常快。

操作系统一般将内存和磁盘分割成固态大小的块，每一块称为一页，内存与磁盘以页为单位交换数据。数据库系统将索引的一个节点的大小设置为页的大小，使得一次 I/O 就能完全载入一个节点，并且可以利用预读特性，相邻的节点也能够被预先载入。

## 覆盖索引（covering index）

即从辅助索引中就可以查询到需要的信息，不需要再去查询聚集索引的信息，减少了回表，减少了IO。



## 索引下推（index condition pushdown，ICP）

不支持 ICP 时，当进行索引查询时，首先根据索引查找到记录，再根据 where 条件过滤记录。而支持 ICP的话，在取出索引的同时，进行 where 条件的过滤，即将 where 操作放在了存储引擎层。在某些查询下，可以大大减少上层SQL层对记录的索取，也减少了回表次数。

## 参考资料：

- [主键与唯一索引的区别](https://blog.mimvp.com/article/7462.html)
- [MySQL聚集索引和非聚集索引](https://zhuanlan.zhihu.com/p/39293940)
- [MySQL索引都有哪些分类？](https://developer.huawei.com/consumer/cn/forum/topic/0204405591412170236)
