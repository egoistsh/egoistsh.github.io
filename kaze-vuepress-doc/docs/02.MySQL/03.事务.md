---
title: 事务
date: 2023-03-23 22:19:19
permalink: /pages/e88566/
---



## 事务

事务的通俗解释：事务是一组逻辑操作，要么都执行，要么都不执行。

经典例子：转账。



## 事务的四大特性（ACID）

- 原子性
- 一致性：执行事务前后，数据保持一致，多个事务对同一个数据读取的结果是相同的；
- 隔离性
- 持久性



## 事务的隔离级别

为了达到事务的四大特性，数据库定义了4种不同的事务隔离级别，由低到高依次为

Read uncommitted、Read committed、Repeatable read、Serializable，

这四个级别可以逐个解决脏读、不可重复读、幻读这几类问题。



- **READ-UNCOMMITTED(读取未提交)：** 最低的隔离级别，允许读取尚未提交的数据变更，**可能会导致脏读、不可重复读、幻读问题**。

- **READ-COMMITTED(读取已提交)：** 允许读取并发事务已经提交的数据，**可以阻止脏读，但是幻读或不可重复读仍有可能发生**。

- **REPEATABLE-READ(可重复读)：** 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，**可以阻止脏读和不可重复读，但幻读仍有可能发生**。

- **SERIALIZABLE(可串行化)：** 最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，**该级别可以防止脏读、不可重复读以及幻读**。



### 设置隔离级别

设置innodb的事务级别方法是：set 作用域 transaction isolation level 事务隔离级别，例如：

```sql
SET [SESSION | GLOBAL] TRANSACTION ISOLATION LEVEL {READ UNCOMMITTED | READ COMMITTED | REPEATABLE READ | SERIALIZABLE}

mysql> set global transaction isolation level read committed; //全局的

mysql> set session transaction isolation level read committed; //当前会话（一个cmd窗口）
```







### 脏读、不可重复读、幻读

- 脏读(Drity Read)：某个事务已更新一份数据，另一个事务在此时读取了同一份数据，由于某些原因，前一个RollBack了操作，则后一个事务所读取的数据就会是不正确的。
- 不可重复读(Non-repeatable read):在一个事务的两次查询之中数据不一致，这可能是两次查询过程中间插入了一个事务更新的原有的数据。
- 幻读(Phantom Read):在一个事务的两次查询中数据笔数不一致，例如有一个事务查询了几列(Row)数据，而另一个事务却在此时插入了新的几列数据，先前的事务在接下来的查询中，就会发现有几列数据是它先前所没有的。



### 注意

Mysql 默认采用的 REPEATABLE_READ隔离级别 Oracle 默认采用的 READ_COMMITTED隔离级别

事务隔离机制的实现基于锁机制和并发调度。其中并发调度使用的是MVVC（多版本并发控制），通过保存修改的旧版本信息来支持并发一致性读和回滚等特性。

因为隔离级别越低，事务请求的锁越少，所以大部分数据库系统的隔离级别都是**READ-COMMITTED(读取提交内容):**，但是你要知道的是InnoDB 存储引擎默认使用 **REPEATABLE-READ（可重读）**并不会有任何性能损失。

InnoDB 存储引擎在 **分布式事务** 的情况下一般会用到**SERIALIZABLE(可串行化)**隔离级别。



## 理解数据库如何通过 ACID 来实现事务

ACID：

AID是手段，C是目的。为了保证数据状态的一致性，需要通过原子性、隔离性、持久性来保障。



实现原子性和持久性：需要崩溃恢复。常用write-ahead logging，使用redo log 和 undo log实现。

实现隔离性：加锁同步。

提供了3种锁：写锁、读锁、范围锁。

根据加锁的不同，提供了不同的隔离级别。

串行化：对事务所有读、写的数据全加上读锁、写锁和范围锁。

可重复读：对事务所涉及的数据加读锁和写锁，且直到事务结束，但不加范围锁。可能导致**幻读**问题（事务执行过程中，两个完全相同的范围查询得到不同的结果）。

读已提交：对事务涉及的数据加的写锁一直持续到事务结束，加的读锁在查询操作结束后便马上释放。可能导致**不可重复读**问题（事务执行过程中，对同一行数据的两次查询得到不同结果）。

读未提交：对事务涉及的数据只加写锁，且持续到事务结束。可能导致**脏读**问题（在事务执行过程中，一个事务读取到另一个事务未提交的数据）。



MVCC（multi-version concurrency control）多版本并发控制

针对一个事务读+一个事务写的场景，可以进行MVCC的无锁优化方案。只针对“读+写”场景优化。

基本思路：对数据库的任何修改都不会覆盖之前的数据，而是产生一个新版副本与旧版本共存，以此达到读取时可以完全不用加锁的目的。版本可理解为数据库中每一行数据记录都存在2个看不见的字段：CREATE_VERSION和DELETE_VERSION，两个字段记录的都是事务ID。

- 插入数据时：CREATE_VERSION 记录插入数据的事务 ID，DELETE_VERSION 为空。
- 删除数据时：DELETE_VERSION 记录删除数据的事务 ID，CREATE_VERSION 为空。
- 修改数据时：将修改数据视为“删除旧数据，插入新数据”的组合，即先将原有数据复制一份，原有数据的 DELETE_VERSION 记录修改数据的事务 ID，CREATE_VERSION 为空。复制出来的新数据的 CREATE_VERSION 记录修改数据的事务 ID，DELETE_VERSION 为空。

此时，如有另外一个事务要读取这些发生了变化的数据，将根据隔离级别来决定到底应该读取哪个版本的数据。

- 隔离级别是`可重复读`：总是读取 CREATE_VERSION 小于或等于当前事务 ID 的记录，在这个前提下，如果数据仍有多个版本，则取最新（事务 ID 最大）的。
- 隔离级别是`读已提交`：总是取最新的版本即可，即最近被 Commit 的那个版本的数据记录。

另外两个隔离级别都没有必要用到 MVCC，因为`读未提交`直接修改原始数据即可，其他事务查看数据的时候立刻可以看到，根本无须版本字段。`可串行化`本来的语义就是要阻塞其他事务的读取操作，而 MVCC 是做读取时无锁优化的，自然就不会放到一起用。
