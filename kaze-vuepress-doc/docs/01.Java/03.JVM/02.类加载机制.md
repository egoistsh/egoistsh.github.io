---
title: 类加载机制
date: 2023-03-19 15:24:12
permalink: /pages/7d816e/
---



## 类的生命周期

Java虚拟机把描述类的数据从class文件加载到内存，并对数据进行验证、解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这个过程被称作虚拟机的类加载机制。

与那些在编译器需要进行连接的语言不同，在Java语言里，类型的加载、连接和初始化都是在程序运行期间完成的。



一个类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期将会经历7个阶段。

![image-20230319152651537](https://p.ipic.vip/i73uih.png)

## 类加载

类加载全过程：加载、验证、准备、解析、初始化。

- 加载：主要是在内存中生成一个代表这个类的 Class 对象，作为方法区这个类的访问入口
- 连接
  - 验证：确保 Class 文件的字节流满足“Java虚拟机规范”
  - 准备：给类中定义的变量（static 修饰的静态变量）分配内存并设置初始值。
  - 解析：将常量池中的符号引用替换为直接引用的过程。
    - 符号引用是“Java虚拟机规范”所定义的 Class 文件格式。比如CONSTAN_class_info 这些变量
    - 直接引用是可以直接指向目标的指针、相对偏移量或能间接定位到目标的句柄。有了直接引用，引用的对象必定在虚拟机的内存中存在。
  
- 初始化：执行类构造器方法



第一阶段，加载阶段（Loading）：虚拟完成三件事

- 通过类的全限定名获取其定义的二进制字节流（.class）。【class loader】
- 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。
- 在 Java 堆中生成一个代表这个类的 java.lang.Class 对象，作为对方法区中这些数据的访问入口。

![image-20230319164455842](https://p.ipic.vip/l3qmdj.png)

## 类加载器

Java虚拟机设计团队有意把类加载阶段中的“通过一个类的全限定名来获取描述该类的二进制字节流”这个动作放到Java虚拟机外部去实现， 以便让应用程序自己决定如何去获取所需的类。 实现这个动作的代码被称为“类加载器”（Class Loader） 。



JDK 9 之前：

绝大多数Java程序都会使用到以下3个系统提供的类加载器来进行加载。

1. 启动类加载器 Bootstrap Class Loader：负责加载存放在 <JAVA_HOME>\lib目录，或被 -Xbootclasspath参数所指定的路径中存放的，并且是Java虚拟机能识别的类库加载到虚拟机的内存中。（eg：rt.jar、tools.jar）
2. 扩展类加载器 Extension Class Loader：负责加载 <JAVA_HOME>\lib\ext目录，或被 java.ext.dirs系统变量所指定的路径中所有的类库。
3. 应用程序类加载器/系统类加载器 Application Class Loader：负责加载用户类路径（ClassPath）上所有的类库。如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中**默认的类加载器**。

如果有需要，还可以自定义类加载器。eg：增加除了磁盘位置之外的Class文件来源， 或者通过类加载器实现类的隔离、 重载等功能。 

## 双亲委派模型（Parents Delegation Model）

**双亲委派模型的工作过程是：** 如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到最顶层的启动类加载器中，只有当父类加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去完成加载。

使用双亲委派模型来组织类加载器之间的关系， 一个显而易见的好处就是Java中的类随着它的类加载器一起具备了一种带有优先级的层次关系。 例如类java.lang.Object， 它存放在rt.jar之中， 无论哪一个类加载器要加载这个类， 最终都是委派给处于模型最顶端的启动类加载器进行加载， 因此Object类在程序的各种类加载器环境中都能够保证是同一个类。



优点：

- 防止内存中出现多份同样字节码的系统类。
- 保证 Java 程序安全稳定运行。

## Java模块化系统（JDK 9）
