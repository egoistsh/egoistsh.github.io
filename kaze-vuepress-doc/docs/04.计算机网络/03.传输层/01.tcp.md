---
title: TCP
date: 2023-03-21 18:54:20
permalink: /pages/5e312c/
---

## TCP和UDP的区别

**用户数据报协议UDP（User Datagram Protocol）：**

是无连接的；尽最大可能交付；不能保证数据顺序；没有拥塞控制；面向报文（对于应用程序传下来的报文不合并也不拆分，只是添加UDP首部）；支持一对一、一对多、多对一和多对多的交互通信。

**传输控制协议TCP（Transmission Control Protocol）：**

是面向连接的；提供可靠交付；保证数据顺序（由于使用序号）；有流量控制；有拥塞控制；提供全双工通信；面向字节流（把应用层传下来的报文看成字节流，把字节流组织成大小不等的数据块）；仅支持一对一。

<br/>

- tcp是面向连接的可靠传输协议，是面向字节流的，会发生粘包和拆包现象，有流量控制和拥塞控制保证可靠传输，适合要求对数据传输可靠性要求高的场景。
- udp是无连接的，不可靠的传输协议，会尽最大努力进行交付，面向报文，不会进行拆分和合并，没有拥塞控制，适合允许数据小量丢失的场景，能够实现1对1，1对多，多对多的实时交互通信。
- udp首部长度只有8B，比TCP小。

### TCP和UDP应用

TCP：要求通信数据的完整性和准确性较高（文件传输、邮件发送、重要状态的更新）

UDP：要求通信响应度高，对数据信息的安全性和完整性要求较低（网络电话、网络视频）

### 字节流和报文段

区分字节流和报文关键在于：对使用协议的用户而言，读数据的时候，是不是有“边界”，有边界就是报文，没有边界就是字节流

没有边界：上层协议读取数据的时候不知道读到了几个TCP数据包（因为有缓冲池，所以发送端发送数据和接收端处理数据的频率是可以不对等的）

有边界：上层协议每一次读取必定是一个数据包（没有缓冲池）

## TCP粘包、拆包问题

TCP 是以流的方式来处理数据，一个完整的包可能会被 TCP 拆分成多个包进行发送，也可能把小的封装成一个大的数据包发送。

<br/>

发送方：关闭Nagle算法。接收方：没法处理，只能交给应用层来进行处理

应用层：

- 使用标准的应用层协议（http，https等）来封装要传输的不定长的数据包
- 在每条数据的尾部添加特殊字符，如果遇到特殊字符表明当条数据接受完毕
- 在发送数据前添加包头，数据格式为：数据头+数据块

<br/>

netty的解决方案：

- 消息定长：FixedLengthFrameDecoder
- 包尾增加特殊字符分割：
  - 行分隔符类：LineBasedFrameDecoder
  - 自定义分隔符类 ：DelimiterBasedFrameDecoder
- 将消息分为消息头和消息体：LengthFieldBasedFrameDecoder 类。分为有头部的拆包与粘包、长度字段在前且有头部的拆包与粘包、多扩展头部的拆包与粘包。

也可以使用自定义协议，通过字段标明包长度。

## TCP三次握手

过程：

- A 向 B 发送连接请求报文，**SYN=1，ACK=0，seq=x**。
- B 收到连接请求报文，如果同意建立连接，则向 A 发送连接确认报文，**SYN=1，ACK=1，ack=x+1，seq= y**。
- A 收到 B 的连接确认报文后，还要向 B 发出确认，**ACK=1，ack= y+1，seq=x+1**。

第二次握手完成后SYN将被置为0，第三次握手可以携带数据，前两次不可以携带数据。



为什么需要三次？

- 三次连接才能可靠的同步双方的初始序列号。【tcp的可靠传输是靠同步序列号实现：序列号能保证数据包不重复、不丢弃和按序传输】
- 防止重复的历史连接的建立，造成混乱。
- 避免资源浪费。【重传情况】



重复历史连接建立的具体场景：客户端先发送了 SYN（seq = 90） 报文，然后客户端宕机了，而且这个 SYN 报文还被网络阻塞了，服务端并没有收到，接着客户端重启后，又重新向服务端建立连接，发送了 SYN（seq = 100） 报文（注意不是重传 SYN，重传的 SYN 的序列号是一样的）。

客户端连续发送多次 SYN 建立连接的报文，在**网络拥堵**情况下：

- 一个「旧 SYN 报文」比「最新的 SYN 」 报文早到达了服务端；
- 那么此时服务端就会回一个 SYN + ACK 报文给客户端；
- 客户端收到后可以根据自身的上下文，判断这是一个历史连接（序列号过期或超时），那么客户端就会发送 RST 报文给服务端，表示中止这一次连接。

**如果是两次握手连接，就无法阻止历史连接。**两次握手的情况下，「被动发起方」在收到 SYN 报文后，就进入 ESTABLISHED 状态，意味着这时可以给对方发送数据，但是「主动发起方」此时还没有进入 ESTABLISHED 状态，假设这次是历史连接，「主动发起方」判断到此次连接为历史连接，那么就会回 RST 报文来断开连接，而「被动发起方」在第一次握手的时候就进入 ESTABLISHED 状态，所以它可以发送数据的，但是它并不知道这个是历史连接，它只有在收到 RST 报文后，才会断开连接。

两次握手的话，当客户端连续发送多个建立连接的报文，在网络阻塞的情况下，由于服务端收到应答后就建立了连接，所以会造成服务端多个连接的建立，从而尝试混乱。

## TCP四次挥手

- 过程：

  - 客户端发出连接释放报文段（**FIN=1，序号seq=u**），并停止再发送数据，主动关闭TCP连接，进入FIN_WAIT1（终止等待1）状态，等待服务端的确认。
  - 服务端收到连接释放报文段后即发出确认报文段（**ACK=1，确认号ack=u+1，序号seq=v**），服务端进入CLOSE_WAIT（关闭等待）状态，此时的TCP处于半关闭状态，客户端到服务端的连接释放。客户端收到服务端的确认后，进入FIN_WAIT2（终止等待2）状态，等待服务端发出的连接释放报文段。
  - 服务端没有要向客户端发出的数据，服务端发出连接释放报文段（**FIN=1，ACK=1，序号seq=w，确认号ack=u+1**），服务端进入LAST_ACK（最后确认）状态，等待客户端的确认。
  - 客户端收到服务端的连接释放报文段后，对此发出确认报文段（**ACK=1，seq=u+1，ack=w+1**），客户端进入TIME_WAIT（时间等待）状态。此时TCP未释放掉，需要经过时间等待计时器设置的时间2MSL后，客户端才进入CLOSED状态。

  ![img](https://p.ipic.vip/5gyfdx.png)

  **为什么是四次：**

  这由TCP的半关闭（half-close）造成的。所谓的半关闭，其实就是TCP提供了连接的一端在结束它的发送后还能接收来自另一端数据的能力。

  **为什么需要等待2个MSL**

  防止主动接受方发送的最后确认报文，被动接受方没能接受到，触发被动接受方的超时重传，一来一回刚好两个2MSL

  **MSL（****Maximum Segment Lifetime****）为报文最大生存时间**，他是任何报文在网络上存在的最长时间，超过这个时间报文将会被丢弃，被接收方处理后又向发送方发送响应，一来一回需要等待2倍的时间

  **为什么第二次挥手和第三次挥手不能合并成一次**

  服务器需要先应答接受到了客户端需要断开的请求，但是服务器可能还有数据需要处理和发送，并且TCP具有一端在结束它发送后仍能接受数据的能力，因此服务器还能向客户端进行发送数据

## TCP可靠传输

TCP通过**重传机制**、**流量控制**、**拥塞控制**来实现可靠传输

### 重传机制

| 重传机制 | 描述                                                         |
| -------- | ------------------------------------------------------------ |
| 超时重传 | 超出一定时间没有收到响应触发重传机制                         |
| 快速重传 | 连续收到三次相同的ACK触发重传机制                            |
| SACK     | TCP的字段中添加SACK，显示哪些数据被接收到                    |
| D-SACK   | 用SACK字段表明哪些数据被重复接收，用ACK表明哪些字段丢失，可以用来检测是响应丢失还是请求丢失 |



TCP超时重传和快速重传都是TCP协议在数据传输时使用的机制，用于提高数据传输的可靠性。它们的主要区别如下：

1. 触发机制：TCP超时重传是在发送数据后等待一段时间，如果未收到确认应答，就会触发重传机制；而快速重传是在接收到重复确认应答时触发的，这意味着网络出现拥塞，导致数据包丢失。
2. 重传次数：TCP超时重传会在每次超时后重传数据包，直到收到确认应答为止；而快速重传只会在接收到3个重复确认应答后立即重传数据包，避免了等待超时时间的延迟。
3. 对网络性能的影响：TCP超时重传会导致网络出现更多的拥塞，因为每次重传都会重新发送所有数据包，而这些数据包可能会增加网络拥塞的程度。而快速重传通过减少数据包的重传次数，可以减轻网络拥塞的程度。



### 流量控制和拥塞控制的区别

TCP流量控制和拥塞控制是TCP协议中两个重要的机制，它们的主要区别如下：

1. 目的不同：TCP流量控制的目的是确保**发送方不会发送使接收方无法处理数据**，通过动态调整发送方发送的数据量，控制接收方的接收速率，以达到平衡发送方和接收方之间的数据流量。拥塞控制则是为了**防止网络拥塞**而采取的一种机制。

2. 控制对象不同：TCP流量控制是对单个连接的**发送方和接收方之间的数据流量**进行控制，而拥塞控制是对**整个网络的流量**进行控制。

3. 触发机制不同：TCP流量控制是由接收方来触发的，当接收方处理不过来数据时，会发送窗口通告（Window Size），告诉发送方可以发送的数据量，从而控制发送方的发送速率。而拥塞控制则是由网络的拥塞情况来触发的，当网络拥塞时，发送方会收到拥塞信号（Congestion Signal），从而调整发送速率。

4. 实现方法不同：TCP流量控制通过调整窗口大小来控制发送方的发送速率。窗口大小是发送方和接收方之间的一个参数，发送方可以根据窗口大小来确定可以发送的数据量。而拥塞控制则采用了多种算法，例如TCP Reno、TCP Vegas等，通过不同的算法来调整发送方的发送速率，以避免网络拥塞。

### 流量控制

通过使用**滑动窗口**来进行流量控制

- 滑动窗口的大小就是指发送方无需等待确认应答，而可以继续发送数据的最大值

- **滑动窗口的大小是由接收方的窗口大小决定**的：接收方告诉发送方自己有多少缓冲区可以接收数据，发送方根据这个接收端的处理能力来发送数据，而不会导致接收端处理不过来
- 初始滑动窗口的大小=缓存池中数据量+动态变动后的滑动窗口大小

注意事项：

- 接收方需要更改滑动窗口的大小时，需要先发送更改大小的请求，然后再变更大小
- 如果窗口大小为0的时，需要设置自动发送询问报文来询问接收方是否缓存池有可用大小（窗口关闭问题）
- 滑动窗口过小的时候，不进行数据发送，等窗口恢复到一定大小时再进行发送（糊涂窗口综合症）

### 拥塞控制

根据网络环境（是否丢包）使用**拥塞窗口**进行拥塞控制，拥塞控制算法如下

- 慢启动

  拥塞窗口<=慢启动门限：拥塞窗口呈指数型增长

- 拥塞避免算法

  拥塞窗口>=慢启动门限：拥塞窗口呈线性增长

- 拥塞发生算法

  出现丢包时：

  使用**超时重传**：慢启动门限=拥塞窗口/2｜拥塞窗口=1｜重新启动慢启动

  使用**快速重传**：拥塞窗口 = 拥塞窗口/2｜慢启动门限 = 拥塞窗口｜进入快速恢复算法

- 快速恢复

  拥塞窗口 = 慢启动门限+3，通过重传一个包。

  如果接收到重复的ACK的话，那么拥塞窗口+1，继续重传

  如果是新的ACK，进入拥塞避免算法
