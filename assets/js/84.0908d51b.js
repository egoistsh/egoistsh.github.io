(window.webpackJsonp=window.webpackJsonp||[]).push([[84],{408:function(s,a,e){"use strict";e.r(a);var t=e(7),r=Object(t.a)({},(function(){var s=this,a=s._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[a("h2",{attrs:{id:"什么是分布式锁"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#什么是分布式锁"}},[s._v("#")]),s._v(" 什么是分布式锁？")]),s._v(" "),a("p",[s._v("分布式锁顾名思义就是用在分布式系统中，用于控制分布式系统之间同步访问共享资源。")]),s._v(" "),a("p",[s._v("核心操作：加锁、解锁、防止锁超时。")]),s._v(" "),a("h2",{attrs:{id:"分布式锁的几种实现"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#分布式锁的几种实现"}},[s._v("#")]),s._v(" 分布式锁的几种实现")]),s._v(" "),a("ul",[a("li",[s._v("Memcached 分布式锁：Memecached add命令是原子性的。")]),s._v(" "),a("li",[s._v("Zookeeper 分布式锁：利用Zookeeper 的顺序临时节点，且临时节点连接中断会自动删除，来实现分布式锁。同时还提供watch机制，可以实现加锁失败就阻塞住，直到获取到锁为止。")]),s._v(" "),a("li",[s._v("Chubby：Google实现的粗粒度分布式锁服务。")]),s._v(" "),a("li",[s._v("Redis 分布式锁：下文详细讨论。")])]),s._v(" "),a("h2",{attrs:{id:"setnx指令"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#setnx指令"}},[s._v("#")]),s._v(" SETNX指令")]),s._v(" "),a("p",[s._v("SETNX指令只在key不存在的情况下，将key设置为value值，若key存在，则不做任何操作。")]),s._v(" "),a("p",[s._v("key是锁的唯一标识，可以按业务需求锁定的资源命名。")]),s._v(" "),a("div",{staticClass:"language-shell extra-class"},[a("pre",{pre:!0,attrs:{class:"language-shell"}},[a("code",[s._v("SETNX lock_key lock_value\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("do")]),s._v(" something\nDEL lock_key\n")])])]),a("p",[s._v("这一方式的问题在于：锁超时问题。如果获得锁的进程在业务处理过程中出现了异常，将导致DEL指令无法执行，锁无法释放，该资源将会被一直锁住。")]),s._v(" "),a("h2",{attrs:{id:"setnx指令-expire指令"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#setnx指令-expire指令"}},[s._v("#")]),s._v(" SETNX指令 + EXPIRE指令")]),s._v(" "),a("p",[s._v("因此很容易想到，给key设置一个过期时间。由于SETNX不支持设置过期时间，所以需要额外的EXPIRE指令")]),s._v(" "),a("div",{staticClass:"language-sh extra-class"},[a("pre",{pre:!0,attrs:{class:"language-sh"}},[a("code",[s._v("SETNX lock_key lock_value\nEXPIRE lock_key "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("10")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("do")]),s._v(" something\nDEL lock_key\n")])])]),a("p",[s._v("这一方式的问题在于：SETNX 和 EXPIRE 这两个操作是非原子性的， 如果进程在执行 SETNX 和 EXPIRE 之间发生异常，同样会出现上述问题。")]),s._v(" "),a("h2",{attrs:{id:"set扩展指令"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#set扩展指令"}},[s._v("#")]),s._v(" SET扩展指令")]),s._v(" "),a("p",[s._v("为了解决 SETNX 和 EXPIRE 两个操作非原子性的问题，可以使用 Redis 的 SET 指令的扩展参数，使得 SETNX 和 EXPIRE 这两个操作可以原子执行。")]),s._v(" "),a("div",{staticClass:"language-sh extra-class"},[a("pre",{pre:!0,attrs:{class:"language-sh"}},[a("code",[s._v("SET lock_key lock_value NX EX "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("10")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("do")]),s._v(" something\nDEL lock_key\n")])])]),a("p",[s._v("这一方式的问题在于：锁可能在业务处理结束前提前释放。从而也可能导致锁被误删。")]),s._v(" "),a("p",[s._v("为了避免上述情况，建议不要在执行时间过长的场景中使用 Redis 分布式锁，同时一个比较安全的做法是在执行 DEL 释放锁之前对锁进行判断，验证当前锁的持有者是否是自己。")]),s._v(" "),a("p",[s._v("具体实现就是在加锁时将 value 设置为一个唯一的随机数（或者线程 ID ），释放锁时先判断随机数是否一致，然后再执行释放操作，确保不会错误地释放其它线程持有的锁，除非是锁过期了被服务器自动释放。")]),s._v(" "),a("div",{staticClass:"language-sh extra-class"},[a("pre",{pre:!0,attrs:{class:"language-sh"}},[a("code",[s._v("SET lock_key random_value nx ex "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("10")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("do")]),s._v(" something\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("if")]),s._v(" random_value "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("==")]),s._v(" lock_key.value\n\tDEL lock_key\n")])])]),a("h2",{attrs:{id:"set扩展指令-lua"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#set扩展指令-lua"}},[s._v("#")]),s._v(" SET扩展指令 + Lua")]),s._v(" "),a("p",[s._v("但判断 value 和删除 key 是两个独立的操作，并不是原子性的，所以这个地方需要使用 Lua 脚本进行处理。")]),s._v(" "),a("div",{staticClass:"language-lua extra-class"},[a("pre",{pre:!0,attrs:{class:"language-lua"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("if")]),s._v(" redis"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[s._v("call")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[s._v('"get"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v(" KEYS"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("[")]),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("1")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("]")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("==")]),s._v(" ARGV"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("[")]),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("1")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("]")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("then")]),s._v("\n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("return")]),s._v(" redis"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[s._v("call")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[s._v('"del"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v(" KEYS"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("[")]),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("1")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("]")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("else")]),s._v(" \n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("return")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("0")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("end")]),s._v("\n")])])]),a("blockquote",[a("p",[s._v("Redis使用Lua脚本时为什么能保证原子性?")]),s._v(" "),a("p",[s._v("Redis使用同一个的Lua解释器，来运行所有的命令。Redis保证以一种原子性的方式来执行脚本。在执行脚本时，不会执行其他脚本或Redis命令。这个语义类似于MULTI（开启事务）/EXEC（触发事务，一并执行事务中的所有命令）。从所有其他客户端的角度来看，脚本的效果要么仍然不可见，要么已经完成。")])]),s._v(" "),a("p",[s._v("但这并不是一个完美的方案，只是相对完全一点，因为它并没有完全解决执行超时锁被提前释放的问题。")]),s._v(" "),a("h2",{attrs:{id:"redisson"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#redisson"}},[s._v("#")]),s._v(" Redisson")]),s._v(" "),a("p",[s._v("原理：可以利用锁的可重入特性，让获得锁的线程开启一个定时器的守护线程，每 expireTime/3 执行一次，去检查该线程的锁是否存在，如果存在则对锁的过期时间重新设置为 expireTime，即利用守护线程对锁进行“续命”，防止锁由于过期提前释放。")]),s._v(" "),a("p",[a("img",{attrs:{src:"https://tva1.sinaimg.cn/large/e6c9d24egy1h09rbzt7i7j216s0p4wha.jpg",alt:"image-20220314220024341"}})]),s._v(" "),a("h2",{attrs:{id:"基于redis多机实现的redlock"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#基于redis多机实现的redlock"}},[s._v("#")]),s._v(" 基于Redis多机实现的Redlock")]),s._v(" "),a("p",[s._v("以上几种基于 Redis 单机实现的分布式锁其实都存在一个问题，就是加锁时只作用在一个 Redis 节点上，即使 Redis 通过 Sentinel 保证了高可用，但由于 Redis 的复制是异步的，Master 节点获取到锁后在未完成数据同步的情况下发生故障转移，此时其他客户端上的线程依然可以获取到锁，因此会丧失锁的安全性。")]),s._v(" "),a("p",[s._v("在 Redis 的分布式环境中，Redis 的作者 antirez 提供了 RedLock 的算法来实现一个分布式锁，该算法大概是这样的：")]),s._v(" "),a("p",[s._v("假设有 N（N>=5）个 Redis 节点，这些节点完全互相独立，不存在主从复制或者其他集群协调机制，确保在这 N 个节点上使用与在 Redis 单实例下相同的方法获取和释放锁。")]),s._v(" "),a("p",[s._v("获取锁的过程，客户端应执行如下操作：")]),s._v(" "),a("ul",[a("li",[s._v("获取当前 Unix 时间，以毫秒为单位。")]),s._v(" "),a("li",[s._v("按顺序依次尝试从 5 个实例使用相同的 key 和具有唯一性的 value（例如 UUID）获取锁。当向 Redis 请求获取锁时，客户端应该设置一个网络连接和响应超时时间，这个超时时间应该小于锁的失效时间。例如锁自动失效时间为 10 秒，则超时时间应该在 5-50 毫秒之间。这样可以避免服务器端 Redis 已经挂掉的情况下，客户端还在一直等待响应结果。如果服务器端没有在规定时间内响应，客户端应该尽快尝试去另外一个 Redis 实例请求获取锁。")]),s._v(" "),a("li",[s._v("客户端使用当前时间减去开始获取锁时间（步骤 1 记录的时间）就得到获取锁使用的时间。当且仅当从大多数（N/2+1，这里是 3 个节点）的 Redis 节点都取到锁，并且使用的时间小于锁失效时间时，锁才算获取成功。")]),s._v(" "),a("li",[s._v("如果取到了锁，key 的真正有效时间等于有效时间减去获取锁所使用的时间（步骤 3 计算的结果）。")]),s._v(" "),a("li",[s._v("如果因为某些原因，获取锁失败（没有在至少 N/2+1 个 Redis 实例取到锁或者取锁时间已经超过了有效时间），客户端应该在所有的 Redis 实例上进行解锁（使用 Redis Lua 脚本）。")])]),s._v(" "),a("h2",{attrs:{id:"参考"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#参考"}},[s._v("#")]),s._v(" 参考")]),s._v(" "),a("ol",[a("li",[a("p",[s._v("https://www.infoq.cn/article/dvaaj71f4fbqsxmgvdce")])]),s._v(" "),a("li",[a("p",[s._v("https://juejin.cn/post/6844903830442737671#heading-14")])])])])}),[],!1,null,null,null);a.default=r.exports}}]);