(window.webpackJsonp=window.webpackJsonp||[]).push([[53],{377:function(t,s,a){"use strict";a.r(s);var e=a(7),v=Object(e.a)({},(function(){var t=this,s=t._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h2",{attrs:{id:"动态字符串"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#动态字符串"}},[t._v("#")]),t._v(" 动态字符串")]),t._v(" "),s("p",[t._v("SDS(simple dynamic string)")]),t._v(" "),s("div",{staticClass:"language-c extra-class"},[s("pre",{pre:!0,attrs:{class:"language-c"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("sdshdr")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 记录 buf 数组中已使用字节的数量")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 等于 SDS 所保存字符串的长度")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" len"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 记录 buf 数组中未使用字节的数量")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" free"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("char")]),t._v(" buf"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),s("p",[t._v("下面是SDS与C字符串的区别。")]),t._v(" "),s("table",[s("thead",[s("tr",[s("th",{staticStyle:{"text-align":"left"}},[t._v("C 字符串")]),t._v(" "),s("th",{staticStyle:{"text-align":"left"}},[t._v("SDS")])])]),t._v(" "),s("tbody",[s("tr",[s("td",{staticStyle:{"text-align":"left"}},[t._v("获取字符串长度的复杂度为 O(N) 。")]),t._v(" "),s("td",{staticStyle:{"text-align":"left"}},[t._v("获取字符串长度的复杂度为 O(1) 。")])]),t._v(" "),s("tr",[s("td",{staticStyle:{"text-align":"left"}},[t._v("API 是不安全的，可能会造成缓冲区溢出。")]),t._v(" "),s("td",{staticStyle:{"text-align":"left"}},[t._v("API 是安全的，不会造成缓冲区溢出。")])]),t._v(" "),s("tr",[s("td",{staticStyle:{"text-align":"left"}},[t._v("修改字符串长度 "),s("code",[t._v("N")]),t._v(" 次必然需要执行 "),s("code",[t._v("N")]),t._v(" 次内存重分配。")]),t._v(" "),s("td",{staticStyle:{"text-align":"left"}},[t._v("修改字符串长度 "),s("code",[t._v("N")]),t._v(" 次最多需要执行 "),s("code",[t._v("N")]),t._v(" 次内存重分配。")])]),t._v(" "),s("tr",[s("td",{staticStyle:{"text-align":"left"}},[t._v("只能保存文本数据。")]),t._v(" "),s("td",{staticStyle:{"text-align":"left"}},[t._v("可以保存文本或者二进制数据。")])]),t._v(" "),s("tr",[s("td",{staticStyle:{"text-align":"left"}},[t._v("可以使用所有 "),s("code",[t._v("<string.h>")]),t._v(" 库中的函数。")]),t._v(" "),s("td",{staticStyle:{"text-align":"left"}},[t._v("可以使用一部分 "),s("code",[t._v("<string.h>")]),t._v(" 库中的函数。")])])])]),t._v(" "),s("h2",{attrs:{id:"跳表"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#跳表"}},[t._v("#")]),t._v(" 跳表")]),t._v(" "),s("p",[t._v("跳表可以看成多层链表，它有如下的性质：")]),t._v(" "),s("ul",[s("li",[t._v("多层的结构组成，每层是一个有序的链表")]),t._v(" "),s("li",[t._v("最底层的链表包含所有的元素")]),t._v(" "),s("li",[t._v("跳跃表的查找次数近似于层数，时间复杂度为O(logn)，插入、删除也为 O(logn)")])]),t._v(" "),s("p",[s("img",{attrs:{src:"https://p.ipic.vip/brgcbp.png",alt:"image-20230317210656286"}})]),t._v(" "),s("h3",{attrs:{id:"skiplist与平衡树、哈希表的比较-待整理"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#skiplist与平衡树、哈希表的比较-待整理"}},[t._v("#")]),t._v(" skiplist与平衡树、哈希表的比较（待整理）")]),t._v(" "),s("ul",[s("li",[t._v("skiplist和各种平衡树（如AVL、红黑树等）的元素是有序排列的，而哈希表不是有序的。因此，在哈希表上只能做单个key的查找，不适宜做范围查找。所谓范围查找，指的是查找那些大小在指定的两个值之间的所有节点。")]),t._v(" "),s("li",[t._v("在做范围查找的时候，平衡树比skiplist操作要复杂。在平衡树上，我们找到指定范围的小值之后，还需要以中序遍历的顺序继续寻找其它不超过大值的节点。如果不对平衡树进行一定的改造，这里的中序遍历并不容易实现。而在skiplist上进行范围查找就非常简单，只需要在找到小值之后，对第1层链表进行若干步的遍历就可以实现。")]),t._v(" "),s("li",[t._v("平衡树的插入和删除操作可能引发子树的调整，逻辑复杂，而skiplist的插入和删除只需要修改相邻节点的指针，操作简单又快速。")]),t._v(" "),s("li",[t._v("从内存占用上来说，skiplist比平衡树更灵活一些。一般来说，平衡树每个节点包含2个指针（分别指向左右子树），而skiplist每个节点包含的指针数目平均为1/(1-p)，具体取决于参数p的大小。如果像Redis里的实现一样，取p=1/4，那么平均每个节点包含1.33个指针，比平衡树更有优势。")]),t._v(" "),s("li",[t._v("查找单个key，skiplist和平衡树的时间复杂度都为O(log n)，大体相当；而哈希表在保持较低的哈希值冲突概率的前提下，查找时间复杂度接近O(1)，性能更高一些。所以我们平常使用的各种Map或dictionary结构，大都是基于哈希表实现的。")]),t._v(" "),s("li",[t._v("从算法实现难度上来比较，skiplist比平衡树要简单得多。")])]),t._v(" "),s("h2",{attrs:{id:"字典"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#字典"}},[t._v("#")]),t._v(" 字典")]),t._v(" "),s("h2",{attrs:{id:"整数集合"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#整数集合"}},[t._v("#")]),t._v(" 整数集合")]),t._v(" "),s("h2",{attrs:{id:"压缩列表"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#压缩列表"}},[t._v("#")]),t._v(" 压缩列表")]),t._v(" "),s("h2",{attrs:{id:"对象"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#对象"}},[t._v("#")]),t._v(" 对象")]),t._v(" "),s("p",[t._v("http://www.topjavaer.cn/redis/redis-basic/3-data-structure.html")])])}),[],!1,null,null,null);s.default=v.exports}}]);