(window.webpackJsonp=window.webpackJsonp||[]).push([[51],{375:function(s,t,a){"use strict";a.r(t);var e=a(7),r=Object(e.a)({},(function(){var s=this,t=s._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[t("p",[s._v("Redis支持：")]),s._v(" "),t("ul",[t("li",[s._v("string：值可以是字符串、数字或者二进制，但值最大不能超过512MB。")]),s._v(" "),t("li",[s._v("hash")]),s._v(" "),t("li",[s._v("list")]),s._v(" "),t("li",[s._v("set")]),s._v(" "),t("li",[s._v("zset(sorted set)")]),s._v(" "),t("li",[s._v("bitmaps")]),s._v(" "),t("li",[s._v("hyperloglog")]),s._v(" "),t("li",[s._v("stream")]),s._v(" "),t("li",[s._v("geospatial")])]),s._v(" "),t("h2",{attrs:{id:"set集合运算"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#set集合运算"}},[s._v("#")]),s._v(" set集合运算")]),s._v(" "),t("div",{staticClass:"language-sh extra-class"},[t("pre",{pre:!0,attrs:{class:"language-sh"}},[t("code",[s._v("SDIFF setA setB  //差集运算\nSINTER setA setB //交集运算\nSUNION setA setB //并集运算\n")])])]),t("p",[s._v("三个命令都可以传进多个键 "),t("code",[s._v("SDIFF setA setB setC")])]),s._v(" "),t("h2",{attrs:{id:"zset"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#zset"}},[s._v("#")]),s._v(" zset")]),s._v(" "),t("div",{staticClass:"language-sh extra-class"},[t("pre",{pre:!0,attrs:{class:"language-sh"}},[t("code",[s._v("zadd zsetkey "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("50")]),s._v(" e1 "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("60")]),s._v(" e2 "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("30")]),s._v(" e3\n")])])]),t("p",[s._v("Zset每个元素都会关联一个double（超过17位使用科学计算法表示，可能丢失精度）类型的分数，通过分数来为集合中的成员进行排序。zset的成员是唯一的,但分数(score)可以重复。")]),s._v(" "),t("p",[t("strong",[s._v("有序集合和列表相同点：")])]),s._v(" "),t("ol",[t("li",[s._v("都是有序的；")]),s._v(" "),t("li",[s._v("都可以获得某个范围内的元素。lrange和zrange")])]),s._v(" "),t("p",[t("strong",[s._v("有序集合和列表不同点：")])]),s._v(" "),t("ol",[t("li",[s._v("列表基于链表实现，获取两端元素速度快，访问中间元素速度慢；")]),s._v(" "),t("li",[s._v("有序集合基于散列表和跳跃表实现，访问中间元素时间复杂度是OlogN；")]),s._v(" "),t("li",[s._v("列表不能简单的调整某个元素的位置，有序列表可以（更改元素的分数）；")]),s._v(" "),t("li",[s._v("有序集合更耗内存。")])]),s._v(" "),t("h2",{attrs:{id:"bitmaps"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#bitmaps"}},[s._v("#")]),s._v(" bitmaps")]),s._v(" "),t("p",[s._v("Bitmaps本身不是一种数据结构，实际上它就是字符串，但是它可以对字符串的位进行操作，可以把Bitmaps想象成一个以位为单位的数组，数组的每个单元只能存储0和1。")]),s._v(" "),t("p",[s._v("bitmap的长度与集合中元素个数无关，而是与基数的上限有关。假如要计算上限为1亿的基数，则需要12.5M字节的bitmap。就算集合中只有10个元素也需要12.5M。")]),s._v(" "),t("p",[s._v("offset从0开始。")]),s._v(" "),t("div",{staticClass:"language-shell extra-class"},[t("pre",{pre:!0,attrs:{class:"language-shell"}},[t("code",[s._v("SETBIT "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("<")]),s._v("key"),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v(">")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("<")]),s._v("offset"),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v(">")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("<")]),s._v("value"),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v(">")]),s._v("\nGETBIT "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("<")]),s._v("key"),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v(">")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("<")]),s._v("offset"),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v(">")]),s._v("\nBITCOUNT "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("<")]),s._v("key"),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v(">")]),s._v("\nBITPOS key bitValue "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("[")]),s._v("start"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("]")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("[")]),s._v("end"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("]")]),s._v(" //返回数据表示 Bitmap 中第一个值为 bitValue 的 offset 位置。\nBITOP operation destkey key "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("[")]),s._v("key "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("..")]),s._v("."),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("]")]),s._v(" //用于对一个或者多个 键 "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" key 的 Bitmap 进行位元操作。opration 可以是 and、OR、NOT、XOR。处理不同长度的字符串时，较短的那个字符串所缺少的部分会被看作 "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("0")]),s._v(" 。空的 key 也被看作是包含 "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("0")]),s._v(" 的字符串序列。\n")])])]),t("h3",{attrs:{id:"实现判断海量用户是否在线"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#实现判断海量用户是否在线"}},[s._v("#")]),s._v(" 实现判断海量用户是否在线：")]),s._v(" "),t("p",[s._v("key = login_status 表示存储用户登陆状态集合数据， 将用户 ID 作为 offset，在线就设置为 1，下线设置 0。通过 "),t("code",[s._v("GETBIT")]),s._v("判断对应的用户是否在线。 50000 万 用户只需要 6 MB 的空间。")]),s._v(" "),t("p",[s._v("假如我们要判断 ID = 10086 的用户的登陆情况：")]),s._v(" "),t("div",{staticClass:"language-sh extra-class"},[t("pre",{pre:!0,attrs:{class:"language-sh"}},[t("code",[t("span",{pre:!0,attrs:{class:"token number"}},[s._v("1")]),s._v(".表示用户登录\nSETBIT login_status "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("10086")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("1")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("2")]),s._v(".检查用户是否登录\nGETBIT login_status "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("10086")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("3")]),s._v(".用户登出\nSETBIT login_status "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("10086")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("0")]),s._v("\n")])])]),t("h3",{attrs:{id:"实现用户每月的登录情况"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#实现用户每月的登录情况"}},[s._v("#")]),s._v(" 实现用户每月的登录情况：")]),s._v(" "),t("p",[s._v("key 可以设计成 "),t("code",[s._v("uid:sign:{userId}:{yyyyMM}")]),s._v("，月份的每一天的值 - 1 可以作为 offset（因为 offset 从 0 开始，所以 "),t("code",[s._v("offset = 日期 - 1")]),s._v("）。")]),s._v(" "),t("div",{staticClass:"language-sh extra-class"},[t("pre",{pre:!0,attrs:{class:"language-sh"}},[t("code",[t("span",{pre:!0,attrs:{class:"token number"}},[s._v("1")]),s._v(".表示记录用户在 "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("2021")]),s._v(" 年 "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("5")]),s._v(" 月 "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("16")]),s._v(" 号打卡。\nSETBIT uid:sign:89757:202105 "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("15")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("1")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("2")]),s._v(".判断编号 "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("89757")]),s._v(" 用户在 "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("2021")]),s._v(" 年 "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("5")]),s._v(" 月 "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("16")]),s._v(" 号是否打卡。\nGETBIT uid:sign:89757:202105 "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("15")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("3")]),s._v(".统计该用户在 "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("5")]),s._v(" 月份的打卡次数。\nBITCOUNT uid:sign:89757:202105\n"),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("4")]),s._v(".获取 userID "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("89757")]),s._v(" 在 "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("2021")]),s._v(" 年 "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("5")]),s._v(" 月份首次打卡日期。\nBITPOS uid:sign:89757:202105 "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("1")]),s._v("\n")])])]),t("h3",{attrs:{id:"实现连续签到用户总数统计"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#实现连续签到用户总数统计"}},[s._v("#")]),s._v(" 实现连续签到用户总数统计")]),s._v(" "),t("p",[s._v("在记录了一个亿的用户连续 7 天的打卡数据，如何统计出这连续 7 天连续打卡用户总数呢？")]),s._v(" "),t("p",[s._v("我们把每天的日期作为 Bitmap 的 key，userId 作为 offset，若是打卡则将 offset 位置的 bit 设置成 1。")]),s._v(" "),t("p",[s._v("key 对应的集合的每个 bit 位的数据则是一个用户在该日期的打卡记录。")]),s._v(" "),t("p",[s._v("一共有 7 个这样的 Bitmap，如果我们能对这 7 个 Bitmap 的对应的 bit 位做 『与』运算。")]),s._v(" "),t("div",{staticClass:"language-sh extra-class"},[t("pre",{pre:!0,attrs:{class:"language-sh"}},[t("code",[s._v("// 与操作\nBITOP AND destmap bitmap:01 bitmap:02 bitmap:03\n// 统计 bit 位 "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v("  "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("1")]),s._v(" 的个数\nBITCOUNT destmap\n")])])]),t("p",[s._v("简单计算下 一个一亿个位的 Bitmap占用的内存开销，大约占 12 MB 的内存（10^8/8/1024/1024），7 天的 Bitmap 的内存开销约为 84 MB。同时我们最好给 Bitmap 设置过期时间，让 Redis 删除过期的打卡数据，节省内存。")]),s._v(" "),t("p",[s._v("https://segmentfault.com/a/1190000040177140")]),s._v(" "),t("h2",{attrs:{id:"hyperloglog"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#hyperloglog"}},[s._v("#")]),s._v(" HyperLogLog")]),s._v(" "),t("p",[s._v("HyperLogLog 是用来做基数统计的算法，其优点是，它所需的内存并不会因为集合的大小而改变，无论集合包含的元素有多少个，HyperLogLog进行计算所需的内存总是固定的，并且是非常少的。")]),s._v(" "),t("p",[s._v("目的是做基数统计，故不是集合，不会保存元数据，只记录数量而不是数值。")]),s._v(" "),t("p",[s._v("每个 "),t("code",[s._v("HyperLogLog")]),s._v(" 最多只需要花费 12KB 内存，在标准误差 "),t("code",[s._v("0.81%")]),s._v("的前提下，就可以计算 2 的 64 次方个元素的基数。")]),s._v(" "),t("p",[s._v("基数：比如数据集 {1, 3, 5, 7, 5, 7, 8}， 那么这个数据集的基数集为 {1, 3, 5 ,7, 8}，基数即不重复元素为5。")]),s._v(" "),t("p",[s._v("基数统计：统计一个集合中不重复元素的个数。")]),s._v(" "),t("p",[s._v("核心是基数估算算法，主要表现为计算时内存的使用和数据合并的处理。最终数值存在一定误差。")]),s._v(" "),t("p",[s._v("应用场景")]),s._v(" "),t("ul",[t("li",[s._v("统计一个 "),t("code",[s._v("APP")]),s._v(" 的日活、月活数；")]),s._v(" "),t("li",[s._v("统计一个页面的每天被多少个不同账户访问量（Unique Visitor，UV））；")]),s._v(" "),t("li",[s._v("统计用户每天搜索不同词条的个数；")]),s._v(" "),t("li",[s._v("统计注册 IP 数。")])]),s._v(" "),t("h3",{attrs:{id:"统计页面的uv"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#统计页面的uv"}},[s._v("#")]),s._v(" 统计页面的UV：")]),s._v(" "),t("div",{staticClass:"language-sh extra-class"},[t("pre",{pre:!0,attrs:{class:"language-sh"}},[t("code",[t("span",{pre:!0,attrs:{class:"token number"}},[s._v("1")]),s._v(".将访问页面的每个用户 ID 添加到 HyperLogLog 中。\nPFADD key:uv userID1 userID2 useID3\n"),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("2")]),s._v(".利用 PFCOUNT 获取key的UV值。\nPFCOUNT key:uv\n")])])]),t("div",{staticClass:"language-sh extra-class"},[t("pre",{pre:!0,attrs:{class:"language-sh"}},[t("code",[s._v("合并\nPFADD Redis数据 user1 user2 user3\nPFADD MySQL数据 user1 user2 user4\nPFMERGE 数据库 Redis数据 MySQL数据\nPFCOUNT 数据库 // 返回值 "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("4")]),s._v("\n")])])]),t("p",[s._v("https://segmentfault.com/a/1190000041696066")]),s._v(" "),t("h2",{attrs:{id:"各数据类型使用场景"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#各数据类型使用场景"}},[s._v("#")]),s._v(" 各数据类型使用场景")]),s._v(" "),t("p",[s._v("string：1、常规key-value缓存应用。常规计数如微博数、粉丝数。2、分布式锁。")]),s._v(" "),t("p",[s._v("hash：存放结构化数据，如用户信息（昵称、年龄、性别、积分等）。")]),s._v(" "),t("p",[s._v("list：热门博客列表、消息队列系统。使用list可以构建队列系统，比如：将Redis用作日志收集器，多个端点将日志信息写入Redis，然后一个worker统一将所有日志写到磁盘。")]),s._v(" "),t("p",[s._v("set：1、好友关系，微博粉丝的共同关注、共同喜好、共同好友等；2、利用唯一性，统计访问网站的所有独立ip 。")]),s._v(" "),t("p",[s._v("zset：1、排行榜；2、优先级队列。")])])}),[],!1,null,null,null);t.default=r.exports}}]);