(window.webpackJsonp=window.webpackJsonp||[]).push([[41],{365:function(s,a,t){"use strict";t.r(a);var e=t(7),n=Object(e.a)({},(function(){var s=this,a=s._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[a("p",[s._v("InnoDB 是 MySQL 数据库中一种常见的存储引擎，它使用 MVCC 技术来实现并发控制。")]),s._v(" "),a("p",[s._v("MVCC 的流程可以一定程度上解决幻读问题。幻读是指在同一事务中，第二次读取同样的查询条件，却得到了不同的结果，通常发生在并发事务中插入或删除数据时。MVCC 使用快照读（Snapshot Read）和当前读（Current Read）来避免幻读问题。")]),s._v(" "),a("p",[s._v("对于 InnoDB 引擎，MVCC 的实现方式是通过使用多版本数据行来避免锁竞争问题。具体地，每行数据在表中存储多个版本，每个版本都有一个时间戳，用于表示该版本的创建时间。事务在执行读操作时，会根据其启动时间来选择一个一致性视图（Consistent Read View），只能看到该视图中已经存在的数据，因此可以避免幻读的问题。")]),s._v(" "),a("p",[s._v("如果在>80的范围内插入一条90的数据，在 InnoDB 引擎中，如果该事务使用的是快照读，那么它将看不到这条记录，因此也不会出现幻读问题。如果该事务使用的是当前读，那么它将会锁定记录，避免其他并发事务对该记录进行修改或删除操作，从而避免幻读的问题。")]),s._v(" "),a("p",[s._v("需要注意的是，InnoDB 引擎中仍然存在一些特殊情况下可能会出现幻读问题，例如在读取一些特殊的索引时。为了避免这些问题，可以使用一些技术来提高 MVCC 的可靠性，例如使用间隙锁（Gap Lock）来避免幻读。")]),s._v(" "),a("h2",{attrs:{id:"快照读和当前读"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#快照读和当前读"}},[s._v("#")]),s._v(" 快照读和当前读")]),s._v(" "),a("p",[s._v("在数据库中，快照读和当前读是两种不同的读取数据的方式。")]),s._v(" "),a("p",[s._v("快照读是指在读取数据时，读取的是数据库在事务开始时的一个快照，不会受到其他并发事务的影响。在 MySQL 数据库中，可以使用 SELECT 语句来进行快照读取，例如：")]),s._v(" "),a("div",{staticClass:"language-sql extra-class"},[a("pre",{pre:!0,attrs:{class:"language-sql"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("SELECT")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("*")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("FROM")]),s._v(" table_name"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n")])])]),a("p",[s._v("当前读则会锁定记录，保证在当前事务内读取的数据是最新的。在 MySQL 数据库中，如果需要进行当前读操作，可以使用 FOR UPDATE 或者 FOR SHARE 语句来进行锁定，例如：")]),s._v(" "),a("div",{staticClass:"language-sql extra-class"},[a("pre",{pre:!0,attrs:{class:"language-sql"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("SELECT")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("*")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("FROM")]),s._v(" table_name "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("WHERE")]),s._v(" column_name "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("value")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("FOR")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("UPDATE")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n")])])]),a("p",[s._v("在以上语句中，FOR UPDATE 表示对查询到的记录进行排它锁定，其他事务不能修改或者锁定该记录，而 FOR SHARE 则表示对查询到的记录进行共享锁定，其他事务不能修改该记录，但可以读取该记录。")]),s._v(" "),a("p",[s._v("需要注意的是，不同的数据库管理系统中可能具有不同的语法来进行快照读或当前读操作，具体的实现方式可能会有所不同。")])])}),[],!1,null,null,null);a.default=n.exports}}]);