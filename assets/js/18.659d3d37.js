(window.webpackJsonp=window.webpackJsonp||[]).push([[18],{342:function(t,r,v){"use strict";v.r(r);var a=v(7),o=Object(a.a)({},(function(){var t=this,r=t._self._c;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("h2",{attrs:{id:"堆溢出"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#堆溢出"}},[t._v("#")]),t._v(" 堆溢出")]),t._v(" "),r("p",[t._v("将堆的最小值-Xms参数与最大值-Xmx参数设置为一样的话可避免堆自动扩展，即设置为不可扩展。")]),t._v(" "),r("p",[t._v("要解决这个内存区域的异常， 常规的处理方法是首先通过内存映像分析工具（如MAT）对Dump出来的堆转储快照进行分析。 第一步首先应确认内存中导致OOM的对象是否是必要的， 也就是要先分清楚到底是出现了内存泄漏（Memory Leak） 还是内存溢出（Memory Overflow） 。")]),t._v(" "),r("p",[t._v("如果是内存泄漏， 可进一步通过工具查看泄漏对象到GC Roots的引用链， 找到泄漏对象是通过怎样的引用路径、 与哪些GC Roots相关联， 才导致垃圾收集器无法回收它们， 根据泄漏对象的类型信息以及它到GC Roots引用链的信息， 一般可以比较准确地定位到这些对象创建的位置， 进而找出产生内存泄漏的代码的具体位置。")]),t._v(" "),r("p",[t._v("如果不是内存泄漏， 换句话说就是内存中的对象确实都是必须存活的， 那就应当检查Java虚拟机的堆参数（-Xmx与-Xms） 设置， 与机器的内存对比， 看看是否还有向上调整的空间。 再从代码上检查是否存在某些对象生命周期过长、 持有状态时间过长、 存储结构设计不合理等情况， 尽量减少程序运行期的内存消耗。")]),t._v(" "),r("p",[t._v("步骤：")]),t._v(" "),r("ol",[r("li",[t._v("使用 jps或者 ps -ef | grep XXXX 查看运行的Java项目信息")]),t._v(" "),r("li",[t._v("由使用 jmap dump内存快照时，如果当前用户与启动进程的用户不一致时，不允许进行快照的备份。查询进程启动所属："),r("code",[t._v("top -pid PID")]),t._v("，其中 COMMAND 信息就是启动进程的所属，sudo 到这个所属用户即可。")]),t._v(" "),r("li",[t._v("dump 保存内存快照信息：jmap -dump:live, format=b, file=dump.hprof 2629")]),t._v(" "),r("li",[t._v("使用 MAT 加载dump文件。")])]),t._v(" "),r("h2",{attrs:{id:"栈溢出"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#栈溢出"}},[t._v("#")]),t._v(" 栈溢出")]),t._v(" "),r("p",[t._v("由于HotSpot虚拟机并不区分虚拟机栈和本地方法栈，所以栈容量只由 -Xss参数决定。")]),t._v(" "),r("ol",[r("li",[t._v("如果线程请求的栈深度大于虚拟机所允许的最大深度， 将抛出StackOverflowError异常。")]),t._v(" "),r("li",[r("strong",[t._v("如果虚拟机的栈内存允许动态扩展")]),t._v("， 当扩展栈容量无法申请到足够的内存时， 将抛出OutOfMemoryError异常。")])]),t._v(" "),r("h2",{attrs:{id:"本机直接内存溢出"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#本机直接内存溢出"}},[t._v("#")]),t._v(" 本机直接内存溢出")]),t._v(" "),r("p",[t._v("直接内存（Direct Memory） 的容量大小可通过-XX： MaxDirectMemorySize参数来指定， 如果不去指定， 则默认与Java堆最大值（由-Xmx指定） 一致。")]),t._v(" "),r("p",[t._v("由直接内存导致的内存溢出， 一个明显的特征是在Heap Dump文件中不会看见有什么明显的异常情况， 如果读者发现内存溢出之后产生的Dump文件很小， 而程序中又直接或间接使用了DirectMemory（典型的间接使用就是NIO） ， 那就可以考虑重点检查一下直接内存方面的原因了。")])])}),[],!1,null,null,null);r.default=o.exports}}]);