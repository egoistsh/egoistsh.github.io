(window.webpackJsonp=window.webpackJsonp||[]).push([[16],{340:function(v,_,a){"use strict";a.r(_);var t=a(7),r=Object(t.a)({},(function(){var v=this,_=v._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("p",[_("img",{attrs:{src:"https://p.ipic.vip/nux2x4.png",alt:"image.png"}})]),v._v(" "),_("p",[v._v("线程私有：程序计数器、虚拟机栈、本地方法栈")]),v._v(" "),_("p",[v._v("线程共享：堆、方法区、堆外内存（JDK8的元空间、代码缓存）")]),v._v(" "),_("p",[v._v("栈是运行时的单位，而堆是存储的单位。")]),v._v(" "),_("p",[v._v("栈解决程序的运行问题，即程序如何执行，或者说如何处理数据。堆解决的是数据存储的问题，即数据怎么放、放在哪。")]),v._v(" "),_("h2",{attrs:{id:"堆"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#堆"}},[v._v("#")]),v._v(" 堆")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("对象实例以及数组都在这里分配内存")])]),v._v(" "),_("li",[_("p",[v._v("新生代：eden、from survivor、to survior 8:1:1")]),v._v(" "),_("ul",[_("li",[v._v("当 Eden 空间被对象填充时，执行"),_("strong",[v._v("Minor GC")]),v._v("，并将所有幸存者对象移动到一个幸存者空间中")])])]),v._v(" "),_("li",[_("p",[v._v("老年代：老年代垃圾收集称为 Major GC，通常需要更长的时间。")])]),v._v(" "),_("li",[_("p",[v._v("永久代（JDK 8用元空间取代）。永久代物理是堆的一部分，和新生代，老年代地址是连续的（受垃圾回收器管理），而元空间存在于本地内存（我们常说的堆外内存，不受垃圾回收器管理），这样就不受 JVM 限制了，也比较难发生OOM（都会有溢出异常）。")])]),v._v(" "),_("li",[_("p",[v._v("元空间存储类的元信息，"),_("strong",[v._v("静态变量和字符串常量池")]),v._v("等并入堆中。相当于永久代的数据被分到了堆和元空间中。")])]),v._v(" "),_("li",[_("p",[v._v("分代的目的是优化 GC 性能。")])])]),v._v(" "),_("p",[v._v("堆配置：")]),v._v(" "),_("ul",[_("li",[v._v("-Xms: 配置堆的起始内存（最小内存）。等价于 "),_("code",[v._v("-XX:InitialHeapSize")]),v._v("。默认是物理内存1/64。")]),v._v(" "),_("li",[v._v("-Xmx: 配置堆的最大内存。等价于 "),_("code",[v._v("-XX:MaxHeapSize")]),v._v("。")]),v._v(" "),_("li",[v._v("默认情况下新生代和老年代的比例是 1:2，可以通过 "),_("code",[v._v("–XX:NewRatio")]),v._v(" 来配置")]),v._v(" "),_("li",[v._v("新生代中的 "),_("strong",[v._v("Eden")]),v._v(":"),_("strong",[v._v("From Survivor")]),v._v(":"),_("strong",[v._v("To Survivor")]),v._v(" 的比例是 "),_("strong",[v._v("8:1:1")]),v._v("，可以通过 "),_("code",[v._v("-XX:SurvivorRatio")]),v._v(" 来配置")]),v._v(" "),_("li",[v._v("若在 JDK 7 中开启了 "),_("code",[v._v("-XX:+UseAdaptiveSizePolicy")]),v._v("，JVM 会动态调整 JVM 堆中各个区域的大小以及进入老年代的年龄，此时 "),_("code",[v._v("–XX:NewRatio")]),v._v(" 和 "),_("code",[v._v("-XX:SurvivorRatio")]),v._v(" 将会失效，而 JDK 8 是默认开启"),_("code",[v._v("-XX:+UseAdaptiveSizePolicy")]),v._v("，在 JDK 8中，"),_("strong",[v._v("不要随意关闭")]),_("code",[v._v("-XX:+UseAdaptiveSizePolicy")]),v._v("，除非对堆内存的划分有明确的规划。")]),v._v(" "),_("li",[_("strong",[v._v("对象年轻计数器")]),v._v("（"),_("code",[v._v("-XX:MaxTenuringThreshold")]),v._v("）")]),v._v(" "),_("li",[v._v("如果分配的对象超过了"),_("code",[v._v("-XX:PetenureSizeThreshold")]),v._v("，对象会"),_("strong",[v._v("直接被分配到老年代")])]),v._v(" "),_("li",[v._v("Java7 中我们通过"),_("code",[v._v("-XX:PermSize")]),v._v(" 和 "),_("code",[v._v("-xx:MaxPermSize")]),v._v(" 来设置永久代参数，Java8 之后，随着永久代的取消，这些参数也就随之失效了，改为通过"),_("code",[v._v("-XX:MetaspaceSize")]),v._v(" 和 "),_("code",[v._v("-XX:MaxMetaspaceSize")]),v._v(" 用来设置元空间参数")])]),v._v(" "),_("h3",{attrs:{id:"将-xmx-和-xms-两个参数配置为相同的值"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#将-xmx-和-xms-两个参数配置为相同的值"}},[v._v("#")]),v._v(" 将 "),_("code",[v._v("-Xmx")]),v._v(" 和 "),_("code",[v._v("-Xms")]),v._v(" 两个参数配置为相同的值")]),v._v(" "),_("p",[v._v("如：常规的JVM参数使用")]),v._v(" "),_("div",{staticClass:"language-javascript extra-class"},[_("pre",{pre:!0,attrs:{class:"language-javascript"}},[_("code",[v._v("java "),_("span",{pre:!0,attrs:{class:"token operator"}},[v._v("-")]),v._v("Xms512m "),_("span",{pre:!0,attrs:{class:"token operator"}},[v._v("-")]),v._v("Xmx1g\n")])])]),_("p",[v._v("在这种配置下，JVM启动时会分配512M的堆内存空间，随着程序的执行，所需的堆空间越来越大，则会逐渐增大堆内存空间，直到Xmx参数指定的堆最大空间1G。当堆内存使用率降低，则会逐渐减小该内存区域的大小。")]),v._v(" "),_("p",[v._v("我们通常会将 "),_("code",[v._v("-Xmx")]),v._v(" 和 "),_("code",[v._v("-Xms")]),v._v(" 两个参数配置为相同的值，为了避免由于heap内存扩大或缩小导致应用停顿，降低延迟，同时避免每次垃圾回收完成后JVM重新分配内存。")]),v._v(" "),_("h3",{attrs:{id:"minor-gc、major-gc、full-gc"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#minor-gc、major-gc、full-gc"}},[v._v("#")]),v._v(" Minor GC、Major GC、Full GC")]),v._v(" "),_("p",[v._v("针对 HotSpot VM 的实现，它里面的 GC 按照回收区域又分为两大类：部分收集（Partial GC），整堆收集（Full GC）")]),v._v(" "),_("ul",[_("li",[v._v("部分收集：不是完整收集整个 Java 堆的垃圾收集。其中又分为：\n"),_("ul",[_("li",[v._v("新生代收集（Minor GC/Young GC）：只是新生代的垃圾收集")]),v._v(" "),_("li",[v._v("老年代收集（Major GC/Old GC）：只是老年代的垃圾收集\n"),_("ul",[_("li",[v._v("目前，只有 CMS GC 会有单独收集老年代的行为")]),v._v(" "),_("li",[v._v("很多时候 Major GC 会和 Full GC 混合使用，需要具体分辨是老年代回收还是整堆回收")])])]),v._v(" "),_("li",[v._v("混合收集（Mixed GC）：收集整个新生代以及部分老年代的垃圾收集\n"),_("ul",[_("li",[v._v("目前只有 G1 GC 会有这种行为")])])])])]),v._v(" "),_("li",[v._v("整堆收集（Full GC）：收集整个 Java 堆和方法区的垃圾")])]),v._v(" "),_("h2",{attrs:{id:"方法区"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#方法区"}},[v._v("#")]),v._v(" 方法区")]),v._v(" "),_("p",[v._v("也称为非堆 non-heap")]),v._v(" "),_("p",[v._v("方法区的实现JDK7用永久代，JDK8改用本地内存的元空间。")]),v._v(" "),_("p",[v._v("方法区用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据。")]),v._v(" "),_("p",[v._v("虽然 Java 虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫 Non-Heap（非堆），目的应该是与 Java 堆区分开。")]),v._v(" "),_("p",[_("strong",[v._v("运行时常量池")]),v._v("（Runtime Constant Pool）是方法区的一部分。Class 文件中除了有"),_("strong",[v._v("类的版本/字段/方法/接口等描述信息外")]),v._v("，还有一项信息是常量池（Constant Pool Table），用于存放编译期生成的各种字面量和符号引用，这部分内容将类在加载后进入方法区的运行时常量池中存放。运行期间也可能将新的常量放入池中，这种特性被开发人员利用得比较多的是 "),_("code",[v._v("String.intern()")]),v._v("方法。受方法区内存的限制，当常量池无法再申请到内存时会抛出 "),_("code",[v._v("OutOfMemoryError")]),v._v(" 异常。")]),v._v(" "),_("p",[v._v("方法区的大小和堆空间一样，可以选择固定大小也可选择可扩展，方法区的大小决定了系统可以放多少个类，如果系统类太多，导致方法区溢出，虚拟机同样会抛出内存溢出错误。")]),v._v(" "),_("h3",{attrs:{id:"类型信息"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#类型信息"}},[v._v("#")]),v._v(" 类型信息")]),v._v(" "),_("p",[v._v("对每个加载的类型（类 class、接口 interface、枚举 enum、注解 annotation），JVM 必须在方法区中存储以下类型信息")]),v._v(" "),_("ul",[_("li",[v._v("这个类型的完整有效名称（全名=包名.类名）")]),v._v(" "),_("li",[v._v("这个类型直接父类的完整有效名（对于 interface或是 java.lang.Object，都没有父类）")]),v._v(" "),_("li",[v._v("这个类型的修饰符（public，abstract，final 的某个子集）")]),v._v(" "),_("li",[v._v("这个类型直接接口的一个有序列表")])]),v._v(" "),_("h3",{attrs:{id:"对于方法区-java8-之后的变化"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#对于方法区-java8-之后的变化"}},[v._v("#")]),v._v(" 对于方法区，Java8 之后的变化：")]),v._v(" "),_("ul",[_("li",[v._v("移除了永久代（PermGen），替换为元空间（Metaspace）；")]),v._v(" "),_("li",[v._v("永久代中的 class metadata 转移到了 native memory（本地内存，而不是虚拟机）；")]),v._v(" "),_("li",[v._v("永久代中的 interned Strings （字符串常量池）和 class static variables （静态变量）转移到了 Java heap；")]),v._v(" "),_("li",[v._v("永久代参数 （PermSize MaxPermSize） -> 元空间参数（MetaspaceSize MaxMetaspaceSize）")])]),v._v(" "),_("h3",{attrs:{id:"方法区的垃圾回收"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#方法区的垃圾回收"}},[v._v("#")]),v._v(" 方法区的垃圾回收")]),v._v(" "),_("p",[v._v("方法区的垃圾收集主要回收两部分内容："),_("strong",[v._v("常量池中废弃的常量和不再使用的类型")]),v._v("。")]),v._v(" "),_("p",[v._v("先来说说方法区内常量池之中主要存放的两大类常量：字面量和符号引用。字面量比较接近 Java 语言层次的常量概念，如文本字符串、被声明为 final 的常量值等。而符号引用则属于编译原理方面的概念，包括下面三类常量：")]),v._v(" "),_("ul",[_("li",[v._v("类和接口的全限定名")]),v._v(" "),_("li",[v._v("字段的名称和描述符")]),v._v(" "),_("li",[v._v("方法的名称和描述符")])]),v._v(" "),_("p",[v._v("HotSpot 虚拟机对常量池的回收策略是很明确的，只要常量池中的常量没有被任何地方引用，就可以被回收")]),v._v(" "),_("p",[v._v("判定一个类型是否属于“不再被使用的类”，需要同时满足三个条件：")]),v._v(" "),_("ul",[_("li",[v._v("该类所有的实例都已经被回收，也就是 Java 堆中不存在该类及其任何派生子类的实例")]),v._v(" "),_("li",[v._v("加载该类的类加载器已经被回收，这个条件除非是经过精心设计的可替换类加载器的场景，如 OSGi、JSP 的重加载等，否则通常很难达成")]),v._v(" "),_("li",[v._v("该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法")])]),v._v(" "),_("p",[v._v("Java 虚拟机被允许堆满足上述三个条件的无用类进行回收，这里说的仅仅是“被允许”，而并不是和对象一样，不使用了就必然会回收。是否对类进行回收，HotSpot 虚拟机提供了 "),_("code",[v._v("-Xnoclassgc")]),v._v(" 参数进行控制，还可以使用 "),_("code",[v._v("-verbose:class")]),v._v(" 以及 "),_("code",[v._v("-XX:+TraceClassLoading")]),v._v(" 、"),_("code",[v._v("-XX:+TraceClassUnLoading")]),v._v(" 查看类加载和卸载信息。")]),v._v(" "),_("p",[v._v("在大量使用反射、动态代理、CGLib 等 ByteCode 框架、动态生成 JSP 以及 OSGi 这类频繁自定义 ClassLoader 的场景都需要虚拟机具备类卸载的功能，以保证永久代不会溢出。")]),v._v(" "),_("h2",{attrs:{id:"虚拟机栈"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#虚拟机栈"}},[v._v("#")]),v._v(" 虚拟机栈")]),v._v(" "),_("ul",[_("li",[v._v("每个方法被执行时，都会创建一个栈帧（Stack Frame）用于存储局部变量表、操作数栈、动态连接、方法出口等信息。")]),v._v(" "),_("li",[v._v("在一条活动线程中，一个时间点上，只会有一个活动的栈帧。即只有当前正在执行的方法的栈帧（"),_("strong",[v._v("栈顶栈帧")]),v._v("）是有效的，这个栈帧被称为"),_("strong",[v._v("当前栈帧")]),v._v("（Current Frame），与当前栈帧对应的方法就是"),_("strong",[v._v("当前方法")]),v._v("（Current Method），定义这个方法的类就是"),_("strong",[v._v("当前类")]),v._v("（Current Class）。")]),v._v(" "),_("li",[v._v("执行引擎运行的所有字节码指令只针对当前栈帧进行操作。")]),v._v(" "),_("li",[v._v("不同线程中所包含的栈帧是不允许存在相互引用的，即不可能在一个栈帧中引用另外一个线程的栈帧。")]),v._v(" "),_("li",[v._v("Java 方法有两种返回函数的方式，"),_("strong",[v._v("一种是正常的函数返回，使用 return 指令，另一种是抛出异常，不管用哪种方式，都会导致栈帧被弹出")]),v._v("。")]),v._v(" "),_("li",[_("strong",[v._v("栈不存在垃圾回收问题")])])]),v._v(" "),_("p",[_("img",{attrs:{src:"https://p.ipic.vip/ilwgdv.png",alt:"image-20230319183129970"}})]),v._v(" "),_("p",[_("strong",[v._v("栈中可能出现的异常")]),v._v("：")]),v._v(" "),_("p",[v._v("Java 虚拟机规范允许 "),_("strong",[v._v("Java虚拟机栈的大小是动态的或者是固定不变的")])]),v._v(" "),_("ul",[_("li",[v._v("如果采用固定大小的 Java 虚拟机栈，那每个线程的 Java 虚拟机栈容量可以在线程创建的时候独立选定。如果线程请求分配的栈容量超过 Java 虚拟机栈允许的最大容量，Java 虚拟机将会抛出一个 "),_("strong",[v._v("StackOverflowError")]),v._v(" 异常")]),v._v(" "),_("li",[v._v("如果 Java 虚拟机栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的虚拟机栈，那 Java 虚拟机将会抛出一个"),_("strong",[v._v("OutOfMemoryError")]),v._v("异常")])]),v._v(" "),_("p",[v._v("可以通过参数"),_("code",[v._v("-Xss")]),v._v("来设置线程的最大栈空间，栈的大小直接决定了函数调用的最大可达深度。")]),v._v(" "),_("h2",{attrs:{id:"本地方法栈"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#本地方法栈"}},[v._v("#")]),v._v(" 本地方法栈")]),v._v(" "),_("ul",[_("li",[v._v("与虚拟机栈相似，只是服务的是native 方法。")]),v._v(" "),_("li",[v._v("Unsafe 类就有很多本地方法。")])]),v._v(" "),_("h2",{attrs:{id:"程序计数器"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#程序计数器"}},[v._v("#")]),v._v(" 程序计数器")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("记录当前线程所执行的字节码的行号。JVM 中的 PC 寄存器是对物理 PC 寄存器的一种抽象模拟。")])]),v._v(" "),_("li",[_("p",[v._v("因为CPU需要不停的切换各个线程，这时候切换回来以后，就得知道接着从哪开始继续执行。JVM的字节码解释器就需要通过改变PC寄存器的值来明确下一条应该执行什么样的字节码指令。")])]),v._v(" "),_("li",[_("p",[v._v("它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。")])]),v._v(" "),_("li",[_("p",[_("strong",[v._v("它是唯一一个在 JVM 规范中没有规定任何 "),_("code",[v._v("OutOfMemoryError")]),v._v(" 情况的区域")])])])]),v._v(" "),_("h2",{attrs:{id:"本地内存-元空间、直接内存"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#本地内存-元空间、直接内存"}},[v._v("#")]),v._v(" 本地内存（元空间、直接内存）")]),v._v(" "),_("ul",[_("li",[v._v("如NIO，分配堆外内存，避免了在 Java 堆和 Native 堆之间来回复制数据，可提高性能。")])]),v._v(" "),_("h2",{attrs:{id:"运行时常量池-runtime-constant-pool"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#运行时常量池-runtime-constant-pool"}},[v._v("#")]),v._v(" 运行时常量池（Runtime Constant Pool）")]),v._v(" "),_("p",[v._v("运行时常量池（Runtime Constant Pool）是方法区的一部分。")]),v._v(" "),_("p",[v._v("理解运行时常量池：")]),v._v(" "),_("p",[v._v("字节码文件（Class 文件）中的包含一项信息常量池 Constant Pool，它可以看作是一张表，虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量等类型。")]),v._v(" "),_("p",[v._v("常量池表（Constant Pool Table）是 Class 文件的一部分，用于存储编译期生成的各种字面量和符号引用，这部分内容将在类加载后存放到方法区的"),_("strong",[v._v("运行时常量池")]),v._v("中。")]),v._v(" "),_("p",[v._v("JDK1.7 之前运行时常量池逻辑包含字符串常量池存放在"),_("strong",[v._v("方法区")]),v._v(", 此时 hotspot 虚拟机对方法区的实现为永久代。")]),v._v(" "),_("p",[v._v("JDK1.7字符串常量池被从方法区拿到了堆中, 这里没有提到运行时常量池,也就是说字符串常量池被单独拿到堆,运行时常量池剩下的东西还在方法区, 也就是 hotspot 中的永久代。")]),v._v(" "),_("p",[v._v("JDK1.8 hotspot 移除了永久代用元空间(Metaspace)取而代之, 这时候"),_("strong",[v._v("字符串常量池还在堆")]),v._v(", "),_("strong",[v._v("运行时常量池还在方法区")]),v._v(", 只不过方法区的实现从永久代变成了元空间(Metaspace)。")]),v._v(" "),_("p",[v._v("引申的问题：")]),v._v(" "),_("p",[v._v("为什么要改永久代为元空间去实现方法区？")]),v._v(" "),_("p",[v._v("因为用永久代实现导致Java应用更容易产生内存溢出问题。而改用本地内存实现的元空间则比较好。")])])}),[],!1,null,null,null);_.default=r.exports}}]);