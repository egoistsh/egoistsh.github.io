(window.webpackJsonp=window.webpackJsonp||[]).push([[27],{351:function(e,a,t){"use strict";t.r(a);var s=t(7),v=Object(s.a)({},(function(){var e=this,a=e._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h2",{attrs:{id:"java线程池为什么不设计成先扩大线程数再加入阻塞队列"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#java线程池为什么不设计成先扩大线程数再加入阻塞队列"}},[e._v("#")]),e._v(" Java线程池为什么不设计成先扩大线程数再加入阻塞队列？")]),e._v(" "),a("ol",[a("li",[a("strong",[e._v("资源利用率：")]),e._v(" 在大多数情况下，线程的创建和销毁都比较昂贵。如果每个新任务都立即创建一个新线程，这会导致频繁的线程创建和销毁，浪费系统资源。通过将任务放入阻塞队列，可以将任务排队，以便线程可以重用，从而更有效地利用资源。")]),e._v(" "),a("li",[a("strong",[e._v("控制并发度：")]),e._v(" 通过将任务放入队列，线程池可以更好地控制并发度。线程池可以根据负载和资源情况来决定是否需要创建新线程，以保持合适的并发度。这可以防止系统过载，避免创建过多的线程导致性能下降或资源竞争。")]),e._v(" "),a("li",[a("strong",[e._v("避免线程爆炸：")]),e._v(" 如果不使用阻塞队列，当有大量任务同时到达时，会导致大量线程同时创建，这可能会导致系统的线程数急剧增加，从而增加了上下文切换的开销，甚至可能导致系统崩溃。通过使用阻塞队列，可以平滑地处理任务，避免线程爆炸。")])]),e._v(" "),a("h2",{attrs:{id:"核心参数"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#核心参数"}},[e._v("#")]),e._v(" 核心参数")]),e._v(" "),a("div",{staticClass:"language-java extra-class"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("public")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("ThreadPoolExecutor")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("int")]),e._v(" corePoolSize"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v("\n                              "),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("int")]),e._v(" maximumPoolSize"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v("\n                              "),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("long")]),e._v(" keepAliveTime"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v("\n                              "),a("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("TimeUnit")]),e._v(" unit"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v("\n                              "),a("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("BlockingQueue")]),a("span",{pre:!0,attrs:{class:"token generics"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("<")]),a("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("Runnable")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(">")])]),e._v(" workQueue"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v("\n                              "),a("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("ThreadFactory")]),e._v(" threadFactory"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v("\n                              "),a("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("RejectedExecutionHandler")]),e._v(" handler"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v("\n")])])]),a("h2",{attrs:{id:"阻塞队列-blockingqueue"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#阻塞队列-blockingqueue"}},[e._v("#")]),e._v(" 阻塞队列 BlockingQueue")]),e._v(" "),a("p",[a("code",[e._v("ArrayBlockingQueue")]),e._v(": 基于数组结构的有界阻塞队列，按FIFO排序任务；")]),e._v(" "),a("p",[a("code",[e._v("LinkedBlockingQueue")]),e._v(": 基于链表结构的阻塞队列，按FIFO排序任务，吞吐量通常要高于ArrayBlockingQueue；")]),e._v(" "),a("p",[a("code",[e._v("SynchronousQueue")]),e._v(": 一个不存储元素的阻塞队列，每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于LinkedBlockingQueue；")]),e._v(" "),a("p",[a("code",[e._v("PriorityBlockingQueue")]),e._v(": 具有优先级的无界阻塞队列；")]),e._v(" "),a("p",[a("code",[e._v("LinkedBlockingQueue")]),e._v("比"),a("code",[e._v("ArrayBlockingQueue")]),e._v("在插入删除节点性能方面更优，但是二者在"),a("code",[e._v("put()")]),e._v(", "),a("code",[e._v("take()")]),e._v("任务的时均需要加锁，"),a("code",[e._v("SynchronousQueue")]),e._v("使用无锁算法，根据节点的状态判断执行，而不需要用到锁，其核心是"),a("code",[e._v("Transfer.transfer()")]),e._v(".")]),e._v(" "),a("h2",{attrs:{id:"拒绝策略"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#拒绝策略"}},[e._v("#")]),e._v(" 拒绝策略")]),e._v(" "),a("p",[a("code",[e._v("AbortPolicy")]),e._v(": 直接抛出异常，"),a("strong",[e._v("默认策略")]),e._v("；")]),e._v(" "),a("p",[a("code",[e._v("CallerRunsPolicy")]),e._v(": 用调用者所在的线程来执行任务；")]),e._v(" "),a("p",[a("code",[e._v("DiscardOldestPolicy")]),e._v(": 丢弃阻塞队列中最老的任务，将此任务加入到阻塞队列中；")]),e._v(" "),a("p",[a("code",[e._v("DiscardPolicy")]),e._v(": 直接丢弃任务；")]),e._v(" "),a("p",[e._v("也可以根据应用场景实现RejectedExecutionHandler接口，自定义饱和策略，如记录日志或持久化存储不能处理的任务。")]),e._v(" "),a("h2",{attrs:{id:"threadfactory"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#threadfactory"}},[e._v("#")]),e._v(" threadFactory")]),e._v(" "),a("p",[a("code",[e._v("threadFactory")]),e._v("创建线程的工厂，通过自定义的线程工厂可以给每个新建的线程设置一个具有识别度的线程名。默认为"),a("code",[e._v("Executors.defaultThreadFactory()")]),e._v("。")]),e._v(" "),a("h2",{attrs:{id:"执行过程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#执行过程"}},[e._v("#")]),e._v(" 执行过程")]),e._v(" "),a("ol",[a("li",[a("p",[e._v("线程池首先当前运行的线程数量是否少于corePoolSize。如果是，则创建一个新的工作线程来执行任务。如果都在执行任务，则进入2.")])]),e._v(" "),a("li",[a("p",[e._v("判断BlockingQueue是否已经满了，倘若还没有满，则将线程放入BlockingQueue。否则进入3.")])]),e._v(" "),a("li",[a("p",[e._v("创建一个新的工作线程，如果使当前运行的线程数量超过maximumPoolSize，则交给RejectedExecutionHandler来处理任务。")])])]),e._v(" "),a("h2",{attrs:{id:"为什么线程池不允许使用executors去创建-推荐方式是什么"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#为什么线程池不允许使用executors去创建-推荐方式是什么"}},[e._v("#")]),e._v(" 为什么线程池不允许使用Executors去创建? 推荐方式是什么?")]),e._v(" "),a("p",[e._v("线程池不允许使用Executors去创建，而是通过ThreadPoolExecutor的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。")]),e._v(" "),a("p",[e._v("说明：Executors各个方法的弊端：")]),e._v(" "),a("ul",[a("li",[e._v("newFixedThreadPool和newSingleThreadExecutor：主要问题是堆积的请求处理队列（"),a("code",[e._v("LinkedBlockingQueue<Runnable>")]),e._v("的无界队列）可能会耗费非常大的内存，甚至OOM。")]),e._v(" "),a("li",[e._v("newCachedThreadPool和newScheduledThreadPool：主要问题是线程数最大数是"),a("code",[e._v("Integer.MAX_VALUE")]),e._v("，可能会创建数量非常多的线程，甚至OOM。")])]),e._v(" "),a("h2",{attrs:{id:"配置线程池需要考虑因素"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#配置线程池需要考虑因素"}},[e._v("#")]),e._v(" 配置线程池需要考虑因素")]),e._v(" "),a("p",[e._v("从任务的优先级，任务的执行时间长短，任务的性质(CPU密集/ IO密集)，任务的依赖关系这四个角度来分析。并且近可能地使用有界的工作队列。")]),e._v(" "),a("p",[e._v("性质不同的任务可用使用不同规模的线程池分开处理:")]),e._v(" "),a("ul",[a("li",[e._v("CPU密集型: 尽可能少的线程，Ncpu+1")]),e._v(" "),a("li",[e._v("IO密集型: 尽可能多的线程, Ncpu*2，比如数据库连接池")]),e._v(" "),a("li",[e._v("混合型: CPU密集型的任务与IO密集型任务的执行时间差别较小，否则没有必要拆分。")])]),e._v(" "),a("p",[e._v("【待验证】")]),e._v(" "),a("ol",[a("li",[a("strong",[e._v("任务的优先级：")]),e._v(" 如果你的应用程序中有不同优先级的任务，可以考虑使用"),a("code",[e._v("ThreadPoolExecutor")]),e._v("的构造函数中的"),a("code",[e._v("ThreadFactory")]),e._v("参数来为不同优先级的任务分配不同的线程池。这允许你为高优先级的任务分配更多的线程资源，以确保它们能够及时执行。此外，你还可以使用优先级队列来管理任务的执行顺序，确保高优先级任务优先执行。")]),e._v(" "),a("li",[a("strong",[e._v("任务的执行时间长短：")]),e._v(" 如果你的应用程序包含执行时间长的任务，可以考虑调整线程池的核心线程数和最大线程数。如果执行时间长的任务较多，可能需要增加线程池的最大线程数，以防止任务排队过长。另外，你还可以使用合适的任务拒绝策略来处理执行时间过长的任务，例如"),a("code",[e._v("CallerRunsPolicy")]),e._v("，它可以将任务在调用线程上执行，而不是放入队列等待。")]),e._v(" "),a("li",[a("strong",[e._v("任务的性质（CPU密集/IO密集）：")]),e._v(" 任务的性质决定了线程池的类型。如果任务是CPU密集型，即它们主要消耗CPU资源而不涉及大量的IO操作，可以考虑使用固定大小的线程池，以充分利用CPU核心。对于IO密集型任务，你可以使用可缩放的线程池，允许根据需求自动调整线程数，以最大程度地利用IO等待时间。")]),e._v(" "),a("li",[a("strong",[e._v("任务的依赖关系：")]),e._v(" 如果任务之间存在依赖关系，需要确保线程池能够正确处理这些依赖关系。你可以使用"),a("code",[e._v("ExecutorCompletionService")]),e._v("来等待任务的完成，并按照它们的完成顺序处理结果。另外，如果任务之间存在依赖关系，要确保线程池的线程数足够大，以避免由于等待依赖任务而导致的性能下降。")])])])}),[],!1,null,null,null);a.default=v.exports}}]);