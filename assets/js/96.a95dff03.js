(window.webpackJsonp=window.webpackJsonp||[]).push([[96],{419:function(v,_,e){"use strict";e.r(_);var o=e(7),r=Object(o.a)({},(function(){var v=this,_=v._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("h2",{attrs:{id:"rocketmq中的消息模型"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#rocketmq中的消息模型"}},[v._v("#")]),v._v(" RocketMQ中的消息模型")]),v._v(" "),_("p",[_("code",[v._v("RocketMQ")]),v._v(" 中的消息模型就是按照 "),_("strong",[v._v("主题模型（发布订阅模式）")]),v._v(" 所实现的。")]),v._v(" "),_("p",[v._v("其实对于主题模型的实现来说每个消息中间件的底层设计都是不一样的，就比如 "),_("code",[v._v("Kafka")]),v._v(" 中的 "),_("strong",[v._v("分区")]),v._v(" ，"),_("code",[v._v("RocketMQ")]),v._v(" 中的 "),_("strong",[v._v("队列")]),v._v(" ，"),_("code",[v._v("RabbitMQ")]),v._v(" 中的 "),_("code",[v._v("Exchange")]),v._v(" 。我们可以理解为 "),_("strong",[v._v("主题模型/发布订阅模型")]),v._v(" 就是一个标准，那些中间件只不过照着这个标准去实现而已。")]),v._v(" "),_("p",[_("img",{attrs:{src:"https://p.ipic.vip/3c3t43.jpg",alt:"img"}})]),v._v(" "),_("p",[v._v("生产者组中的生产者会向主题发送消息，而 "),_("strong",[v._v("主题中存在多个队列")]),v._v("，生产者每次生产消息之后是指定主题中的某个队列发送消息的。")]),v._v(" "),_("p",[v._v("每个主题中都有多个队列(分布在不同的 "),_("code",[v._v("Broker")]),v._v("中，如果是集群的话，"),_("code",[v._v("Broker")]),v._v("又分布在不同的服务器中)，集群消费模式下，一个消费者集群多台机器共同消费一个 "),_("code",[v._v("topic")]),v._v(" 的多个队列，"),_("strong",[v._v("一个队列只会被一个消费者消费")]),v._v("。如果某个消费者挂掉，分组内其它消费者会接替挂掉的消费者继续消费。就像上图中 "),_("code",[v._v("Consumer1")]),v._v(" 和 "),_("code",[v._v("Consumer2")]),v._v(" 分别对应着两个队列，而 "),_("code",[v._v("Consumer3")]),v._v(" 是没有队列对应的，所以一般来讲要控制 "),_("strong",[v._v("消费者组中的消费者个数和主题中队列个数相同")]),v._v(" 。")]),v._v(" "),_("br"),v._v(" "),_("p",[_("strong",[v._v("每个消费组在每个队列上维护一个消费位置")]),v._v(" ，为什么呢？")]),v._v(" "),_("p",[v._v("因为我们刚刚画的仅仅是一个消费者组，我们知道在发布订阅模式中一般会涉及到多个消费者组，而每个消费者组在每个队列中的消费位置都是不同的。如果此时有多个消费者组，那么消息被一个消费者组消费完之后是不会删除的(因为其它消费者组也需要呀)，它仅仅是为每个消费者组维护一个 "),_("strong",[v._v("消费位移(offset)")]),v._v(" ，每次消费者组消费完会返回一个成功的响应，然后队列再把维护的消费位移加一，这样就不会出现刚刚消费过的消息再一次被消费了。")]),v._v(" "),_("p",[_("img",{attrs:{src:"https://p.ipic.vip/svrk6r.jpg",alt:"img"}})]),v._v(" "),_("br"),v._v(" "),_("p",[v._v("为什么一个主题中需要维护多个队列 ？")]),v._v(" "),_("p",[v._v("为了 "),_("strong",[v._v("提高并发能力")]),v._v(" 。的确，每个主题中只存在一个队列也是可行的。但是，这样生产者是不是只能向一个队列发送消息？又因为需要维护消费位置所以一个队列只能对应一个消费者组中的消费者，这样是不是其他的 "),_("code",[v._v("Consumer")]),v._v(" 就没有用武之地了？从这两个角度来讲，并发度一下子就小了很多。")]),v._v(" "),_("p",[v._v("所以总结来说，"),_("code",[v._v("RocketMQ")]),v._v(" 通过"),_("strong",[v._v("使用在一个 "),_("code",[v._v("Topic")]),v._v(" 中配置多个队列并且每个队列维护每个消费者组的消费位置")]),v._v(" 实现了 "),_("strong",[v._v("主题模式/发布订阅模式")]),v._v(" 。")]),v._v(" "),_("h2",{attrs:{id:"rocketmq的架构"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#rocketmq的架构"}},[v._v("#")]),v._v(" RocketMQ的架构")]),v._v(" "),_("p",[_("img",{attrs:{src:"https://p.ipic.vip/xkl6j4.jpg",alt:"img"}})]),v._v(" "),_("ul",[_("li",[_("code",[v._v("NameServer")]),v._v("： 跟 "),_("code",[v._v("ZooKeeper")]),v._v(" 和 "),_("code",[v._v("Spring Cloud")]),v._v(" 中的 "),_("code",[v._v("Eureka")]),v._v(" ，一样是一个 "),_("strong",[v._v("注册中心")]),v._v(" ，主要提供两个功能："),_("strong",[v._v("Broker管理")]),v._v(" 和 "),_("strong",[v._v("路由信息管理")]),v._v(" 。说白了就是 "),_("code",[v._v("Broker")]),v._v(" 会将自己的信息注册到 "),_("code",[v._v("NameServer")]),v._v(" 中，此时 "),_("code",[v._v("NameServer")]),v._v(" 就存放了很多 "),_("code",[v._v("Broker")]),v._v(" 的信息(Broker的路由表)，消费者和生产者就从 "),_("code",[v._v("NameServer")]),v._v(" 中获取路由表然后照着路由表的信息和对应的 "),_("code",[v._v("Broker")]),v._v(" 进行通信(生产者和消费者定期会向 "),_("code",[v._v("NameServer")]),v._v(" 去查询相关的 "),_("code",[v._v("Broker")]),v._v(" 的信息)。")]),v._v(" "),_("li",[_("code",[v._v("Producer")]),v._v("： 消息发布的角色，支持分布式集群方式部署。")]),v._v(" "),_("li",[_("code",[v._v("Consumer")]),v._v("： 消息消费的角色，支持分布式集群方式部署。支持以push推，pull拉两种模式对消息进行消费。同时也支持集群方式和广播方式的消费，它提供实时消息订阅机制。")]),v._v(" "),_("li",[_("code",[v._v("Broker")]),v._v("： 主要负责消息的存储、投递和查询以及服务高可用保证。就是消息队列服务器，生产者生产消息到 "),_("code",[v._v("Broker")]),v._v(" ，消费者从 "),_("code",[v._v("Broker")]),v._v(" 拉取消息并消费。\n"),_("ul",[_("li",[_("code",[v._v("Broker")]),v._v(" 、"),_("code",[v._v("Topic")]),v._v(" 和 队列的关系。上面我讲解了 "),_("code",[v._v("Topic")]),v._v(" 和队列的关系——一个 "),_("code",[v._v("Topic")]),v._v(" 中存在多个队列，那么这个 "),_("code",[v._v("Topic")]),v._v(" 和队列存放在哪呢？")]),v._v(" "),_("li",[_("strong",[v._v("一个 "),_("code",[v._v("Topic")]),v._v(" 分布在多个 "),_("code",[v._v("Broker")]),v._v("上，一个 "),_("code",[v._v("Broker")]),v._v(" 可以配置多个 "),_("code",[v._v("Topic")]),v._v(" ，它们是多对多的关系")]),v._v("。")]),v._v(" "),_("li",[v._v("如果某个 "),_("code",[v._v("Topic")]),v._v(" 消息量很大，应该给它多配置几个队列(上文中提到了提高并发能力)，并且 "),_("strong",[v._v("尽量多分布在不同 "),_("code",[v._v("Broker")]),v._v(" 上，以减轻某个 "),_("code",[v._v("Broker")]),v._v(" 的压力")]),v._v(" 。")])])])]),v._v(" "),_("p",[_("img",{attrs:{src:"https://p.ipic.vip/o96rol.jpg",alt:"img"}})]),v._v(" "),_("p",[_("img",{attrs:{src:"https://p.ipic.vip/tjmhkx.jpg",alt:"img"}})]),v._v(" "),_("p",[v._v("第一、我们的 "),_("code",[v._v("Broker")]),v._v(" "),_("strong",[v._v("做了集群并且还进行了主从部署")]),v._v(" ，由于消息分布在各个 "),_("code",[v._v("Broker")]),v._v(" 上，一旦某个 "),_("code",[v._v("Broker")]),v._v(" 宕机，则该"),_("code",[v._v("Broker")]),v._v(" 上的消息读写都会受到影响。所以 "),_("code",[v._v("Rocketmq")]),v._v(" 提供了 "),_("code",[v._v("master/slave")]),v._v(" 的结构，"),_("code",[v._v("salve")]),v._v(" 定时从 "),_("code",[v._v("master")]),v._v(" 同步数据(同步刷盘或者异步刷盘)，如果 "),_("code",[v._v("master")]),v._v(" 宕机，"),_("strong",[v._v("则 "),_("code",[v._v("slave")]),v._v(" 提供消费服务，但是不能写入消息")]),v._v(" (后面我还会提到哦)。")]),v._v(" "),_("p",[v._v("第二、为了保证 "),_("code",[v._v("HA")]),v._v(" ，我们的 "),_("code",[v._v("NameServer")]),v._v(" 也做了集群部署，但是请注意它是 "),_("strong",[v._v("去中心化")]),v._v(" 的。也就意味着它没有主节点，你可以很明显地看出 "),_("code",[v._v("NameServer")]),v._v(" 的所有节点是没有进行 "),_("code",[v._v("Info Replicate")]),v._v(" 的，在 "),_("code",[v._v("RocketMQ")]),v._v(" 中是通过 "),_("strong",[v._v("单个Broker和所有NameServer保持长连接")]),v._v(" ，并且在每隔30秒 "),_("code",[v._v("Broker")]),v._v(" 会向所有 "),_("code",[v._v("Nameserver")]),v._v(" 发送心跳，心跳包含了自身的 "),_("code",[v._v("Topic")]),v._v(" 配置信息，这个步骤就对应这上面的 "),_("code",[v._v("Routing Info")]),v._v(" 。")]),v._v(" "),_("p",[v._v("第三、在生产者需要向 "),_("code",[v._v("Broker")]),v._v(" 发送消息的时候，"),_("strong",[v._v("需要先从 "),_("code",[v._v("NameServer")]),v._v(" 获取关于 "),_("code",[v._v("Broker")]),v._v(" 的路由信息")]),v._v("，然后通过 "),_("strong",[v._v("轮询")]),v._v(" 的方法去向每个队列中生产数据以达到 "),_("strong",[v._v("负载均衡")]),v._v(" 的效果。")]),v._v(" "),_("p",[v._v("第四、消费者通过 "),_("code",[v._v("NameServer")]),v._v(" 获取所有 "),_("code",[v._v("Broker")]),v._v(" 的路由信息后，向 "),_("code",[v._v("Broker")]),v._v(" 发送 "),_("code",[v._v("Pull")]),v._v(" 请求来获取消息数据。"),_("code",[v._v("Consumer")]),v._v(" 可以以两种模式启动—— "),_("strong",[v._v("广播（Broadcast）和集群（Cluster）")]),v._v("。广播模式下，一条消息会发送给 "),_("strong",[v._v("同一个消费组中的所有消费者")]),v._v(" ，集群模式下消息只会发送给一个消费者。")]),v._v(" "),_("h2",{attrs:{id:"重复消费问题"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#重复消费问题"}},[v._v("#")]),v._v(" 重复消费问题")]),v._v(" "),_("p",[v._v("解决方案：保证消费"),_("strong",[v._v("幂等")]),v._v(" 。在编程中一个幂等操作的特点是其任意多次执行所产生的影响均与一次执行的影响相同。")]),v._v(" "),_("p",[v._v("所以我们需要给我们的消费者实现 "),_("strong",[v._v("幂等")]),v._v(" ，也就是对同一个消息的处理结果，执行多少次都不变。")]),v._v(" "),_("p",[v._v("那么如何给业务实现幂等呢？这个还是需要结合具体的业务的。你可以使用 "),_("strong",[v._v("写入 "),_("code",[v._v("Redis")])]),v._v(" 来保证，因为 "),_("code",[v._v("Redis")]),v._v(" 的 "),_("code",[v._v("key")]),v._v(" 和 "),_("code",[v._v("value")]),v._v(" 就是天然支持幂等的。当然还有使用 "),_("strong",[v._v("数据库插入法")]),v._v(" ，基于数据库的唯一键来保证重复数据不会被插入多条。")]),v._v(" "),_("p",[v._v("不过最主要的还是需要 "),_("strong",[v._v("根据特定场景使用特定的解决方案")]),v._v(" ，你要知道你的消息消费是否是完全不可重复消费还是可以忍受重复消费的，然后再选择强校验和弱校验的方式。毕竟在 CS 领域还是很少有技术银弹的说法。")]),v._v(" "),_("p",[v._v("而在整个互联网领域，幂等不仅仅适用于消息队列的重复消费问题，这些实现幂等的方法，也同样适用于，"),_("strong",[v._v("在其他场景中来解决重复请求或者重复调用的问题")]),v._v(" 。比如将HTTP服务设计成幂等的，"),_("strong",[v._v("解决前端或者APP重复提交表单数据的问题")]),v._v(" ，也可以将一个微服务设计成幂等的，解决 "),_("code",[v._v("RPC")]),v._v(" 框架自动重试导致的 "),_("strong",[v._v("重复调用问题")]),v._v(" 。")]),v._v(" "),_("h2",{attrs:{id:"实现顺序消费"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#实现顺序消费"}},[v._v("#")]),v._v(" 实现顺序消费")]),v._v(" "),_("p",[_("strong",[_("code",[v._v("RocketMQ")]),v._v(" 在主题上是无序的、它只有在队列层面才是保证有序")]),v._v(" 的。")]),v._v(" "),_("p",[v._v("案例：在 "),_("code",[v._v("Producer")]),v._v(" 生产消息的时候会进行轮询(取决你的负载均衡策略)来向同一主题的不同消息队列发送消息。如果此时我有几个消息分别是同一个订单的创建、支付、发货，在轮询的策略下这 "),_("strong",[v._v("三个消息会被发送到不同队列")]),v._v(" ，因为在不同的队列此时就无法使用 "),_("code",[v._v("RocketMQ")]),v._v(" 带来的队列有序特性来保证消息有序性了。")]),v._v(" "),_("p",[v._v("解决方案：将同一语义下的消息放入"),_("strong",[v._v("同一个队列")]),v._v("(比如这里是同一个订单)，那我们就可以使用 "),_("strong",[v._v("Hash取模法")]),v._v(" 来保证同一个订单在同一个队列中。")]),v._v(" "),_("h2",{attrs:{id:"消息堆积问题"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#消息堆积问题"}},[v._v("#")]),v._v(" 消息堆积问题")]),v._v(" "),_("p",[v._v("产生消息堆积的根源其实就只有两个：生产者生产太快或者消费者消费太慢。")]),v._v(" "),_("p",[v._v("如果当流量到峰值的时候是因为生产者生产太快，我们可以使用一些 "),_("strong",[v._v("限流降级")]),v._v(" 的方法，当然你也可以增加多个消费者实例去水平扩展增加消费能力来匹配生产的激增。")]),v._v(" "),_("p",[v._v("如果消费者消费过慢的话，我们可以先检查 "),_("strong",[v._v("是否是消费者出现了大量的消费错误")]),v._v(" ，或者打印一下日志查看是否是哪一个线程卡死，出现了锁资源不释放等等的问题。")]),v._v(" "),_("p",[v._v("当然，最快速解决消息堆积问题的方法还是增加消费者实例，不过 "),_("strong",[v._v("同时你还需要增加每个主题的队列数量")]),v._v(" 。别忘了在 "),_("code",[v._v("RocketMQ")]),v._v(" 中，"),_("strong",[v._v("一个队列只会被一个消费者消费")]),v._v(" 。")]),v._v(" "),_("h2",{attrs:{id:"回溯消费"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#回溯消费"}},[v._v("#")]),v._v(" 回溯消费")]),v._v(" "),_("p",[v._v("回溯消费是指 "),_("code",[v._v("Consumer")]),v._v(" 已经消费成功的消息，由于业务上需求需要重新消费，在"),_("code",[v._v("RocketMQ")]),v._v(" 中， "),_("code",[v._v("Broker")]),v._v(" 在向"),_("code",[v._v("Consumer")]),v._v(" 投递成功消息后，"),_("strong",[v._v("消息仍然需要保留")]),v._v(" 。并且重新消费一般是按照时间维度，例如由于 "),_("code",[v._v("Consumer")]),v._v(" 系统故障，恢复后需要重新消费1小时前的数据，那么 "),_("code",[v._v("Broker")]),v._v(" 要提供一种机制，可以按照时间维度来回退消费进度。"),_("code",[v._v("RocketMQ")]),v._v(" 支持按照时间回溯消费，时间维度精确到毫秒。")]),v._v(" "),_("h2",{attrs:{id:"分布式事务"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#分布式事务"}},[v._v("#")]),v._v(" 分布式事务")]),v._v(" "),_("p",[v._v("在同一个系统中我们可以轻松地实现事务，但是在分布式架构中，我们有很多服务是部署在不同系统之间的，而不同服务之间又需要进行调用。比如此时我下订单然后增加积分，如果保证不了分布式事务的话，就会出现A系统下了订单，但是B系统增加积分失败或者A系统没有下订单，B系统却增加了积分。")]),v._v(" "),_("p",[v._v("如今比较常见的分布式事务实现有 2PC、TCC 和事务消息(half 半消息机制)。每一种实现都有其特定的使用场景，但是也有各自的问题，"),_("strong",[v._v("都不是完美的解决方案")]),v._v("。")]),v._v(" "),_("p",[v._v("在 "),_("code",[v._v("RocketMQ")]),v._v(" 中使用的是 "),_("strong",[v._v("事务消息加上事务反查机制")]),v._v(" 来解决分布式事务问题的。")]),v._v(" "),_("p",[_("img",{attrs:{src:"https://p.ipic.vip/2z4std.jpg",alt:"img"}})]),v._v(" "),_("p",[v._v("在第一步发送的 half 消息 ，它的意思是 "),_("strong",[v._v("在事务提交之前，对于消费者来说，这个消息是不可见的")]),v._v(" 。")]),v._v(" "),_("p",[v._v("如何做到写入消息但是对用户不可见呢？RocketMQ事务消息的做法是：如果消息是half消息，将备份原消息的主题与消息消费队列，然后 "),_("strong",[v._v("改变主题")]),v._v(" 为RMQ_SYS_TRANS_HALF_TOPIC。由于消费组未订阅该主题，故消费端无法消费half类型的消息，"),_("strong",[v._v("然后RocketMQ会开启一个定时任务，从Topic为RMQ_SYS_TRANS_HALF_TOPIC中拉取消息进行消费")]),v._v("，根据生产者组获取一个服务提供者发送回查事务状态请求，根据事务状态来决定是提交或回滚消息。")]),v._v(" "),_("p",[v._v("如果没有从第5步开始的 "),_("strong",[v._v("事务反查机制")]),v._v(" ，如果出现网路波动第4步没有发送成功，这样就会产生 MQ 不知道是不是需要给消费者消费的问题，他就像一个无头苍蝇一样。在 "),_("code",[v._v("RocketMQ")]),v._v(" 中就是使用的上述的事务反查来解决的，而在 "),_("code",[v._v("Kafka")]),v._v(" 中通常是直接抛出一个异常让用户来自行解决。")]),v._v(" "),_("p",[v._v("你还需要注意的是，在 "),_("code",[v._v("MQ Server")]),v._v(" 指向系统B的操作已经和系统A不相关了，也就是说在消息队列中的分布式事务是——"),_("strong",[v._v("本地事务和存储消息到消息队列才是同一个事务")]),v._v("。这样也就产生了事务的"),_("strong",[v._v("最终一致性")]),v._v("，因为整个过程是异步的，"),_("strong",[v._v("每个系统只要保证它自己那一部分的事务就行了")]),v._v("。")]),v._v(" "),_("h2",{attrs:{id:"rocketmq-的刷盘机制"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#rocketmq-的刷盘机制"}},[v._v("#")]),v._v(" RocketMQ 的刷盘机制")]),v._v(" "),_("h3",{attrs:{id:"同步刷盘和异步刷盘"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#同步刷盘和异步刷盘"}},[v._v("#")]),v._v(" 同步刷盘和异步刷盘")]),v._v(" "),_("p",[_("img",{attrs:{src:"https://p.ipic.vip/c723ch.jpg",alt:"img"}})]),v._v(" "),_("h2",{attrs:{id:"存储机制"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#存储机制"}},[v._v("#")]),v._v(" 存储机制")]),v._v(" "),_("p",[v._v("在 "),_("code",[v._v("Topic")]),v._v(" 中的 "),_("strong",[v._v("队列是以什么样的形式存在的？")])]),v._v(" "),_("p",[_("strong",[v._v("队列中的消息又是如何进行存储持久化的呢？")])]),v._v(" "),_("p",[_("code",[v._v("RocketMQ")]),v._v(" 消息存储架构中的三大角色——"),_("code",[v._v("CommitLog")]),v._v(" 、"),_("code",[v._v("ConsumeQueue")]),v._v(" 和 "),_("code",[v._v("IndexFile")]),v._v(" 。")]),v._v(" "),_("ul",[_("li",[_("code",[v._v("CommitLog")]),v._v("： "),_("strong",[v._v("消息主体以及元数据的存储主体")]),v._v("，存储 "),_("code",[v._v("Producer")]),v._v(" 端写入的消息主体内容,消息内容不是定长的。单个文件大小默认1G ，文件名长度为20位，左边补零，剩余为起始偏移量，比如00000000000000000000代表了第一个文件，起始偏移量为0，文件大小为1G=1073741824；当第一个文件写满了，第二个文件为00000000001073741824，起始偏移量为1073741824，以此类推。消息主要是"),_("strong",[v._v("顺序写入日志文件")]),v._v("，当文件满了，写入下一个文件。")]),v._v(" "),_("li",[_("code",[v._v("ConsumeQueue")]),v._v("： 消息消费队列，"),_("strong",[v._v("引入的目的主要是提高消息消费的性能")]),v._v("(我们再前面也讲了)，由于"),_("code",[v._v("RocketMQ")]),v._v(" 是基于主题 "),_("code",[v._v("Topic")]),v._v(" 的订阅模式，消息消费是针对主题进行的，如果要遍历 "),_("code",[v._v("commitlog")]),v._v(" 文件中根据 "),_("code",[v._v("Topic")]),v._v(" 检索消息是非常低效的。"),_("code",[v._v("Consumer")]),v._v(" 即可根据 "),_("code",[v._v("ConsumeQueue")]),v._v(" 来查找待消费的消息。其中，"),_("code",[v._v("ConsumeQueue")]),v._v("（逻辑消费队列）"),_("strong",[v._v("作为消费消息的索引")]),v._v("，保存了指定 "),_("code",[v._v("Topic")]),v._v(" 下的队列消息在 "),_("code",[v._v("CommitLog")]),v._v(" 中的"),_("strong",[v._v("起始物理偏移量 "),_("code",[v._v("offset")]),v._v(" *"),_("em",[v._v("，消息大小 "),_("code",[v._v("size")]),v._v(" 和消息 "),_("code",[v._v("Tag")]),v._v(" 的 "),_("code",[v._v("HashCode")]),v._v(" 值。*")]),_("code",[v._v("consumequeue")]),v._v(" 文件可以看成是基于 "),_("code",[v._v("topic")]),v._v(" 的 "),_("code",[v._v("commitlog")]),v._v(" 索引文件")]),v._v("，故 "),_("code",[v._v("consumequeue")]),v._v(" 文件夹的组织方式如下：topic/queue/file三层组织结构，具体存储路径为：$HOME/store/consumequeue/{topic}/{queueId}/{fileName}。同样 "),_("code",[v._v("consumequeue")]),v._v(" 文件采取定长设计，每一个条目共20个字节，分别为8字节的 "),_("code",[v._v("commitlog")]),v._v(" 物理偏移量、4字节的消息长度、8字节tag "),_("code",[v._v("hashcode")]),v._v("，单个文件由30W个条目组成，可以像数组一样随机访问每一个条目，每个 "),_("code",[v._v("ConsumeQueue")]),v._v("文件大小约5.72M；")]),v._v(" "),_("li",[_("code",[v._v("IndexFile")]),v._v("： "),_("code",[v._v("IndexFile")]),v._v("（索引文件）提供了一种可以通过key或时间区间来查询消息的方法。这里只做科普不做详细介绍。")])]),v._v(" "),_("p",[v._v("总结来说，整个消息存储的结构，最主要的就是 "),_("code",[v._v("CommitLoq")]),v._v(" 和 "),_("code",[v._v("ConsumeQueue")]),v._v(" 。而 "),_("code",[v._v("ConsumeQueue")]),v._v(" 你可以大概理解为 "),_("code",[v._v("Topic")]),v._v(" 中的队列。")]),v._v(" "),_("p",[_("img",{attrs:{src:"https://p.ipic.vip/28ahfq.png",alt:"img"}})]),v._v(" "),_("p",[v._v("红色方块代表被写入的消息，虚线方块代表等待被写入的。左边的生产者发送消息会指定 "),_("code",[v._v("Topic")]),v._v(" 、"),_("code",[v._v("QueueId")]),v._v(" 和具体消息内容，而在 "),_("code",[v._v("Broker")]),v._v(" 中管你是哪门子消息，他直接 "),_("strong",[v._v("全部顺序存储到了 CommitLog")]),v._v("。而根据生产者指定的 "),_("code",[v._v("Topic")]),v._v(" 和 "),_("code",[v._v("QueueId")]),v._v(" 将这条消息本身在 "),_("code",[v._v("CommitLog")]),v._v(" 的偏移(offset)，消息本身大小，和tag的hash值存入对应的 "),_("code",[v._v("ConsumeQueue")]),v._v(" 索引文件中。而在每个队列中都保存了 "),_("code",[v._v("ConsumeOffset")]),v._v(" 即每个消费者组的消费位置(我在架构那里提到了，忘了的同学可以回去看一下)，而消费者拉取消息进行消费的时候只需要根据 "),_("code",[v._v("ConsumeOffset")]),v._v(" 获取下一个未被消费的消息就行了。")])])}),[],!1,null,null,null);_.default=r.exports}}]);