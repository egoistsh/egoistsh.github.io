(window.webpackJsonp=window.webpackJsonp||[]).push([[56],{380:function(e,v,l){"use strict";l.r(v);var s=l(7),t=Object(s.a)({},(function(){var e=this,v=e._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[v("p",[e._v("Redis 采用的是 "),v("strong",[e._v("定期删除+惰性/懒汉式删除")])]),e._v(" "),v("ol",[v("li",[v("strong",[e._v("惰性删除")]),e._v(" ：只会在取出 key 的时候才对数据进行过期检查。这样对 CPU 最友好，但是可能会造成太多过期 key 没有被删除。")]),e._v(" "),v("li",[v("strong",[e._v("定期删除")]),e._v(" ： 每隔一段时间抽取一批 key 执行删除过期 key 操作。并且，Redis 底层会通过限制删除操作执行的时长和频率来减少删除操作对 CPU 时间的影响。")])]),e._v(" "),v("p",[e._v("但是，仅仅通过给 key 设置过期时间还是有问题的。因为还是可能存在定期删除和惰性删除漏掉了很多过期 key 的情况。这样就导致大量过期 key 堆积在内存里，然后就 Out of memory 了。")]),e._v(" "),v("p",[e._v("怎么解决这个问题呢？答案就是："),v("strong",[e._v("Redis 内存淘汰机制。")])]),e._v(" "),v("p",[e._v("Redis 提供 6 种数据淘汰策略：")]),e._v(" "),v("ol",[v("li",[v("strong",[e._v("volatile-lru（least recently used）")]),e._v("：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰")]),e._v(" "),v("li",[v("strong",[e._v("volatile-ttl")]),e._v("：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰")]),e._v(" "),v("li",[v("strong",[e._v("volatile-random")]),e._v("：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰")]),e._v(" "),v("li",[v("strong",[e._v("allkeys-lru（least recently used）")]),e._v("：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的 key（这个是最常用的）")]),e._v(" "),v("li",[v("strong",[e._v("allkeys-random")]),e._v("：从数据集（server.db[i].dict）中任意选择数据淘汰")]),e._v(" "),v("li",[v("strong",[e._v("no-eviction")]),e._v("（默认策略）：禁止驱逐数据，也就是说当内存不足以容纳新写入数据时，新写入操作会报错。这个应该没人使用吧！")])]),e._v(" "),v("p",[e._v("4.0 版本后增加以下两种：")]),e._v(" "),v("ol",[v("li",[v("strong",[e._v("volatile-lfu（least frequently used）")]),e._v("：从已设置过期时间的数据集（server.db[i].expires）中挑选最不经常使用的数据淘汰")]),e._v(" "),v("li",[v("strong",[e._v("allkeys-lfu（least frequently used）")]),e._v("：当内存不足以容纳新写入数据时，在键空间中，移除最不经常使用的 key")])])])}),[],!1,null,null,null);v.default=t.exports}}]);