(window.webpackJsonp=window.webpackJsonp||[]).push([[118],{440:function(v,o,a){"use strict";a.r(o);var _=a(7),t=Object(_.a)({},(function(){var v=this,o=v._self._c;return o("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[o("h2",{attrs:{id:"lombok-的用法"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#lombok-的用法"}},[v._v("#")]),v._v(" lombok 的用法")]),v._v(" "),o("ol",[o("li",[v._v("安装插件")]),v._v(" "),o("li",[v._v("pom 加入依赖")]),v._v(" "),o("li",[v._v("使用注解")])]),v._v(" "),o("h2",{attrs:{id:"lombok-的实现原理"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#lombok-的实现原理"}},[v._v("#")]),v._v(" lombok 的实现原理")]),v._v(" "),o("p",[v._v("lombok 是在编译阶段处理注解。在编译阶段，当 Java 源码被抽象成语法树 (AST) 之后，Lombok 会根据自己的注解处理器动态的修改 AST，增加新的代码 (节点)，在这一切执行之后，再通过分析生成了最终的字节码 (.class) 文件。")]),v._v(" "),o("p",[v._v("Java 的编译过程大致可以分为三个阶段：")]),v._v(" "),o("ol",[o("li",[v._v("解析与填充符号表")]),v._v(" "),o("li",[v._v("注解处理")]),v._v(" "),o("li",[v._v("分析与字节码生成")])]),v._v(" "),o("p",[v._v("Java 的编译过程主要包括以下几个步骤：（详细版）")]),v._v(" "),o("ol",[o("li",[v._v("词法分析（Lexical Analysis）：将源代码分解为基本的词法单元（Tokens），如关键字、标识符、运算符、分隔符等。")]),v._v(" "),o("li",[v._v("语法分析（Syntax Analysis）：将词法单元组织成语法结构，并根据语法规则进行验证。这个过程构建了抽象语法树（Abstract Syntax Tree，AST）。")]),v._v(" "),o("li",[v._v("语义分析（Semantic Analysis）：对语法结构进行语义检查，包括类型检查、作用域检查等。此步骤确保代码的合法性和正确性。")]),v._v(" "),o("li",[v._v("中间代码生成（Intermediate Code Generation）：根据语法结构和语义信息生成中间代码。中间代码可以是一种抽象表示形式，如字节码、中间语言（例如Java字节码或LLVM IR）。")]),v._v(" "),o("li",[v._v("优化（Optimization）：对生成的中间代码进行优化，以提高程序的性能和效率。这包括常量折叠、无用代码消除、循环展开等优化技术。")]),v._v(" "),o("li",[v._v("目标代码生成（Code Generation）：根据优化后的中间代码生成目标平台特定的机器代码或可执行文件。这个过程将中间代码翻译为可以在目标平台上执行的机器指令。")]),v._v(" "),o("li",[v._v("编译器链接（Compiler Linking）：如果代码依赖于其他类或库，编译器会进行链接操作，以将编译的代码与所需的类和库进行关联。")])]),v._v(" "),o("p",[v._v("这些步骤中的大部分工作由 Java 编译器（如javac）完成。编译过程的最终输出是可执行的目标代码或可部署的字节码文件，可以在相应的运行时环境中执行。")]),v._v(" "),o("p",[v._v("编译时的注解处理是在 Java 编译过程的语义分析阶段之后的特定阶段进行的。该阶段称为注解处理器处理阶段（Annotation Processing Phase）。")]),v._v(" "),o("p",[v._v("在语义分析阶段后，编译器会检查源代码中的注解信息，并将这些注解信息传递给相应的注解处理器进行处理。注解处理器是开发人员编写的特殊类，实现了 "),o("code",[v._v("javax.annotation.processing.Processor")]),v._v(" 接口，用于处理特定注解的逻辑。")]),v._v(" "),o("p",[v._v("在注解处理器处理阶段，编译器会调用相应的注解处理器，传递源代码中的注解信息给它们。注解处理器可以读取注解信息、检查和修改抽象语法树（AST），生成额外的代码或进行其他自定义的操作。")]),v._v(" "),o("p",[v._v("注解处理器处理阶段的输出结果通常是生成的代码或其他相关的元数据信息。这些生成的代码可以是为了提供额外的功能、减少样板代码或与注解相关的逻辑。生成的代码会与原始源代码一起参与后续的编译过程。")]),v._v(" "),o("h2",{attrs:{id:"注解的处理时机"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#注解的处理时机"}},[v._v("#")]),v._v(" 注解的处理时机：")]),v._v(" "),o("p",[v._v("注解的处理方式取决于注解的元注解（meta-annotation）和注解处理器（annotation processor）的定义。")]),v._v(" "),o("p",[v._v("在 Java 中，有三种主要类型的注解处理方式：")]),v._v(" "),o("ol",[o("li",[v._v("编译时处理：一些注解在编译时会被特定的注解处理器处理。这些注解处理器会读取源代码中的注解信息，并生成相应的代码或进行其他处理操作。Lombok 就是一个使用编译时处理的注解库。")]),v._v(" "),o("li",[v._v("运行时反射处理：某些注解在运行时使用反射机制进行处理。这意味着注解在编译时不会产生特定的代码生成，而是在运行时通过反射读取注解信息并执行相应的操作。例如，JUnit 中的测试注解 "),o("code",[v._v("@Test")]),v._v(" 就是在运行时通过反射机制来运行测试方法。")]),v._v(" "),o("li",[v._v("无处理：一些注解在编译和运行时都没有特定的处理。这些注解可能仅用于提供额外的元数据信息，供其他工具或框架使用，而不会直接影响代码的生成或行为。")])]),v._v(" "),o("h2",{attrs:{id:"为什么lombok要在编译器时处理注解-而不采用反射的方式去生成代码"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#为什么lombok要在编译器时处理注解-而不采用反射的方式去生成代码"}},[v._v("#")]),v._v(" 为什么lombok要在编译器时处理注解，而不采用反射的方式去生成代码？")]),v._v(" "),o("p",[v._v("Lombok 之所以选择在编译器时处理注解，而不是采用运行时反射的方式去生成代码，主要是出于性能的考虑。")]),v._v(" "),o("p",[v._v("Lombok 在编译器时直接生成代码，避免了运行时反射的开销。使用反射生成代码可能会导致运行时的性能损耗，特别是在大型项目中或频繁使用的地方。通过在编译器阶段生成代码，Lombok 可以确保生成的代码是原生的、高效的，并且与手写的代码一样性能良好。")]),v._v(" "),o("p",[v._v("https://www.cnblogs.com/vipstone/p/12597756.html")])])}),[],!1,null,null,null);o.default=t.exports}}]);