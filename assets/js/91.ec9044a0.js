(window.webpackJsonp=window.webpackJsonp||[]).push([[91],{415:function(a,t,e){"use strict";e.r(t);var n=e(7),r=Object(n.a)({},(function(){var a=this,t=a._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("h2",{attrs:{id:"beanfactory"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#beanfactory"}},[a._v("#")]),a._v(" BeanFactory")]),a._v(" "),t("p",[t("code",[a._v("BeanFactory")]),a._v("是一个接口，它是Spring中工厂的顶层规范，是Spring Ioc容器的核心接口，定义了IOC容器的最基本形式，并提供了IOC容器应遵守的的最基本的接口，职责包括实例化、定位、配置应用程序中的对象以及建立这些对象之间的依赖。")]),a._v(" "),t("p",[a._v("它定义了"),t("code",[a._v("getBean()")]),a._v("、"),t("code",[a._v("containsBean()")]),a._v("等管理Bean的通用方法。")]),a._v(" "),t("p",[a._v("BeanFacotry是spring中比较原始的Factory。原始的BeanFactory无法支持spring的许多插件，如AOP功能、Web应用等。")]),a._v(" "),t("p",[a._v("Spring的容器都是它的具体实现如：")]),a._v(" "),t("ul",[t("li",[a._v("DefaultListableBeanFactory")]),a._v(" "),t("li",[a._v("XmlBeanFactory")]),a._v(" "),t("li",[a._v("ApplicationContext：ApplicationContext接口由BeanFactory接口派生而来，ApplicationContext包含BeanFactory的所有功能，通常建议比BeanFactory优先。")])]),a._v(" "),t("p",[a._v("这些实现类又从不同的维度分别有不同的扩展。")]),a._v(" "),t("h2",{attrs:{id:"factorybean"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#factorybean"}},[a._v("#")]),a._v(" FactoryBean")]),a._v(" "),t("p",[a._v("首先它是一个Bean，但又不仅仅是一个Bean。它是一个能生产或修饰对象生成的工厂Bean，类似于设计模式中的工厂模式和装饰器模式。")]),a._v(" "),t("p",[a._v("方法：")]),a._v(" "),t("ul",[t("li",[a._v("getObject：自定义创建对象的过程（new，反射，动态代理）")]),a._v(" "),t("li",[a._v("isSingleton")]),a._v(" "),t("li",[a._v("getObjectType")])]),a._v(" "),t("p",[a._v("Spring 对实现了FactoryBean接口的Bean进行了特殊处理。")]),a._v(" "),t("p",[a._v("主要表现为:")]),a._v(" "),t("p",[a._v("1、FactoryBean本身是个Bean\n2、试图获取FactoryBean时，得到的是 FactoryBean 的 getObject() 返回的对象\n3、可以通过 “&”+”name” 得到FactoryBean 本体对象")]),a._v(" "),t("h3",{attrs:{id:"factorybean-在-mybatis-中的应用"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#factorybean-在-mybatis-中的应用"}},[a._v("#")]),a._v(" FactoryBean 在 Mybatis 中的应用")]),a._v(" "),t("p",[a._v("使用过Spring Boot的同学都知道，当我们需要扫描Mapper的时候，需要添加@MapperScan注解完成对Mapper对象的扫描，@MapperScan导入MapperScannerRegistrar类完成扫描。")]),a._v(" "),t("p",[a._v("但是Mapper类都是接口，无法被实例化，那么为什么在Spring中能够直接注入Mapper对象呢？")]),a._v(" "),t("p",[a._v("实际上Mybatis是通过FactoryBean对象创建Mapper对象的代理对象，完成Mapper接口的注入。")]),a._v(" "),t("p",[a._v("Mybatis通过JDK动态代理的方式，创建Mapper接口的代理对象，并通过接口声明的方法查找并执行SQL。")]),a._v(" "),t("p",[a._v("https://juejin.cn/post/6844903878949863431#heading-2")]),a._v(" "),t("p",[a._v("https://www.skypyb.com/2019/08/jishu/979/ 牛呀，还不知道FactoryBean有啥用？探寻FactoryBean的究极奥义之从Spring+MyBatis扫描源码说起")]),a._v(" "),t("h2",{attrs:{id:"二者的区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#二者的区别"}},[a._v("#")]),a._v(" 二者的区别")]),a._v(" "),t("p",[a._v("spring 的核心是 IOC 容器，IOC 容器本质上就是 bean 的容器，或者是一个 bean 的工厂。能够更具我们声明的配置或注解去进行 bean 的加载和初始化。然后通过 beanFactory 生产我们需要的各种各样的 bean。")]),a._v(" "),t("p",[a._v("BeanFactory 是所有 Spring Bean 容器的顶级接口，它为 Spring 的容器定义了一套规范，并提供像 getBean 这样的方法从容器中获取指定的 bean 实例。")]),a._v(" "),t("p",[a._v("而 FactoryBean 是一个工厂 bean，它也是一个接口，其主要能力是动态的去生成某一类型的 Bean 的实例，也就是我们可以自定义一个 Bean，并加载到 IOC 容器中。其中有一个重要的方法 getObject()，就是用来实现动态构建 bean 的一个过程")]),a._v(" "),t("p",[a._v("相同点：都是用来创建 bean 的。")]),a._v(" "),t("p",[a._v("不同点：是用 BeanFactory 创建对象时，必须遵循严格的生命周期流程。如果想要简单自定义某个对象的创建，同时将创建完成的对象交给 spring 容器管理，那么需要实现 FactoryBean 接口。")]),a._v(" "),t("h2",{attrs:{id:"参考"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#参考"}},[a._v("#")]),a._v(" 参考")]),a._v(" "),t("ul",[t("li",[t("p",[a._v("https://juejin.cn/post/6844903967600836621")])]),a._v(" "),t("li",[t("p",[a._v("https://bbs.huaweicloud.com/blogs/363939")])]),a._v(" "),t("li",[t("p",[a._v("https://www.bilibili.com/video/BV1ts4y1z7wJ/?spm_id_from=333.337.search-card.all.click&vd_source=56a32d67ac4f0ccac0c6360804c3cf67")])])])])}),[],!1,null,null,null);t.default=r.exports}}]);