(window.webpackJsonp=window.webpackJsonp||[]).push([[0],[]]);!function(n){function e(e){for(var a,i,s=e[0],l=e[1],c=e[2],p=0,u=[];p<s.length;p++)i=s[p],Object.prototype.hasOwnProperty.call(r,i)&&r[i]&&u.push(r[i][0]),r[i]=0;for(a in l)Object.prototype.hasOwnProperty.call(l,a)&&(n[a]=l[a]);for(d&&d(e);u.length;)u.shift()();return o.push.apply(o,c||[]),t()}function t(){for(var n,e=0;e<o.length;e++){for(var t=o[e],a=!0,s=1;s<t.length;s++){var l=t[s];0!==r[l]&&(a=!1)}a&&(o.splice(e--,1),n=i(i.s=t[0]))}return n}var a={},r={1:0},o=[];function i(e){if(a[e])return a[e].exports;var t=a[e]={i:e,l:!1,exports:{}};return n[e].call(t.exports,t,t.exports,i),t.l=!0,t.exports}i.e=function(n){var e=[],t=r[n];if(0!==t)if(t)e.push(t[2]);else{var a=new Promise((function(e,a){t=r[n]=[e,a]}));e.push(t[2]=a);var o,s=document.createElement("script");s.charset="utf-8",s.timeout=120,i.nc&&s.setAttribute("nonce",i.nc),s.src=function(n){return i.p+"assets/js/"+({}[n]||n)+"."+{2:"604e56ea",3:"bbf7c2c7",4:"e5c81a93",5:"e9b01ef0",6:"fe4b6fe2",7:"3a487f9a",8:"c944f066",9:"2ad96cd8",10:"aa4eb0a1",11:"422adc61",12:"10334e95",13:"012d1e50",14:"6f0a2a5b",15:"1c77c22d",16:"4fd3525c",17:"217e38b9",18:"659d3d37",19:"e80afa6e",20:"9139e280",21:"10b172f8",22:"34ea571d",23:"138b35dc",24:"21c40e06",25:"5ca101aa",26:"aa0459b9",27:"31c0ed2a",28:"ceae43cc",29:"609ae9eb",30:"5b8d6841",31:"391c4a7f",32:"443a9301",33:"df735b9d",34:"d191f3e0",35:"281471e2",36:"cf77c6fa",37:"53b63146",38:"4da53f4c",39:"852a90d7",40:"084d8c1d",41:"53829a8c",42:"ae751da7",43:"7751b9a8",44:"a4810927",45:"1312b3c9",46:"e6bc055c",47:"18bee4c5",48:"9f656bee",49:"da4c46c5",50:"cfc199d6",51:"127a05ac",52:"633f5b3b",53:"ddd52237",54:"2a49467c",55:"94a84abb",56:"65a6cf9b",57:"ac756580",58:"66ea8998",59:"a888705f",60:"78f4b8bd",61:"e0383d44",62:"825d9207",63:"03fa7d9a",64:"475fe16b",65:"dc316c26",66:"d8e2fe6a",67:"8ca17ad8",68:"28ac914f",69:"af110c89",70:"2203d85c",71:"b533ed03",72:"3d9b90b3",73:"72e1a805",74:"870299c6",75:"6749a9b9",76:"1d514dca",77:"af4dc008",78:"9e830fa7",79:"cc70fb45",80:"5a560ea2",81:"f005b264",82:"75c0cb1b",83:"02e320c4",84:"0908d51b",85:"7c368752",86:"274b50ae",87:"3682de75",88:"af0b698f",89:"11a63b60",90:"06f487da",91:"ec9044a0",92:"208a9d92",93:"43e7fa8d",94:"d5b898f0",95:"bad0da9f",96:"a95dff03",97:"d7a433e6",98:"66ebf4b1",99:"2904f4b0",100:"e0982e8f",101:"0fd8df8f",102:"254e5733",103:"0f450abe",104:"068362bb",105:"f93efa4b",106:"fc600d71",107:"d3248776",108:"7eca1198",109:"60e835c6",110:"76a0db62",111:"a36f567a",112:"d14be259",113:"daf919ff",114:"b31bf64d",115:"2ae6963e",116:"7a9dbf0a",117:"d99a1526",118:"15a2f063",119:"adfcc31f",120:"fe2ffab5",121:"3643e944",122:"cf337595",123:"ff5b2675",124:"6c3159a5",125:"b0c7f558",126:"2c46ced5",127:"04650369",128:"bf298103",129:"2252deae",130:"ae0e6a61"}[n]+".js"}(n);var l=new Error;o=function(e){s.onerror=s.onload=null,clearTimeout(c);var t=r[n];if(0!==t){if(t){var a=e&&("load"===e.type?"missing":e.type),o=e&&e.target&&e.target.src;l.message="Loading chunk "+n+" failed.\n("+a+": "+o+")",l.name="ChunkLoadError",l.type=a,l.request=o,t[1](l)}r[n]=void 0}};var c=setTimeout((function(){o({type:"timeout",target:s})}),12e4);s.onerror=s.onload=o,document.head.appendChild(s)}return Promise.all(e)},i.m=n,i.c=a,i.d=function(n,e,t){i.o(n,e)||Object.defineProperty(n,e,{enumerable:!0,get:t})},i.r=function(n){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(n,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(n,"__esModule",{value:!0})},i.t=function(n,e){if(1&e&&(n=i(n)),8&e)return n;if(4&e&&"object"==typeof n&&n&&n.__esModule)return n;var t=Object.create(null);if(i.r(t),Object.defineProperty(t,"default",{enumerable:!0,value:n}),2&e&&"string"!=typeof n)for(var a in n)i.d(t,a,function(e){return n[e]}.bind(null,a));return t},i.n=function(n){var e=n&&n.__esModule?function(){return n.default}:function(){return n};return i.d(e,"a",e),e},i.o=function(n,e){return Object.prototype.hasOwnProperty.call(n,e)},i.p="/",i.oe=function(n){throw console.error(n),n};var s=window.webpackJsonp=window.webpackJsonp||[],l=s.push.bind(s);s.push=e,s=s.slice();for(var c=0;c<s.length;c++)e(s[c]);var d=l;o.push([102,0]),t()}([function(n,e,t){var a=t(55),r=a.all;n.exports=a.IS_HTMLDDA?function(n){return"function"==typeof n||n===r}:function(n){return"function"==typeof n}},function(n,e,t){var a=t(27),r=Function.prototype,o=r.call,i=a&&r.bind.bind(o,o);n.exports=a?i:function(n){return function(){return o.apply(n,arguments)}}},function(n,e){n.exports=function(n){try{return!!n()}catch(n){return!0}}},function(n,e){var t=function(n){return n&&n.Math==Math&&n};n.exports=t("object"==typeof globalThis&&globalThis)||t("object"==typeof window&&window)||t("object"==typeof self&&self)||t("object"==typeof global&&global)||function(){return this}()||Function("return this")()},function(n,e,t){var a=t(2);n.exports=!a((function(){return 7!=Object.defineProperty({},1,{get:function(){return 7}})[1]}))},function(n,e){var t=Array.isArray;n.exports=t},function(n,e,t){var a=t(69),r="object"==typeof self&&self&&self.Object===Object&&self,o=a||r||Function("return this")();n.exports=o},function(n,e,t){"use strict";function a(n,e,t,a,r,o,i,s){var l,c="function"==typeof n?n.options:n;if(e&&(c.render=e,c.staticRenderFns=t,c._compiled=!0),a&&(c.functional=!0),o&&(c._scopeId="data-v-"+o),i?(l=function(n){(n=n||this.$vnode&&this.$vnode.ssrContext||this.parent&&this.parent.$vnode&&this.parent.$vnode.ssrContext)||"undefined"==typeof __VUE_SSR_CONTEXT__||(n=__VUE_SSR_CONTEXT__),r&&r.call(this,n),n&&n._registeredComponents&&n._registeredComponents.add(i)},c._ssrRegister=l):r&&(l=s?function(){r.call(this,(c.functional?this.parent:this).$root.$options.shadowRoot)}:r),l)if(c.functional){c._injectStyles=l;var d=c.render;c.render=function(n,e){return l.call(e),d(n,e)}}else{var p=c.beforeCreate;c.beforeCreate=p?[].concat(p,l):[l]}return{exports:n,options:c}}t.d(e,"a",(function(){return a}))},function(n,e,t){var a=t(1),r=t(32),o=a({}.hasOwnProperty);n.exports=Object.hasOwn||function(n,e){return o(r(n),e)}},function(n,e,t){var a=t(0),r=t(55),o=r.all;n.exports=r.IS_HTMLDDA?function(n){return"object"==typeof n?null!==n:a(n)||n===o}:function(n){return"object"==typeof n?null!==n:a(n)}},function(n,e,t){var a=t(163),r=t(166);n.exports=function(n,e){var t=r(n,e);return a(t)?t:void 0}},function(n,e,t){"use strict";t.d(e,"e",(function(){return a})),t.d(e,"b",(function(){return o})),t.d(e,"j",(function(){return i})),t.d(e,"g",(function(){return l})),t.d(e,"h",(function(){return c})),t.d(e,"i",(function(){return d})),t.d(e,"c",(function(){return p})),t.d(e,"f",(function(){return u})),t.d(e,"l",(function(){return h})),t.d(e,"m",(function(){return m})),t.d(e,"d",(function(){return g})),t.d(e,"k",(function(){return v})),t.d(e,"n",(function(){return b})),t.d(e,"a",(function(){return k}));t(16);const a=/#.*$/,r=/\.(md|html)$/,o=/\/$/,i=/^[a-z]+:/i;function s(n){return decodeURI(n).replace(a,"").replace(r,"")}function l(n){return i.test(n)}function c(n){return/^mailto:/.test(n)}function d(n){return/^tel:/.test(n)}function p(n){if(l(n))return n;if(!n)return"404";const e=n.match(a),t=e?e[0]:"",r=s(n);return o.test(r)?n:r+".html"+t}function u(n,e){const t=n.hash,r=function(n){const e=n&&n.match(a);if(e)return e[0]}(e);if(r&&t!==r)return!1;return s(n.path)===s(e)}function h(n,e,t){if(l(e))return{type:"external",path:e};t&&(e=function(n,e,t){const a=n.charAt(0);if("/"===a)return n;if("?"===a||"#"===a)return e+n;const r=e.split("/");t&&r[r.length-1]||r.pop();const o=n.replace(/^\//,"").split("/");for(let n=0;n<o.length;n++){const e=o[n];".."===e?r.pop():"."!==e&&r.push(e)}""!==r[0]&&r.unshift("");return r.join("/")}(e,t));const a=s(e);for(let e=0;e<n.length;e++)if(s(n[e].regularPath)===a)return Object.assign({},n[e],{type:"page",path:p(n[e].path)});return console.error(`[vuepress] No matching page found for sidebar item "${e}"`),{}}function m(n,e,t,a){const{pages:r,themeConfig:o}=t,i=a&&o.locales&&o.locales[a]||o;if("auto"===(n.frontmatter.sidebar||i.sidebar||o.sidebar))return f(n);const s=i.sidebar||o.sidebar;if(s){const{base:t,config:a}=function(n,e){if(Array.isArray(e))return{base:"/",config:e};for(const a in e)if(0===(t=n,/(\.html|\/)$/.test(t)?t:t+"/").indexOf(encodeURI(a)))return{base:a,config:e[a]};var t;return{}}(e,s);return"auto"===a?f(n):a?a.map(n=>function n(e,t,a,r=1){if("string"==typeof e)return h(t,e,a);if(Array.isArray(e))return Object.assign(h(t,e[0],a),{title:e[1]});{r>3&&console.error("[vuepress] detected a too deep nested sidebar group.");const o=e.children||[];return 0===o.length&&e.path?Object.assign(h(t,e.path,a),{title:e.title}):{type:"group",path:e.path,title:e.title,sidebarDepth:e.sidebarDepth,initialOpenGroupIndex:e.initialOpenGroupIndex,children:o.map(e=>n(e,t,a,r+1)),collapsable:!1!==e.collapsable}}}(n,r,t)):[]}return[]}function f(n){const e=g(n.headers||[]);return[{type:"group",collapsable:!1,title:n.title,path:null,children:e.map(e=>({type:"auto",title:e.title,basePath:n.path,path:n.path+"#"+e.slug,children:e.children||[]}))}]}function g(n){let e;return(n=n.map(n=>Object.assign({},n))).forEach(n=>{2===n.level?e=n:e&&(e.children||(e.children=[])).push(n)}),n.filter(n=>2===n.level)}function v(n){return Object.assign(n,{type:n.items&&n.items.length?"links":"link"})}function b(n){return Object.prototype.toString.call(n).match(/\[object (.*?)\]/)[1].toLowerCase()}function y(n){let e=n.frontmatter.date||n.lastUpdated||new Date,t=new Date(e);return"Invalid Date"==t&&e&&(t=new Date(e.replace(/-/g,"/"))),t.getTime()}function k(n,e){return y(e)-y(n)}},function(n,e){n.exports=function(n){return null!=n&&"object"==typeof n}},function(n,e,t){var a=t(15),r=t(148),o=t(149),i=a?a.toStringTag:void 0;n.exports=function(n){return null==n?void 0===n?"[object Undefined]":"[object Null]":i&&i in Object(n)?r(n):o(n)}},function(n,e,t){var a=t(4),r=t(17),o=t(35);n.exports=a?function(n,e,t){return r.f(n,e,o(1,t))}:function(n,e,t){return n[e]=t,n}},function(n,e,t){var a=t(6).Symbol;n.exports=a},function(n,e,t){"use strict";var a=t(26),r=t(32),o=t(33),i=t(127),s=t(129);a({target:"Array",proto:!0,arity:1,forced:t(2)((function(){return 4294967297!==[].push.call({length:4294967296},1)}))||!function(){try{Object.defineProperty([],"length",{writable:!1}).push()}catch(n){return n instanceof TypeError}}()},{push:function(n){var e=r(this),t=o(e),a=arguments.length;s(t+a);for(var l=0;l<a;l++)e[t]=arguments[l],t++;return i(e,t),t}})},function(n,e,t){var a=t(4),r=t(64),o=t(98),i=t(25),s=t(54),l=TypeError,c=Object.defineProperty,d=Object.getOwnPropertyDescriptor;e.f=a?o?function(n,e,t){if(i(n),e=s(e),i(t),"function"==typeof n&&"prototype"===e&&"value"in t&&"writable"in t&&!t.writable){var a=d(n,e);a&&a.writable&&(n[e]=t.value,t={configurable:"configurable"in t?t.configurable:a.configurable,enumerable:"enumerable"in t?t.enumerable:a.enumerable,writable:!1})}return c(n,e,t)}:c:function(n,e,t){if(i(n),e=s(e),i(t),r)try{return c(n,e,t)}catch(n){}if("get"in t||"set"in t)throw l("Accessors not supported");return"value"in t&&(n[e]=t.value),n}},function(n,e,t){var a=t(1),r=a({}.toString),o=a("".slice);n.exports=function(n){return o(r(n),8,-1)}},function(n,e,t){var a=t(153),r=t(154),o=t(155),i=t(156),s=t(157);function l(n){var e=-1,t=null==n?0:n.length;for(this.clear();++e<t;){var a=n[e];this.set(a[0],a[1])}}l.prototype.clear=a,l.prototype.delete=r,l.prototype.get=o,l.prototype.has=i,l.prototype.set=s,n.exports=l},function(n,e,t){var a=t(71);n.exports=function(n,e){for(var t=n.length;t--;)if(a(n[t][0],e))return t;return-1}},function(n,e,t){var a=t(10)(Object,"create");n.exports=a},function(n,e,t){var a=t(175);n.exports=function(n,e){var t=n.__data__;return a(e)?t["string"==typeof e?"string":"hash"]:t.map}},function(n,e,t){var a=t(45);n.exports=function(n){if("string"==typeof n||a(n))return n;var e=n+"";return"0"==e&&1/n==-1/0?"-0":e}},function(n,e,t){var a,r;
/* NProgress, (c) 2013, 2014 Rico Sta. Cruz - http://ricostacruz.com/nprogress
 * @license MIT */void 0===(r="function"==typeof(a=function(){var n,e,t={version:"0.2.0"},a=t.settings={minimum:.08,easing:"ease",positionUsing:"",speed:200,trickle:!0,trickleRate:.02,trickleSpeed:800,showSpinner:!0,barSelector:'[role="bar"]',spinnerSelector:'[role="spinner"]',parent:"body",template:'<div class="bar" role="bar"><div class="peg"></div></div><div class="spinner" role="spinner"><div class="spinner-icon"></div></div>'};function r(n,e,t){return n<e?e:n>t?t:n}function o(n){return 100*(-1+n)}t.configure=function(n){var e,t;for(e in n)void 0!==(t=n[e])&&n.hasOwnProperty(e)&&(a[e]=t);return this},t.status=null,t.set=function(n){var e=t.isStarted();n=r(n,a.minimum,1),t.status=1===n?null:n;var l=t.render(!e),c=l.querySelector(a.barSelector),d=a.speed,p=a.easing;return l.offsetWidth,i((function(e){""===a.positionUsing&&(a.positionUsing=t.getPositioningCSS()),s(c,function(n,e,t){var r;return(r="translate3d"===a.positionUsing?{transform:"translate3d("+o(n)+"%,0,0)"}:"translate"===a.positionUsing?{transform:"translate("+o(n)+"%,0)"}:{"margin-left":o(n)+"%"}).transition="all "+e+"ms "+t,r}(n,d,p)),1===n?(s(l,{transition:"none",opacity:1}),l.offsetWidth,setTimeout((function(){s(l,{transition:"all "+d+"ms linear",opacity:0}),setTimeout((function(){t.remove(),e()}),d)}),d)):setTimeout(e,d)})),this},t.isStarted=function(){return"number"==typeof t.status},t.start=function(){t.status||t.set(0);var n=function(){setTimeout((function(){t.status&&(t.trickle(),n())}),a.trickleSpeed)};return a.trickle&&n(),this},t.done=function(n){return n||t.status?t.inc(.3+.5*Math.random()).set(1):this},t.inc=function(n){var e=t.status;return e?("number"!=typeof n&&(n=(1-e)*r(Math.random()*e,.1,.95)),e=r(e+n,0,.994),t.set(e)):t.start()},t.trickle=function(){return t.inc(Math.random()*a.trickleRate)},n=0,e=0,t.promise=function(a){return a&&"resolved"!==a.state()?(0===e&&t.start(),n++,e++,a.always((function(){0==--e?(n=0,t.done()):t.set((n-e)/n)})),this):this},t.render=function(n){if(t.isRendered())return document.getElementById("nprogress");c(document.documentElement,"nprogress-busy");var e=document.createElement("div");e.id="nprogress",e.innerHTML=a.template;var r,i=e.querySelector(a.barSelector),l=n?"-100":o(t.status||0),d=document.querySelector(a.parent);return s(i,{transition:"all 0 linear",transform:"translate3d("+l+"%,0,0)"}),a.showSpinner||(r=e.querySelector(a.spinnerSelector))&&u(r),d!=document.body&&c(d,"nprogress-custom-parent"),d.appendChild(e),e},t.remove=function(){d(document.documentElement,"nprogress-busy"),d(document.querySelector(a.parent),"nprogress-custom-parent");var n=document.getElementById("nprogress");n&&u(n)},t.isRendered=function(){return!!document.getElementById("nprogress")},t.getPositioningCSS=function(){var n=document.body.style,e="WebkitTransform"in n?"Webkit":"MozTransform"in n?"Moz":"msTransform"in n?"ms":"OTransform"in n?"O":"";return e+"Perspective"in n?"translate3d":e+"Transform"in n?"translate":"margin"};var i=function(){var n=[];function e(){var t=n.shift();t&&t(e)}return function(t){n.push(t),1==n.length&&e()}}(),s=function(){var n=["Webkit","O","Moz","ms"],e={};function t(t){return t=t.replace(/^-ms-/,"ms-").replace(/-([\da-z])/gi,(function(n,e){return e.toUpperCase()})),e[t]||(e[t]=function(e){var t=document.body.style;if(e in t)return e;for(var a,r=n.length,o=e.charAt(0).toUpperCase()+e.slice(1);r--;)if((a=n[r]+o)in t)return a;return e}(t))}function a(n,e,a){e=t(e),n.style[e]=a}return function(n,e){var t,r,o=arguments;if(2==o.length)for(t in e)void 0!==(r=e[t])&&e.hasOwnProperty(t)&&a(n,t,r);else a(n,o[1],o[2])}}();function l(n,e){return("string"==typeof n?n:p(n)).indexOf(" "+e+" ")>=0}function c(n,e){var t=p(n),a=t+e;l(t,e)||(n.className=a.substring(1))}function d(n,e){var t,a=p(n);l(n,e)&&(t=a.replace(" "+e+" "," "),n.className=t.substring(1,t.length-1))}function p(n){return(" "+(n.className||"")+" ").replace(/\s+/gi," ")}function u(n){n&&n.parentNode&&n.parentNode.removeChild(n)}return t})?a.call(e,t,e,n):a)||(n.exports=r)},function(n,e,t){var a=t(9),r=String,o=TypeError;n.exports=function(n){if(a(n))return n;throw o(r(n)+" is not an object")}},function(n,e,t){var a=t(3),r=t(51).f,o=t(14),i=t(110),s=t(37),l=t(65),c=t(123);n.exports=function(n,e){var t,d,p,u,h,m=n.target,f=n.global,g=n.stat;if(t=f?a:g?a[m]||s(m,{}):(a[m]||{}).prototype)for(d in e){if(u=e[d],p=n.dontCallGetSet?(h=r(t,d))&&h.value:t[d],!c(f?d:m+(g?".":"#")+d,n.forced)&&void 0!==p){if(typeof u==typeof p)continue;l(u,p)}(n.sham||p&&p.sham)&&o(u,"sham",!0),i(t,d,u,n)}}},function(n,e,t){var a=t(2);n.exports=!a((function(){var n=function(){}.bind();return"function"!=typeof n||n.hasOwnProperty("prototype")}))},function(n,e,t){var a=t(47),r=t(52);n.exports=function(n){return a(r(n))}},function(n,e,t){var a=t(3),r=t(0),o=function(n){return r(n)?n:void 0};n.exports=function(n,e){return arguments.length<2?o(a[n]):a[n]&&a[n][e]}},function(n,e,t){var a=t(0),r=t(108),o=TypeError;n.exports=function(n){if(a(n))return n;throw o(r(n)+" is not a function")}},function(n,e,t){var a=t(3),r=t(61),o=t(8),i=t(63),s=t(59),l=t(58),c=a.Symbol,d=r("wks"),p=l?c.for||c:c&&c.withoutSetter||i;n.exports=function(n){return o(d,n)||(d[n]=s&&o(c,n)?c[n]:p("Symbol."+n)),d[n]}},function(n,e,t){var a=t(52),r=Object;n.exports=function(n){return r(a(n))}},function(n,e,t){var a=t(121);n.exports=function(n){return a(n.length)}},function(n,e,t){var a=t(27),r=Function.prototype.call;n.exports=a?r.bind(r):function(){return r.apply(r,arguments)}},function(n,e){n.exports=function(n,e){return{enumerable:!(1&n),configurable:!(2&n),writable:!(4&n),value:e}}},function(n,e,t){var a=t(3),r=t(37),o=a["__core-js_shared__"]||r("__core-js_shared__",{});n.exports=o},function(n,e,t){var a=t(3),r=Object.defineProperty;n.exports=function(n,e){try{r(a,n,{value:e,configurable:!0,writable:!0})}catch(t){a[n]=e}return e}},function(n,e,t){var a=t(147),r=t(12),o=Object.prototype,i=o.hasOwnProperty,s=o.propertyIsEnumerable,l=a(function(){return arguments}())?a:function(n){return r(n)&&i.call(n,"callee")&&!s.call(n,"callee")};n.exports=l},function(n,e,t){var a=t(10)(t(6),"Map");n.exports=a},function(n,e){n.exports=function(n){var e=typeof n;return null!=n&&("object"==e||"function"==e)}},function(n,e,t){var a=t(167),r=t(174),o=t(176),i=t(177),s=t(178);function l(n){var e=-1,t=null==n?0:n.length;for(this.clear();++e<t;){var a=n[e];this.set(a[0],a[1])}}l.prototype.clear=a,l.prototype.delete=r,l.prototype.get=o,l.prototype.has=i,l.prototype.set=s,n.exports=l},function(n,e){n.exports=function(n){var e=-1,t=Array(n.size);return n.forEach((function(n){t[++e]=n})),t}},function(n,e){n.exports=function(n){return"number"==typeof n&&n>-1&&n%1==0&&n<=9007199254740991}},function(n,e,t){var a=t(5),r=t(45),o=/\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,i=/^\w*$/;n.exports=function(n,e){if(a(n))return!1;var t=typeof n;return!("number"!=t&&"symbol"!=t&&"boolean"!=t&&null!=n&&!r(n))||(i.test(n)||!o.test(n)||null!=e&&n in Object(e))}},function(n,e,t){var a=t(13),r=t(12);n.exports=function(n){return"symbol"==typeof n||r(n)&&"[object Symbol]"==a(n)}},function(n,e){n.exports=function(n){return n}},function(n,e,t){var a=t(1),r=t(2),o=t(18),i=Object,s=a("".split);n.exports=r((function(){return!i("z").propertyIsEnumerable(0)}))?function(n){return"String"==o(n)?s(n,""):i(n)}:i},function(n,e){n.exports={}},function(n,e){n.exports=function(n){return n.webpackPolyfill||(n.deprecate=function(){},n.paths=[],n.children||(n.children=[]),Object.defineProperty(n,"loaded",{enumerable:!0,get:function(){return n.l}}),Object.defineProperty(n,"id",{enumerable:!0,get:function(){return n.i}}),n.webpackPolyfill=1),n}},function(n,e){var t=/^\s+|\s+$/g,a=/^[-+]0x[0-9a-f]+$/i,r=/^0b[01]+$/i,o=/^0o[0-7]+$/i,i=parseInt,s="object"==typeof global&&global&&global.Object===Object&&global,l="object"==typeof self&&self&&self.Object===Object&&self,c=s||l||Function("return this")(),d=Object.prototype.toString,p=Math.max,u=Math.min,h=function(){return c.Date.now()};function m(n){var e=typeof n;return!!n&&("object"==e||"function"==e)}function f(n){if("number"==typeof n)return n;if(function(n){return"symbol"==typeof n||function(n){return!!n&&"object"==typeof n}(n)&&"[object Symbol]"==d.call(n)}(n))return NaN;if(m(n)){var e="function"==typeof n.valueOf?n.valueOf():n;n=m(e)?e+"":e}if("string"!=typeof n)return 0===n?n:+n;n=n.replace(t,"");var s=r.test(n);return s||o.test(n)?i(n.slice(2),s?2:8):a.test(n)?NaN:+n}n.exports=function(n,e,t){var a,r,o,i,s,l,c=0,d=!1,g=!1,v=!0;if("function"!=typeof n)throw new TypeError("Expected a function");function b(e){var t=a,o=r;return a=r=void 0,c=e,i=n.apply(o,t)}function y(n){return c=n,s=setTimeout(x,e),d?b(n):i}function k(n){var t=n-l;return void 0===l||t>=e||t<0||g&&n-c>=o}function x(){var n=h();if(k(n))return w(n);s=setTimeout(x,function(n){var t=e-(n-l);return g?u(t,o-(n-c)):t}(n))}function w(n){return s=void 0,v&&a?b(n):(a=r=void 0,i)}function S(){var n=h(),t=k(n);if(a=arguments,r=this,l=n,t){if(void 0===s)return y(l);if(g)return s=setTimeout(x,e),b(l)}return void 0===s&&(s=setTimeout(x,e)),i}return e=f(e)||0,m(t)&&(d=!!t.leading,o=(g="maxWait"in t)?p(f(t.maxWait)||0,e):o,v="trailing"in t?!!t.trailing:v),S.cancel=function(){void 0!==s&&clearTimeout(s),c=0,a=l=r=s=void 0},S.flush=function(){return void 0===s?i:w(h())},S}},function(n,e,t){var a=t(4),r=t(34),o=t(104),i=t(35),s=t(28),l=t(54),c=t(8),d=t(64),p=Object.getOwnPropertyDescriptor;e.f=a?p:function(n,e){if(n=s(n),e=l(e),d)try{return p(n,e)}catch(n){}if(c(n,e))return i(!r(o.f,n,e),n[e])}},function(n,e,t){var a=t(53),r=TypeError;n.exports=function(n){if(a(n))throw r("Can't call method on "+n);return n}},function(n,e){n.exports=function(n){return null==n}},function(n,e,t){var a=t(105),r=t(56);n.exports=function(n){var e=a(n,"string");return r(e)?e:e+""}},function(n,e){var t="object"==typeof document&&document.all,a=void 0===t&&void 0!==t;n.exports={all:t,IS_HTMLDDA:a}},function(n,e,t){var a=t(29),r=t(0),o=t(57),i=t(58),s=Object;n.exports=i?function(n){return"symbol"==typeof n}:function(n){var e=a("Symbol");return r(e)&&o(e.prototype,s(n))}},function(n,e,t){var a=t(1);n.exports=a({}.isPrototypeOf)},function(n,e,t){var a=t(59);n.exports=a&&!Symbol.sham&&"symbol"==typeof Symbol.iterator},function(n,e,t){var a=t(60),r=t(2);n.exports=!!Object.getOwnPropertySymbols&&!r((function(){var n=Symbol();return!String(n)||!(Object(n)instanceof Symbol)||!Symbol.sham&&a&&a<41}))},function(n,e,t){var a,r,o=t(3),i=t(106),s=o.process,l=o.Deno,c=s&&s.versions||l&&l.version,d=c&&c.v8;d&&(r=(a=d.split("."))[0]>0&&a[0]<4?1:+(a[0]+a[1])),!r&&i&&(!(a=i.match(/Edge\/(\d+)/))||a[1]>=74)&&(a=i.match(/Chrome\/(\d+)/))&&(r=+a[1]),n.exports=r},function(n,e,t){var a=t(62),r=t(36);(n.exports=function(n,e){return r[n]||(r[n]=void 0!==e?e:{})})("versions",[]).push({version:"3.29.1",mode:a?"pure":"global",copyright:"© 2014-2023 Denis Pushkarev (zloirock.ru)",license:"https://github.com/zloirock/core-js/blob/v3.29.1/LICENSE",source:"https://github.com/zloirock/core-js"})},function(n,e){n.exports=!1},function(n,e,t){var a=t(1),r=0,o=Math.random(),i=a(1..toString);n.exports=function(n){return"Symbol("+(void 0===n?"":n)+")_"+i(++r+o,36)}},function(n,e,t){var a=t(4),r=t(2),o=t(97);n.exports=!a&&!r((function(){return 7!=Object.defineProperty(o("div"),"a",{get:function(){return 7}}).a}))},function(n,e,t){var a=t(8),r=t(116),o=t(51),i=t(17);n.exports=function(n,e,t){for(var s=r(e),l=i.f,c=o.f,d=0;d<s.length;d++){var p=s[d];a(n,p)||t&&a(t,p)||l(n,p,c(e,p))}}},function(n,e,t){var a=t(120);n.exports=function(n){var e=+n;return e!=e||0===e?0:a(e)}},function(n,e,t){var a=t(133),r=t(25),o=t(134);n.exports=Object.setPrototypeOf||("__proto__"in{}?function(){var n,e=!1,t={};try{(n=a(Object.prototype,"__proto__","set"))(t,[]),e=t instanceof Array}catch(n){}return function(t,a){return r(t),o(a),e?n(t,a):t.__proto__=a,t}}():void 0)},function(n,e){n.exports=function(n,e){for(var t=-1,a=e.length,r=n.length;++t<a;)n[r+t]=e[t];return n}},function(n,e){var t="object"==typeof global&&global&&global.Object===Object&&global;n.exports=t},function(n,e,t){var a=t(19),r=t(158),o=t(159),i=t(160),s=t(161),l=t(162);function c(n){var e=this.__data__=new a(n);this.size=e.size}c.prototype.clear=r,c.prototype.delete=o,c.prototype.get=i,c.prototype.has=s,c.prototype.set=l,n.exports=c},function(n,e){n.exports=function(n,e){return n===e||n!=n&&e!=e}},function(n,e,t){var a=t(13),r=t(40);n.exports=function(n){if(!r(n))return!1;var e=a(n);return"[object Function]"==e||"[object GeneratorFunction]"==e||"[object AsyncFunction]"==e||"[object Proxy]"==e}},function(n,e){var t=Function.prototype.toString;n.exports=function(n){if(null!=n){try{return t.call(n)}catch(n){}try{return n+""}catch(n){}}return""}},function(n,e,t){var a=t(179),r=t(12);n.exports=function n(e,t,o,i,s){return e===t||(null==e||null==t||!r(e)&&!r(t)?e!=e&&t!=t:a(e,t,o,i,n,s))}},function(n,e,t){var a=t(76),r=t(182),o=t(77);n.exports=function(n,e,t,i,s,l){var c=1&t,d=n.length,p=e.length;if(d!=p&&!(c&&p>d))return!1;var u=l.get(n),h=l.get(e);if(u&&h)return u==e&&h==n;var m=-1,f=!0,g=2&t?new a:void 0;for(l.set(n,e),l.set(e,n);++m<d;){var v=n[m],b=e[m];if(i)var y=c?i(b,v,m,e,n,l):i(v,b,m,n,e,l);if(void 0!==y){if(y)continue;f=!1;break}if(g){if(!r(e,(function(n,e){if(!o(g,e)&&(v===n||s(v,n,t,i,l)))return g.push(e)}))){f=!1;break}}else if(v!==b&&!s(v,b,t,i,l)){f=!1;break}}return l.delete(n),l.delete(e),f}},function(n,e,t){var a=t(41),r=t(180),o=t(181);function i(n){var e=-1,t=null==n?0:n.length;for(this.__data__=new a;++e<t;)this.add(n[e])}i.prototype.add=i.prototype.push=r,i.prototype.has=o,n.exports=i},function(n,e){n.exports=function(n,e){return n.has(e)}},function(n,e,t){var a=t(192),r=t(198),o=t(82);n.exports=function(n){return o(n)?a(n):r(n)}},function(n,e,t){(function(n){var a=t(6),r=t(194),o=e&&!e.nodeType&&e,i=o&&"object"==typeof n&&n&&!n.nodeType&&n,s=i&&i.exports===o?a.Buffer:void 0,l=(s?s.isBuffer:void 0)||r;n.exports=l}).call(this,t(49)(n))},function(n,e){var t=/^(?:0|[1-9]\d*)$/;n.exports=function(n,e){var a=typeof n;return!!(e=null==e?9007199254740991:e)&&("number"==a||"symbol"!=a&&t.test(n))&&n>-1&&n%1==0&&n<e}},function(n,e,t){var a=t(195),r=t(196),o=t(197),i=o&&o.isTypedArray,s=i?r(i):a;n.exports=s},function(n,e,t){var a=t(72),r=t(43);n.exports=function(n){return null!=n&&r(n.length)&&!a(n)}},function(n,e,t){var a=t(10)(t(6),"Set");n.exports=a},function(n,e,t){var a=t(40);n.exports=function(n){return n==n&&!a(n)}},function(n,e){n.exports=function(n,e){return function(t){return null!=t&&(t[n]===e&&(void 0!==e||n in Object(t)))}}},function(n,e,t){var a=t(87),r=t(23);n.exports=function(n,e){for(var t=0,o=(e=a(e,n)).length;null!=n&&t<o;)n=n[r(e[t++])];return t&&t==o?n:void 0}},function(n,e,t){var a=t(5),r=t(44),o=t(209),i=t(212);n.exports=function(n,e){return a(n)?n:r(n,e)?[n]:o(i(n))}},function(n,e,t){},function(n,e,t){},function(n,e,t){},function(n,e,t){},function(n,e,t){var a=t(145),r=t(150),o=t(221),i=t(229),s=t(238),l=t(101),c=o((function(n){var e=l(n);return s(e)&&(e=void 0),i(a(n,1,s,!0),r(e,2))}));n.exports=c},function(n,e,t){"use strict";
/*!
 * escape-html
 * Copyright(c) 2012-2013 TJ Holowaychuk
 * Copyright(c) 2015 Andreas Lubbe
 * Copyright(c) 2015 Tiancheng "Timothy" Gu
 * MIT Licensed
 */var a=/["'&<>]/;n.exports=function(n){var e,t=""+n,r=a.exec(t);if(!r)return t;var o="",i=0,s=0;for(i=r.index;i<t.length;i++){switch(t.charCodeAt(i)){case 34:e="&quot;";break;case 38:e="&amp;";break;case 39:e="&#39;";break;case 60:e="&lt;";break;case 62:e="&gt;";break;default:continue}s!==i&&(o+=t.substring(s,i)),s=i+1,o+=e}return s!==i?o+t.substring(s,i):o}},function(n,e,t){"use strict";t.r(e);var a={name:"CodeBlock",props:{title:{type:String,required:!0},active:{type:Boolean,default:!1}}},r=(t(241),t(7)),o=Object(r.a)(a,(function(){return(0,this._self._c)("div",{staticClass:"theme-code-block",class:{"theme-code-block__active":this.active}},[this._t("default")],2)}),[],!1,null,"4f1e9d0c",null);e.default=o.exports},function(n,e,t){"use strict";t.r(e);var a={name:"CodeGroup",data:()=>({codeTabs:[],activeCodeTabIndex:-1}),watch:{activeCodeTabIndex(n){this.codeTabs.forEach(n=>{n.elm.classList.remove("theme-code-block__active")}),this.codeTabs[n].elm.classList.add("theme-code-block__active")}},mounted(){this.codeTabs=(this.$slots.default||[]).filter(n=>Boolean(n.componentOptions)).map((n,e)=>(""===n.componentOptions.propsData.active&&(this.activeCodeTabIndex=e),{title:n.componentOptions.propsData.title,elm:n.elm})),-1===this.activeCodeTabIndex&&this.codeTabs.length>0&&(this.activeCodeTabIndex=0)},methods:{changeCodeTab(n){this.activeCodeTabIndex=n}}},r=(t(242),t(7)),o=Object(r.a)(a,(function(){var n=this,e=n._self._c;return e("div",{staticClass:"theme-code-group"},[e("div",{staticClass:"theme-code-group__nav"},[e("ul",{staticClass:"theme-code-group__ul"},n._l(n.codeTabs,(function(t,a){return e("li",{key:t.title,staticClass:"theme-code-group__li"},[e("button",{staticClass:"theme-code-group__nav-tab",class:{"theme-code-group__nav-tab-active":a===n.activeCodeTabIndex},on:{click:function(e){return n.changeCodeTab(a)}}},[n._v("\n            "+n._s(t.title)+"\n          ")])])})),0)]),n._v(" "),n._t("default"),n._v(" "),n.codeTabs.length<1?e("pre",{staticClass:"pre-blank"},[n._v("// Make sure to add code blocks to your code group")]):n._e()],2)}),[],!1,null,"2f5f1757",null);e.default=o.exports},function(n,e){n.exports=["constructor","hasOwnProperty","isPrototypeOf","propertyIsEnumerable","toLocaleString","toString","valueOf"]},function(n,e,t){var a=t(3),r=t(9),o=a.document,i=r(o)&&r(o.createElement);n.exports=function(n){return i?o.createElement(n):{}}},function(n,e,t){var a=t(4),r=t(2);n.exports=a&&r((function(){return 42!=Object.defineProperty((function(){}),"prototype",{value:42,writable:!1}).prototype}))},function(n,e,t){var a=t(61),r=t(63),o=a("keys");n.exports=function(n){return o[n]||(o[n]=r(n))}},function(n,e,t){var a=t(1),r=t(8),o=t(28),i=t(118).indexOf,s=t(48),l=a([].push);n.exports=function(n,e){var t,a=o(n),c=0,d=[];for(t in a)!r(s,t)&&r(a,t)&&l(d,t);for(;e.length>c;)r(a,t=e[c++])&&(~i(d,t)||l(d,t));return d}},function(n,e){n.exports=function(n){var e=null==n?0:n.length;return e?n[e-1]:void 0}},function(n,e,t){n.exports=t(247)},function(n,e,t){"use strict";var a=t(26),r=t(124).left,o=t(125),i=t(60);a({target:"Array",proto:!0,forced:!t(126)&&i>79&&i<83||!o("reduce")},{reduce:function(n){var e=arguments.length;return r(this,n,e,e>1?arguments[1]:void 0)}})},function(n,e,t){"use strict";var a={}.propertyIsEnumerable,r=Object.getOwnPropertyDescriptor,o=r&&!a.call({1:2},1);e.f=o?function(n){var e=r(this,n);return!!e&&e.enumerable}:a},function(n,e,t){var a=t(34),r=t(9),o=t(56),i=t(107),s=t(109),l=t(31),c=TypeError,d=l("toPrimitive");n.exports=function(n,e){if(!r(n)||o(n))return n;var t,l=i(n,d);if(l){if(void 0===e&&(e="default"),t=a(l,n,e),!r(t)||o(t))return t;throw c("Can't convert object to primitive value")}return void 0===e&&(e="number"),s(n,e)}},function(n,e){n.exports="undefined"!=typeof navigator&&String(navigator.userAgent)||""},function(n,e,t){var a=t(30),r=t(53);n.exports=function(n,e){var t=n[e];return r(t)?void 0:a(t)}},function(n,e){var t=String;n.exports=function(n){try{return t(n)}catch(n){return"Object"}}},function(n,e,t){var a=t(34),r=t(0),o=t(9),i=TypeError;n.exports=function(n,e){var t,s;if("string"===e&&r(t=n.toString)&&!o(s=a(t,n)))return s;if(r(t=n.valueOf)&&!o(s=a(t,n)))return s;if("string"!==e&&r(t=n.toString)&&!o(s=a(t,n)))return s;throw i("Can't convert object to primitive value")}},function(n,e,t){var a=t(0),r=t(17),o=t(111),i=t(37);n.exports=function(n,e,t,s){s||(s={});var l=s.enumerable,c=void 0!==s.name?s.name:e;if(a(t)&&o(t,c,s),s.global)l?n[e]=t:i(e,t);else{try{s.unsafe?n[e]&&(l=!0):delete n[e]}catch(n){}l?n[e]=t:r.f(n,e,{value:t,enumerable:!1,configurable:!s.nonConfigurable,writable:!s.nonWritable})}return n}},function(n,e,t){var a=t(1),r=t(2),o=t(0),i=t(8),s=t(4),l=t(112).CONFIGURABLE,c=t(113),d=t(114),p=d.enforce,u=d.get,h=String,m=Object.defineProperty,f=a("".slice),g=a("".replace),v=a([].join),b=s&&!r((function(){return 8!==m((function(){}),"length",{value:8}).length})),y=String(String).split("String"),k=n.exports=function(n,e,t){"Symbol("===f(h(e),0,7)&&(e="["+g(h(e),/^Symbol\(([^)]*)\)/,"$1")+"]"),t&&t.getter&&(e="get "+e),t&&t.setter&&(e="set "+e),(!i(n,"name")||l&&n.name!==e)&&(s?m(n,"name",{value:e,configurable:!0}):n.name=e),b&&t&&i(t,"arity")&&n.length!==t.arity&&m(n,"length",{value:t.arity});try{t&&i(t,"constructor")&&t.constructor?s&&m(n,"prototype",{writable:!1}):n.prototype&&(n.prototype=void 0)}catch(n){}var a=p(n);return i(a,"source")||(a.source=v(y,"string"==typeof e?e:"")),n};Function.prototype.toString=k((function(){return o(this)&&u(this).source||c(this)}),"toString")},function(n,e,t){var a=t(4),r=t(8),o=Function.prototype,i=a&&Object.getOwnPropertyDescriptor,s=r(o,"name"),l=s&&"something"===function(){}.name,c=s&&(!a||a&&i(o,"name").configurable);n.exports={EXISTS:s,PROPER:l,CONFIGURABLE:c}},function(n,e,t){var a=t(1),r=t(0),o=t(36),i=a(Function.toString);r(o.inspectSource)||(o.inspectSource=function(n){return i(n)}),n.exports=o.inspectSource},function(n,e,t){var a,r,o,i=t(115),s=t(3),l=t(9),c=t(14),d=t(8),p=t(36),u=t(99),h=t(48),m=s.TypeError,f=s.WeakMap;if(i||p.state){var g=p.state||(p.state=new f);g.get=g.get,g.has=g.has,g.set=g.set,a=function(n,e){if(g.has(n))throw m("Object already initialized");return e.facade=n,g.set(n,e),e},r=function(n){return g.get(n)||{}},o=function(n){return g.has(n)}}else{var v=u("state");h[v]=!0,a=function(n,e){if(d(n,v))throw m("Object already initialized");return e.facade=n,c(n,v,e),e},r=function(n){return d(n,v)?n[v]:{}},o=function(n){return d(n,v)}}n.exports={set:a,get:r,has:o,enforce:function(n){return o(n)?r(n):a(n,{})},getterFor:function(n){return function(e){var t;if(!l(e)||(t=r(e)).type!==n)throw m("Incompatible receiver, "+n+" required");return t}}}},function(n,e,t){var a=t(3),r=t(0),o=a.WeakMap;n.exports=r(o)&&/native code/.test(String(o))},function(n,e,t){var a=t(29),r=t(1),o=t(117),i=t(122),s=t(25),l=r([].concat);n.exports=a("Reflect","ownKeys")||function(n){var e=o.f(s(n)),t=i.f;return t?l(e,t(n)):e}},function(n,e,t){var a=t(100),r=t(96).concat("length","prototype");e.f=Object.getOwnPropertyNames||function(n){return a(n,r)}},function(n,e,t){var a=t(28),r=t(119),o=t(33),i=function(n){return function(e,t,i){var s,l=a(e),c=o(l),d=r(i,c);if(n&&t!=t){for(;c>d;)if((s=l[d++])!=s)return!0}else for(;c>d;d++)if((n||d in l)&&l[d]===t)return n||d||0;return!n&&-1}};n.exports={includes:i(!0),indexOf:i(!1)}},function(n,e,t){var a=t(66),r=Math.max,o=Math.min;n.exports=function(n,e){var t=a(n);return t<0?r(t+e,0):o(t,e)}},function(n,e){var t=Math.ceil,a=Math.floor;n.exports=Math.trunc||function(n){var e=+n;return(e>0?a:t)(e)}},function(n,e,t){var a=t(66),r=Math.min;n.exports=function(n){return n>0?r(a(n),9007199254740991):0}},function(n,e){e.f=Object.getOwnPropertySymbols},function(n,e,t){var a=t(2),r=t(0),o=/#|\.prototype\./,i=function(n,e){var t=l[s(n)];return t==d||t!=c&&(r(e)?a(e):!!e)},s=i.normalize=function(n){return String(n).replace(o,".").toLowerCase()},l=i.data={},c=i.NATIVE="N",d=i.POLYFILL="P";n.exports=i},function(n,e,t){var a=t(30),r=t(32),o=t(47),i=t(33),s=TypeError,l=function(n){return function(e,t,l,c){a(t);var d=r(e),p=o(d),u=i(d),h=n?u-1:0,m=n?-1:1;if(l<2)for(;;){if(h in p){c=p[h],h+=m;break}if(h+=m,n?h<0:u<=h)throw s("Reduce of empty array with no initial value")}for(;n?h>=0:u>h;h+=m)h in p&&(c=t(c,p[h],h,d));return c}};n.exports={left:l(!1),right:l(!0)}},function(n,e,t){"use strict";var a=t(2);n.exports=function(n,e){var t=[][n];return!!t&&a((function(){t.call(null,e||function(){return 1},1)}))}},function(n,e,t){var a=t(18);n.exports="undefined"!=typeof process&&"process"==a(process)},function(n,e,t){"use strict";var a=t(4),r=t(128),o=TypeError,i=Object.getOwnPropertyDescriptor,s=a&&!function(){if(void 0!==this)return!0;try{Object.defineProperty([],"length",{writable:!1}).length=1}catch(n){return n instanceof TypeError}}();n.exports=s?function(n,e){if(r(n)&&!i(n,"length").writable)throw o("Cannot set read only .length");return n.length=e}:function(n,e){return n.length=e}},function(n,e,t){var a=t(18);n.exports=Array.isArray||function(n){return"Array"==a(n)}},function(n,e){var t=TypeError;n.exports=function(n){if(n>9007199254740991)throw t("Maximum allowed index exceeded");return n}},function(n,e,t){var a=t(26),r=t(3),o=t(131),i=t(132),s=r.WebAssembly,l=7!==Error("e",{cause:7}).cause,c=function(n,e){var t={};t[n]=i(n,e,l),a({global:!0,constructor:!0,arity:1,forced:l},t)},d=function(n,e){if(s&&s[n]){var t={};t[n]=i("WebAssembly."+n,e,l),a({target:"WebAssembly",stat:!0,constructor:!0,arity:1,forced:l},t)}};c("Error",(function(n){return function(e){return o(n,this,arguments)}})),c("EvalError",(function(n){return function(e){return o(n,this,arguments)}})),c("RangeError",(function(n){return function(e){return o(n,this,arguments)}})),c("ReferenceError",(function(n){return function(e){return o(n,this,arguments)}})),c("SyntaxError",(function(n){return function(e){return o(n,this,arguments)}})),c("TypeError",(function(n){return function(e){return o(n,this,arguments)}})),c("URIError",(function(n){return function(e){return o(n,this,arguments)}})),d("CompileError",(function(n){return function(e){return o(n,this,arguments)}})),d("LinkError",(function(n){return function(e){return o(n,this,arguments)}})),d("RuntimeError",(function(n){return function(e){return o(n,this,arguments)}}))},function(n,e,t){var a=t(27),r=Function.prototype,o=r.apply,i=r.call;n.exports="object"==typeof Reflect&&Reflect.apply||(a?i.bind(o):function(){return i.apply(o,arguments)})},function(n,e,t){"use strict";var a=t(29),r=t(8),o=t(14),i=t(57),s=t(67),l=t(65),c=t(135),d=t(136),p=t(137),u=t(141),h=t(142),m=t(4),f=t(62);n.exports=function(n,e,t,g){var v=g?2:1,b=n.split("."),y=b[b.length-1],k=a.apply(null,b);if(k){var x=k.prototype;if(!f&&r(x,"cause")&&delete x.cause,!t)return k;var w=a("Error"),S=e((function(n,e){var t=p(g?e:n,void 0),a=g?new k(n):new k;return void 0!==t&&o(a,"message",t),h(a,S,a.stack,2),this&&i(x,this)&&d(a,this,S),arguments.length>v&&u(a,arguments[v]),a}));if(S.prototype=x,"Error"!==y?s?s(S,w):l(S,w,{name:!0}):m&&"stackTraceLimit"in k&&(c(S,k,"stackTraceLimit"),c(S,k,"prepareStackTrace")),l(S,k),!f)try{x.name!==y&&o(x,"name",y),x.constructor=S}catch(n){}return S}}},function(n,e,t){var a=t(1),r=t(30);n.exports=function(n,e,t){try{return a(r(Object.getOwnPropertyDescriptor(n,e)[t]))}catch(n){}}},function(n,e,t){var a=t(0),r=String,o=TypeError;n.exports=function(n){if("object"==typeof n||a(n))return n;throw o("Can't set "+r(n)+" as a prototype")}},function(n,e,t){var a=t(17).f;n.exports=function(n,e,t){t in n||a(n,t,{configurable:!0,get:function(){return e[t]},set:function(n){e[t]=n}})}},function(n,e,t){var a=t(0),r=t(9),o=t(67);n.exports=function(n,e,t){var i,s;return o&&a(i=e.constructor)&&i!==t&&r(s=i.prototype)&&s!==t.prototype&&o(n,s),n}},function(n,e,t){var a=t(138);n.exports=function(n,e){return void 0===n?arguments.length<2?"":e:a(n)}},function(n,e,t){var a=t(139),r=String;n.exports=function(n){if("Symbol"===a(n))throw TypeError("Cannot convert a Symbol value to a string");return r(n)}},function(n,e,t){var a=t(140),r=t(0),o=t(18),i=t(31)("toStringTag"),s=Object,l="Arguments"==o(function(){return arguments}());n.exports=a?o:function(n){var e,t,a;return void 0===n?"Undefined":null===n?"Null":"string"==typeof(t=function(n,e){try{return n[e]}catch(n){}}(e=s(n),i))?t:l?o(e):"Object"==(a=o(e))&&r(e.callee)?"Arguments":a}},function(n,e,t){var a={};a[t(31)("toStringTag")]="z",n.exports="[object z]"===String(a)},function(n,e,t){var a=t(9),r=t(14);n.exports=function(n,e){a(e)&&"cause"in e&&r(n,"cause",e.cause)}},function(n,e,t){var a=t(14),r=t(143),o=t(144),i=Error.captureStackTrace;n.exports=function(n,e,t,s){o&&(i?i(n,e):a(n,"stack",r(t,s)))}},function(n,e,t){var a=t(1),r=Error,o=a("".replace),i=String(r("zxcasd").stack),s=/\n\s*at [^:]*:[^\n]*/,l=s.test(i);n.exports=function(n,e){if(l&&"string"==typeof n&&!r.prepareStackTrace)for(;e--;)n=o(n,s,"");return n}},function(n,e,t){var a=t(2),r=t(35);n.exports=!a((function(){var n=Error("a");return!("stack"in n)||(Object.defineProperty(n,"stack",r(1,7)),7!==n.stack)}))},function(n,e,t){var a=t(68),r=t(146);n.exports=function n(e,t,o,i,s){var l=-1,c=e.length;for(o||(o=r),s||(s=[]);++l<c;){var d=e[l];t>0&&o(d)?t>1?n(d,t-1,o,i,s):a(s,d):i||(s[s.length]=d)}return s}},function(n,e,t){var a=t(15),r=t(38),o=t(5),i=a?a.isConcatSpreadable:void 0;n.exports=function(n){return o(n)||r(n)||!!(i&&n&&n[i])}},function(n,e,t){var a=t(13),r=t(12);n.exports=function(n){return r(n)&&"[object Arguments]"==a(n)}},function(n,e,t){var a=t(15),r=Object.prototype,o=r.hasOwnProperty,i=r.toString,s=a?a.toStringTag:void 0;n.exports=function(n){var e=o.call(n,s),t=n[s];try{n[s]=void 0;var a=!0}catch(n){}var r=i.call(n);return a&&(e?n[s]=t:delete n[s]),r}},function(n,e){var t=Object.prototype.toString;n.exports=function(n){return t.call(n)}},function(n,e,t){var a=t(151),r=t(207),o=t(46),i=t(5),s=t(218);n.exports=function(n){return"function"==typeof n?n:null==n?o:"object"==typeof n?i(n)?r(n[0],n[1]):a(n):s(n)}},function(n,e,t){var a=t(152),r=t(206),o=t(85);n.exports=function(n){var e=r(n);return 1==e.length&&e[0][2]?o(e[0][0],e[0][1]):function(t){return t===n||a(t,n,e)}}},function(n,e,t){var a=t(70),r=t(74);n.exports=function(n,e,t,o){var i=t.length,s=i,l=!o;if(null==n)return!s;for(n=Object(n);i--;){var c=t[i];if(l&&c[2]?c[1]!==n[c[0]]:!(c[0]in n))return!1}for(;++i<s;){var d=(c=t[i])[0],p=n[d],u=c[1];if(l&&c[2]){if(void 0===p&&!(d in n))return!1}else{var h=new a;if(o)var m=o(p,u,d,n,e,h);if(!(void 0===m?r(u,p,3,o,h):m))return!1}}return!0}},function(n,e){n.exports=function(){this.__data__=[],this.size=0}},function(n,e,t){var a=t(20),r=Array.prototype.splice;n.exports=function(n){var e=this.__data__,t=a(e,n);return!(t<0)&&(t==e.length-1?e.pop():r.call(e,t,1),--this.size,!0)}},function(n,e,t){var a=t(20);n.exports=function(n){var e=this.__data__,t=a(e,n);return t<0?void 0:e[t][1]}},function(n,e,t){var a=t(20);n.exports=function(n){return a(this.__data__,n)>-1}},function(n,e,t){var a=t(20);n.exports=function(n,e){var t=this.__data__,r=a(t,n);return r<0?(++this.size,t.push([n,e])):t[r][1]=e,this}},function(n,e,t){var a=t(19);n.exports=function(){this.__data__=new a,this.size=0}},function(n,e){n.exports=function(n){var e=this.__data__,t=e.delete(n);return this.size=e.size,t}},function(n,e){n.exports=function(n){return this.__data__.get(n)}},function(n,e){n.exports=function(n){return this.__data__.has(n)}},function(n,e,t){var a=t(19),r=t(39),o=t(41);n.exports=function(n,e){var t=this.__data__;if(t instanceof a){var i=t.__data__;if(!r||i.length<199)return i.push([n,e]),this.size=++t.size,this;t=this.__data__=new o(i)}return t.set(n,e),this.size=t.size,this}},function(n,e,t){var a=t(72),r=t(164),o=t(40),i=t(73),s=/^\[object .+?Constructor\]$/,l=Function.prototype,c=Object.prototype,d=l.toString,p=c.hasOwnProperty,u=RegExp("^"+d.call(p).replace(/[\\^$.*+?()[\]{}|]/g,"\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,"$1.*?")+"$");n.exports=function(n){return!(!o(n)||r(n))&&(a(n)?u:s).test(i(n))}},function(n,e,t){var a,r=t(165),o=(a=/[^.]+$/.exec(r&&r.keys&&r.keys.IE_PROTO||""))?"Symbol(src)_1."+a:"";n.exports=function(n){return!!o&&o in n}},function(n,e,t){var a=t(6)["__core-js_shared__"];n.exports=a},function(n,e){n.exports=function(n,e){return null==n?void 0:n[e]}},function(n,e,t){var a=t(168),r=t(19),o=t(39);n.exports=function(){this.size=0,this.__data__={hash:new a,map:new(o||r),string:new a}}},function(n,e,t){var a=t(169),r=t(170),o=t(171),i=t(172),s=t(173);function l(n){var e=-1,t=null==n?0:n.length;for(this.clear();++e<t;){var a=n[e];this.set(a[0],a[1])}}l.prototype.clear=a,l.prototype.delete=r,l.prototype.get=o,l.prototype.has=i,l.prototype.set=s,n.exports=l},function(n,e,t){var a=t(21);n.exports=function(){this.__data__=a?a(null):{},this.size=0}},function(n,e){n.exports=function(n){var e=this.has(n)&&delete this.__data__[n];return this.size-=e?1:0,e}},function(n,e,t){var a=t(21),r=Object.prototype.hasOwnProperty;n.exports=function(n){var e=this.__data__;if(a){var t=e[n];return"__lodash_hash_undefined__"===t?void 0:t}return r.call(e,n)?e[n]:void 0}},function(n,e,t){var a=t(21),r=Object.prototype.hasOwnProperty;n.exports=function(n){var e=this.__data__;return a?void 0!==e[n]:r.call(e,n)}},function(n,e,t){var a=t(21);n.exports=function(n,e){var t=this.__data__;return this.size+=this.has(n)?0:1,t[n]=a&&void 0===e?"__lodash_hash_undefined__":e,this}},function(n,e,t){var a=t(22);n.exports=function(n){var e=a(this,n).delete(n);return this.size-=e?1:0,e}},function(n,e){n.exports=function(n){var e=typeof n;return"string"==e||"number"==e||"symbol"==e||"boolean"==e?"__proto__"!==n:null===n}},function(n,e,t){var a=t(22);n.exports=function(n){return a(this,n).get(n)}},function(n,e,t){var a=t(22);n.exports=function(n){return a(this,n).has(n)}},function(n,e,t){var a=t(22);n.exports=function(n,e){var t=a(this,n),r=t.size;return t.set(n,e),this.size+=t.size==r?0:1,this}},function(n,e,t){var a=t(70),r=t(75),o=t(183),i=t(186),s=t(202),l=t(5),c=t(79),d=t(81),p="[object Object]",u=Object.prototype.hasOwnProperty;n.exports=function(n,e,t,h,m,f){var g=l(n),v=l(e),b=g?"[object Array]":s(n),y=v?"[object Array]":s(e),k=(b="[object Arguments]"==b?p:b)==p,x=(y="[object Arguments]"==y?p:y)==p,w=b==y;if(w&&c(n)){if(!c(e))return!1;g=!0,k=!1}if(w&&!k)return f||(f=new a),g||d(n)?r(n,e,t,h,m,f):o(n,e,b,t,h,m,f);if(!(1&t)){var S=k&&u.call(n,"__wrapped__"),T=x&&u.call(e,"__wrapped__");if(S||T){var C=S?n.value():n,j=T?e.value():e;return f||(f=new a),m(C,j,t,h,f)}}return!!w&&(f||(f=new a),i(n,e,t,h,m,f))}},function(n,e){n.exports=function(n){return this.__data__.set(n,"__lodash_hash_undefined__"),this}},function(n,e){n.exports=function(n){return this.__data__.has(n)}},function(n,e){n.exports=function(n,e){for(var t=-1,a=null==n?0:n.length;++t<a;)if(e(n[t],t,n))return!0;return!1}},function(n,e,t){var a=t(15),r=t(184),o=t(71),i=t(75),s=t(185),l=t(42),c=a?a.prototype:void 0,d=c?c.valueOf:void 0;n.exports=function(n,e,t,a,c,p,u){switch(t){case"[object DataView]":if(n.byteLength!=e.byteLength||n.byteOffset!=e.byteOffset)return!1;n=n.buffer,e=e.buffer;case"[object ArrayBuffer]":return!(n.byteLength!=e.byteLength||!p(new r(n),new r(e)));case"[object Boolean]":case"[object Date]":case"[object Number]":return o(+n,+e);case"[object Error]":return n.name==e.name&&n.message==e.message;case"[object RegExp]":case"[object String]":return n==e+"";case"[object Map]":var h=s;case"[object Set]":var m=1&a;if(h||(h=l),n.size!=e.size&&!m)return!1;var f=u.get(n);if(f)return f==e;a|=2,u.set(n,e);var g=i(h(n),h(e),a,c,p,u);return u.delete(n),g;case"[object Symbol]":if(d)return d.call(n)==d.call(e)}return!1}},function(n,e,t){var a=t(6).Uint8Array;n.exports=a},function(n,e){n.exports=function(n){var e=-1,t=Array(n.size);return n.forEach((function(n,a){t[++e]=[a,n]})),t}},function(n,e,t){var a=t(187),r=Object.prototype.hasOwnProperty;n.exports=function(n,e,t,o,i,s){var l=1&t,c=a(n),d=c.length;if(d!=a(e).length&&!l)return!1;for(var p=d;p--;){var u=c[p];if(!(l?u in e:r.call(e,u)))return!1}var h=s.get(n),m=s.get(e);if(h&&m)return h==e&&m==n;var f=!0;s.set(n,e),s.set(e,n);for(var g=l;++p<d;){var v=n[u=c[p]],b=e[u];if(o)var y=l?o(b,v,u,e,n,s):o(v,b,u,n,e,s);if(!(void 0===y?v===b||i(v,b,t,o,s):y)){f=!1;break}g||(g="constructor"==u)}if(f&&!g){var k=n.constructor,x=e.constructor;k==x||!("constructor"in n)||!("constructor"in e)||"function"==typeof k&&k instanceof k&&"function"==typeof x&&x instanceof x||(f=!1)}return s.delete(n),s.delete(e),f}},function(n,e,t){var a=t(188),r=t(189),o=t(78);n.exports=function(n){return a(n,o,r)}},function(n,e,t){var a=t(68),r=t(5);n.exports=function(n,e,t){var o=e(n);return r(n)?o:a(o,t(n))}},function(n,e,t){var a=t(190),r=t(191),o=Object.prototype.propertyIsEnumerable,i=Object.getOwnPropertySymbols,s=i?function(n){return null==n?[]:(n=Object(n),a(i(n),(function(e){return o.call(n,e)})))}:r;n.exports=s},function(n,e){n.exports=function(n,e){for(var t=-1,a=null==n?0:n.length,r=0,o=[];++t<a;){var i=n[t];e(i,t,n)&&(o[r++]=i)}return o}},function(n,e){n.exports=function(){return[]}},function(n,e,t){var a=t(193),r=t(38),o=t(5),i=t(79),s=t(80),l=t(81),c=Object.prototype.hasOwnProperty;n.exports=function(n,e){var t=o(n),d=!t&&r(n),p=!t&&!d&&i(n),u=!t&&!d&&!p&&l(n),h=t||d||p||u,m=h?a(n.length,String):[],f=m.length;for(var g in n)!e&&!c.call(n,g)||h&&("length"==g||p&&("offset"==g||"parent"==g)||u&&("buffer"==g||"byteLength"==g||"byteOffset"==g)||s(g,f))||m.push(g);return m}},function(n,e){n.exports=function(n,e){for(var t=-1,a=Array(n);++t<n;)a[t]=e(t);return a}},function(n,e){n.exports=function(){return!1}},function(n,e,t){var a=t(13),r=t(43),o=t(12),i={};i["[object Float32Array]"]=i["[object Float64Array]"]=i["[object Int8Array]"]=i["[object Int16Array]"]=i["[object Int32Array]"]=i["[object Uint8Array]"]=i["[object Uint8ClampedArray]"]=i["[object Uint16Array]"]=i["[object Uint32Array]"]=!0,i["[object Arguments]"]=i["[object Array]"]=i["[object ArrayBuffer]"]=i["[object Boolean]"]=i["[object DataView]"]=i["[object Date]"]=i["[object Error]"]=i["[object Function]"]=i["[object Map]"]=i["[object Number]"]=i["[object Object]"]=i["[object RegExp]"]=i["[object Set]"]=i["[object String]"]=i["[object WeakMap]"]=!1,n.exports=function(n){return o(n)&&r(n.length)&&!!i[a(n)]}},function(n,e){n.exports=function(n){return function(e){return n(e)}}},function(n,e,t){(function(n){var a=t(69),r=e&&!e.nodeType&&e,o=r&&"object"==typeof n&&n&&!n.nodeType&&n,i=o&&o.exports===r&&a.process,s=function(){try{var n=o&&o.require&&o.require("util").types;return n||i&&i.binding&&i.binding("util")}catch(n){}}();n.exports=s}).call(this,t(49)(n))},function(n,e,t){var a=t(199),r=t(200),o=Object.prototype.hasOwnProperty;n.exports=function(n){if(!a(n))return r(n);var e=[];for(var t in Object(n))o.call(n,t)&&"constructor"!=t&&e.push(t);return e}},function(n,e){var t=Object.prototype;n.exports=function(n){var e=n&&n.constructor;return n===("function"==typeof e&&e.prototype||t)}},function(n,e,t){var a=t(201)(Object.keys,Object);n.exports=a},function(n,e){n.exports=function(n,e){return function(t){return n(e(t))}}},function(n,e,t){var a=t(203),r=t(39),o=t(204),i=t(83),s=t(205),l=t(13),c=t(73),d=c(a),p=c(r),u=c(o),h=c(i),m=c(s),f=l;(a&&"[object DataView]"!=f(new a(new ArrayBuffer(1)))||r&&"[object Map]"!=f(new r)||o&&"[object Promise]"!=f(o.resolve())||i&&"[object Set]"!=f(new i)||s&&"[object WeakMap]"!=f(new s))&&(f=function(n){var e=l(n),t="[object Object]"==e?n.constructor:void 0,a=t?c(t):"";if(a)switch(a){case d:return"[object DataView]";case p:return"[object Map]";case u:return"[object Promise]";case h:return"[object Set]";case m:return"[object WeakMap]"}return e}),n.exports=f},function(n,e,t){var a=t(10)(t(6),"DataView");n.exports=a},function(n,e,t){var a=t(10)(t(6),"Promise");n.exports=a},function(n,e,t){var a=t(10)(t(6),"WeakMap");n.exports=a},function(n,e,t){var a=t(84),r=t(78);n.exports=function(n){for(var e=r(n),t=e.length;t--;){var o=e[t],i=n[o];e[t]=[o,i,a(i)]}return e}},function(n,e,t){var a=t(74),r=t(208),o=t(215),i=t(44),s=t(84),l=t(85),c=t(23);n.exports=function(n,e){return i(n)&&s(e)?l(c(n),e):function(t){var i=r(t,n);return void 0===i&&i===e?o(t,n):a(e,i,3)}}},function(n,e,t){var a=t(86);n.exports=function(n,e,t){var r=null==n?void 0:a(n,e);return void 0===r?t:r}},function(n,e,t){var a=t(210),r=/[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g,o=/\\(\\)?/g,i=a((function(n){var e=[];return 46===n.charCodeAt(0)&&e.push(""),n.replace(r,(function(n,t,a,r){e.push(a?r.replace(o,"$1"):t||n)})),e}));n.exports=i},function(n,e,t){var a=t(211);n.exports=function(n){var e=a(n,(function(n){return 500===t.size&&t.clear(),n})),t=e.cache;return e}},function(n,e,t){var a=t(41);function r(n,e){if("function"!=typeof n||null!=e&&"function"!=typeof e)throw new TypeError("Expected a function");var t=function(){var a=arguments,r=e?e.apply(this,a):a[0],o=t.cache;if(o.has(r))return o.get(r);var i=n.apply(this,a);return t.cache=o.set(r,i)||o,i};return t.cache=new(r.Cache||a),t}r.Cache=a,n.exports=r},function(n,e,t){var a=t(213);n.exports=function(n){return null==n?"":a(n)}},function(n,e,t){var a=t(15),r=t(214),o=t(5),i=t(45),s=a?a.prototype:void 0,l=s?s.toString:void 0;n.exports=function n(e){if("string"==typeof e)return e;if(o(e))return r(e,n)+"";if(i(e))return l?l.call(e):"";var t=e+"";return"0"==t&&1/e==-1/0?"-0":t}},function(n,e){n.exports=function(n,e){for(var t=-1,a=null==n?0:n.length,r=Array(a);++t<a;)r[t]=e(n[t],t,n);return r}},function(n,e,t){var a=t(216),r=t(217);n.exports=function(n,e){return null!=n&&r(n,e,a)}},function(n,e){n.exports=function(n,e){return null!=n&&e in Object(n)}},function(n,e,t){var a=t(87),r=t(38),o=t(5),i=t(80),s=t(43),l=t(23);n.exports=function(n,e,t){for(var c=-1,d=(e=a(e,n)).length,p=!1;++c<d;){var u=l(e[c]);if(!(p=null!=n&&t(n,u)))break;n=n[u]}return p||++c!=d?p:!!(d=null==n?0:n.length)&&s(d)&&i(u,d)&&(o(n)||r(n))}},function(n,e,t){var a=t(219),r=t(220),o=t(44),i=t(23);n.exports=function(n){return o(n)?a(i(n)):r(n)}},function(n,e){n.exports=function(n){return function(e){return null==e?void 0:e[n]}}},function(n,e,t){var a=t(86);n.exports=function(n){return function(e){return a(e,n)}}},function(n,e,t){var a=t(46),r=t(222),o=t(224);n.exports=function(n,e){return o(r(n,e,a),n+"")}},function(n,e,t){var a=t(223),r=Math.max;n.exports=function(n,e,t){return e=r(void 0===e?n.length-1:e,0),function(){for(var o=arguments,i=-1,s=r(o.length-e,0),l=Array(s);++i<s;)l[i]=o[e+i];i=-1;for(var c=Array(e+1);++i<e;)c[i]=o[i];return c[e]=t(l),a(n,this,c)}}},function(n,e){n.exports=function(n,e,t){switch(t.length){case 0:return n.call(e);case 1:return n.call(e,t[0]);case 2:return n.call(e,t[0],t[1]);case 3:return n.call(e,t[0],t[1],t[2])}return n.apply(e,t)}},function(n,e,t){var a=t(225),r=t(228)(a);n.exports=r},function(n,e,t){var a=t(226),r=t(227),o=t(46),i=r?function(n,e){return r(n,"toString",{configurable:!0,enumerable:!1,value:a(e),writable:!0})}:o;n.exports=i},function(n,e){n.exports=function(n){return function(){return n}}},function(n,e,t){var a=t(10),r=function(){try{var n=a(Object,"defineProperty");return n({},"",{}),n}catch(n){}}();n.exports=r},function(n,e){var t=Date.now;n.exports=function(n){var e=0,a=0;return function(){var r=t(),o=16-(r-a);if(a=r,o>0){if(++e>=800)return arguments[0]}else e=0;return n.apply(void 0,arguments)}}},function(n,e,t){var a=t(76),r=t(230),o=t(235),i=t(77),s=t(236),l=t(42);n.exports=function(n,e,t){var c=-1,d=r,p=n.length,u=!0,h=[],m=h;if(t)u=!1,d=o;else if(p>=200){var f=e?null:s(n);if(f)return l(f);u=!1,d=i,m=new a}else m=e?[]:h;n:for(;++c<p;){var g=n[c],v=e?e(g):g;if(g=t||0!==g?g:0,u&&v==v){for(var b=m.length;b--;)if(m[b]===v)continue n;e&&m.push(v),h.push(g)}else d(m,v,t)||(m!==h&&m.push(v),h.push(g))}return h}},function(n,e,t){var a=t(231);n.exports=function(n,e){return!!(null==n?0:n.length)&&a(n,e,0)>-1}},function(n,e,t){var a=t(232),r=t(233),o=t(234);n.exports=function(n,e,t){return e==e?o(n,e,t):a(n,r,t)}},function(n,e){n.exports=function(n,e,t,a){for(var r=n.length,o=t+(a?1:-1);a?o--:++o<r;)if(e(n[o],o,n))return o;return-1}},function(n,e){n.exports=function(n){return n!=n}},function(n,e){n.exports=function(n,e,t){for(var a=t-1,r=n.length;++a<r;)if(n[a]===e)return a;return-1}},function(n,e){n.exports=function(n,e,t){for(var a=-1,r=null==n?0:n.length;++a<r;)if(t(e,n[a]))return!0;return!1}},function(n,e,t){var a=t(83),r=t(237),o=t(42),i=a&&1/o(new a([,-0]))[1]==1/0?function(n){return new a(n)}:r;n.exports=i},function(n,e){n.exports=function(){}},function(n,e,t){var a=t(82),r=t(12);n.exports=function(n){return r(n)&&a(n)}},function(n,e,t){},function(n,e,t){},function(n,e,t){"use strict";t(88)},function(n,e,t){"use strict";t(89)},function(n,e,t){},function(n,e,t){},function(n,e,t){"use strict";t(90)},function(n,e,t){"use strict";t(91)},function(n,e,t){"use strict";t.r(e);
/*!
 * Vue.js v2.7.14
 * (c) 2014-2022 Evan You
 * Released under the MIT License.
 */
var a=Object.freeze({}),r=Array.isArray;function o(n){return null==n}function i(n){return null!=n}function s(n){return!0===n}function l(n){return"string"==typeof n||"number"==typeof n||"symbol"==typeof n||"boolean"==typeof n}function c(n){return"function"==typeof n}function d(n){return null!==n&&"object"==typeof n}var p=Object.prototype.toString;function u(n){return"[object Object]"===p.call(n)}function h(n){return"[object RegExp]"===p.call(n)}function m(n){var e=parseFloat(String(n));return e>=0&&Math.floor(e)===e&&isFinite(n)}function f(n){return i(n)&&"function"==typeof n.then&&"function"==typeof n.catch}function g(n){return null==n?"":Array.isArray(n)||u(n)&&n.toString===p?JSON.stringify(n,null,2):String(n)}function v(n){var e=parseFloat(n);return isNaN(e)?n:e}function b(n,e){for(var t=Object.create(null),a=n.split(","),r=0;r<a.length;r++)t[a[r]]=!0;return e?function(n){return t[n.toLowerCase()]}:function(n){return t[n]}}b("slot,component",!0);var y=b("key,ref,slot,slot-scope,is");function k(n,e){var t=n.length;if(t){if(e===n[t-1])return void(n.length=t-1);var a=n.indexOf(e);if(a>-1)return n.splice(a,1)}}var x=Object.prototype.hasOwnProperty;function w(n,e){return x.call(n,e)}function S(n){var e=Object.create(null);return function(t){return e[t]||(e[t]=n(t))}}var T=/-(\w)/g,C=S((function(n){return n.replace(T,(function(n,e){return e?e.toUpperCase():""}))})),j=S((function(n){return n.charAt(0).toUpperCase()+n.slice(1)})),E=/\B([A-Z])/g,A=S((function(n){return n.replace(E,"-$1").toLowerCase()}));var I=Function.prototype.bind?function(n,e){return n.bind(e)}:function(n,e){function t(t){var a=arguments.length;return a?a>1?n.apply(e,arguments):n.call(e,t):n.call(e)}return t._length=n.length,t};function _(n,e){e=e||0;for(var t=n.length-e,a=new Array(t);t--;)a[t]=n[t+e];return a}function L(n,e){for(var t in e)n[t]=e[t];return n}function z(n){for(var e={},t=0;t<n.length;t++)n[t]&&L(e,n[t]);return e}function P(n,e,t){}var B=function(n,e,t){return!1},M=function(n){return n};function O(n,e){if(n===e)return!0;var t=d(n),a=d(e);if(!t||!a)return!t&&!a&&String(n)===String(e);try{var r=Array.isArray(n),o=Array.isArray(e);if(r&&o)return n.length===e.length&&n.every((function(n,t){return O(n,e[t])}));if(n instanceof Date&&e instanceof Date)return n.getTime()===e.getTime();if(r||o)return!1;var i=Object.keys(n),s=Object.keys(e);return i.length===s.length&&i.every((function(t){return O(n[t],e[t])}))}catch(n){return!1}}function R(n,e){for(var t=0;t<n.length;t++)if(O(n[t],e))return t;return-1}function D(n){var e=!1;return function(){e||(e=!0,n.apply(this,arguments))}}function J(n,e){return n===e?0===n&&1/n!=1/e:n==n||e==e}var q=["component","directive","filter"],F=["beforeCreate","created","beforeMount","mounted","beforeUpdate","updated","beforeDestroy","destroyed","activated","deactivated","errorCaptured","serverPrefetch","renderTracked","renderTriggered"],N={optionMergeStrategies:Object.create(null),silent:!1,productionTip:!1,devtools:!1,performance:!1,errorHandler:null,warnHandler:null,ignoredElements:[],keyCodes:Object.create(null),isReservedTag:B,isReservedAttr:B,isUnknownElement:B,getTagNamespace:P,parsePlatformTagName:M,mustUseProp:B,async:!0,_lifecycleHooks:F},Q=/a-zA-Z\u00B7\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u037D\u037F-\u1FFF\u200C-\u200D\u203F-\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD/;function U(n){var e=(n+"").charCodeAt(0);return 36===e||95===e}function H(n,e,t,a){Object.defineProperty(n,e,{value:t,enumerable:!!a,writable:!0,configurable:!0})}var $=new RegExp("[^".concat(Q.source,".$_\\d]"));var G="__proto__"in{},V="undefined"!=typeof window,X=V&&window.navigator.userAgent.toLowerCase(),K=X&&/msie|trident/.test(X),W=X&&X.indexOf("msie 9.0")>0,Z=X&&X.indexOf("edge/")>0;X&&X.indexOf("android");var Y=X&&/iphone|ipad|ipod|ios/.test(X);X&&/chrome\/\d+/.test(X),X&&/phantomjs/.test(X);var nn,en=X&&X.match(/firefox\/(\d+)/),tn={}.watch,an=!1;if(V)try{var rn={};Object.defineProperty(rn,"passive",{get:function(){an=!0}}),window.addEventListener("test-passive",null,rn)}catch(n){}var on=function(){return void 0===nn&&(nn=!V&&"undefined"!=typeof global&&(global.process&&"server"===global.process.env.VUE_ENV)),nn},sn=V&&window.__VUE_DEVTOOLS_GLOBAL_HOOK__;function ln(n){return"function"==typeof n&&/native code/.test(n.toString())}var cn,dn="undefined"!=typeof Symbol&&ln(Symbol)&&"undefined"!=typeof Reflect&&ln(Reflect.ownKeys);cn="undefined"!=typeof Set&&ln(Set)?Set:function(){function n(){this.set=Object.create(null)}return n.prototype.has=function(n){return!0===this.set[n]},n.prototype.add=function(n){this.set[n]=!0},n.prototype.clear=function(){this.set=Object.create(null)},n}();var pn=null;function un(n){void 0===n&&(n=null),n||pn&&pn._scope.off(),pn=n,n&&n._scope.on()}var hn=function(){function n(n,e,t,a,r,o,i,s){this.tag=n,this.data=e,this.children=t,this.text=a,this.elm=r,this.ns=void 0,this.context=o,this.fnContext=void 0,this.fnOptions=void 0,this.fnScopeId=void 0,this.key=e&&e.key,this.componentOptions=i,this.componentInstance=void 0,this.parent=void 0,this.raw=!1,this.isStatic=!1,this.isRootInsert=!0,this.isComment=!1,this.isCloned=!1,this.isOnce=!1,this.asyncFactory=s,this.asyncMeta=void 0,this.isAsyncPlaceholder=!1}return Object.defineProperty(n.prototype,"child",{get:function(){return this.componentInstance},enumerable:!1,configurable:!0}),n}(),mn=function(n){void 0===n&&(n="");var e=new hn;return e.text=n,e.isComment=!0,e};function fn(n){return new hn(void 0,void 0,void 0,String(n))}function gn(n){var e=new hn(n.tag,n.data,n.children&&n.children.slice(),n.text,n.elm,n.context,n.componentOptions,n.asyncFactory);return e.ns=n.ns,e.isStatic=n.isStatic,e.key=n.key,e.isComment=n.isComment,e.fnContext=n.fnContext,e.fnOptions=n.fnOptions,e.fnScopeId=n.fnScopeId,e.asyncMeta=n.asyncMeta,e.isCloned=!0,e}var vn=0,bn=[],yn=function(){function n(){this._pending=!1,this.id=vn++,this.subs=[]}return n.prototype.addSub=function(n){this.subs.push(n)},n.prototype.removeSub=function(n){this.subs[this.subs.indexOf(n)]=null,this._pending||(this._pending=!0,bn.push(this))},n.prototype.depend=function(e){n.target&&n.target.addDep(this)},n.prototype.notify=function(n){var e=this.subs.filter((function(n){return n}));for(var t=0,a=e.length;t<a;t++){0,e[t].update()}},n}();yn.target=null;var kn=[];function xn(n){kn.push(n),yn.target=n}function wn(){kn.pop(),yn.target=kn[kn.length-1]}var Sn=Array.prototype,Tn=Object.create(Sn);["push","pop","shift","unshift","splice","sort","reverse"].forEach((function(n){var e=Sn[n];H(Tn,n,(function(){for(var t=[],a=0;a<arguments.length;a++)t[a]=arguments[a];var r,o=e.apply(this,t),i=this.__ob__;switch(n){case"push":case"unshift":r=t;break;case"splice":r=t.slice(2)}return r&&i.observeArray(r),i.dep.notify(),o}))}));var Cn=Object.getOwnPropertyNames(Tn),jn={},En=!0;function An(n){En=n}var In={notify:P,depend:P,addSub:P,removeSub:P},_n=function(){function n(n,e,t){if(void 0===e&&(e=!1),void 0===t&&(t=!1),this.value=n,this.shallow=e,this.mock=t,this.dep=t?In:new yn,this.vmCount=0,H(n,"__ob__",this),r(n)){if(!t)if(G)n.__proto__=Tn;else for(var a=0,o=Cn.length;a<o;a++){H(n,s=Cn[a],Tn[s])}e||this.observeArray(n)}else{var i=Object.keys(n);for(a=0;a<i.length;a++){var s;zn(n,s=i[a],jn,void 0,e,t)}}}return n.prototype.observeArray=function(n){for(var e=0,t=n.length;e<t;e++)Ln(n[e],!1,this.mock)},n}();function Ln(n,e,t){return n&&w(n,"__ob__")&&n.__ob__ instanceof _n?n.__ob__:!En||!t&&on()||!r(n)&&!u(n)||!Object.isExtensible(n)||n.__v_skip||Jn(n)||n instanceof hn?void 0:new _n(n,e,t)}function zn(n,e,t,a,o,i){var s=new yn,l=Object.getOwnPropertyDescriptor(n,e);if(!l||!1!==l.configurable){var c=l&&l.get,d=l&&l.set;c&&!d||t!==jn&&2!==arguments.length||(t=n[e]);var p=!o&&Ln(t,!1,i);return Object.defineProperty(n,e,{enumerable:!0,configurable:!0,get:function(){var e=c?c.call(n):t;return yn.target&&(s.depend(),p&&(p.dep.depend(),r(e)&&Mn(e))),Jn(e)&&!o?e.value:e},set:function(e){var a=c?c.call(n):t;if(J(a,e)){if(d)d.call(n,e);else{if(c)return;if(!o&&Jn(a)&&!Jn(e))return void(a.value=e);t=e}p=!o&&Ln(e,!1,i),s.notify()}}}),s}}function Pn(n,e,t){if(!Dn(n)){var a=n.__ob__;return r(n)&&m(e)?(n.length=Math.max(n.length,e),n.splice(e,1,t),a&&!a.shallow&&a.mock&&Ln(t,!1,!0),t):e in n&&!(e in Object.prototype)?(n[e]=t,t):n._isVue||a&&a.vmCount?t:a?(zn(a.value,e,t,void 0,a.shallow,a.mock),a.dep.notify(),t):(n[e]=t,t)}}function Bn(n,e){if(r(n)&&m(e))n.splice(e,1);else{var t=n.__ob__;n._isVue||t&&t.vmCount||Dn(n)||w(n,e)&&(delete n[e],t&&t.dep.notify())}}function Mn(n){for(var e=void 0,t=0,a=n.length;t<a;t++)(e=n[t])&&e.__ob__&&e.__ob__.dep.depend(),r(e)&&Mn(e)}function On(n){return Rn(n,!0),H(n,"__v_isShallow",!0),n}function Rn(n,e){if(!Dn(n)){Ln(n,e,on());0}}function Dn(n){return!(!n||!n.__v_isReadonly)}function Jn(n){return!(!n||!0!==n.__v_isRef)}function qn(n,e,t){Object.defineProperty(n,t,{enumerable:!0,configurable:!0,get:function(){var n=e[t];if(Jn(n))return n.value;var a=n&&n.__ob__;return a&&a.dep.depend(),n},set:function(n){var a=e[t];Jn(a)&&!Jn(n)?a.value=n:e[t]=n}})}"".concat("watcher"," callback"),"".concat("watcher"," getter"),"".concat("watcher"," cleanup");var Fn;var Nn=function(){function n(n){void 0===n&&(n=!1),this.detached=n,this.active=!0,this.effects=[],this.cleanups=[],this.parent=Fn,!n&&Fn&&(this.index=(Fn.scopes||(Fn.scopes=[])).push(this)-1)}return n.prototype.run=function(n){if(this.active){var e=Fn;try{return Fn=this,n()}finally{Fn=e}}else 0},n.prototype.on=function(){Fn=this},n.prototype.off=function(){Fn=this.parent},n.prototype.stop=function(n){if(this.active){var e=void 0,t=void 0;for(e=0,t=this.effects.length;e<t;e++)this.effects[e].teardown();for(e=0,t=this.cleanups.length;e<t;e++)this.cleanups[e]();if(this.scopes)for(e=0,t=this.scopes.length;e<t;e++)this.scopes[e].stop(!0);if(!this.detached&&this.parent&&!n){var a=this.parent.scopes.pop();a&&a!==this&&(this.parent.scopes[this.index]=a,a.index=this.index)}this.parent=void 0,this.active=!1}},n}();function Qn(n){var e=n._provided,t=n.$parent&&n.$parent._provided;return t===e?n._provided=Object.create(t):e}var Un=S((function(n){var e="&"===n.charAt(0),t="~"===(n=e?n.slice(1):n).charAt(0),a="!"===(n=t?n.slice(1):n).charAt(0);return{name:n=a?n.slice(1):n,once:t,capture:a,passive:e}}));function Hn(n,e){function t(){var n=t.fns;if(!r(n))return Ee(n,null,arguments,e,"v-on handler");for(var a=n.slice(),o=0;o<a.length;o++)Ee(a[o],null,arguments,e,"v-on handler")}return t.fns=n,t}function $n(n,e,t,a,r,i){var l,c,d,p;for(l in n)c=n[l],d=e[l],p=Un(l),o(c)||(o(d)?(o(c.fns)&&(c=n[l]=Hn(c,i)),s(p.once)&&(c=n[l]=r(p.name,c,p.capture)),t(p.name,c,p.capture,p.passive,p.params)):c!==d&&(d.fns=c,n[l]=d));for(l in e)o(n[l])&&a((p=Un(l)).name,e[l],p.capture)}function Gn(n,e,t){var a;n instanceof hn&&(n=n.data.hook||(n.data.hook={}));var r=n[e];function l(){t.apply(this,arguments),k(a.fns,l)}o(r)?a=Hn([l]):i(r.fns)&&s(r.merged)?(a=r).fns.push(l):a=Hn([r,l]),a.merged=!0,n[e]=a}function Vn(n,e,t,a,r){if(i(e)){if(w(e,t))return n[t]=e[t],r||delete e[t],!0;if(w(e,a))return n[t]=e[a],r||delete e[a],!0}return!1}function Xn(n){return l(n)?[fn(n)]:r(n)?function n(e,t){var a,c,d,p,u=[];for(a=0;a<e.length;a++)o(c=e[a])||"boolean"==typeof c||(d=u.length-1,p=u[d],r(c)?c.length>0&&(Kn((c=n(c,"".concat(t||"","_").concat(a)))[0])&&Kn(p)&&(u[d]=fn(p.text+c[0].text),c.shift()),u.push.apply(u,c)):l(c)?Kn(p)?u[d]=fn(p.text+c):""!==c&&u.push(fn(c)):Kn(c)&&Kn(p)?u[d]=fn(p.text+c.text):(s(e._isVList)&&i(c.tag)&&o(c.key)&&i(t)&&(c.key="__vlist".concat(t,"_").concat(a,"__")),u.push(c)));return u}(n):void 0}function Kn(n){return i(n)&&i(n.text)&&!1===n.isComment}function Wn(n,e){var t,a,o,s,l=null;if(r(n)||"string"==typeof n)for(l=new Array(n.length),t=0,a=n.length;t<a;t++)l[t]=e(n[t],t);else if("number"==typeof n)for(l=new Array(n),t=0;t<n;t++)l[t]=e(t+1,t);else if(d(n))if(dn&&n[Symbol.iterator]){l=[];for(var c=n[Symbol.iterator](),p=c.next();!p.done;)l.push(e(p.value,l.length)),p=c.next()}else for(o=Object.keys(n),l=new Array(o.length),t=0,a=o.length;t<a;t++)s=o[t],l[t]=e(n[s],s,t);return i(l)||(l=[]),l._isVList=!0,l}function Zn(n,e,t,a){var r,o=this.$scopedSlots[n];o?(t=t||{},a&&(t=L(L({},a),t)),r=o(t)||(c(e)?e():e)):r=this.$slots[n]||(c(e)?e():e);var i=t&&t.slot;return i?this.$createElement("template",{slot:i},r):r}function Yn(n){return _t(this.$options,"filters",n,!0)||M}function ne(n,e){return r(n)?-1===n.indexOf(e):n!==e}function ee(n,e,t,a,r){var o=N.keyCodes[e]||t;return r&&a&&!N.keyCodes[e]?ne(r,a):o?ne(o,n):a?A(a)!==e:void 0===n}function te(n,e,t,a,o){if(t)if(d(t)){r(t)&&(t=z(t));var i=void 0,s=function(r){if("class"===r||"style"===r||y(r))i=n;else{var s=n.attrs&&n.attrs.type;i=a||N.mustUseProp(e,s,r)?n.domProps||(n.domProps={}):n.attrs||(n.attrs={})}var l=C(r),c=A(r);l in i||c in i||(i[r]=t[r],o&&((n.on||(n.on={}))["update:".concat(r)]=function(n){t[r]=n}))};for(var l in t)s(l)}else;return n}function ae(n,e){var t=this._staticTrees||(this._staticTrees=[]),a=t[n];return a&&!e||oe(a=t[n]=this.$options.staticRenderFns[n].call(this._renderProxy,this._c,this),"__static__".concat(n),!1),a}function re(n,e,t){return oe(n,"__once__".concat(e).concat(t?"_".concat(t):""),!0),n}function oe(n,e,t){if(r(n))for(var a=0;a<n.length;a++)n[a]&&"string"!=typeof n[a]&&ie(n[a],"".concat(e,"_").concat(a),t);else ie(n,e,t)}function ie(n,e,t){n.isStatic=!0,n.key=e,n.isOnce=t}function se(n,e){if(e)if(u(e)){var t=n.on=n.on?L({},n.on):{};for(var a in e){var r=t[a],o=e[a];t[a]=r?[].concat(r,o):o}}else;return n}function le(n,e,t,a){e=e||{$stable:!t};for(var o=0;o<n.length;o++){var i=n[o];r(i)?le(i,e,t):i&&(i.proxy&&(i.fn.proxy=!0),e[i.key]=i.fn)}return a&&(e.$key=a),e}function ce(n,e){for(var t=0;t<e.length;t+=2){var a=e[t];"string"==typeof a&&a&&(n[e[t]]=e[t+1])}return n}function de(n,e){return"string"==typeof n?e+n:n}function pe(n){n._o=re,n._n=v,n._s=g,n._l=Wn,n._t=Zn,n._q=O,n._i=R,n._m=ae,n._f=Yn,n._k=ee,n._b=te,n._v=fn,n._e=mn,n._u=le,n._g=se,n._d=ce,n._p=de}function ue(n,e){if(!n||!n.length)return{};for(var t={},a=0,r=n.length;a<r;a++){var o=n[a],i=o.data;if(i&&i.attrs&&i.attrs.slot&&delete i.attrs.slot,o.context!==e&&o.fnContext!==e||!i||null==i.slot)(t.default||(t.default=[])).push(o);else{var s=i.slot,l=t[s]||(t[s]=[]);"template"===o.tag?l.push.apply(l,o.children||[]):l.push(o)}}for(var c in t)t[c].every(he)&&delete t[c];return t}function he(n){return n.isComment&&!n.asyncFactory||" "===n.text}function me(n){return n.isComment&&n.asyncFactory}function fe(n,e,t,r){var o,i=Object.keys(t).length>0,s=e?!!e.$stable:!i,l=e&&e.$key;if(e){if(e._normalized)return e._normalized;if(s&&r&&r!==a&&l===r.$key&&!i&&!r.$hasNormal)return r;for(var c in o={},e)e[c]&&"$"!==c[0]&&(o[c]=ge(n,t,c,e[c]))}else o={};for(var d in t)d in o||(o[d]=ve(t,d));return e&&Object.isExtensible(e)&&(e._normalized=o),H(o,"$stable",s),H(o,"$key",l),H(o,"$hasNormal",i),o}function ge(n,e,t,a){var o=function(){var e=pn;un(n);var t=arguments.length?a.apply(null,arguments):a({}),o=(t=t&&"object"==typeof t&&!r(t)?[t]:Xn(t))&&t[0];return un(e),t&&(!o||1===t.length&&o.isComment&&!me(o))?void 0:t};return a.proxy&&Object.defineProperty(e,t,{get:o,enumerable:!0,configurable:!0}),o}function ve(n,e){return function(){return n[e]}}function be(n){return{get attrs(){if(!n._attrsProxy){var e=n._attrsProxy={};H(e,"_v_attr_proxy",!0),ye(e,n.$attrs,a,n,"$attrs")}return n._attrsProxy},get listeners(){n._listenersProxy||ye(n._listenersProxy={},n.$listeners,a,n,"$listeners");return n._listenersProxy},get slots(){return function(n){n._slotsProxy||xe(n._slotsProxy={},n.$scopedSlots);return n._slotsProxy}(n)},emit:I(n.$emit,n),expose:function(e){e&&Object.keys(e).forEach((function(t){return qn(n,e,t)}))}}}function ye(n,e,t,a,r){var o=!1;for(var i in e)i in n?e[i]!==t[i]&&(o=!0):(o=!0,ke(n,i,a,r));for(var i in n)i in e||(o=!0,delete n[i]);return o}function ke(n,e,t,a){Object.defineProperty(n,e,{enumerable:!0,configurable:!0,get:function(){return t[a][e]}})}function xe(n,e){for(var t in e)n[t]=e[t];for(var t in n)t in e||delete n[t]}var we=null;function Se(n,e){return(n.__esModule||dn&&"Module"===n[Symbol.toStringTag])&&(n=n.default),d(n)?e.extend(n):n}function Te(n){if(r(n))for(var e=0;e<n.length;e++){var t=n[e];if(i(t)&&(i(t.componentOptions)||me(t)))return t}}function Ce(n,e,t,a,p,u){return(r(t)||l(t))&&(p=a,a=t,t=void 0),s(u)&&(p=2),function(n,e,t,a,l){if(i(t)&&i(t.__ob__))return mn();i(t)&&i(t.is)&&(e=t.is);if(!e)return mn();0;r(a)&&c(a[0])&&((t=t||{}).scopedSlots={default:a[0]},a.length=0);2===l?a=Xn(a):1===l&&(a=function(n){for(var e=0;e<n.length;e++)if(r(n[e]))return Array.prototype.concat.apply([],n);return n}(a));var p,u;if("string"==typeof e){var h=void 0;u=n.$vnode&&n.$vnode.ns||N.getTagNamespace(e),p=N.isReservedTag(e)?new hn(N.parsePlatformTagName(e),t,a,void 0,void 0,n):t&&t.pre||!i(h=_t(n.$options,"components",e))?new hn(e,t,a,void 0,void 0,n):kt(h,t,n,a,e)}else p=kt(e,t,n,a);return r(p)?p:i(p)?(i(u)&&function n(e,t,a){e.ns=t,"foreignObject"===e.tag&&(t=void 0,a=!0);if(i(e.children))for(var r=0,l=e.children.length;r<l;r++){var c=e.children[r];i(c.tag)&&(o(c.ns)||s(a)&&"svg"!==c.tag)&&n(c,t,a)}}(p,u),i(t)&&function(n){d(n.style)&&Ne(n.style);d(n.class)&&Ne(n.class)}(t),p):mn()}(n,e,t,a,p)}function je(n,e,t){xn();try{if(e)for(var a=e;a=a.$parent;){var r=a.$options.errorCaptured;if(r)for(var o=0;o<r.length;o++)try{if(!1===r[o].call(a,n,e,t))return}catch(n){Ae(n,a,"errorCaptured hook")}}Ae(n,e,t)}finally{wn()}}function Ee(n,e,t,a,r){var o;try{(o=t?n.apply(e,t):n.call(e))&&!o._isVue&&f(o)&&!o._handled&&(o.catch((function(n){return je(n,a,r+" (Promise/async)")})),o._handled=!0)}catch(n){je(n,a,r)}return o}function Ae(n,e,t){if(N.errorHandler)try{return N.errorHandler.call(null,n,e,t)}catch(e){e!==n&&Ie(e,null,"config.errorHandler")}Ie(n,e,t)}function Ie(n,e,t){if(!V||"undefined"==typeof console)throw n;console.error(n)}var _e,Le=!1,ze=[],Pe=!1;function Be(){Pe=!1;var n=ze.slice(0);ze.length=0;for(var e=0;e<n.length;e++)n[e]()}if("undefined"!=typeof Promise&&ln(Promise)){var Me=Promise.resolve();_e=function(){Me.then(Be),Y&&setTimeout(P)},Le=!0}else if(K||"undefined"==typeof MutationObserver||!ln(MutationObserver)&&"[object MutationObserverConstructor]"!==MutationObserver.toString())_e="undefined"!=typeof setImmediate&&ln(setImmediate)?function(){setImmediate(Be)}:function(){setTimeout(Be,0)};else{var Oe=1,Re=new MutationObserver(Be),De=document.createTextNode(String(Oe));Re.observe(De,{characterData:!0}),_e=function(){Oe=(Oe+1)%2,De.data=String(Oe)},Le=!0}function Je(n,e){var t;if(ze.push((function(){if(n)try{n.call(e)}catch(n){je(n,e,"nextTick")}else t&&t(e)})),Pe||(Pe=!0,_e()),!n&&"undefined"!=typeof Promise)return new Promise((function(n){t=n}))}function qe(n){return function(e,t){if(void 0===t&&(t=pn),t)return function(n,e,t){var a=n.$options;a[e]=jt(a[e],t)}(t,n,e)}}qe("beforeMount"),qe("mounted"),qe("beforeUpdate"),qe("updated"),qe("beforeDestroy"),qe("destroyed"),qe("activated"),qe("deactivated"),qe("serverPrefetch"),qe("renderTracked"),qe("renderTriggered"),qe("errorCaptured");var Fe=new cn;function Ne(n){return function n(e,t){var a,o,i=r(e);if(!i&&!d(e)||e.__v_skip||Object.isFrozen(e)||e instanceof hn)return;if(e.__ob__){var s=e.__ob__.dep.id;if(t.has(s))return;t.add(s)}if(i)for(a=e.length;a--;)n(e[a],t);else if(Jn(e))n(e.value,t);else for(o=Object.keys(e),a=o.length;a--;)n(e[o[a]],t)}(n,Fe),Fe.clear(),n}var Qe,Ue=0,He=function(){function n(n,e,t,a,r){var o,i;o=this,void 0===(i=Fn&&!Fn._vm?Fn:n?n._scope:void 0)&&(i=Fn),i&&i.active&&i.effects.push(o),(this.vm=n)&&r&&(n._watcher=this),a?(this.deep=!!a.deep,this.user=!!a.user,this.lazy=!!a.lazy,this.sync=!!a.sync,this.before=a.before):this.deep=this.user=this.lazy=this.sync=!1,this.cb=t,this.id=++Ue,this.active=!0,this.post=!1,this.dirty=this.lazy,this.deps=[],this.newDeps=[],this.depIds=new cn,this.newDepIds=new cn,this.expression="",c(e)?this.getter=e:(this.getter=function(n){if(!$.test(n)){var e=n.split(".");return function(n){for(var t=0;t<e.length;t++){if(!n)return;n=n[e[t]]}return n}}}(e),this.getter||(this.getter=P)),this.value=this.lazy?void 0:this.get()}return n.prototype.get=function(){var n;xn(this);var e=this.vm;try{n=this.getter.call(e,e)}catch(n){if(!this.user)throw n;je(n,e,'getter for watcher "'.concat(this.expression,'"'))}finally{this.deep&&Ne(n),wn(),this.cleanupDeps()}return n},n.prototype.addDep=function(n){var e=n.id;this.newDepIds.has(e)||(this.newDepIds.add(e),this.newDeps.push(n),this.depIds.has(e)||n.addSub(this))},n.prototype.cleanupDeps=function(){for(var n=this.deps.length;n--;){var e=this.deps[n];this.newDepIds.has(e.id)||e.removeSub(this)}var t=this.depIds;this.depIds=this.newDepIds,this.newDepIds=t,this.newDepIds.clear(),t=this.deps,this.deps=this.newDeps,this.newDeps=t,this.newDeps.length=0},n.prototype.update=function(){this.lazy?this.dirty=!0:this.sync?this.run():ut(this)},n.prototype.run=function(){if(this.active){var n=this.get();if(n!==this.value||d(n)||this.deep){var e=this.value;if(this.value=n,this.user){var t='callback for watcher "'.concat(this.expression,'"');Ee(this.cb,this.vm,[n,e],this.vm,t)}else this.cb.call(this.vm,n,e)}}},n.prototype.evaluate=function(){this.value=this.get(),this.dirty=!1},n.prototype.depend=function(){for(var n=this.deps.length;n--;)this.deps[n].depend()},n.prototype.teardown=function(){if(this.vm&&!this.vm._isBeingDestroyed&&k(this.vm._scope.effects,this),this.active){for(var n=this.deps.length;n--;)this.deps[n].removeSub(this);this.active=!1,this.onStop&&this.onStop()}},n}();function $e(n,e){Qe.$on(n,e)}function Ge(n,e){Qe.$off(n,e)}function Ve(n,e){var t=Qe;return function a(){var r=e.apply(null,arguments);null!==r&&t.$off(n,a)}}function Xe(n,e,t){Qe=n,$n(e,t||{},$e,Ge,Ve,n),Qe=void 0}var Ke=null;function We(n){var e=Ke;return Ke=n,function(){Ke=e}}function Ze(n){for(;n&&(n=n.$parent);)if(n._inactive)return!0;return!1}function Ye(n,e){if(e){if(n._directInactive=!1,Ze(n))return}else if(n._directInactive)return;if(n._inactive||null===n._inactive){n._inactive=!1;for(var t=0;t<n.$children.length;t++)Ye(n.$children[t]);nt(n,"activated")}}function nt(n,e,t,a){void 0===a&&(a=!0),xn();var r=pn;a&&un(n);var o=n.$options[e],i="".concat(e," hook");if(o)for(var s=0,l=o.length;s<l;s++)Ee(o[s],n,t||null,n,i);n._hasHookEvent&&n.$emit("hook:"+e),a&&un(r),wn()}var et=[],tt=[],at={},rt=!1,ot=!1,it=0;var st=0,lt=Date.now;if(V&&!K){var ct=window.performance;ct&&"function"==typeof ct.now&&lt()>document.createEvent("Event").timeStamp&&(lt=function(){return ct.now()})}var dt=function(n,e){if(n.post){if(!e.post)return 1}else if(e.post)return-1;return n.id-e.id};function pt(){var n,e;for(st=lt(),ot=!0,et.sort(dt),it=0;it<et.length;it++)(n=et[it]).before&&n.before(),e=n.id,at[e]=null,n.run();var t=tt.slice(),a=et.slice();it=et.length=tt.length=0,at={},rt=ot=!1,function(n){for(var e=0;e<n.length;e++)n[e]._inactive=!0,Ye(n[e],!0)}(t),function(n){var e=n.length;for(;e--;){var t=n[e],a=t.vm;a&&a._watcher===t&&a._isMounted&&!a._isDestroyed&&nt(a,"updated")}}(a),function(){for(var n=0;n<bn.length;n++){var e=bn[n];e.subs=e.subs.filter((function(n){return n})),e._pending=!1}bn.length=0}(),sn&&N.devtools&&sn.emit("flush")}function ut(n){var e=n.id;if(null==at[e]&&(n!==yn.target||!n.noRecurse)){if(at[e]=!0,ot){for(var t=et.length-1;t>it&&et[t].id>n.id;)t--;et.splice(t+1,0,n)}else et.push(n);rt||(rt=!0,Je(pt))}}function ht(n,e){if(n){for(var t=Object.create(null),a=dn?Reflect.ownKeys(n):Object.keys(n),r=0;r<a.length;r++){var o=a[r];if("__ob__"!==o){var i=n[o].from;if(i in e._provided)t[o]=e._provided[i];else if("default"in n[o]){var s=n[o].default;t[o]=c(s)?s.call(e):s}else 0}}return t}}function mt(n,e,t,o,i){var l,c=this,d=i.options;w(o,"_uid")?(l=Object.create(o))._original=o:(l=o,o=o._original);var p=s(d._compiled),u=!p;this.data=n,this.props=e,this.children=t,this.parent=o,this.listeners=n.on||a,this.injections=ht(d.inject,o),this.slots=function(){return c.$slots||fe(o,n.scopedSlots,c.$slots=ue(t,o)),c.$slots},Object.defineProperty(this,"scopedSlots",{enumerable:!0,get:function(){return fe(o,n.scopedSlots,this.slots())}}),p&&(this.$options=d,this.$slots=this.slots(),this.$scopedSlots=fe(o,n.scopedSlots,this.$slots)),d._scopeId?this._c=function(n,e,t,a){var i=Ce(l,n,e,t,a,u);return i&&!r(i)&&(i.fnScopeId=d._scopeId,i.fnContext=o),i}:this._c=function(n,e,t,a){return Ce(l,n,e,t,a,u)}}function ft(n,e,t,a,r){var o=gn(n);return o.fnContext=t,o.fnOptions=a,e.slot&&((o.data||(o.data={})).slot=e.slot),o}function gt(n,e){for(var t in e)n[C(t)]=e[t]}function vt(n){return n.name||n.__name||n._componentTag}pe(mt.prototype);var bt={init:function(n,e){if(n.componentInstance&&!n.componentInstance._isDestroyed&&n.data.keepAlive){var t=n;bt.prepatch(t,t)}else{(n.componentInstance=function(n,e){var t={_isComponent:!0,_parentVnode:n,parent:e},a=n.data.inlineTemplate;i(a)&&(t.render=a.render,t.staticRenderFns=a.staticRenderFns);return new n.componentOptions.Ctor(t)}(n,Ke)).$mount(e?n.elm:void 0,e)}},prepatch:function(n,e){var t=e.componentOptions;!function(n,e,t,r,o){var i=r.data.scopedSlots,s=n.$scopedSlots,l=!!(i&&!i.$stable||s!==a&&!s.$stable||i&&n.$scopedSlots.$key!==i.$key||!i&&n.$scopedSlots.$key),c=!!(o||n.$options._renderChildren||l),d=n.$vnode;n.$options._parentVnode=r,n.$vnode=r,n._vnode&&(n._vnode.parent=r),n.$options._renderChildren=o;var p=r.data.attrs||a;n._attrsProxy&&ye(n._attrsProxy,p,d.data&&d.data.attrs||a,n,"$attrs")&&(c=!0),n.$attrs=p,t=t||a;var u=n.$options._parentListeners;if(n._listenersProxy&&ye(n._listenersProxy,t,u||a,n,"$listeners"),n.$listeners=n.$options._parentListeners=t,Xe(n,t,u),e&&n.$options.props){An(!1);for(var h=n._props,m=n.$options._propKeys||[],f=0;f<m.length;f++){var g=m[f],v=n.$options.props;h[g]=Lt(g,v,e,n)}An(!0),n.$options.propsData=e}c&&(n.$slots=ue(o,r.context),n.$forceUpdate())}(e.componentInstance=n.componentInstance,t.propsData,t.listeners,e,t.children)},insert:function(n){var e,t=n.context,a=n.componentInstance;a._isMounted||(a._isMounted=!0,nt(a,"mounted")),n.data.keepAlive&&(t._isMounted?((e=a)._inactive=!1,tt.push(e)):Ye(a,!0))},destroy:function(n){var e=n.componentInstance;e._isDestroyed||(n.data.keepAlive?function n(e,t){if(!(t&&(e._directInactive=!0,Ze(e))||e._inactive)){e._inactive=!0;for(var a=0;a<e.$children.length;a++)n(e.$children[a]);nt(e,"deactivated")}}(e,!0):e.$destroy())}},yt=Object.keys(bt);function kt(n,e,t,l,c){if(!o(n)){var p=t.$options._base;if(d(n)&&(n=p.extend(n)),"function"==typeof n){var u;if(o(n.cid)&&void 0===(n=function(n,e){if(s(n.error)&&i(n.errorComp))return n.errorComp;if(i(n.resolved))return n.resolved;var t=we;if(t&&i(n.owners)&&-1===n.owners.indexOf(t)&&n.owners.push(t),s(n.loading)&&i(n.loadingComp))return n.loadingComp;if(t&&!i(n.owners)){var a=n.owners=[t],r=!0,l=null,c=null;t.$on("hook:destroyed",(function(){return k(a,t)}));var p=function(n){for(var e=0,t=a.length;e<t;e++)a[e].$forceUpdate();n&&(a.length=0,null!==l&&(clearTimeout(l),l=null),null!==c&&(clearTimeout(c),c=null))},u=D((function(t){n.resolved=Se(t,e),r?a.length=0:p(!0)})),h=D((function(e){i(n.errorComp)&&(n.error=!0,p(!0))})),m=n(u,h);return d(m)&&(f(m)?o(n.resolved)&&m.then(u,h):f(m.component)&&(m.component.then(u,h),i(m.error)&&(n.errorComp=Se(m.error,e)),i(m.loading)&&(n.loadingComp=Se(m.loading,e),0===m.delay?n.loading=!0:l=setTimeout((function(){l=null,o(n.resolved)&&o(n.error)&&(n.loading=!0,p(!1))}),m.delay||200)),i(m.timeout)&&(c=setTimeout((function(){c=null,o(n.resolved)&&h(null)}),m.timeout)))),r=!1,n.loading?n.loadingComp:n.resolved}}(u=n,p)))return function(n,e,t,a,r){var o=mn();return o.asyncFactory=n,o.asyncMeta={data:e,context:t,children:a,tag:r},o}(u,e,t,l,c);e=e||{},Ht(n),i(e.model)&&function(n,e){var t=n.model&&n.model.prop||"value",a=n.model&&n.model.event||"input";(e.attrs||(e.attrs={}))[t]=e.model.value;var o=e.on||(e.on={}),s=o[a],l=e.model.callback;i(s)?(r(s)?-1===s.indexOf(l):s!==l)&&(o[a]=[l].concat(s)):o[a]=l}(n.options,e);var h=function(n,e,t){var a=e.options.props;if(!o(a)){var r={},s=n.attrs,l=n.props;if(i(s)||i(l))for(var c in a){var d=A(c);Vn(r,l,c,d,!0)||Vn(r,s,c,d,!1)}return r}}(e,n);if(s(n.options.functional))return function(n,e,t,o,s){var l=n.options,c={},d=l.props;if(i(d))for(var p in d)c[p]=Lt(p,d,e||a);else i(t.attrs)&&gt(c,t.attrs),i(t.props)&&gt(c,t.props);var u=new mt(t,c,s,o,n),h=l.render.call(null,u._c,u);if(h instanceof hn)return ft(h,t,u.parent,l,u);if(r(h)){for(var m=Xn(h)||[],f=new Array(m.length),g=0;g<m.length;g++)f[g]=ft(m[g],t,u.parent,l,u);return f}}(n,h,e,t,l);var m=e.on;if(e.on=e.nativeOn,s(n.options.abstract)){var g=e.slot;e={},g&&(e.slot=g)}!function(n){for(var e=n.hook||(n.hook={}),t=0;t<yt.length;t++){var a=yt[t],r=e[a],o=bt[a];r===o||r&&r._merged||(e[a]=r?xt(o,r):o)}}(e);var v=vt(n.options)||c;return new hn("vue-component-".concat(n.cid).concat(v?"-".concat(v):""),e,void 0,void 0,void 0,t,{Ctor:n,propsData:h,listeners:m,tag:c,children:l},u)}}}function xt(n,e){var t=function(t,a){n(t,a),e(t,a)};return t._merged=!0,t}var wt=P,St=N.optionMergeStrategies;function Tt(n,e,t){if(void 0===t&&(t=!0),!e)return n;for(var a,r,o,i=dn?Reflect.ownKeys(e):Object.keys(e),s=0;s<i.length;s++)"__ob__"!==(a=i[s])&&(r=n[a],o=e[a],t&&w(n,a)?r!==o&&u(r)&&u(o)&&Tt(r,o):Pn(n,a,o));return n}function Ct(n,e,t){return t?function(){var a=c(e)?e.call(t,t):e,r=c(n)?n.call(t,t):n;return a?Tt(a,r):r}:e?n?function(){return Tt(c(e)?e.call(this,this):e,c(n)?n.call(this,this):n)}:e:n}function jt(n,e){var t=e?n?n.concat(e):r(e)?e:[e]:n;return t?function(n){for(var e=[],t=0;t<n.length;t++)-1===e.indexOf(n[t])&&e.push(n[t]);return e}(t):t}function Et(n,e,t,a){var r=Object.create(n||null);return e?L(r,e):r}St.data=function(n,e,t){return t?Ct(n,e,t):e&&"function"!=typeof e?n:Ct(n,e)},F.forEach((function(n){St[n]=jt})),q.forEach((function(n){St[n+"s"]=Et})),St.watch=function(n,e,t,a){if(n===tn&&(n=void 0),e===tn&&(e=void 0),!e)return Object.create(n||null);if(!n)return e;var o={};for(var i in L(o,n),e){var s=o[i],l=e[i];s&&!r(s)&&(s=[s]),o[i]=s?s.concat(l):r(l)?l:[l]}return o},St.props=St.methods=St.inject=St.computed=function(n,e,t,a){if(!n)return e;var r=Object.create(null);return L(r,n),e&&L(r,e),r},St.provide=function(n,e){return n?function(){var t=Object.create(null);return Tt(t,c(n)?n.call(this):n),e&&Tt(t,c(e)?e.call(this):e,!1),t}:e};var At=function(n,e){return void 0===e?n:e};function It(n,e,t){if(c(e)&&(e=e.options),function(n,e){var t=n.props;if(t){var a,o,i={};if(r(t))for(a=t.length;a--;)"string"==typeof(o=t[a])&&(i[C(o)]={type:null});else if(u(t))for(var s in t)o=t[s],i[C(s)]=u(o)?o:{type:o};else 0;n.props=i}}(e),function(n,e){var t=n.inject;if(t){var a=n.inject={};if(r(t))for(var o=0;o<t.length;o++)a[t[o]]={from:t[o]};else if(u(t))for(var i in t){var s=t[i];a[i]=u(s)?L({from:i},s):{from:s}}else 0}}(e),function(n){var e=n.directives;if(e)for(var t in e){var a=e[t];c(a)&&(e[t]={bind:a,update:a})}}(e),!e._base&&(e.extends&&(n=It(n,e.extends,t)),e.mixins))for(var a=0,o=e.mixins.length;a<o;a++)n=It(n,e.mixins[a],t);var i,s={};for(i in n)l(i);for(i in e)w(n,i)||l(i);function l(a){var r=St[a]||At;s[a]=r(n[a],e[a],t,a)}return s}function _t(n,e,t,a){if("string"==typeof t){var r=n[e];if(w(r,t))return r[t];var o=C(t);if(w(r,o))return r[o];var i=j(o);return w(r,i)?r[i]:r[t]||r[o]||r[i]}}function Lt(n,e,t,a){var r=e[n],o=!w(t,n),i=t[n],s=Mt(Boolean,r.type);if(s>-1)if(o&&!w(r,"default"))i=!1;else if(""===i||i===A(n)){var l=Mt(String,r.type);(l<0||s<l)&&(i=!0)}if(void 0===i){i=function(n,e,t){if(!w(e,"default"))return;var a=e.default;0;if(n&&n.$options.propsData&&void 0===n.$options.propsData[t]&&void 0!==n._props[t])return n._props[t];return c(a)&&"Function"!==Pt(e.type)?a.call(n):a}(a,r,n);var d=En;An(!0),Ln(i),An(d)}return i}var zt=/^\s*function (\w+)/;function Pt(n){var e=n&&n.toString().match(zt);return e?e[1]:""}function Bt(n,e){return Pt(n)===Pt(e)}function Mt(n,e){if(!r(e))return Bt(e,n)?0:-1;for(var t=0,a=e.length;t<a;t++)if(Bt(e[t],n))return t;return-1}var Ot={enumerable:!0,configurable:!0,get:P,set:P};function Rt(n,e,t){Ot.get=function(){return this[e][t]},Ot.set=function(n){this[e][t]=n},Object.defineProperty(n,t,Ot)}function Dt(n){var e=n.$options;if(e.props&&function(n,e){var t=n.$options.propsData||{},a=n._props=On({}),r=n.$options._propKeys=[];n.$parent&&An(!1);var o=function(o){r.push(o);var i=Lt(o,e,t,n);zn(a,o,i),o in n||Rt(n,"_props",o)};for(var i in e)o(i);An(!0)}(n,e.props),function(n){var e=n.$options,t=e.setup;if(t){var a=n._setupContext=be(n);un(n),xn();var r=Ee(t,null,[n._props||On({}),a],n,"setup");if(wn(),un(),c(r))e.render=r;else if(d(r))if(n._setupState=r,r.__sfc){var o=n._setupProxy={};for(var i in r)"__sfc"!==i&&qn(o,r,i)}else for(var i in r)U(i)||qn(n,r,i);else 0}}(n),e.methods&&function(n,e){n.$options.props;for(var t in e)n[t]="function"!=typeof e[t]?P:I(e[t],n)}(n,e.methods),e.data)!function(n){var e=n.$options.data;u(e=n._data=c(e)?function(n,e){xn();try{return n.call(e,e)}catch(n){return je(n,e,"data()"),{}}finally{wn()}}(e,n):e||{})||(e={});var t=Object.keys(e),a=n.$options.props,r=(n.$options.methods,t.length);for(;r--;){var o=t[r];0,a&&w(a,o)||U(o)||Rt(n,"_data",o)}var i=Ln(e);i&&i.vmCount++}(n);else{var t=Ln(n._data={});t&&t.vmCount++}e.computed&&function(n,e){var t=n._computedWatchers=Object.create(null),a=on();for(var r in e){var o=e[r],i=c(o)?o:o.get;0,a||(t[r]=new He(n,i||P,P,Jt)),r in n||qt(n,r,o)}}(n,e.computed),e.watch&&e.watch!==tn&&function(n,e){for(var t in e){var a=e[t];if(r(a))for(var o=0;o<a.length;o++)Qt(n,t,a[o]);else Qt(n,t,a)}}(n,e.watch)}var Jt={lazy:!0};function qt(n,e,t){var a=!on();c(t)?(Ot.get=a?Ft(e):Nt(t),Ot.set=P):(Ot.get=t.get?a&&!1!==t.cache?Ft(e):Nt(t.get):P,Ot.set=t.set||P),Object.defineProperty(n,e,Ot)}function Ft(n){return function(){var e=this._computedWatchers&&this._computedWatchers[n];if(e)return e.dirty&&e.evaluate(),yn.target&&e.depend(),e.value}}function Nt(n){return function(){return n.call(this,this)}}function Qt(n,e,t,a){return u(t)&&(a=t,t=t.handler),"string"==typeof t&&(t=n[t]),n.$watch(e,t,a)}var Ut=0;function Ht(n){var e=n.options;if(n.super){var t=Ht(n.super);if(t!==n.superOptions){n.superOptions=t;var a=function(n){var e,t=n.options,a=n.sealedOptions;for(var r in t)t[r]!==a[r]&&(e||(e={}),e[r]=t[r]);return e}(n);a&&L(n.extendOptions,a),(e=n.options=It(t,n.extendOptions)).name&&(e.components[e.name]=n)}}return e}function $t(n){this._init(n)}function Gt(n){n.cid=0;var e=1;n.extend=function(n){n=n||{};var t=this,a=t.cid,r=n._Ctor||(n._Ctor={});if(r[a])return r[a];var o=vt(n)||vt(t.options);var i=function(n){this._init(n)};return(i.prototype=Object.create(t.prototype)).constructor=i,i.cid=e++,i.options=It(t.options,n),i.super=t,i.options.props&&function(n){var e=n.options.props;for(var t in e)Rt(n.prototype,"_props",t)}(i),i.options.computed&&function(n){var e=n.options.computed;for(var t in e)qt(n.prototype,t,e[t])}(i),i.extend=t.extend,i.mixin=t.mixin,i.use=t.use,q.forEach((function(n){i[n]=t[n]})),o&&(i.options.components[o]=i),i.superOptions=t.options,i.extendOptions=n,i.sealedOptions=L({},i.options),r[a]=i,i}}function Vt(n){return n&&(vt(n.Ctor.options)||n.tag)}function Xt(n,e){return r(n)?n.indexOf(e)>-1:"string"==typeof n?n.split(",").indexOf(e)>-1:!!h(n)&&n.test(e)}function Kt(n,e){var t=n.cache,a=n.keys,r=n._vnode;for(var o in t){var i=t[o];if(i){var s=i.name;s&&!e(s)&&Wt(t,o,a,r)}}}function Wt(n,e,t,a){var r=n[e];!r||a&&r.tag===a.tag||r.componentInstance.$destroy(),n[e]=null,k(t,e)}!function(n){n.prototype._init=function(n){var e=this;e._uid=Ut++,e._isVue=!0,e.__v_skip=!0,e._scope=new Nn(!0),e._scope._vm=!0,n&&n._isComponent?function(n,e){var t=n.$options=Object.create(n.constructor.options),a=e._parentVnode;t.parent=e.parent,t._parentVnode=a;var r=a.componentOptions;t.propsData=r.propsData,t._parentListeners=r.listeners,t._renderChildren=r.children,t._componentTag=r.tag,e.render&&(t.render=e.render,t.staticRenderFns=e.staticRenderFns)}(e,n):e.$options=It(Ht(e.constructor),n||{},e),e._renderProxy=e,e._self=e,function(n){var e=n.$options,t=e.parent;if(t&&!e.abstract){for(;t.$options.abstract&&t.$parent;)t=t.$parent;t.$children.push(n)}n.$parent=t,n.$root=t?t.$root:n,n.$children=[],n.$refs={},n._provided=t?t._provided:Object.create(null),n._watcher=null,n._inactive=null,n._directInactive=!1,n._isMounted=!1,n._isDestroyed=!1,n._isBeingDestroyed=!1}(e),function(n){n._events=Object.create(null),n._hasHookEvent=!1;var e=n.$options._parentListeners;e&&Xe(n,e)}(e),function(n){n._vnode=null,n._staticTrees=null;var e=n.$options,t=n.$vnode=e._parentVnode,r=t&&t.context;n.$slots=ue(e._renderChildren,r),n.$scopedSlots=t?fe(n.$parent,t.data.scopedSlots,n.$slots):a,n._c=function(e,t,a,r){return Ce(n,e,t,a,r,!1)},n.$createElement=function(e,t,a,r){return Ce(n,e,t,a,r,!0)};var o=t&&t.data;zn(n,"$attrs",o&&o.attrs||a,null,!0),zn(n,"$listeners",e._parentListeners||a,null,!0)}(e),nt(e,"beforeCreate",void 0,!1),function(n){var e=ht(n.$options.inject,n);e&&(An(!1),Object.keys(e).forEach((function(t){zn(n,t,e[t])})),An(!0))}(e),Dt(e),function(n){var e=n.$options.provide;if(e){var t=c(e)?e.call(n):e;if(!d(t))return;for(var a=Qn(n),r=dn?Reflect.ownKeys(t):Object.keys(t),o=0;o<r.length;o++){var i=r[o];Object.defineProperty(a,i,Object.getOwnPropertyDescriptor(t,i))}}}(e),nt(e,"created"),e.$options.el&&e.$mount(e.$options.el)}}($t),function(n){var e={get:function(){return this._data}},t={get:function(){return this._props}};Object.defineProperty(n.prototype,"$data",e),Object.defineProperty(n.prototype,"$props",t),n.prototype.$set=Pn,n.prototype.$delete=Bn,n.prototype.$watch=function(n,e,t){if(u(e))return Qt(this,n,e,t);(t=t||{}).user=!0;var a=new He(this,n,e,t);if(t.immediate){var r='callback for immediate watcher "'.concat(a.expression,'"');xn(),Ee(e,this,[a.value],this,r),wn()}return function(){a.teardown()}}}($t),function(n){var e=/^hook:/;n.prototype.$on=function(n,t){var a=this;if(r(n))for(var o=0,i=n.length;o<i;o++)a.$on(n[o],t);else(a._events[n]||(a._events[n]=[])).push(t),e.test(n)&&(a._hasHookEvent=!0);return a},n.prototype.$once=function(n,e){var t=this;function a(){t.$off(n,a),e.apply(t,arguments)}return a.fn=e,t.$on(n,a),t},n.prototype.$off=function(n,e){var t=this;if(!arguments.length)return t._events=Object.create(null),t;if(r(n)){for(var a=0,o=n.length;a<o;a++)t.$off(n[a],e);return t}var i,s=t._events[n];if(!s)return t;if(!e)return t._events[n]=null,t;for(var l=s.length;l--;)if((i=s[l])===e||i.fn===e){s.splice(l,1);break}return t},n.prototype.$emit=function(n){var e=this,t=e._events[n];if(t){t=t.length>1?_(t):t;for(var a=_(arguments,1),r='event handler for "'.concat(n,'"'),o=0,i=t.length;o<i;o++)Ee(t[o],e,a,e,r)}return e}}($t),function(n){n.prototype._update=function(n,e){var t=this,a=t.$el,r=t._vnode,o=We(t);t._vnode=n,t.$el=r?t.__patch__(r,n):t.__patch__(t.$el,n,e,!1),o(),a&&(a.__vue__=null),t.$el&&(t.$el.__vue__=t);for(var i=t;i&&i.$vnode&&i.$parent&&i.$vnode===i.$parent._vnode;)i.$parent.$el=i.$el,i=i.$parent},n.prototype.$forceUpdate=function(){this._watcher&&this._watcher.update()},n.prototype.$destroy=function(){var n=this;if(!n._isBeingDestroyed){nt(n,"beforeDestroy"),n._isBeingDestroyed=!0;var e=n.$parent;!e||e._isBeingDestroyed||n.$options.abstract||k(e.$children,n),n._scope.stop(),n._data.__ob__&&n._data.__ob__.vmCount--,n._isDestroyed=!0,n.__patch__(n._vnode,null),nt(n,"destroyed"),n.$off(),n.$el&&(n.$el.__vue__=null),n.$vnode&&(n.$vnode.parent=null)}}}($t),function(n){pe(n.prototype),n.prototype.$nextTick=function(n){return Je(n,this)},n.prototype._render=function(){var n,e=this,t=e.$options,a=t.render,o=t._parentVnode;o&&e._isMounted&&(e.$scopedSlots=fe(e.$parent,o.data.scopedSlots,e.$slots,e.$scopedSlots),e._slotsProxy&&xe(e._slotsProxy,e.$scopedSlots)),e.$vnode=o;try{un(e),we=e,n=a.call(e._renderProxy,e.$createElement)}catch(t){je(t,e,"render"),n=e._vnode}finally{we=null,un()}return r(n)&&1===n.length&&(n=n[0]),n instanceof hn||(n=mn()),n.parent=o,n}}($t);var Zt=[String,RegExp,Array],Yt={KeepAlive:{name:"keep-alive",abstract:!0,props:{include:Zt,exclude:Zt,max:[String,Number]},methods:{cacheVNode:function(){var n=this.cache,e=this.keys,t=this.vnodeToCache,a=this.keyToCache;if(t){var r=t.tag,o=t.componentInstance,i=t.componentOptions;n[a]={name:Vt(i),tag:r,componentInstance:o},e.push(a),this.max&&e.length>parseInt(this.max)&&Wt(n,e[0],e,this._vnode),this.vnodeToCache=null}}},created:function(){this.cache=Object.create(null),this.keys=[]},destroyed:function(){for(var n in this.cache)Wt(this.cache,n,this.keys)},mounted:function(){var n=this;this.cacheVNode(),this.$watch("include",(function(e){Kt(n,(function(n){return Xt(e,n)}))})),this.$watch("exclude",(function(e){Kt(n,(function(n){return!Xt(e,n)}))}))},updated:function(){this.cacheVNode()},render:function(){var n=this.$slots.default,e=Te(n),t=e&&e.componentOptions;if(t){var a=Vt(t),r=this.include,o=this.exclude;if(r&&(!a||!Xt(r,a))||o&&a&&Xt(o,a))return e;var i=this.cache,s=this.keys,l=null==e.key?t.Ctor.cid+(t.tag?"::".concat(t.tag):""):e.key;i[l]?(e.componentInstance=i[l].componentInstance,k(s,l),s.push(l)):(this.vnodeToCache=e,this.keyToCache=l),e.data.keepAlive=!0}return e||n&&n[0]}}};!function(n){var e={get:function(){return N}};Object.defineProperty(n,"config",e),n.util={warn:wt,extend:L,mergeOptions:It,defineReactive:zn},n.set=Pn,n.delete=Bn,n.nextTick=Je,n.observable=function(n){return Ln(n),n},n.options=Object.create(null),q.forEach((function(e){n.options[e+"s"]=Object.create(null)})),n.options._base=n,L(n.options.components,Yt),function(n){n.use=function(n){var e=this._installedPlugins||(this._installedPlugins=[]);if(e.indexOf(n)>-1)return this;var t=_(arguments,1);return t.unshift(this),c(n.install)?n.install.apply(n,t):c(n)&&n.apply(null,t),e.push(n),this}}(n),function(n){n.mixin=function(n){return this.options=It(this.options,n),this}}(n),Gt(n),function(n){q.forEach((function(e){n[e]=function(n,t){return t?("component"===e&&u(t)&&(t.name=t.name||n,t=this.options._base.extend(t)),"directive"===e&&c(t)&&(t={bind:t,update:t}),this.options[e+"s"][n]=t,t):this.options[e+"s"][n]}}))}(n)}($t),Object.defineProperty($t.prototype,"$isServer",{get:on}),Object.defineProperty($t.prototype,"$ssrContext",{get:function(){return this.$vnode&&this.$vnode.ssrContext}}),Object.defineProperty($t,"FunctionalRenderContext",{value:mt}),$t.version="2.7.14";var na=b("style,class"),ea=b("input,textarea,option,select,progress"),ta=b("contenteditable,draggable,spellcheck"),aa=b("events,caret,typing,plaintext-only"),ra=b("allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,default,defaultchecked,defaultmuted,defaultselected,defer,disabled,enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,required,reversed,scoped,seamless,selected,sortable,truespeed,typemustmatch,visible"),oa="http://www.w3.org/1999/xlink",ia=function(n){return":"===n.charAt(5)&&"xlink"===n.slice(0,5)},sa=function(n){return ia(n)?n.slice(6,n.length):""},la=function(n){return null==n||!1===n};function ca(n){for(var e=n.data,t=n,a=n;i(a.componentInstance);)(a=a.componentInstance._vnode)&&a.data&&(e=da(a.data,e));for(;i(t=t.parent);)t&&t.data&&(e=da(e,t.data));return function(n,e){if(i(n)||i(e))return pa(n,ua(e));return""}(e.staticClass,e.class)}function da(n,e){return{staticClass:pa(n.staticClass,e.staticClass),class:i(n.class)?[n.class,e.class]:e.class}}function pa(n,e){return n?e?n+" "+e:n:e||""}function ua(n){return Array.isArray(n)?function(n){for(var e,t="",a=0,r=n.length;a<r;a++)i(e=ua(n[a]))&&""!==e&&(t&&(t+=" "),t+=e);return t}(n):d(n)?function(n){var e="";for(var t in n)n[t]&&(e&&(e+=" "),e+=t);return e}(n):"string"==typeof n?n:""}var ha={svg:"http://www.w3.org/2000/svg",math:"http://www.w3.org/1998/Math/MathML"},ma=b("html,body,base,head,link,meta,style,title,address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,menuitem,summary,content,element,shadow,template,blockquote,iframe,tfoot"),fa=b("svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,foreignobject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view",!0),ga=function(n){return ma(n)||fa(n)};var va=Object.create(null);var ba=b("text,number,password,search,email,tel,url");var ya=Object.freeze({__proto__:null,createElement:function(n,e){var t=document.createElement(n);return"select"!==n||e.data&&e.data.attrs&&void 0!==e.data.attrs.multiple&&t.setAttribute("multiple","multiple"),t},createElementNS:function(n,e){return document.createElementNS(ha[n],e)},createTextNode:function(n){return document.createTextNode(n)},createComment:function(n){return document.createComment(n)},insertBefore:function(n,e,t){n.insertBefore(e,t)},removeChild:function(n,e){n.removeChild(e)},appendChild:function(n,e){n.appendChild(e)},parentNode:function(n){return n.parentNode},nextSibling:function(n){return n.nextSibling},tagName:function(n){return n.tagName},setTextContent:function(n,e){n.textContent=e},setStyleScope:function(n,e){n.setAttribute(e,"")}}),ka={create:function(n,e){xa(e)},update:function(n,e){n.data.ref!==e.data.ref&&(xa(n,!0),xa(e))},destroy:function(n){xa(n,!0)}};function xa(n,e){var t=n.data.ref;if(i(t)){var a=n.context,o=n.componentInstance||n.elm,s=e?null:o,l=e?void 0:o;if(c(t))Ee(t,a,[s],a,"template ref function");else{var d=n.data.refInFor,p="string"==typeof t||"number"==typeof t,u=Jn(t),h=a.$refs;if(p||u)if(d){var m=p?h[t]:t.value;e?r(m)&&k(m,o):r(m)?m.includes(o)||m.push(o):p?(h[t]=[o],wa(a,t,h[t])):t.value=[o]}else if(p){if(e&&h[t]!==o)return;h[t]=l,wa(a,t,s)}else if(u){if(e&&t.value!==o)return;t.value=s}else 0}}}function wa(n,e,t){var a=n._setupState;a&&w(a,e)&&(Jn(a[e])?a[e].value=t:a[e]=t)}var Sa=new hn("",{},[]),Ta=["create","activate","update","remove","destroy"];function Ca(n,e){return n.key===e.key&&n.asyncFactory===e.asyncFactory&&(n.tag===e.tag&&n.isComment===e.isComment&&i(n.data)===i(e.data)&&function(n,e){if("input"!==n.tag)return!0;var t,a=i(t=n.data)&&i(t=t.attrs)&&t.type,r=i(t=e.data)&&i(t=t.attrs)&&t.type;return a===r||ba(a)&&ba(r)}(n,e)||s(n.isAsyncPlaceholder)&&o(e.asyncFactory.error))}function ja(n,e,t){var a,r,o={};for(a=e;a<=t;++a)i(r=n[a].key)&&(o[r]=a);return o}var Ea={create:Aa,update:Aa,destroy:function(n){Aa(n,Sa)}};function Aa(n,e){(n.data.directives||e.data.directives)&&function(n,e){var t,a,r,o=n===Sa,i=e===Sa,s=_a(n.data.directives,n.context),l=_a(e.data.directives,e.context),c=[],d=[];for(t in l)a=s[t],r=l[t],a?(r.oldValue=a.value,r.oldArg=a.arg,za(r,"update",e,n),r.def&&r.def.componentUpdated&&d.push(r)):(za(r,"bind",e,n),r.def&&r.def.inserted&&c.push(r));if(c.length){var p=function(){for(var t=0;t<c.length;t++)za(c[t],"inserted",e,n)};o?Gn(e,"insert",p):p()}d.length&&Gn(e,"postpatch",(function(){for(var t=0;t<d.length;t++)za(d[t],"componentUpdated",e,n)}));if(!o)for(t in s)l[t]||za(s[t],"unbind",n,n,i)}(n,e)}var Ia=Object.create(null);function _a(n,e){var t,a,r=Object.create(null);if(!n)return r;for(t=0;t<n.length;t++){if((a=n[t]).modifiers||(a.modifiers=Ia),r[La(a)]=a,e._setupState&&e._setupState.__sfc){var o=a.def||_t(e,"_setupState","v-"+a.name);a.def="function"==typeof o?{bind:o,update:o}:o}a.def=a.def||_t(e.$options,"directives",a.name)}return r}function La(n){return n.rawName||"".concat(n.name,".").concat(Object.keys(n.modifiers||{}).join("."))}function za(n,e,t,a,r){var o=n.def&&n.def[e];if(o)try{o(t.elm,n,t,a,r)}catch(a){je(a,t.context,"directive ".concat(n.name," ").concat(e," hook"))}}var Pa=[ka,Ea];function Ba(n,e){var t=e.componentOptions;if(!(i(t)&&!1===t.Ctor.options.inheritAttrs||o(n.data.attrs)&&o(e.data.attrs))){var a,r,l=e.elm,c=n.data.attrs||{},d=e.data.attrs||{};for(a in(i(d.__ob__)||s(d._v_attr_proxy))&&(d=e.data.attrs=L({},d)),d)r=d[a],c[a]!==r&&Ma(l,a,r,e.data.pre);for(a in(K||Z)&&d.value!==c.value&&Ma(l,"value",d.value),c)o(d[a])&&(ia(a)?l.removeAttributeNS(oa,sa(a)):ta(a)||l.removeAttribute(a))}}function Ma(n,e,t,a){a||n.tagName.indexOf("-")>-1?Oa(n,e,t):ra(e)?la(t)?n.removeAttribute(e):(t="allowfullscreen"===e&&"EMBED"===n.tagName?"true":e,n.setAttribute(e,t)):ta(e)?n.setAttribute(e,function(n,e){return la(e)||"false"===e?"false":"contenteditable"===n&&aa(e)?e:"true"}(e,t)):ia(e)?la(t)?n.removeAttributeNS(oa,sa(e)):n.setAttributeNS(oa,e,t):Oa(n,e,t)}function Oa(n,e,t){if(la(t))n.removeAttribute(e);else{if(K&&!W&&"TEXTAREA"===n.tagName&&"placeholder"===e&&""!==t&&!n.__ieph){var a=function(e){e.stopImmediatePropagation(),n.removeEventListener("input",a)};n.addEventListener("input",a),n.__ieph=!0}n.setAttribute(e,t)}}var Ra={create:Ba,update:Ba};function Da(n,e){var t=e.elm,a=e.data,r=n.data;if(!(o(a.staticClass)&&o(a.class)&&(o(r)||o(r.staticClass)&&o(r.class)))){var s=ca(e),l=t._transitionClasses;i(l)&&(s=pa(s,ua(l))),s!==t._prevClass&&(t.setAttribute("class",s),t._prevClass=s)}}var Ja,qa={create:Da,update:Da};function Fa(n,e,t){var a=Ja;return function r(){var o=e.apply(null,arguments);null!==o&&Ua(n,r,t,a)}}var Na=Le&&!(en&&Number(en[1])<=53);function Qa(n,e,t,a){if(Na){var r=st,o=e;e=o._wrapper=function(n){if(n.target===n.currentTarget||n.timeStamp>=r||n.timeStamp<=0||n.target.ownerDocument!==document)return o.apply(this,arguments)}}Ja.addEventListener(n,e,an?{capture:t,passive:a}:t)}function Ua(n,e,t,a){(a||Ja).removeEventListener(n,e._wrapper||e,t)}function Ha(n,e){if(!o(n.data.on)||!o(e.data.on)){var t=e.data.on||{},a=n.data.on||{};Ja=e.elm||n.elm,function(n){if(i(n.__r)){var e=K?"change":"input";n[e]=[].concat(n.__r,n[e]||[]),delete n.__r}i(n.__c)&&(n.change=[].concat(n.__c,n.change||[]),delete n.__c)}(t),$n(t,a,Qa,Ua,Fa,e.context),Ja=void 0}}var $a,Ga={create:Ha,update:Ha,destroy:function(n){return Ha(n,Sa)}};function Va(n,e){if(!o(n.data.domProps)||!o(e.data.domProps)){var t,a,r=e.elm,l=n.data.domProps||{},c=e.data.domProps||{};for(t in(i(c.__ob__)||s(c._v_attr_proxy))&&(c=e.data.domProps=L({},c)),l)t in c||(r[t]="");for(t in c){if(a=c[t],"textContent"===t||"innerHTML"===t){if(e.children&&(e.children.length=0),a===l[t])continue;1===r.childNodes.length&&r.removeChild(r.childNodes[0])}if("value"===t&&"PROGRESS"!==r.tagName){r._value=a;var d=o(a)?"":String(a);Xa(r,d)&&(r.value=d)}else if("innerHTML"===t&&fa(r.tagName)&&o(r.innerHTML)){($a=$a||document.createElement("div")).innerHTML="<svg>".concat(a,"</svg>");for(var p=$a.firstChild;r.firstChild;)r.removeChild(r.firstChild);for(;p.firstChild;)r.appendChild(p.firstChild)}else if(a!==l[t])try{r[t]=a}catch(n){}}}}function Xa(n,e){return!n.composing&&("OPTION"===n.tagName||function(n,e){var t=!0;try{t=document.activeElement!==n}catch(n){}return t&&n.value!==e}(n,e)||function(n,e){var t=n.value,a=n._vModifiers;if(i(a)){if(a.number)return v(t)!==v(e);if(a.trim)return t.trim()!==e.trim()}return t!==e}(n,e))}var Ka={create:Va,update:Va},Wa=S((function(n){var e={},t=/:(.+)/;return n.split(/;(?![^(]*\))/g).forEach((function(n){if(n){var a=n.split(t);a.length>1&&(e[a[0].trim()]=a[1].trim())}})),e}));function Za(n){var e=Ya(n.style);return n.staticStyle?L(n.staticStyle,e):e}function Ya(n){return Array.isArray(n)?z(n):"string"==typeof n?Wa(n):n}var nr,er=/^--/,tr=/\s*!important$/,ar=function(n,e,t){if(er.test(e))n.style.setProperty(e,t);else if(tr.test(t))n.style.setProperty(A(e),t.replace(tr,""),"important");else{var a=or(e);if(Array.isArray(t))for(var r=0,o=t.length;r<o;r++)n.style[a]=t[r];else n.style[a]=t}},rr=["Webkit","Moz","ms"],or=S((function(n){if(nr=nr||document.createElement("div").style,"filter"!==(n=C(n))&&n in nr)return n;for(var e=n.charAt(0).toUpperCase()+n.slice(1),t=0;t<rr.length;t++){var a=rr[t]+e;if(a in nr)return a}}));function ir(n,e){var t=e.data,a=n.data;if(!(o(t.staticStyle)&&o(t.style)&&o(a.staticStyle)&&o(a.style))){var r,s,l=e.elm,c=a.staticStyle,d=a.normalizedStyle||a.style||{},p=c||d,u=Ya(e.data.style)||{};e.data.normalizedStyle=i(u.__ob__)?L({},u):u;var h=function(n,e){var t,a={};if(e)for(var r=n;r.componentInstance;)(r=r.componentInstance._vnode)&&r.data&&(t=Za(r.data))&&L(a,t);(t=Za(n.data))&&L(a,t);for(var o=n;o=o.parent;)o.data&&(t=Za(o.data))&&L(a,t);return a}(e,!0);for(s in p)o(h[s])&&ar(l,s,"");for(s in h)(r=h[s])!==p[s]&&ar(l,s,null==r?"":r)}}var sr={create:ir,update:ir},lr=/\s+/;function cr(n,e){if(e&&(e=e.trim()))if(n.classList)e.indexOf(" ")>-1?e.split(lr).forEach((function(e){return n.classList.add(e)})):n.classList.add(e);else{var t=" ".concat(n.getAttribute("class")||""," ");t.indexOf(" "+e+" ")<0&&n.setAttribute("class",(t+e).trim())}}function dr(n,e){if(e&&(e=e.trim()))if(n.classList)e.indexOf(" ")>-1?e.split(lr).forEach((function(e){return n.classList.remove(e)})):n.classList.remove(e),n.classList.length||n.removeAttribute("class");else{for(var t=" ".concat(n.getAttribute("class")||""," "),a=" "+e+" ";t.indexOf(a)>=0;)t=t.replace(a," ");(t=t.trim())?n.setAttribute("class",t):n.removeAttribute("class")}}function pr(n){if(n){if("object"==typeof n){var e={};return!1!==n.css&&L(e,ur(n.name||"v")),L(e,n),e}return"string"==typeof n?ur(n):void 0}}var ur=S((function(n){return{enterClass:"".concat(n,"-enter"),enterToClass:"".concat(n,"-enter-to"),enterActiveClass:"".concat(n,"-enter-active"),leaveClass:"".concat(n,"-leave"),leaveToClass:"".concat(n,"-leave-to"),leaveActiveClass:"".concat(n,"-leave-active")}})),hr=V&&!W,mr="transition",fr="transitionend",gr="animation",vr="animationend";hr&&(void 0===window.ontransitionend&&void 0!==window.onwebkittransitionend&&(mr="WebkitTransition",fr="webkitTransitionEnd"),void 0===window.onanimationend&&void 0!==window.onwebkitanimationend&&(gr="WebkitAnimation",vr="webkitAnimationEnd"));var br=V?window.requestAnimationFrame?window.requestAnimationFrame.bind(window):setTimeout:function(n){return n()};function yr(n){br((function(){br(n)}))}function kr(n,e){var t=n._transitionClasses||(n._transitionClasses=[]);t.indexOf(e)<0&&(t.push(e),cr(n,e))}function xr(n,e){n._transitionClasses&&k(n._transitionClasses,e),dr(n,e)}function wr(n,e,t){var a=Tr(n,e),r=a.type,o=a.timeout,i=a.propCount;if(!r)return t();var s="transition"===r?fr:vr,l=0,c=function(){n.removeEventListener(s,d),t()},d=function(e){e.target===n&&++l>=i&&c()};setTimeout((function(){l<i&&c()}),o+1),n.addEventListener(s,d)}var Sr=/\b(transform|all)(,|$)/;function Tr(n,e){var t,a=window.getComputedStyle(n),r=(a[mr+"Delay"]||"").split(", "),o=(a[mr+"Duration"]||"").split(", "),i=Cr(r,o),s=(a[gr+"Delay"]||"").split(", "),l=(a[gr+"Duration"]||"").split(", "),c=Cr(s,l),d=0,p=0;return"transition"===e?i>0&&(t="transition",d=i,p=o.length):"animation"===e?c>0&&(t="animation",d=c,p=l.length):p=(t=(d=Math.max(i,c))>0?i>c?"transition":"animation":null)?"transition"===t?o.length:l.length:0,{type:t,timeout:d,propCount:p,hasTransform:"transition"===t&&Sr.test(a[mr+"Property"])}}function Cr(n,e){for(;n.length<e.length;)n=n.concat(n);return Math.max.apply(null,e.map((function(e,t){return jr(e)+jr(n[t])})))}function jr(n){return 1e3*Number(n.slice(0,-1).replace(",","."))}function Er(n,e){var t=n.elm;i(t._leaveCb)&&(t._leaveCb.cancelled=!0,t._leaveCb());var a=pr(n.data.transition);if(!o(a)&&!i(t._enterCb)&&1===t.nodeType){for(var r=a.css,s=a.type,l=a.enterClass,p=a.enterToClass,u=a.enterActiveClass,h=a.appearClass,m=a.appearToClass,f=a.appearActiveClass,g=a.beforeEnter,b=a.enter,y=a.afterEnter,k=a.enterCancelled,x=a.beforeAppear,w=a.appear,S=a.afterAppear,T=a.appearCancelled,C=a.duration,j=Ke,E=Ke.$vnode;E&&E.parent;)j=E.context,E=E.parent;var A=!j._isMounted||!n.isRootInsert;if(!A||w||""===w){var I=A&&h?h:l,_=A&&f?f:u,L=A&&m?m:p,z=A&&x||g,P=A&&c(w)?w:b,B=A&&S||y,M=A&&T||k,O=v(d(C)?C.enter:C);0;var R=!1!==r&&!W,J=_r(P),q=t._enterCb=D((function(){R&&(xr(t,L),xr(t,_)),q.cancelled?(R&&xr(t,I),M&&M(t)):B&&B(t),t._enterCb=null}));n.data.show||Gn(n,"insert",(function(){var e=t.parentNode,a=e&&e._pending&&e._pending[n.key];a&&a.tag===n.tag&&a.elm._leaveCb&&a.elm._leaveCb(),P&&P(t,q)})),z&&z(t),R&&(kr(t,I),kr(t,_),yr((function(){xr(t,I),q.cancelled||(kr(t,L),J||(Ir(O)?setTimeout(q,O):wr(t,s,q)))}))),n.data.show&&(e&&e(),P&&P(t,q)),R||J||q()}}}function Ar(n,e){var t=n.elm;i(t._enterCb)&&(t._enterCb.cancelled=!0,t._enterCb());var a=pr(n.data.transition);if(o(a)||1!==t.nodeType)return e();if(!i(t._leaveCb)){var r=a.css,s=a.type,l=a.leaveClass,c=a.leaveToClass,p=a.leaveActiveClass,u=a.beforeLeave,h=a.leave,m=a.afterLeave,f=a.leaveCancelled,g=a.delayLeave,b=a.duration,y=!1!==r&&!W,k=_r(h),x=v(d(b)?b.leave:b);0;var w=t._leaveCb=D((function(){t.parentNode&&t.parentNode._pending&&(t.parentNode._pending[n.key]=null),y&&(xr(t,c),xr(t,p)),w.cancelled?(y&&xr(t,l),f&&f(t)):(e(),m&&m(t)),t._leaveCb=null}));g?g(S):S()}function S(){w.cancelled||(!n.data.show&&t.parentNode&&((t.parentNode._pending||(t.parentNode._pending={}))[n.key]=n),u&&u(t),y&&(kr(t,l),kr(t,p),yr((function(){xr(t,l),w.cancelled||(kr(t,c),k||(Ir(x)?setTimeout(w,x):wr(t,s,w)))}))),h&&h(t,w),y||k||w())}}function Ir(n){return"number"==typeof n&&!isNaN(n)}function _r(n){if(o(n))return!1;var e=n.fns;return i(e)?_r(Array.isArray(e)?e[0]:e):(n._length||n.length)>1}function Lr(n,e){!0!==e.data.show&&Er(e)}var zr=function(n){var e,t,a={},c=n.modules,d=n.nodeOps;for(e=0;e<Ta.length;++e)for(a[Ta[e]]=[],t=0;t<c.length;++t)i(c[t][Ta[e]])&&a[Ta[e]].push(c[t][Ta[e]]);function p(n){var e=d.parentNode(n);i(e)&&d.removeChild(e,n)}function u(n,e,t,r,o,l,c){if(i(n.elm)&&i(l)&&(n=l[c]=gn(n)),n.isRootInsert=!o,!function(n,e,t,r){var o=n.data;if(i(o)){var l=i(n.componentInstance)&&o.keepAlive;if(i(o=o.hook)&&i(o=o.init)&&o(n,!1),i(n.componentInstance))return h(n,e),m(t,n.elm,r),s(l)&&function(n,e,t,r){var o,s=n;for(;s.componentInstance;)if(s=s.componentInstance._vnode,i(o=s.data)&&i(o=o.transition)){for(o=0;o<a.activate.length;++o)a.activate[o](Sa,s);e.push(s);break}m(t,n.elm,r)}(n,e,t,r),!0}}(n,e,t,r)){var p=n.data,u=n.children,g=n.tag;i(g)?(n.elm=n.ns?d.createElementNS(n.ns,g):d.createElement(g,n),y(n),f(n,u,e),i(p)&&v(n,e),m(t,n.elm,r)):s(n.isComment)?(n.elm=d.createComment(n.text),m(t,n.elm,r)):(n.elm=d.createTextNode(n.text),m(t,n.elm,r))}}function h(n,e){i(n.data.pendingInsert)&&(e.push.apply(e,n.data.pendingInsert),n.data.pendingInsert=null),n.elm=n.componentInstance.$el,g(n)?(v(n,e),y(n)):(xa(n),e.push(n))}function m(n,e,t){i(n)&&(i(t)?d.parentNode(t)===n&&d.insertBefore(n,e,t):d.appendChild(n,e))}function f(n,e,t){if(r(e)){0;for(var a=0;a<e.length;++a)u(e[a],t,n.elm,null,!0,e,a)}else l(n.text)&&d.appendChild(n.elm,d.createTextNode(String(n.text)))}function g(n){for(;n.componentInstance;)n=n.componentInstance._vnode;return i(n.tag)}function v(n,t){for(var r=0;r<a.create.length;++r)a.create[r](Sa,n);i(e=n.data.hook)&&(i(e.create)&&e.create(Sa,n),i(e.insert)&&t.push(n))}function y(n){var e;if(i(e=n.fnScopeId))d.setStyleScope(n.elm,e);else for(var t=n;t;)i(e=t.context)&&i(e=e.$options._scopeId)&&d.setStyleScope(n.elm,e),t=t.parent;i(e=Ke)&&e!==n.context&&e!==n.fnContext&&i(e=e.$options._scopeId)&&d.setStyleScope(n.elm,e)}function k(n,e,t,a,r,o){for(;a<=r;++a)u(t[a],o,n,e,!1,t,a)}function x(n){var e,t,r=n.data;if(i(r))for(i(e=r.hook)&&i(e=e.destroy)&&e(n),e=0;e<a.destroy.length;++e)a.destroy[e](n);if(i(e=n.children))for(t=0;t<n.children.length;++t)x(n.children[t])}function w(n,e,t){for(;e<=t;++e){var a=n[e];i(a)&&(i(a.tag)?(S(a),x(a)):p(a.elm))}}function S(n,e){if(i(e)||i(n.data)){var t,r=a.remove.length+1;for(i(e)?e.listeners+=r:e=function(n,e){function t(){0==--t.listeners&&p(n)}return t.listeners=e,t}(n.elm,r),i(t=n.componentInstance)&&i(t=t._vnode)&&i(t.data)&&S(t,e),t=0;t<a.remove.length;++t)a.remove[t](n,e);i(t=n.data.hook)&&i(t=t.remove)?t(n,e):e()}else p(n.elm)}function T(n,e,t,a){for(var r=t;r<a;r++){var o=e[r];if(i(o)&&Ca(n,o))return r}}function C(n,e,t,r,l,c){if(n!==e){i(e.elm)&&i(r)&&(e=r[l]=gn(e));var p=e.elm=n.elm;if(s(n.isAsyncPlaceholder))i(e.asyncFactory.resolved)?A(n.elm,e,t):e.isAsyncPlaceholder=!0;else if(s(e.isStatic)&&s(n.isStatic)&&e.key===n.key&&(s(e.isCloned)||s(e.isOnce)))e.componentInstance=n.componentInstance;else{var h,m=e.data;i(m)&&i(h=m.hook)&&i(h=h.prepatch)&&h(n,e);var f=n.children,v=e.children;if(i(m)&&g(e)){for(h=0;h<a.update.length;++h)a.update[h](n,e);i(h=m.hook)&&i(h=h.update)&&h(n,e)}o(e.text)?i(f)&&i(v)?f!==v&&function(n,e,t,a,r){var s,l,c,p=0,h=0,m=e.length-1,f=e[0],g=e[m],v=t.length-1,b=t[0],y=t[v],x=!r;for(0;p<=m&&h<=v;)o(f)?f=e[++p]:o(g)?g=e[--m]:Ca(f,b)?(C(f,b,a,t,h),f=e[++p],b=t[++h]):Ca(g,y)?(C(g,y,a,t,v),g=e[--m],y=t[--v]):Ca(f,y)?(C(f,y,a,t,v),x&&d.insertBefore(n,f.elm,d.nextSibling(g.elm)),f=e[++p],y=t[--v]):Ca(g,b)?(C(g,b,a,t,h),x&&d.insertBefore(n,g.elm,f.elm),g=e[--m],b=t[++h]):(o(s)&&(s=ja(e,p,m)),o(l=i(b.key)?s[b.key]:T(b,e,p,m))?u(b,a,n,f.elm,!1,t,h):Ca(c=e[l],b)?(C(c,b,a,t,h),e[l]=void 0,x&&d.insertBefore(n,c.elm,f.elm)):u(b,a,n,f.elm,!1,t,h),b=t[++h]);p>m?k(n,o(t[v+1])?null:t[v+1].elm,t,h,v,a):h>v&&w(e,p,m)}(p,f,v,t,c):i(v)?(i(n.text)&&d.setTextContent(p,""),k(p,null,v,0,v.length-1,t)):i(f)?w(f,0,f.length-1):i(n.text)&&d.setTextContent(p,""):n.text!==e.text&&d.setTextContent(p,e.text),i(m)&&i(h=m.hook)&&i(h=h.postpatch)&&h(n,e)}}}function j(n,e,t){if(s(t)&&i(n.parent))n.parent.data.pendingInsert=e;else for(var a=0;a<e.length;++a)e[a].data.hook.insert(e[a])}var E=b("attrs,class,staticClass,staticStyle,key");function A(n,e,t,a){var r,o=e.tag,l=e.data,c=e.children;if(a=a||l&&l.pre,e.elm=n,s(e.isComment)&&i(e.asyncFactory))return e.isAsyncPlaceholder=!0,!0;if(i(l)&&(i(r=l.hook)&&i(r=r.init)&&r(e,!0),i(r=e.componentInstance)))return h(e,t),!0;if(i(o)){if(i(c))if(n.hasChildNodes())if(i(r=l)&&i(r=r.domProps)&&i(r=r.innerHTML)){if(r!==n.innerHTML)return!1}else{for(var d=!0,p=n.firstChild,u=0;u<c.length;u++){if(!p||!A(p,c[u],t,a)){d=!1;break}p=p.nextSibling}if(!d||p)return!1}else f(e,c,t);if(i(l)){var m=!1;for(var g in l)if(!E(g)){m=!0,v(e,t);break}!m&&l.class&&Ne(l.class)}}else n.data!==e.text&&(n.data=e.text);return!0}return function(n,e,t,r){if(!o(e)){var l,c=!1,p=[];if(o(n))c=!0,u(e,p);else{var h=i(n.nodeType);if(!h&&Ca(n,e))C(n,e,p,null,null,r);else{if(h){if(1===n.nodeType&&n.hasAttribute("data-server-rendered")&&(n.removeAttribute("data-server-rendered"),t=!0),s(t)&&A(n,e,p))return j(e,p,!0),n;l=n,n=new hn(d.tagName(l).toLowerCase(),{},[],void 0,l)}var m=n.elm,f=d.parentNode(m);if(u(e,p,m._leaveCb?null:f,d.nextSibling(m)),i(e.parent))for(var v=e.parent,b=g(e);v;){for(var y=0;y<a.destroy.length;++y)a.destroy[y](v);if(v.elm=e.elm,b){for(var k=0;k<a.create.length;++k)a.create[k](Sa,v);var S=v.data.hook.insert;if(S.merged)for(var T=1;T<S.fns.length;T++)S.fns[T]()}else xa(v);v=v.parent}i(f)?w([n],0,0):i(n.tag)&&x(n)}}return j(e,p,c),e.elm}i(n)&&x(n)}}({nodeOps:ya,modules:[Ra,qa,Ga,Ka,sr,V?{create:Lr,activate:Lr,remove:function(n,e){!0!==n.data.show?Ar(n,e):e()}}:{}].concat(Pa)});W&&document.addEventListener("selectionchange",(function(){var n=document.activeElement;n&&n.vmodel&&qr(n,"input")}));var Pr={inserted:function(n,e,t,a){"select"===t.tag?(a.elm&&!a.elm._vOptions?Gn(t,"postpatch",(function(){Pr.componentUpdated(n,e,t)})):Br(n,e,t.context),n._vOptions=[].map.call(n.options,Rr)):("textarea"===t.tag||ba(n.type))&&(n._vModifiers=e.modifiers,e.modifiers.lazy||(n.addEventListener("compositionstart",Dr),n.addEventListener("compositionend",Jr),n.addEventListener("change",Jr),W&&(n.vmodel=!0)))},componentUpdated:function(n,e,t){if("select"===t.tag){Br(n,e,t.context);var a=n._vOptions,r=n._vOptions=[].map.call(n.options,Rr);if(r.some((function(n,e){return!O(n,a[e])})))(n.multiple?e.value.some((function(n){return Or(n,r)})):e.value!==e.oldValue&&Or(e.value,r))&&qr(n,"change")}}};function Br(n,e,t){Mr(n,e,t),(K||Z)&&setTimeout((function(){Mr(n,e,t)}),0)}function Mr(n,e,t){var a=e.value,r=n.multiple;if(!r||Array.isArray(a)){for(var o,i,s=0,l=n.options.length;s<l;s++)if(i=n.options[s],r)o=R(a,Rr(i))>-1,i.selected!==o&&(i.selected=o);else if(O(Rr(i),a))return void(n.selectedIndex!==s&&(n.selectedIndex=s));r||(n.selectedIndex=-1)}}function Or(n,e){return e.every((function(e){return!O(e,n)}))}function Rr(n){return"_value"in n?n._value:n.value}function Dr(n){n.target.composing=!0}function Jr(n){n.target.composing&&(n.target.composing=!1,qr(n.target,"input"))}function qr(n,e){var t=document.createEvent("HTMLEvents");t.initEvent(e,!0,!0),n.dispatchEvent(t)}function Fr(n){return!n.componentInstance||n.data&&n.data.transition?n:Fr(n.componentInstance._vnode)}var Nr={model:Pr,show:{bind:function(n,e,t){var a=e.value,r=(t=Fr(t)).data&&t.data.transition,o=n.__vOriginalDisplay="none"===n.style.display?"":n.style.display;a&&r?(t.data.show=!0,Er(t,(function(){n.style.display=o}))):n.style.display=a?o:"none"},update:function(n,e,t){var a=e.value;!a!=!e.oldValue&&((t=Fr(t)).data&&t.data.transition?(t.data.show=!0,a?Er(t,(function(){n.style.display=n.__vOriginalDisplay})):Ar(t,(function(){n.style.display="none"}))):n.style.display=a?n.__vOriginalDisplay:"none")},unbind:function(n,e,t,a,r){r||(n.style.display=n.__vOriginalDisplay)}}},Qr={name:String,appear:Boolean,css:Boolean,mode:String,type:String,enterClass:String,leaveClass:String,enterToClass:String,leaveToClass:String,enterActiveClass:String,leaveActiveClass:String,appearClass:String,appearActiveClass:String,appearToClass:String,duration:[Number,String,Object]};function Ur(n){var e=n&&n.componentOptions;return e&&e.Ctor.options.abstract?Ur(Te(e.children)):n}function Hr(n){var e={},t=n.$options;for(var a in t.propsData)e[a]=n[a];var r=t._parentListeners;for(var a in r)e[C(a)]=r[a];return e}function $r(n,e){if(/\d-keep-alive$/.test(e.tag))return n("keep-alive",{props:e.componentOptions.propsData})}var Gr=function(n){return n.tag||me(n)},Vr=function(n){return"show"===n.name},Xr={name:"transition",props:Qr,abstract:!0,render:function(n){var e=this,t=this.$slots.default;if(t&&(t=t.filter(Gr)).length){0;var a=this.mode;0;var r=t[0];if(function(n){for(;n=n.parent;)if(n.data.transition)return!0}(this.$vnode))return r;var o=Ur(r);if(!o)return r;if(this._leaving)return $r(n,r);var i="__transition-".concat(this._uid,"-");o.key=null==o.key?o.isComment?i+"comment":i+o.tag:l(o.key)?0===String(o.key).indexOf(i)?o.key:i+o.key:o.key;var s=(o.data||(o.data={})).transition=Hr(this),c=this._vnode,d=Ur(c);if(o.data.directives&&o.data.directives.some(Vr)&&(o.data.show=!0),d&&d.data&&!function(n,e){return e.key===n.key&&e.tag===n.tag}(o,d)&&!me(d)&&(!d.componentInstance||!d.componentInstance._vnode.isComment)){var p=d.data.transition=L({},s);if("out-in"===a)return this._leaving=!0,Gn(p,"afterLeave",(function(){e._leaving=!1,e.$forceUpdate()})),$r(n,r);if("in-out"===a){if(me(o))return c;var u,h=function(){u()};Gn(s,"afterEnter",h),Gn(s,"enterCancelled",h),Gn(p,"delayLeave",(function(n){u=n}))}}return r}}},Kr=L({tag:String,moveClass:String},Qr);function Wr(n){n.elm._moveCb&&n.elm._moveCb(),n.elm._enterCb&&n.elm._enterCb()}function Zr(n){n.data.newPos=n.elm.getBoundingClientRect()}function Yr(n){var e=n.data.pos,t=n.data.newPos,a=e.left-t.left,r=e.top-t.top;if(a||r){n.data.moved=!0;var o=n.elm.style;o.transform=o.WebkitTransform="translate(".concat(a,"px,").concat(r,"px)"),o.transitionDuration="0s"}}delete Kr.mode;var no={Transition:Xr,TransitionGroup:{props:Kr,beforeMount:function(){var n=this,e=this._update;this._update=function(t,a){var r=We(n);n.__patch__(n._vnode,n.kept,!1,!0),n._vnode=n.kept,r(),e.call(n,t,a)}},render:function(n){for(var e=this.tag||this.$vnode.data.tag||"span",t=Object.create(null),a=this.prevChildren=this.children,r=this.$slots.default||[],o=this.children=[],i=Hr(this),s=0;s<r.length;s++){if((d=r[s]).tag)if(null!=d.key&&0!==String(d.key).indexOf("__vlist"))o.push(d),t[d.key]=d,(d.data||(d.data={})).transition=i;else;}if(a){var l=[],c=[];for(s=0;s<a.length;s++){var d;(d=a[s]).data.transition=i,d.data.pos=d.elm.getBoundingClientRect(),t[d.key]?l.push(d):c.push(d)}this.kept=n(e,null,l),this.removed=c}return n(e,null,o)},updated:function(){var n=this.prevChildren,e=this.moveClass||(this.name||"v")+"-move";n.length&&this.hasMove(n[0].elm,e)&&(n.forEach(Wr),n.forEach(Zr),n.forEach(Yr),this._reflow=document.body.offsetHeight,n.forEach((function(n){if(n.data.moved){var t=n.elm,a=t.style;kr(t,e),a.transform=a.WebkitTransform=a.transitionDuration="",t.addEventListener(fr,t._moveCb=function n(a){a&&a.target!==t||a&&!/transform$/.test(a.propertyName)||(t.removeEventListener(fr,n),t._moveCb=null,xr(t,e))})}})))},methods:{hasMove:function(n,e){if(!hr)return!1;if(this._hasMove)return this._hasMove;var t=n.cloneNode();n._transitionClasses&&n._transitionClasses.forEach((function(n){dr(t,n)})),cr(t,e),t.style.display="none",this.$el.appendChild(t);var a=Tr(t);return this.$el.removeChild(t),this._hasMove=a.hasTransform}}}};function eo(n,e){for(var t in e)n[t]=e[t];return n}$t.config.mustUseProp=function(n,e,t){return"value"===t&&ea(n)&&"button"!==e||"selected"===t&&"option"===n||"checked"===t&&"input"===n||"muted"===t&&"video"===n},$t.config.isReservedTag=ga,$t.config.isReservedAttr=na,$t.config.getTagNamespace=function(n){return fa(n)?"svg":"math"===n?"math":void 0},$t.config.isUnknownElement=function(n){if(!V)return!0;if(ga(n))return!1;if(n=n.toLowerCase(),null!=va[n])return va[n];var e=document.createElement(n);return n.indexOf("-")>-1?va[n]=e.constructor===window.HTMLUnknownElement||e.constructor===window.HTMLElement:va[n]=/HTMLUnknownElement/.test(e.toString())},L($t.options.directives,Nr),L($t.options.components,no),$t.prototype.__patch__=V?zr:P,$t.prototype.$mount=function(n,e){return function(n,e,t){var a;n.$el=e,n.$options.render||(n.$options.render=mn),nt(n,"beforeMount"),a=function(){n._update(n._render(),t)},new He(n,a,P,{before:function(){n._isMounted&&!n._isDestroyed&&nt(n,"beforeUpdate")}},!0),t=!1;var r=n._preWatchers;if(r)for(var o=0;o<r.length;o++)r[o].run();return null==n.$vnode&&(n._isMounted=!0,nt(n,"mounted")),n}(this,n=n&&V?function(n){if("string"==typeof n){var e=document.querySelector(n);return e||document.createElement("div")}return n}(n):void 0,e)},V&&setTimeout((function(){N.devtools&&sn&&sn.emit("init",$t)}),0);var to=/[!'()*]/g,ao=function(n){return"%"+n.charCodeAt(0).toString(16)},ro=/%2C/g,oo=function(n){return encodeURIComponent(n).replace(to,ao).replace(ro,",")};function io(n){try{return decodeURIComponent(n)}catch(n){0}return n}var so=function(n){return null==n||"object"==typeof n?n:String(n)};function lo(n){var e={};return(n=n.trim().replace(/^(\?|#|&)/,""))?(n.split("&").forEach((function(n){var t=n.replace(/\+/g," ").split("="),a=io(t.shift()),r=t.length>0?io(t.join("=")):null;void 0===e[a]?e[a]=r:Array.isArray(e[a])?e[a].push(r):e[a]=[e[a],r]})),e):e}function co(n){var e=n?Object.keys(n).map((function(e){var t=n[e];if(void 0===t)return"";if(null===t)return oo(e);if(Array.isArray(t)){var a=[];return t.forEach((function(n){void 0!==n&&(null===n?a.push(oo(e)):a.push(oo(e)+"="+oo(n)))})),a.join("&")}return oo(e)+"="+oo(t)})).filter((function(n){return n.length>0})).join("&"):null;return e?"?"+e:""}var po=/\/?$/;function uo(n,e,t,a){var r=a&&a.options.stringifyQuery,o=e.query||{};try{o=ho(o)}catch(n){}var i={name:e.name||n&&n.name,meta:n&&n.meta||{},path:e.path||"/",hash:e.hash||"",query:o,params:e.params||{},fullPath:go(e,r),matched:n?fo(n):[]};return t&&(i.redirectedFrom=go(t,r)),Object.freeze(i)}function ho(n){if(Array.isArray(n))return n.map(ho);if(n&&"object"==typeof n){var e={};for(var t in n)e[t]=ho(n[t]);return e}return n}var mo=uo(null,{path:"/"});function fo(n){for(var e=[];n;)e.unshift(n),n=n.parent;return e}function go(n,e){var t=n.path,a=n.query;void 0===a&&(a={});var r=n.hash;return void 0===r&&(r=""),(t||"/")+(e||co)(a)+r}function vo(n,e,t){return e===mo?n===e:!!e&&(n.path&&e.path?n.path.replace(po,"")===e.path.replace(po,"")&&(t||n.hash===e.hash&&bo(n.query,e.query)):!(!n.name||!e.name)&&(n.name===e.name&&(t||n.hash===e.hash&&bo(n.query,e.query)&&bo(n.params,e.params))))}function bo(n,e){if(void 0===n&&(n={}),void 0===e&&(e={}),!n||!e)return n===e;var t=Object.keys(n).sort(),a=Object.keys(e).sort();return t.length===a.length&&t.every((function(t,r){var o=n[t];if(a[r]!==t)return!1;var i=e[t];return null==o||null==i?o===i:"object"==typeof o&&"object"==typeof i?bo(o,i):String(o)===String(i)}))}function yo(n){for(var e=0;e<n.matched.length;e++){var t=n.matched[e];for(var a in t.instances){var r=t.instances[a],o=t.enteredCbs[a];if(r&&o){delete t.enteredCbs[a];for(var i=0;i<o.length;i++)r._isBeingDestroyed||o[i](r)}}}}var ko={name:"RouterView",functional:!0,props:{name:{type:String,default:"default"}},render:function(n,e){var t=e.props,a=e.children,r=e.parent,o=e.data;o.routerView=!0;for(var i=r.$createElement,s=t.name,l=r.$route,c=r._routerViewCache||(r._routerViewCache={}),d=0,p=!1;r&&r._routerRoot!==r;){var u=r.$vnode?r.$vnode.data:{};u.routerView&&d++,u.keepAlive&&r._directInactive&&r._inactive&&(p=!0),r=r.$parent}if(o.routerViewDepth=d,p){var h=c[s],m=h&&h.component;return m?(h.configProps&&xo(m,o,h.route,h.configProps),i(m,o,a)):i()}var f=l.matched[d],g=f&&f.components[s];if(!f||!g)return c[s]=null,i();c[s]={component:g},o.registerRouteInstance=function(n,e){var t=f.instances[s];(e&&t!==n||!e&&t===n)&&(f.instances[s]=e)},(o.hook||(o.hook={})).prepatch=function(n,e){f.instances[s]=e.componentInstance},o.hook.init=function(n){n.data.keepAlive&&n.componentInstance&&n.componentInstance!==f.instances[s]&&(f.instances[s]=n.componentInstance),yo(l)};var v=f.props&&f.props[s];return v&&(eo(c[s],{route:l,configProps:v}),xo(g,o,l,v)),i(g,o,a)}};function xo(n,e,t,a){var r=e.props=function(n,e){switch(typeof e){case"undefined":return;case"object":return e;case"function":return e(n);case"boolean":return e?n.params:void 0;default:0}}(t,a);if(r){r=e.props=eo({},r);var o=e.attrs=e.attrs||{};for(var i in r)n.props&&i in n.props||(o[i]=r[i],delete r[i])}}function wo(n,e,t){var a=n.charAt(0);if("/"===a)return n;if("?"===a||"#"===a)return e+n;var r=e.split("/");t&&r[r.length-1]||r.pop();for(var o=n.replace(/^\//,"").split("/"),i=0;i<o.length;i++){var s=o[i];".."===s?r.pop():"."!==s&&r.push(s)}return""!==r[0]&&r.unshift(""),r.join("/")}function So(n){return n.replace(/\/(?:\s*\/)+/g,"/")}var To=Array.isArray||function(n){return"[object Array]"==Object.prototype.toString.call(n)},Co=Jo,jo=Lo,Eo=function(n,e){return Po(Lo(n,e),e)},Ao=Po,Io=Do,_o=new RegExp(["(\\\\.)","([\\/.])?(?:(?:\\:(\\w+)(?:\\(((?:\\\\.|[^\\\\()])+)\\))?|\\(((?:\\\\.|[^\\\\()])+)\\))([+*?])?|(\\*))"].join("|"),"g");function Lo(n,e){for(var t,a=[],r=0,o=0,i="",s=e&&e.delimiter||"/";null!=(t=_o.exec(n));){var l=t[0],c=t[1],d=t.index;if(i+=n.slice(o,d),o=d+l.length,c)i+=c[1];else{var p=n[o],u=t[2],h=t[3],m=t[4],f=t[5],g=t[6],v=t[7];i&&(a.push(i),i="");var b=null!=u&&null!=p&&p!==u,y="+"===g||"*"===g,k="?"===g||"*"===g,x=t[2]||s,w=m||f;a.push({name:h||r++,prefix:u||"",delimiter:x,optional:k,repeat:y,partial:b,asterisk:!!v,pattern:w?Mo(w):v?".*":"[^"+Bo(x)+"]+?"})}}return o<n.length&&(i+=n.substr(o)),i&&a.push(i),a}function zo(n){return encodeURI(n).replace(/[\/?#]/g,(function(n){return"%"+n.charCodeAt(0).toString(16).toUpperCase()}))}function Po(n,e){for(var t=new Array(n.length),a=0;a<n.length;a++)"object"==typeof n[a]&&(t[a]=new RegExp("^(?:"+n[a].pattern+")$",Ro(e)));return function(e,a){for(var r="",o=e||{},i=(a||{}).pretty?zo:encodeURIComponent,s=0;s<n.length;s++){var l=n[s];if("string"!=typeof l){var c,d=o[l.name];if(null==d){if(l.optional){l.partial&&(r+=l.prefix);continue}throw new TypeError('Expected "'+l.name+'" to be defined')}if(To(d)){if(!l.repeat)throw new TypeError('Expected "'+l.name+'" to not repeat, but received `'+JSON.stringify(d)+"`");if(0===d.length){if(l.optional)continue;throw new TypeError('Expected "'+l.name+'" to not be empty')}for(var p=0;p<d.length;p++){if(c=i(d[p]),!t[s].test(c))throw new TypeError('Expected all "'+l.name+'" to match "'+l.pattern+'", but received `'+JSON.stringify(c)+"`");r+=(0===p?l.prefix:l.delimiter)+c}}else{if(c=l.asterisk?encodeURI(d).replace(/[?#]/g,(function(n){return"%"+n.charCodeAt(0).toString(16).toUpperCase()})):i(d),!t[s].test(c))throw new TypeError('Expected "'+l.name+'" to match "'+l.pattern+'", but received "'+c+'"');r+=l.prefix+c}}else r+=l}return r}}function Bo(n){return n.replace(/([.+*?=^!:${}()[\]|\/\\])/g,"\\$1")}function Mo(n){return n.replace(/([=!:$\/()])/g,"\\$1")}function Oo(n,e){return n.keys=e,n}function Ro(n){return n&&n.sensitive?"":"i"}function Do(n,e,t){To(e)||(t=e||t,e=[]);for(var a=(t=t||{}).strict,r=!1!==t.end,o="",i=0;i<n.length;i++){var s=n[i];if("string"==typeof s)o+=Bo(s);else{var l=Bo(s.prefix),c="(?:"+s.pattern+")";e.push(s),s.repeat&&(c+="(?:"+l+c+")*"),o+=c=s.optional?s.partial?l+"("+c+")?":"(?:"+l+"("+c+"))?":l+"("+c+")"}}var d=Bo(t.delimiter||"/"),p=o.slice(-d.length)===d;return a||(o=(p?o.slice(0,-d.length):o)+"(?:"+d+"(?=$))?"),o+=r?"$":a&&p?"":"(?="+d+"|$)",Oo(new RegExp("^"+o,Ro(t)),e)}function Jo(n,e,t){return To(e)||(t=e||t,e=[]),t=t||{},n instanceof RegExp?function(n,e){var t=n.source.match(/\((?!\?)/g);if(t)for(var a=0;a<t.length;a++)e.push({name:a,prefix:null,delimiter:null,optional:!1,repeat:!1,partial:!1,asterisk:!1,pattern:null});return Oo(n,e)}(n,e):To(n)?function(n,e,t){for(var a=[],r=0;r<n.length;r++)a.push(Jo(n[r],e,t).source);return Oo(new RegExp("(?:"+a.join("|")+")",Ro(t)),e)}(n,e,t):function(n,e,t){return Do(Lo(n,t),e,t)}(n,e,t)}Co.parse=jo,Co.compile=Eo,Co.tokensToFunction=Ao,Co.tokensToRegExp=Io;var qo=Object.create(null);function Fo(n,e,t){e=e||{};try{var a=qo[n]||(qo[n]=Co.compile(n));return"string"==typeof e.pathMatch&&(e[0]=e.pathMatch),a(e,{pretty:!0})}catch(n){return""}finally{delete e[0]}}function No(n,e,t,a){var r="string"==typeof n?{path:n}:n;if(r._normalized)return r;if(r.name){var o=(r=eo({},n)).params;return o&&"object"==typeof o&&(r.params=eo({},o)),r}if(!r.path&&r.params&&e){(r=eo({},r))._normalized=!0;var i=eo(eo({},e.params),r.params);if(e.name)r.name=e.name,r.params=i;else if(e.matched.length){var s=e.matched[e.matched.length-1].path;r.path=Fo(s,i,e.path)}else 0;return r}var l=function(n){var e="",t="",a=n.indexOf("#");a>=0&&(e=n.slice(a),n=n.slice(0,a));var r=n.indexOf("?");return r>=0&&(t=n.slice(r+1),n=n.slice(0,r)),{path:n,query:t,hash:e}}(r.path||""),c=e&&e.path||"/",d=l.path?wo(l.path,c,t||r.append):c,p=function(n,e,t){void 0===e&&(e={});var a,r=t||lo;try{a=r(n||"")}catch(n){a={}}for(var o in e){var i=e[o];a[o]=Array.isArray(i)?i.map(so):so(i)}return a}(l.query,r.query,a&&a.options.parseQuery),u=r.hash||l.hash;return u&&"#"!==u.charAt(0)&&(u="#"+u),{_normalized:!0,path:d,query:p,hash:u}}var Qo,Uo=function(){},Ho={name:"RouterLink",props:{to:{type:[String,Object],required:!0},tag:{type:String,default:"a"},custom:Boolean,exact:Boolean,exactPath:Boolean,append:Boolean,replace:Boolean,activeClass:String,exactActiveClass:String,ariaCurrentValue:{type:String,default:"page"},event:{type:[String,Array],default:"click"}},render:function(n){var e=this,t=this.$router,a=this.$route,r=t.resolve(this.to,a,this.append),o=r.location,i=r.route,s=r.href,l={},c=t.options.linkActiveClass,d=t.options.linkExactActiveClass,p=null==c?"router-link-active":c,u=null==d?"router-link-exact-active":d,h=null==this.activeClass?p:this.activeClass,m=null==this.exactActiveClass?u:this.exactActiveClass,f=i.redirectedFrom?uo(null,No(i.redirectedFrom),null,t):i;l[m]=vo(a,f,this.exactPath),l[h]=this.exact||this.exactPath?l[m]:function(n,e){return 0===n.path.replace(po,"/").indexOf(e.path.replace(po,"/"))&&(!e.hash||n.hash===e.hash)&&function(n,e){for(var t in e)if(!(t in n))return!1;return!0}(n.query,e.query)}(a,f);var g=l[m]?this.ariaCurrentValue:null,v=function(n){$o(n)&&(e.replace?t.replace(o,Uo):t.push(o,Uo))},b={click:$o};Array.isArray(this.event)?this.event.forEach((function(n){b[n]=v})):b[this.event]=v;var y={class:l},k=!this.$scopedSlots.$hasNormal&&this.$scopedSlots.default&&this.$scopedSlots.default({href:s,route:i,navigate:v,isActive:l[h],isExactActive:l[m]});if(k){if(1===k.length)return k[0];if(k.length>1||!k.length)return 0===k.length?n():n("span",{},k)}if("a"===this.tag)y.on=b,y.attrs={href:s,"aria-current":g};else{var x=function n(e){var t;if(e)for(var a=0;a<e.length;a++){if("a"===(t=e[a]).tag)return t;if(t.children&&(t=n(t.children)))return t}}(this.$slots.default);if(x){x.isStatic=!1;var w=x.data=eo({},x.data);for(var S in w.on=w.on||{},w.on){var T=w.on[S];S in b&&(w.on[S]=Array.isArray(T)?T:[T])}for(var C in b)C in w.on?w.on[C].push(b[C]):w.on[C]=v;var j=x.data.attrs=eo({},x.data.attrs);j.href=s,j["aria-current"]=g}else y.on=b}return n(this.tag,y,this.$slots.default)}};function $o(n){if(!(n.metaKey||n.altKey||n.ctrlKey||n.shiftKey||n.defaultPrevented||void 0!==n.button&&0!==n.button)){if(n.currentTarget&&n.currentTarget.getAttribute){var e=n.currentTarget.getAttribute("target");if(/\b_blank\b/i.test(e))return}return n.preventDefault&&n.preventDefault(),!0}}var Go="undefined"!=typeof window;function Vo(n,e,t,a,r){var o=e||[],i=t||Object.create(null),s=a||Object.create(null);n.forEach((function(n){!function n(e,t,a,r,o,i){var s=r.path,l=r.name;0;var c=r.pathToRegexpOptions||{},d=function(n,e,t){t||(n=n.replace(/\/$/,""));if("/"===n[0])return n;if(null==e)return n;return So(e.path+"/"+n)}(s,o,c.strict);"boolean"==typeof r.caseSensitive&&(c.sensitive=r.caseSensitive);var p={path:d,regex:Xo(d,c),components:r.components||{default:r.component},alias:r.alias?"string"==typeof r.alias?[r.alias]:r.alias:[],instances:{},enteredCbs:{},name:l,parent:o,matchAs:i,redirect:r.redirect,beforeEnter:r.beforeEnter,meta:r.meta||{},props:null==r.props?{}:r.components?r.props:{default:r.props}};r.children&&r.children.forEach((function(r){var o=i?So(i+"/"+r.path):void 0;n(e,t,a,r,p,o)}));t[p.path]||(e.push(p.path),t[p.path]=p);if(void 0!==r.alias)for(var u=Array.isArray(r.alias)?r.alias:[r.alias],h=0;h<u.length;++h){0;var m={path:u[h],children:r.children};n(e,t,a,m,o,p.path||"/")}l&&(a[l]||(a[l]=p))}(o,i,s,n,r)}));for(var l=0,c=o.length;l<c;l++)"*"===o[l]&&(o.push(o.splice(l,1)[0]),c--,l--);return{pathList:o,pathMap:i,nameMap:s}}function Xo(n,e){return Co(n,[],e)}function Ko(n,e){var t=Vo(n),a=t.pathList,r=t.pathMap,o=t.nameMap;function i(n,t,i){var s=No(n,t,!1,e),c=s.name;if(c){var d=o[c];if(!d)return l(null,s);var p=d.regex.keys.filter((function(n){return!n.optional})).map((function(n){return n.name}));if("object"!=typeof s.params&&(s.params={}),t&&"object"==typeof t.params)for(var u in t.params)!(u in s.params)&&p.indexOf(u)>-1&&(s.params[u]=t.params[u]);return s.path=Fo(d.path,s.params),l(d,s,i)}if(s.path){s.params={};for(var h=0;h<a.length;h++){var m=a[h],f=r[m];if(Wo(f.regex,s.path,s.params))return l(f,s,i)}}return l(null,s)}function s(n,t){var a=n.redirect,r="function"==typeof a?a(uo(n,t,null,e)):a;if("string"==typeof r&&(r={path:r}),!r||"object"!=typeof r)return l(null,t);var s=r,c=s.name,d=s.path,p=t.query,u=t.hash,h=t.params;if(p=s.hasOwnProperty("query")?s.query:p,u=s.hasOwnProperty("hash")?s.hash:u,h=s.hasOwnProperty("params")?s.params:h,c){o[c];return i({_normalized:!0,name:c,query:p,hash:u,params:h},void 0,t)}if(d){var m=function(n,e){return wo(n,e.parent?e.parent.path:"/",!0)}(d,n);return i({_normalized:!0,path:Fo(m,h),query:p,hash:u},void 0,t)}return l(null,t)}function l(n,t,a){return n&&n.redirect?s(n,a||t):n&&n.matchAs?function(n,e,t){var a=i({_normalized:!0,path:Fo(t,e.params)});if(a){var r=a.matched,o=r[r.length-1];return e.params=a.params,l(o,e)}return l(null,e)}(0,t,n.matchAs):uo(n,t,a,e)}return{match:i,addRoute:function(n,e){var t="object"!=typeof n?o[n]:void 0;Vo([e||n],a,r,o,t),t&&t.alias.length&&Vo(t.alias.map((function(n){return{path:n,children:[e]}})),a,r,o,t)},getRoutes:function(){return a.map((function(n){return r[n]}))},addRoutes:function(n){Vo(n,a,r,o)}}}function Wo(n,e,t){var a=e.match(n);if(!a)return!1;if(!t)return!0;for(var r=1,o=a.length;r<o;++r){var i=n.keys[r-1];i&&(t[i.name||"pathMatch"]="string"==typeof a[r]?io(a[r]):a[r])}return!0}var Zo=Go&&window.performance&&window.performance.now?window.performance:Date;function Yo(){return Zo.now().toFixed(3)}var ni=Yo();function ei(){return ni}function ti(n){return ni=n}var ai=Object.create(null);function ri(){"scrollRestoration"in window.history&&(window.history.scrollRestoration="manual");var n=window.location.protocol+"//"+window.location.host,e=window.location.href.replace(n,""),t=eo({},window.history.state);return t.key=ei(),window.history.replaceState(t,"",e),window.addEventListener("popstate",si),function(){window.removeEventListener("popstate",si)}}function oi(n,e,t,a){if(n.app){var r=n.options.scrollBehavior;r&&n.app.$nextTick((function(){var o=function(){var n=ei();if(n)return ai[n]}(),i=r.call(n,e,t,a?o:null);i&&("function"==typeof i.then?i.then((function(n){ui(n,o)})).catch((function(n){0})):ui(i,o))}))}}function ii(){var n=ei();n&&(ai[n]={x:window.pageXOffset,y:window.pageYOffset})}function si(n){ii(),n.state&&n.state.key&&ti(n.state.key)}function li(n){return di(n.x)||di(n.y)}function ci(n){return{x:di(n.x)?n.x:window.pageXOffset,y:di(n.y)?n.y:window.pageYOffset}}function di(n){return"number"==typeof n}var pi=/^#\d/;function ui(n,e){var t,a="object"==typeof n;if(a&&"string"==typeof n.selector){var r=pi.test(n.selector)?document.getElementById(n.selector.slice(1)):document.querySelector(n.selector);if(r){var o=n.offset&&"object"==typeof n.offset?n.offset:{};e=function(n,e){var t=document.documentElement.getBoundingClientRect(),a=n.getBoundingClientRect();return{x:a.left-t.left-e.x,y:a.top-t.top-e.y}}(r,o={x:di((t=o).x)?t.x:0,y:di(t.y)?t.y:0})}else li(n)&&(e=ci(n))}else a&&li(n)&&(e=ci(n));e&&("scrollBehavior"in document.documentElement.style?window.scrollTo({left:e.x,top:e.y,behavior:n.behavior}):window.scrollTo(e.x,e.y))}var hi,mi=Go&&((-1===(hi=window.navigator.userAgent).indexOf("Android 2.")&&-1===hi.indexOf("Android 4.0")||-1===hi.indexOf("Mobile Safari")||-1!==hi.indexOf("Chrome")||-1!==hi.indexOf("Windows Phone"))&&window.history&&"function"==typeof window.history.pushState);function fi(n,e){ii();var t=window.history;try{if(e){var a=eo({},t.state);a.key=ei(),t.replaceState(a,"",n)}else t.pushState({key:ti(Yo())},"",n)}catch(t){window.location[e?"replace":"assign"](n)}}function gi(n){fi(n,!0)}var vi={redirected:2,aborted:4,cancelled:8,duplicated:16};function bi(n,e){return ki(n,e,vi.redirected,'Redirected when going from "'+n.fullPath+'" to "'+function(n){if("string"==typeof n)return n;if("path"in n)return n.path;var e={};return xi.forEach((function(t){t in n&&(e[t]=n[t])})),JSON.stringify(e,null,2)}(e)+'" via a navigation guard.')}function yi(n,e){return ki(n,e,vi.cancelled,'Navigation cancelled from "'+n.fullPath+'" to "'+e.fullPath+'" with a new navigation.')}function ki(n,e,t,a){var r=new Error(a);return r._isRouter=!0,r.from=n,r.to=e,r.type=t,r}var xi=["params","query","hash"];function wi(n){return Object.prototype.toString.call(n).indexOf("Error")>-1}function Si(n,e){return wi(n)&&n._isRouter&&(null==e||n.type===e)}function Ti(n,e,t){var a=function(r){r>=n.length?t():n[r]?e(n[r],(function(){a(r+1)})):a(r+1)};a(0)}function Ci(n){return function(e,t,a){var r=!1,o=0,i=null;ji(n,(function(n,e,t,s){if("function"==typeof n&&void 0===n.cid){r=!0,o++;var l,c=Ii((function(e){var r;((r=e).__esModule||Ai&&"Module"===r[Symbol.toStringTag])&&(e=e.default),n.resolved="function"==typeof e?e:Qo.extend(e),t.components[s]=e,--o<=0&&a()})),d=Ii((function(n){var e="Failed to resolve async component "+s+": "+n;i||(i=wi(n)?n:new Error(e),a(i))}));try{l=n(c,d)}catch(n){d(n)}if(l)if("function"==typeof l.then)l.then(c,d);else{var p=l.component;p&&"function"==typeof p.then&&p.then(c,d)}}})),r||a()}}function ji(n,e){return Ei(n.map((function(n){return Object.keys(n.components).map((function(t){return e(n.components[t],n.instances[t],n,t)}))})))}function Ei(n){return Array.prototype.concat.apply([],n)}var Ai="function"==typeof Symbol&&"symbol"==typeof Symbol.toStringTag;function Ii(n){var e=!1;return function(){for(var t=[],a=arguments.length;a--;)t[a]=arguments[a];if(!e)return e=!0,n.apply(this,t)}}var _i=function(n,e){this.router=n,this.base=function(n){if(!n)if(Go){var e=document.querySelector("base");n=(n=e&&e.getAttribute("href")||"/").replace(/^https?:\/\/[^\/]+/,"")}else n="/";"/"!==n.charAt(0)&&(n="/"+n);return n.replace(/\/$/,"")}(e),this.current=mo,this.pending=null,this.ready=!1,this.readyCbs=[],this.readyErrorCbs=[],this.errorCbs=[],this.listeners=[]};function Li(n,e,t,a){var r=ji(n,(function(n,a,r,o){var i=function(n,e){"function"!=typeof n&&(n=Qo.extend(n));return n.options[e]}(n,e);if(i)return Array.isArray(i)?i.map((function(n){return t(n,a,r,o)})):t(i,a,r,o)}));return Ei(a?r.reverse():r)}function zi(n,e){if(e)return function(){return n.apply(e,arguments)}}_i.prototype.listen=function(n){this.cb=n},_i.prototype.onReady=function(n,e){this.ready?n():(this.readyCbs.push(n),e&&this.readyErrorCbs.push(e))},_i.prototype.onError=function(n){this.errorCbs.push(n)},_i.prototype.transitionTo=function(n,e,t){var a,r=this;try{a=this.router.match(n,this.current)}catch(n){throw this.errorCbs.forEach((function(e){e(n)})),n}var o=this.current;this.confirmTransition(a,(function(){r.updateRoute(a),e&&e(a),r.ensureURL(),r.router.afterHooks.forEach((function(n){n&&n(a,o)})),r.ready||(r.ready=!0,r.readyCbs.forEach((function(n){n(a)})))}),(function(n){t&&t(n),n&&!r.ready&&(Si(n,vi.redirected)&&o===mo||(r.ready=!0,r.readyErrorCbs.forEach((function(e){e(n)}))))}))},_i.prototype.confirmTransition=function(n,e,t){var a=this,r=this.current;this.pending=n;var o,i,s=function(n){!Si(n)&&wi(n)&&(a.errorCbs.length?a.errorCbs.forEach((function(e){e(n)})):console.error(n)),t&&t(n)},l=n.matched.length-1,c=r.matched.length-1;if(vo(n,r)&&l===c&&n.matched[l]===r.matched[c])return this.ensureURL(),n.hash&&oi(this.router,r,n,!1),s(((i=ki(o=r,n,vi.duplicated,'Avoided redundant navigation to current location: "'+o.fullPath+'".')).name="NavigationDuplicated",i));var d=function(n,e){var t,a=Math.max(n.length,e.length);for(t=0;t<a&&n[t]===e[t];t++);return{updated:e.slice(0,t),activated:e.slice(t),deactivated:n.slice(t)}}(this.current.matched,n.matched),p=d.updated,u=d.deactivated,h=d.activated,m=[].concat(function(n){return Li(n,"beforeRouteLeave",zi,!0)}(u),this.router.beforeHooks,function(n){return Li(n,"beforeRouteUpdate",zi)}(p),h.map((function(n){return n.beforeEnter})),Ci(h)),f=function(e,t){if(a.pending!==n)return s(yi(r,n));try{e(n,r,(function(e){!1===e?(a.ensureURL(!0),s(function(n,e){return ki(n,e,vi.aborted,'Navigation aborted from "'+n.fullPath+'" to "'+e.fullPath+'" via a navigation guard.')}(r,n))):wi(e)?(a.ensureURL(!0),s(e)):"string"==typeof e||"object"==typeof e&&("string"==typeof e.path||"string"==typeof e.name)?(s(bi(r,n)),"object"==typeof e&&e.replace?a.replace(e):a.push(e)):t(e)}))}catch(n){s(n)}};Ti(m,f,(function(){Ti(function(n){return Li(n,"beforeRouteEnter",(function(n,e,t,a){return function(n,e,t){return function(a,r,o){return n(a,r,(function(n){"function"==typeof n&&(e.enteredCbs[t]||(e.enteredCbs[t]=[]),e.enteredCbs[t].push(n)),o(n)}))}}(n,t,a)}))}(h).concat(a.router.resolveHooks),f,(function(){if(a.pending!==n)return s(yi(r,n));a.pending=null,e(n),a.router.app&&a.router.app.$nextTick((function(){yo(n)}))}))}))},_i.prototype.updateRoute=function(n){this.current=n,this.cb&&this.cb(n)},_i.prototype.setupListeners=function(){},_i.prototype.teardown=function(){this.listeners.forEach((function(n){n()})),this.listeners=[],this.current=mo,this.pending=null};var Pi=function(n){function e(e,t){n.call(this,e,t),this._startLocation=Bi(this.base)}return n&&(e.__proto__=n),e.prototype=Object.create(n&&n.prototype),e.prototype.constructor=e,e.prototype.setupListeners=function(){var n=this;if(!(this.listeners.length>0)){var e=this.router,t=e.options.scrollBehavior,a=mi&&t;a&&this.listeners.push(ri());var r=function(){var t=n.current,r=Bi(n.base);n.current===mo&&r===n._startLocation||n.transitionTo(r,(function(n){a&&oi(e,n,t,!0)}))};window.addEventListener("popstate",r),this.listeners.push((function(){window.removeEventListener("popstate",r)}))}},e.prototype.go=function(n){window.history.go(n)},e.prototype.push=function(n,e,t){var a=this,r=this.current;this.transitionTo(n,(function(n){fi(So(a.base+n.fullPath)),oi(a.router,n,r,!1),e&&e(n)}),t)},e.prototype.replace=function(n,e,t){var a=this,r=this.current;this.transitionTo(n,(function(n){gi(So(a.base+n.fullPath)),oi(a.router,n,r,!1),e&&e(n)}),t)},e.prototype.ensureURL=function(n){if(Bi(this.base)!==this.current.fullPath){var e=So(this.base+this.current.fullPath);n?fi(e):gi(e)}},e.prototype.getCurrentLocation=function(){return Bi(this.base)},e}(_i);function Bi(n){var e=window.location.pathname,t=e.toLowerCase(),a=n.toLowerCase();return!n||t!==a&&0!==t.indexOf(So(a+"/"))||(e=e.slice(n.length)),(e||"/")+window.location.search+window.location.hash}var Mi=function(n){function e(e,t,a){n.call(this,e,t),a&&function(n){var e=Bi(n);if(!/^\/#/.test(e))return window.location.replace(So(n+"/#"+e)),!0}(this.base)||Oi()}return n&&(e.__proto__=n),e.prototype=Object.create(n&&n.prototype),e.prototype.constructor=e,e.prototype.setupListeners=function(){var n=this;if(!(this.listeners.length>0)){var e=this.router.options.scrollBehavior,t=mi&&e;t&&this.listeners.push(ri());var a=function(){var e=n.current;Oi()&&n.transitionTo(Ri(),(function(a){t&&oi(n.router,a,e,!0),mi||qi(a.fullPath)}))},r=mi?"popstate":"hashchange";window.addEventListener(r,a),this.listeners.push((function(){window.removeEventListener(r,a)}))}},e.prototype.push=function(n,e,t){var a=this,r=this.current;this.transitionTo(n,(function(n){Ji(n.fullPath),oi(a.router,n,r,!1),e&&e(n)}),t)},e.prototype.replace=function(n,e,t){var a=this,r=this.current;this.transitionTo(n,(function(n){qi(n.fullPath),oi(a.router,n,r,!1),e&&e(n)}),t)},e.prototype.go=function(n){window.history.go(n)},e.prototype.ensureURL=function(n){var e=this.current.fullPath;Ri()!==e&&(n?Ji(e):qi(e))},e.prototype.getCurrentLocation=function(){return Ri()},e}(_i);function Oi(){var n=Ri();return"/"===n.charAt(0)||(qi("/"+n),!1)}function Ri(){var n=window.location.href,e=n.indexOf("#");return e<0?"":n=n.slice(e+1)}function Di(n){var e=window.location.href,t=e.indexOf("#");return(t>=0?e.slice(0,t):e)+"#"+n}function Ji(n){mi?fi(Di(n)):window.location.hash=n}function qi(n){mi?gi(Di(n)):window.location.replace(Di(n))}var Fi=function(n){function e(e,t){n.call(this,e,t),this.stack=[],this.index=-1}return n&&(e.__proto__=n),e.prototype=Object.create(n&&n.prototype),e.prototype.constructor=e,e.prototype.push=function(n,e,t){var a=this;this.transitionTo(n,(function(n){a.stack=a.stack.slice(0,a.index+1).concat(n),a.index++,e&&e(n)}),t)},e.prototype.replace=function(n,e,t){var a=this;this.transitionTo(n,(function(n){a.stack=a.stack.slice(0,a.index).concat(n),e&&e(n)}),t)},e.prototype.go=function(n){var e=this,t=this.index+n;if(!(t<0||t>=this.stack.length)){var a=this.stack[t];this.confirmTransition(a,(function(){var n=e.current;e.index=t,e.updateRoute(a),e.router.afterHooks.forEach((function(e){e&&e(a,n)}))}),(function(n){Si(n,vi.duplicated)&&(e.index=t)}))}},e.prototype.getCurrentLocation=function(){var n=this.stack[this.stack.length-1];return n?n.fullPath:"/"},e.prototype.ensureURL=function(){},e}(_i),Ni=function(n){void 0===n&&(n={}),this.app=null,this.apps=[],this.options=n,this.beforeHooks=[],this.resolveHooks=[],this.afterHooks=[],this.matcher=Ko(n.routes||[],this);var e=n.mode||"hash";switch(this.fallback="history"===e&&!mi&&!1!==n.fallback,this.fallback&&(e="hash"),Go||(e="abstract"),this.mode=e,e){case"history":this.history=new Pi(this,n.base);break;case"hash":this.history=new Mi(this,n.base,this.fallback);break;case"abstract":this.history=new Fi(this,n.base);break;default:0}},Qi={currentRoute:{configurable:!0}};Ni.prototype.match=function(n,e,t){return this.matcher.match(n,e,t)},Qi.currentRoute.get=function(){return this.history&&this.history.current},Ni.prototype.init=function(n){var e=this;if(this.apps.push(n),n.$once("hook:destroyed",(function(){var t=e.apps.indexOf(n);t>-1&&e.apps.splice(t,1),e.app===n&&(e.app=e.apps[0]||null),e.app||e.history.teardown()})),!this.app){this.app=n;var t=this.history;if(t instanceof Pi||t instanceof Mi){var a=function(n){t.setupListeners(),function(n){var a=t.current,r=e.options.scrollBehavior;mi&&r&&"fullPath"in n&&oi(e,n,a,!1)}(n)};t.transitionTo(t.getCurrentLocation(),a,a)}t.listen((function(n){e.apps.forEach((function(e){e._route=n}))}))}},Ni.prototype.beforeEach=function(n){return Hi(this.beforeHooks,n)},Ni.prototype.beforeResolve=function(n){return Hi(this.resolveHooks,n)},Ni.prototype.afterEach=function(n){return Hi(this.afterHooks,n)},Ni.prototype.onReady=function(n,e){this.history.onReady(n,e)},Ni.prototype.onError=function(n){this.history.onError(n)},Ni.prototype.push=function(n,e,t){var a=this;if(!e&&!t&&"undefined"!=typeof Promise)return new Promise((function(e,t){a.history.push(n,e,t)}));this.history.push(n,e,t)},Ni.prototype.replace=function(n,e,t){var a=this;if(!e&&!t&&"undefined"!=typeof Promise)return new Promise((function(e,t){a.history.replace(n,e,t)}));this.history.replace(n,e,t)},Ni.prototype.go=function(n){this.history.go(n)},Ni.prototype.back=function(){this.go(-1)},Ni.prototype.forward=function(){this.go(1)},Ni.prototype.getMatchedComponents=function(n){var e=n?n.matched?n:this.resolve(n).route:this.currentRoute;return e?[].concat.apply([],e.matched.map((function(n){return Object.keys(n.components).map((function(e){return n.components[e]}))}))):[]},Ni.prototype.resolve=function(n,e,t){var a=No(n,e=e||this.history.current,t,this),r=this.match(a,e),o=r.redirectedFrom||r.fullPath;return{location:a,route:r,href:function(n,e,t){var a="hash"===t?"#"+e:e;return n?So(n+"/"+a):a}(this.history.base,o,this.mode),normalizedTo:a,resolved:r}},Ni.prototype.getRoutes=function(){return this.matcher.getRoutes()},Ni.prototype.addRoute=function(n,e){this.matcher.addRoute(n,e),this.history.current!==mo&&this.history.transitionTo(this.history.getCurrentLocation())},Ni.prototype.addRoutes=function(n){this.matcher.addRoutes(n),this.history.current!==mo&&this.history.transitionTo(this.history.getCurrentLocation())},Object.defineProperties(Ni.prototype,Qi);var Ui=Ni;function Hi(n,e){return n.push(e),function(){var t=n.indexOf(e);t>-1&&n.splice(t,1)}}Ni.install=function n(e){if(!n.installed||Qo!==e){n.installed=!0,Qo=e;var t=function(n){return void 0!==n},a=function(n,e){var a=n.$options._parentVnode;t(a)&&t(a=a.data)&&t(a=a.registerRouteInstance)&&a(n,e)};e.mixin({beforeCreate:function(){t(this.$options.router)?(this._routerRoot=this,this._router=this.$options.router,this._router.init(this),e.util.defineReactive(this,"_route",this._router.history.current)):this._routerRoot=this.$parent&&this.$parent._routerRoot||this,a(this,this)},destroyed:function(){a(this)}}),Object.defineProperty(e.prototype,"$router",{get:function(){return this._routerRoot._router}}),Object.defineProperty(e.prototype,"$route",{get:function(){return this._routerRoot._route}}),e.component("RouterView",ko),e.component("RouterLink",Ho);var r=e.config.optionMergeStrategies;r.beforeRouteEnter=r.beforeRouteLeave=r.beforeRouteUpdate=r.created}},Ni.version="3.6.5",Ni.isNavigationFailure=Si,Ni.NavigationFailureType=vi,Ni.START_LOCATION=mo,Go&&window.Vue&&window.Vue.use(Ni);t(103);t(16),t(130);var $i={NotFound:()=>Promise.all([t.e(0),t.e(4)]).then(t.bind(null,328)),Layout:()=>Promise.all([t.e(0),t.e(2)]).then(t.bind(null,327))},Gi={"v-e78034fa":()=>t.e(5).then(t.bind(null,329)),"v-3e714d2a":()=>t.e(6).then(t.bind(null,330)),"v-407e7564":()=>t.e(7).then(t.bind(null,331)),"v-6a669cc4":()=>t.e(8).then(t.bind(null,332)),"v-3897df61":()=>t.e(9).then(t.bind(null,333)),"v-5ddc5e71":()=>t.e(10).then(t.bind(null,334)),"v-6f5fe4a4":()=>t.e(11).then(t.bind(null,335)),"v-5ec93f7b":()=>t.e(13).then(t.bind(null,336)),"v-77eb69ec":()=>t.e(14).then(t.bind(null,337)),"v-410ac754":()=>t.e(12).then(t.bind(null,338)),"v-d45608ea":()=>t.e(15).then(t.bind(null,339)),"v-4a3cf55d":()=>t.e(16).then(t.bind(null,340)),"v-0a837972":()=>t.e(17).then(t.bind(null,341)),"v-89486e7a":()=>t.e(18).then(t.bind(null,342)),"v-38ab7e32":()=>t.e(19).then(t.bind(null,343)),"v-5367a4af":()=>t.e(20).then(t.bind(null,344)),"v-63e48439":()=>t.e(21).then(t.bind(null,345)),"v-9f8ccf5e":()=>t.e(22).then(t.bind(null,346)),"v-99d6e044":()=>t.e(23).then(t.bind(null,347)),"v-43826e72":()=>t.e(24).then(t.bind(null,348)),"v-c20babe6":()=>t.e(25).then(t.bind(null,349)),"v-08c71366":()=>t.e(26).then(t.bind(null,350)),"v-8ae87632":()=>t.e(27).then(t.bind(null,351)),"v-567fbe26":()=>t.e(28).then(t.bind(null,352)),"v-0ba27c18":()=>t.e(29).then(t.bind(null,353)),"v-3f862f67":()=>t.e(30).then(t.bind(null,354)),"v-e30b8032":()=>t.e(31).then(t.bind(null,355)),"v-03e85d0e":()=>t.e(32).then(t.bind(null,356)),"v-6b463bfb":()=>t.e(34).then(t.bind(null,357)),"v-74777bb3":()=>t.e(35).then(t.bind(null,358)),"v-6a709319":()=>t.e(36).then(t.bind(null,359)),"v-135d0248":()=>t.e(37).then(t.bind(null,360)),"v-c3e7532c":()=>t.e(33).then(t.bind(null,361)),"v-571aeb12":()=>t.e(38).then(t.bind(null,362)),"v-d0afba64":()=>t.e(39).then(t.bind(null,363)),"v-5ddc1b80":()=>t.e(40).then(t.bind(null,364)),"v-47a18848":()=>t.e(41).then(t.bind(null,365)),"v-e231d910":()=>t.e(42).then(t.bind(null,366)),"v-5d98fa16":()=>t.e(43).then(t.bind(null,367)),"v-2552a92f":()=>t.e(44).then(t.bind(null,368)),"v-273d7455":()=>t.e(45).then(t.bind(null,369)),"v-d5dc6db4":()=>t.e(46).then(t.bind(null,370)),"v-4a6be083":()=>t.e(47).then(t.bind(null,371)),"v-783fbd46":()=>t.e(48).then(t.bind(null,372)),"v-1c9fd64e":()=>t.e(49).then(t.bind(null,373)),"v-5f0f30c6":()=>t.e(50).then(t.bind(null,374)),"v-51da0e54":()=>t.e(51).then(t.bind(null,375)),"v-78eeb3d8":()=>t.e(52).then(t.bind(null,376)),"v-26fa598d":()=>t.e(53).then(t.bind(null,377)),"v-f5ed38f8":()=>t.e(54).then(t.bind(null,378)),"v-120df2fa":()=>t.e(55).then(t.bind(null,379)),"v-0082735a":()=>t.e(56).then(t.bind(null,380)),"v-669c40a0":()=>t.e(57).then(t.bind(null,381)),"v-09ae1176":()=>t.e(58).then(t.bind(null,382)),"v-4050afac":()=>t.e(59).then(t.bind(null,383)),"v-7dfe13a8":()=>t.e(60).then(t.bind(null,384)),"v-3489417a":()=>t.e(61).then(t.bind(null,385)),"v-f8c2901e":()=>t.e(62).then(t.bind(null,386)),"v-053a73e8":()=>t.e(63).then(t.bind(null,387)),"v-6379fc2e":()=>t.e(64).then(t.bind(null,388)),"v-5140306c":()=>t.e(65).then(t.bind(null,389)),"v-0b9e1aec":()=>t.e(66).then(t.bind(null,390)),"v-0bf64c24":()=>t.e(67).then(t.bind(null,391)),"v-2767b19c":()=>t.e(68).then(t.bind(null,392)),"v-1d611f27":()=>t.e(69).then(t.bind(null,393)),"v-8153bf3c":()=>t.e(71).then(t.bind(null,394)),"v-8f229662":()=>t.e(73).then(t.bind(null,395)),"v-8bbcfd3a":()=>t.e(74).then(t.bind(null,396)),"v-45ced8ca":()=>t.e(70).then(t.bind(null,397)),"v-50a497ba":()=>t.e(72).then(t.bind(null,398)),"v-d0cbc152":()=>t.e(75).then(t.bind(null,399)),"v-d35585c0":()=>t.e(76).then(t.bind(null,400)),"v-957f7b90":()=>t.e(77).then(t.bind(null,401)),"v-224a9095":()=>t.e(78).then(t.bind(null,402)),"v-70032af0":()=>t.e(79).then(t.bind(null,403)),"v-10ca5dc4":()=>t.e(80).then(t.bind(null,404)),"v-c92a649c":()=>t.e(81).then(t.bind(null,405)),"v-76c98d70":()=>t.e(82).then(t.bind(null,406)),"v-ab00c88e":()=>t.e(83).then(t.bind(null,407)),"v-6158f5dc":()=>t.e(84).then(t.bind(null,408)),"v-68d67e22":()=>t.e(85).then(t.bind(null,409)),"v-097ed174":()=>t.e(86).then(t.bind(null,410)),"v-629046d2":()=>t.e(87).then(t.bind(null,411)),"v-80c46bea":()=>t.e(88).then(t.bind(null,412)),"v-1f84369c":()=>t.e(89).then(t.bind(null,413)),"v-e7bc6886":()=>t.e(90).then(t.bind(null,414)),"v-603745ce":()=>t.e(91).then(t.bind(null,415)),"v-4ae61c39":()=>t.e(92).then(t.bind(null,416)),"v-01e74dde":()=>t.e(93).then(t.bind(null,417)),"v-c9002668":()=>t.e(94).then(t.bind(null,418)),"v-129110e4":()=>t.e(96).then(t.bind(null,419)),"v-34c41a32":()=>t.e(97).then(t.bind(null,420)),"v-79517efc":()=>t.e(95).then(t.bind(null,421)),"v-6bc0f08b":()=>t.e(98).then(t.bind(null,422)),"v-c1084aa0":()=>t.e(99).then(t.bind(null,423)),"v-4c9cf11f":()=>t.e(100).then(t.bind(null,424)),"v-7181834a":()=>t.e(101).then(t.bind(null,425)),"v-ea66ad78":()=>t.e(105).then(t.bind(null,426)),"v-2ede7bc6":()=>t.e(104).then(t.bind(null,427)),"v-165dc3de":()=>t.e(103).then(t.bind(null,428)),"v-5798a127":()=>t.e(106).then(t.bind(null,429)),"v-94d81df6":()=>t.e(107).then(t.bind(null,430)),"v-49c893e5":()=>t.e(102).then(t.bind(null,431)),"v-b28245d2":()=>t.e(108).then(t.bind(null,432)),"v-153f7b50":()=>t.e(109).then(t.bind(null,433)),"v-be922ec8":()=>t.e(110).then(t.bind(null,434)),"v-af878584":()=>t.e(111).then(t.bind(null,435)),"v-2ffbbf7d":()=>t.e(114).then(t.bind(null,436)),"v-6d33b879":()=>t.e(115).then(t.bind(null,437)),"v-365b0049":()=>t.e(116).then(t.bind(null,438)),"v-7ba276fa":()=>t.e(117).then(t.bind(null,439)),"v-b0095412":()=>t.e(118).then(t.bind(null,440)),"v-1689eec4":()=>t.e(119).then(t.bind(null,441)),"v-5aaf6e59":()=>t.e(120).then(t.bind(null,442)),"v-42d727d9":()=>t.e(121).then(t.bind(null,443)),"v-91d0c51a":()=>t.e(122).then(t.bind(null,444)),"v-5bbea173":()=>t.e(123).then(t.bind(null,445)),"v-372121bc":()=>t.e(124).then(t.bind(null,446)),"v-4452d00c":()=>t.e(125).then(t.bind(null,447)),"v-5c5b6663":()=>t.e(126).then(t.bind(null,448)),"v-c4807e92":()=>t.e(127).then(t.bind(null,449)),"v-3fb4f800":()=>t.e(128).then(t.bind(null,450)),"v-dbde7360":()=>t.e(129).then(t.bind(null,451)),"v-61301819":()=>t.e(112).then(t.bind(null,452)),"v-262c459c":()=>t.e(113).then(t.bind(null,453)),"v-36ff78c4":()=>t.e(130).then(t.bind(null,454))};function Vi(n){const e=Object.create(null);return function(t){return e[t]||(e[t]=n(t))}}const Xi=/-(\w)/g,Ki=Vi(n=>n.replace(Xi,(n,e)=>e?e.toUpperCase():"")),Wi=/\B([A-Z])/g,Zi=Vi(n=>n.replace(Wi,"-$1").toLowerCase()),Yi=Vi(n=>n.charAt(0).toUpperCase()+n.slice(1));function ns(n,e){if(!e)return;if(n(e))return n(e);return e.includes("-")?n(Yi(Ki(e))):n(Yi(e))||n(Zi(e))}const es=Object.assign({},$i,Gi),ts=n=>es[n],as=n=>Gi[n],rs=n=>$i[n],os=n=>$t.component(n);function is(n){return ns(as,n)}function ss(n){return ns(rs,n)}function ls(n){return ns(ts,n)}function cs(n){return ns(os,n)}function ds(...n){return Promise.all(n.filter(n=>n).map(async n=>{if(!cs(n)&&ls(n)){const e=await ls(n)();$t.component(n,e.default)}}))}function ps(n,e){"undefined"!=typeof window&&window.__VUEPRESS__&&(window.__VUEPRESS__[n]=e)}var us=t(92),hs=t.n(us),ms=t(93),fs=t.n(ms),gs={created(){if(this.siteMeta=this.$site.headTags.filter(([n])=>"meta"===n).map(([n,e])=>e),this.$ssrContext){const e=this.getMergedMetaTags();this.$ssrContext.title=this.$title,this.$ssrContext.lang=this.$lang,this.$ssrContext.pageMeta=(n=e)?n.map(n=>{let e="<meta";return Object.keys(n).forEach(t=>{e+=` ${t}="${fs()(n[t])}"`}),e+">"}).join("\n    "):"",this.$ssrContext.canonicalLink=bs(this.$canonicalUrl)}var n},mounted(){this.currentMetaTags=[...document.querySelectorAll("meta")],this.updateMeta(),this.updateCanonicalLink()},methods:{updateMeta(){document.title=this.$title,document.documentElement.lang=this.$lang;const n=this.getMergedMetaTags();this.currentMetaTags=ys(n,this.currentMetaTags)},getMergedMetaTags(){const n=this.$page.frontmatter.meta||[];return hs()([{name:"description",content:this.$description}],n,this.siteMeta,ks)},updateCanonicalLink(){vs(),this.$canonicalUrl&&document.head.insertAdjacentHTML("beforeend",bs(this.$canonicalUrl))}},watch:{$page(){this.updateMeta(),this.updateCanonicalLink()}},beforeDestroy(){ys(null,this.currentMetaTags),vs()}};function vs(){const n=document.querySelector("link[rel='canonical']");n&&n.remove()}function bs(n=""){return n?`<link href="${n}" rel="canonical" />`:""}function ys(n,e){if(e&&[...e].filter(n=>n.parentNode===document.head).forEach(n=>document.head.removeChild(n)),n)return n.map(n=>{const e=document.createElement("meta");return Object.keys(n).forEach(t=>{e.setAttribute(t,n[t])}),document.head.appendChild(e),e})}function ks(n){for(const e of["name","property","itemprop"])if(n.hasOwnProperty(e))return n[e]+e;return JSON.stringify(n)}var xs=t(50),ws={mounted(){window.addEventListener("scroll",this.onScroll)},methods:{onScroll:t.n(xs)()((function(){this.setActiveHash()}),300),setActiveHash(){const n=[].slice.call(document.querySelectorAll(".sidebar-link")),e=[].slice.call(document.querySelectorAll(".header-anchor")).filter(e=>n.some(n=>n.hash===e.hash)),t=Math.max(window.pageYOffset,document.documentElement.scrollTop,document.body.scrollTop),a=Math.max(document.documentElement.scrollHeight,document.body.scrollHeight),r=window.innerHeight+t;for(let n=0;n<e.length;n++){const o=e[n],i=e[n+1],s=0===n&&0===t||t>=o.parentElement.offsetTop+10&&(!i||t<i.parentElement.offsetTop-10),l=decodeURIComponent(this.$route.hash);if(s&&l!==decodeURIComponent(o.hash)){const t=o;if(r===a)for(let t=n+1;t<e.length;t++)if(l===decodeURIComponent(e[t].hash))return;return this.$vuepress.$set("disableScrollBehavior",!0),void this.$router.replace(decodeURIComponent(t.hash),()=>{this.$nextTick(()=>{this.$vuepress.$set("disableScrollBehavior",!1)})})}}}},beforeDestroy(){window.removeEventListener("scroll",this.onScroll)}},Ss=t(24),Ts=t.n(Ss),Cs={mounted(){Ts.a.configure({showSpinner:!1}),this.$router.beforeEach((n,e,t)=>{n.path===e.path||$t.component(n.name)||Ts.a.start(),t()}),this.$router.afterEach(()=>{Ts.a.done(),this.isSidebarOpen=!1})}};t(239),t(240);class js{constructor(){this.containerEl=document.getElementById("message-container"),this.containerEl||(this.containerEl=document.createElement("div"),this.containerEl.id="message-container",document.body.appendChild(this.containerEl))}show({text:n="",duration:e=3e3}){let t=document.createElement("div");t.className="message move-in",t.innerHTML=`\n      <i style="fill: #06a35a;font-size: 14px;display:inline-flex;align-items: center;">\n        <svg style="fill: #06a35a;font-size: 14px;" t="1572421810237" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="2323" width="16" height="16"><path d="M822.811993 824.617989c-83.075838 81.99224-188.546032 124.613757-316.049383 127.86455-122.085362-3.250794-223.943563-45.87231-305.935802-127.86455s-124.613757-184.21164-127.86455-305.935802c3.250794-127.503351 45.87231-232.973545 127.86455-316.049383 81.99224-83.075838 184.21164-126.058554 305.935802-129.309347 127.503351 3.250794 232.973545 46.23351 316.049383 129.309347 83.075838 83.075838 126.058554 188.546032 129.309347 316.049383C949.231746 640.406349 905.887831 742.62575 822.811993 824.617989zM432.716755 684.111464c3.973192 3.973192 8.307584 5.779189 13.364374 6.140388 5.05679 0.361199 9.752381-1.444797 13.364374-5.417989l292.571429-287.514638c3.973192-3.973192 5.779189-8.307584 5.779189-13.364374 0-5.05679-1.805996-9.752381-5.779189-13.364374l1.805996 1.805996c-3.973192-3.973192-8.668783-5.779189-14.086772-6.140388-5.417989-0.361199-10.47478 1.444797-14.809171 5.417989l-264.397884 220.33157c-3.973192 3.250794-8.668783 4.695591-14.447972 4.695591-5.779189 0-10.835979-1.444797-15.53157-3.973192l-94.273016-72.962257c-4.334392-3.250794-9.391182-4.334392-14.447972-3.973192s-9.391182 3.250794-12.641975 7.585185l-2.889594 3.973192c-3.250794 4.334392-4.334392 9.391182-3.973192 14.809171 0.722399 5.417989 2.528395 10.11358 5.779189 14.086772L432.716755 684.111464z" p-id="2324"></path></svg>\n      </i>\n      <div class="text">${n}</div>\n    `,this.containerEl.appendChild(t),e>0&&setTimeout(()=>{this.close(t)},e)}close(n){n.className=n.className.replace("move-in",""),n.className+="move-out",n.addEventListener("animationend",()=>{n.remove()})}}var Es={mounted(){!!/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)||this.updateCopy()},updated(){!!/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)||this.updateCopy()},methods:{updateCopy(){setTimeout(()=>{(['div[class*="language-"] pre','div[class*="aside-code"] aside']instanceof Array||Array.isArray(['div[class*="language-"] pre','div[class*="aside-code"] aside']))&&['div[class*="language-"] pre','div[class*="aside-code"] aside'].forEach(n=>{document.querySelectorAll(n).forEach(this.generateCopyButton)})},1e3)},generateCopyButton(n){if(n.classList.contains("codecopy-enabled"))return;const e=document.createElement("i");e.className="code-copy",e.innerHTML='<svg  style="color:#aaa;font-size:14px" t="1572422231464" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3201" width="14" height="14"><path d="M866.461538 39.384615H354.461538c-43.323077 0-78.769231 35.446154-78.76923 78.769231v39.384616h472.615384c43.323077 0 78.769231 35.446154 78.769231 78.76923v551.384616h39.384615c43.323077 0 78.769231-35.446154 78.769231-78.769231V118.153846c0-43.323077-35.446154-78.769231-78.769231-78.769231z m-118.153846 275.692308c0-43.323077-35.446154-78.769231-78.76923-78.769231H157.538462c-43.323077 0-78.769231 35.446154-78.769231 78.769231v590.769231c0 43.323077 35.446154 78.769231 78.769231 78.769231h512c43.323077 0 78.769231-35.446154 78.76923-78.769231V315.076923z m-354.461538 137.846154c0 11.815385-7.876923 19.692308-19.692308 19.692308h-157.538461c-11.815385 0-19.692308-7.876923-19.692308-19.692308v-39.384615c0-11.815385 7.876923-19.692308 19.692308-19.692308h157.538461c11.815385 0 19.692308 7.876923 19.692308 19.692308v39.384615z m157.538461 315.076923c0 11.815385-7.876923 19.692308-19.692307 19.692308H216.615385c-11.815385 0-19.692308-7.876923-19.692308-19.692308v-39.384615c0-11.815385 7.876923-19.692308 19.692308-19.692308h315.076923c11.815385 0 19.692308 7.876923 19.692307 19.692308v39.384615z m78.769231-157.538462c0 11.815385-7.876923 19.692308-19.692308 19.692308H216.615385c-11.815385 0-19.692308-7.876923-19.692308-19.692308v-39.384615c0-11.815385 7.876923-19.692308 19.692308-19.692308h393.846153c11.815385 0 19.692308 7.876923 19.692308 19.692308v39.384615z" p-id="3202"></path></svg>',e.title="Copy to clipboard",e.addEventListener("click",()=>{this.copyToClipboard(n.innerText)}),n.appendChild(e),n.classList.add("codecopy-enabled")},copyToClipboard(n){const e=document.createElement("textarea");e.value=n,e.setAttribute("readonly",""),e.style.position="absolute",e.style.left="-9999px",document.body.appendChild(e);const t=document.getSelection().rangeCount>0&&document.getSelection().getRangeAt(0);e.select(),document.execCommand("copy");(new js).show({text:"复制成功",duration:1e3}),document.body.removeChild(e),t&&(document.getSelection().removeAllRanges(),document.getSelection().addRange(t))}}};!function(n,e){void 0===e&&(e={});var t=e.insertAt;if(n&&"undefined"!=typeof document){var a=document.head||document.getElementsByTagName("head")[0],r=document.createElement("style");r.type="text/css","top"===t&&a.firstChild?a.insertBefore(r,a.firstChild):a.appendChild(r),r.styleSheet?r.styleSheet.cssText=n:r.appendChild(document.createTextNode(n))}}("@media (max-width: 1000px) {\n  .vuepress-plugin-demo-block__h_code {\n    display: none;\n  }\n  .vuepress-plugin-demo-block__app {\n    margin-left: auto !important;\n    margin-right: auto !important;\n  }\n}\n.vuepress-plugin-demo-block__wrapper {\n  margin-top: 10px;\n  border: 1px solid #ebebeb;\n  border-radius: 4px;\n  transition: all 0.2s;\n}\n.vuepress-plugin-demo-block__wrapper.vuepress-plugin-demo-block__horizontal .vuepress-plugin-demo-block__display {\n  height: 400px;\n  display: flex;\n}\n.vuepress-plugin-demo-block__wrapper.vuepress-plugin-demo-block__horizontal .vuepress-plugin-demo-block__display .vuepress-plugin-demo-block__app {\n  width: 300px;\n  border: 1px solid #ebebeb;\n  box-shadow: 1px 1px 3px #ebebeb;\n  margin-right: 5px;\n  overflow: auto;\n}\n.vuepress-plugin-demo-block__wrapper.vuepress-plugin-demo-block__horizontal .vuepress-plugin-demo-block__display .vuepress-plugin-demo-block__h_code {\n  flex: 1;\n  overflow: auto;\n  height: 100%;\n}\n.vuepress-plugin-demo-block__wrapper.vuepress-plugin-demo-block__horizontal .vuepress-plugin-demo-block__display .vuepress-plugin-demo-block__h_code > pre {\n  overflow: visible;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__display {\n  max-height: 400px;\n  overflow: auto;\n}\n.vuepress-plugin-demo-block__wrapper div {\n  box-sizing: border-box;\n}\n.vuepress-plugin-demo-block__wrapper:hover {\n  box-shadow: 0 0 11px rgba(33, 33, 33, 0.2);\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__code {\n  overflow: hidden;\n  height: 0;\n  padding: 0 !important;\n  background-color: #282c34;\n  border-radius: 0 !important;\n  transition: height 0.5s;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__code pre {\n  margin: 0 !important;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__display {\n  padding: 20px;\n  border-bottom: 1px solid #ebebeb;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer {\n  position: relative;\n  text-align: center;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer.vuepress-plugin-demo-block__show-link .vuepress-plugin-demo-block__jsfiddle,\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer.vuepress-plugin-demo-block__show-link .vuepress-plugin-demo-block__codepen {\n  opacity: 1;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer.vuepress-plugin-demo-block__show-link .vuepress-plugin-demo-block__expand::before {\n  border-top: none;\n  border-right: 6px solid transparent;\n  border-bottom: 6px solid #ccc;\n  border-left: 6px solid transparent;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover .vuepress-plugin-demo-block__jsfiddle,\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover .vuepress-plugin-demo-block__codepen,\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover .vuepress-plugin-demo-block__expand span,\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover .vuepress-plugin-demo-block__expand {\n  opacity: 1;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover .vuepress-plugin-demo-block__expand::before {\n  border-top-color: #3eaf7c !important;\n  border-bottom-color: #3eaf7c !important;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover svg {\n  fill: #3eaf7c !important;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__expand-text {\n  transition: all 0.5s;\n  opacity: 0;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer form:nth-last-child(2) {\n  right: 50px;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer form:last-child {\n  right: 10px;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__button {\n  border-color: transparent;\n  background-color: transparent;\n  font-size: 14px;\n  color: #3eaf7c;\n  cursor: pointer;\n  outline: none;\n  margin: 0;\n  width: 46px;\n  position: relative;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__button:hover::before {\n  content: attr(data-tip);\n  white-space: nowrap;\n  position: absolute;\n  top: -30px;\n  left: 50%;\n  color: #eee;\n  line-height: 1;\n  z-index: 1000;\n  border-radius: 4px;\n  padding: 6px;\n  -webkit-transform: translateX(-50%);\n          transform: translateX(-50%);\n  background-color: rgba(0, 0, 0, 0.8);\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__button:hover::after {\n  content: '' !important;\n  display: block;\n  position: absolute;\n  left: 50%;\n  top: -5px;\n  -webkit-transform: translateX(-50%);\n          transform: translateX(-50%);\n  border: 5px solid transparent;\n  border-top-color: rgba(0, 0, 0, 0.8);\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__button svg {\n  width: 34px;\n  height: 20px;\n  fill: #ccc;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__jsfiddle,\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__codepen {\n  position: absolute;\n  top: 10px;\n  transition: all 0.5s;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__expand {\n  position: relative;\n  width: 100px;\n  height: 40px;\n  margin: 0;\n  color: #3eaf7c;\n  font-size: 14px;\n  background-color: transparent;\n  border-color: transparent;\n  outline: none;\n  transition: all 0.5s;\n  cursor: pointer;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__expand::before {\n  content: \"\";\n  position: absolute;\n  top: 50%;\n  left: 50%;\n  width: 0;\n  height: 0;\n  border-top: 6px solid #ccc;\n  border-right: 6px solid transparent;\n  border-left: 6px solid transparent;\n  -webkit-transform: translate(-50%, -50%);\n          transform: translate(-50%, -50%);\n}\n");var As={jsLib:[],cssLib:[],jsfiddle:!0,codepen:!0,codepenLayout:"left",codepenJsProcessor:"babel",codepenEditors:"101",horizontal:!1,vue:"https://cdn.jsdelivr.net/npm/vue/dist/vue.min.js",react:"https://cdn.jsdelivr.net/npm/react/umd/react.production.min.js",reactDOM:"https://cdn.jsdelivr.net/npm/react-dom/umd/react-dom.production.min.js"},Is={},_s=function(n){return'<div id="app">\n'.concat(n,"\n</div>")},Ls=function(n){return window.$VUEPRESS_DEMO_BLOCK&&void 0!==window.$VUEPRESS_DEMO_BLOCK[n]?window.$VUEPRESS_DEMO_BLOCK[n]:As[n]},zs=function n(e,t,a){var r=document.createElement(e);return t&&Object.keys(t).forEach((function(n){if(n.indexOf("data"))r[n]=t[n];else{var e=n.replace("data","");r.dataset[e]=t[n]}})),a&&a.forEach((function(e){var t=e.tag,a=e.attrs,o=e.children;r.appendChild(n(t,a,o))})),r},Ps=function(n,e,t){var a,r=(a=n.querySelectorAll(".".concat(e)),Array.prototype.slice.call(a));return 1!==r.length||t?r:r[0]},Bs=function(n,e){var t,a,r=n.match(/<style>([\s\S]+)<\/style>/),o=n.match(/<template>([\s\S]+)<\/template>/),i=n.match(/<script>([\s\S]+)<\/script>/),s={css:r&&r[1].replace(/^\n|\n$/g,""),html:o&&o[1].replace(/^\n|\n$/g,""),js:i&&i[1].replace(/^\n|\n$/g,""),jsLib:e.jsLib||[],cssLib:e.cssLib||[]};s.htmlTpl=_s(s.html),s.jsTpl=(t=s.js,a=t.replace(/export\s+default\s*?\{\n*/,"").replace(/\n*\}\s*$/,"").trim(),"new Vue({\n  el: '#app',\n  ".concat(a,"\n})")),s.script=function(n,e){var t=n.split(/export\s+default/),a="(function() {".concat(t[0]," ; return ").concat(t[1],"})()"),r=window.Babel?window.Babel.transform(a,{presets:["es2015"]}).code:a,o=[eval][0](r);return o.template=e,o}(s.js,s.html);var l=Ls("vue");return s.jsLib.unshift(l),s},Ms=function(n,e){var t,a=n.match(/<style>([\s\S]+)<\/style>/),r=n.match(/<html>([\s\S]+)<\/html>/),o=n.match(/<script>([\s\S]+)<\/script>/),i={css:a&&a[1].replace(/^\n|\n$/g,""),html:r&&r[1].replace(/^\n|\n$/g,""),js:o&&o[1].replace(/^\n|\n$/g,""),jsLib:e.jsLib||[],cssLib:e.cssLib||[]};return i.htmlTpl=i.html,i.jsTpl=i.js,i.script=(t=i.js,window.Babel?window.Babel.transform(t,{presets:["es2015"]}).code:t),i},Os=function(n){return n=n.replace("export default ","").replace(/App\.__style__(\s*)=(\s*)`([\s\S]*)?`/,""),n+='ReactDOM.render(React.createElement(App), document.getElementById("app"))'};function Rs(){var n=Ps(document,"vuepress-plugin-demo-block__wrapper",!0);n.length?n.forEach((function(n){if("true"!==n.dataset.created){n.style.display="block";var e=Ps(n,"vuepress-plugin-demo-block__code"),t=Ps(n,"vuepress-plugin-demo-block__display"),a=Ps(n,"vuepress-plugin-demo-block__footer"),r=Ps(t,"vuepress-plugin-demo-block__app"),o=decodeURIComponent(n.dataset.code),i=decodeURIComponent(n.dataset.config),s=decodeURIComponent(n.dataset.type);i=i?JSON.parse(i):{};var l=e.querySelector("div").clientHeight,c="react"===s?function(n,e){var t=(0,window.Babel.transform)(n,{presets:["es2015","react"]}).code,a="(function(exports){var module={};module.exports=exports;".concat(t,";return module.exports.__esModule?module.exports.default:module.exports;})({})"),r=new Function("return ".concat(a))(),o={js:r,css:r.__style__||"",jsLib:e.jsLib||[],cssLib:e.cssLib||[],jsTpl:Os(n),htmlTpl:_s("")},i=Ls("react"),s=Ls("reactDOM");return o.jsLib.unshift(i,s),o}(o,i):"vanilla"===s?Ms(o,i):Bs(o,i),d=zs("button",{className:"".concat("vuepress-plugin-demo-block__expand")});if(a.appendChild(d),d.addEventListener("click",Ds.bind(null,d,l,e,a)),Ls("jsfiddle")&&a.appendChild(function(n){var e=n.css,t=n.htmlTpl,a=n.jsTpl,r=n.jsLib,o=n.cssLib,i=r.concat(o).concat(Ls("cssLib")).concat(Ls("jsLib")).join(",");return zs("form",{className:"vuepress-plugin-demo-block__jsfiddle",target:"_blank",action:"https://jsfiddle.net/api/post/library/pure/",method:"post"},[{tag:"input",attrs:{type:"hidden",name:"css",value:e}},{tag:"input",attrs:{type:"hidden",name:"html",value:t}},{tag:"input",attrs:{type:"hidden",name:"js",value:a}},{tag:"input",attrs:{type:"hidden",name:"panel_js",value:3}},{tag:"input",attrs:{type:"hidden",name:"wrap",value:1}},{tag:"input",attrs:{type:"hidden",name:"resources",value:i}},{tag:"button",attrs:{type:"submit",className:"vuepress-plugin-demo-block__button",innerHTML:'<?xml version="1.0" standalone="no"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg t="1547088289967" class="icon" style="" viewBox="0 0 1170 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="1952" xmlns:xlink="http://www.w3.org/1999/xlink" width="228.515625" height="200"><defs><style type="text/css"></style></defs><path d="M1028.571429 441.142857q63.428571 26.285714 102.571428 83.142857T1170.285714 650.857143q0 93.714286-67.428571 160.285714T940 877.714286q-2.285714 0-6.571429-0.285715t-6-0.285714H232q-97.142857-5.714286-164.571429-71.714286T0 645.142857q0-62.857143 31.428571-116t84-84q-6.857143-22.285714-6.857142-46.857143 0-65.714286 46.857142-112t113.714286-46.285714q54.285714 0 98.285714 33.142857 42.857143-88 127.142858-141.714286t186.571428-53.714285q94.857143 0 174.857143 46T982.571429 248.571429t46.571428 172q0 3.428571-0.285714 10.285714t-0.285714 10.285714zM267.428571 593.142857q0 69.714286 48 110.285714t118.857143 40.571429q78.285714 0 137.142857-56.571429-9.142857-11.428571-27.142857-32.285714T519.428571 626.285714q-38.285714 37.142857-82.285714 37.142857-31.428571 0-53.428571-19.142857T361.714286 594.285714q0-30.285714 22-49.714285t52.285714-19.428572q25.142857 0 48.285714 12t41.714286 31.428572 37.142857 42.857142 39.428572 46.857143 44 42.857143 55.428571 31.428572 69.428571 12q69.142857 0 116.857143-40.857143T936 594.857143q0-69.142857-48-109.714286t-118.285714-40.571428q-81.714286 0-137.714286 55.428571l53.142857 61.714286q37.714286-36.571429 81.142857-36.571429 29.714286 0 52.571429 18.857143t22.857143 48q0 32.571429-21.142857 52.285714t-53.714286 19.714286q-24.571429 0-47.142857-12t-41.142857-31.428571-37.428572-42.857143-39.714286-46.857143-44.285714-42.857143-55.142857-31.428571T434.285714 444.571429q-69.714286 0-118.285714 40.285714T267.428571 593.142857z" p-id="1953"></path></svg>',datatip:"JSFiddle"}}])}(c)),Ls("codepen")&&a.appendChild(function(n){var e=n.css,t=n.htmlTpl,a=n.jsTpl,r=n.jsLib,o=n.cssLib,i=JSON.stringify({css:e,html:t,js:a,js_external:r.concat(Ls("jsLib")).join(";"),css_external:o.concat(Ls("cssLib")).join(";"),layout:Ls("codepenLayout"),js_pre_processor:Ls("codepenJsProcessor"),editors:Ls("codepenEditors")});return zs("form",{className:"vuepress-plugin-demo-block__codepen",target:"_blank",action:"https://codepen.io/pen/define",method:"post"},[{tag:"input",attrs:{type:"hidden",name:"data",value:i}},{tag:"button",attrs:{type:"submit",innerHTML:'<?xml version="1.0" standalone="no"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg t="1547088271207" class="icon" style="" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="1737" xmlns:xlink="http://www.w3.org/1999/xlink" width="200" height="200"><defs><style type="text/css"></style></defs><path d="M123.428571 668l344.571429 229.714286v-205.142857L277.142857 565.142857z m-35.428571-82.285714l110.285714-73.714286-110.285714-73.714286v147.428572z m468 312l344.571429-229.714286-153.714286-102.857143-190.857143 127.428572v205.142857z m-44-281.714286l155.428571-104-155.428571-104-155.428571 104zM277.142857 458.857143l190.857143-127.428572V126.285714L123.428571 356z m548.571429 53.142857l110.285714 73.714286V438.285714z m-78.857143-53.142857l153.714286-102.857143-344.571429-229.714286v205.142857z m277.142857-102.857143v312q0 23.428571-19.428571 36.571429l-468 312q-12 7.428571-24.571429 7.428571t-24.571429-7.428571L19.428571 704.571429q-19.428571-13.142857-19.428571-36.571429V356q0-23.428571 19.428571-36.571429L487.428571 7.428571q12-7.428571 24.571429-7.428571t24.571429 7.428571l468 312q19.428571 13.142857 19.428571 36.571429z" p-id="1738"></path></svg>',className:"vuepress-plugin-demo-block__button",datatip:"Codepen"}}])}(c)),void 0!==i.horizontal?i.horizontal:Ls("horizontal")){n.classList.add("vuepress-plugin-demo-block__horizontal");var p=e.firstChild.cloneNode(!0);p.classList.add("vuepress-plugin-demo-block__h_code"),t.appendChild(p)}if(c.css&&function(n){if(!Is[n]){var e=zs("style",{innerHTML:n});document.body.appendChild(e),Is[n]=!0}}(c.css),"react"===s)ReactDOM.render(React.createElement(c.js),r);else if("vue"===s){var u=(new(Vue.extend(c.script))).$mount();r.appendChild(u.$el)}else"vanilla"===s&&(r.innerHTML=c.html,new Function("return (function(){".concat(c.script,"})()"))());n.dataset.created="true"}})):setTimeout((function(n){Rs()}),300)}function Ds(n,e,t,a){var r="1"!==n.dataset.isExpand;t.style.height=r?"".concat(e,"px"):0,r?a.classList.add("vuepress-plugin-demo-block__show-link"):a.classList.remove("vuepress-plugin-demo-block__show-link"),n.dataset.isExpand=r?"1":"0"}var Js={mounted:function(){window.$VUEPRESS_DEMO_BLOCK={jsfiddle:!1,codepen:!0,horizontal:!1},Rs()},updated:function(){Rs()}},qs="auto",Fs="zoom-in",Ns="zoom-out",Qs="grab",Us="move";function Hs(n,e,t){var a=!(arguments.length>3&&void 0!==arguments[3])||arguments[3],r={passive:!1};a?n.addEventListener(e,t,r):n.removeEventListener(e,t,r)}function $s(n,e){if(n){var t=new Image;t.onload=function(){e&&e(t)},t.src=n}}function Gs(n){return n.dataset.original?n.dataset.original:"A"===n.parentNode.tagName?n.parentNode.getAttribute("href"):null}function Vs(n,e,t){!function(n){var e=Xs,t=Ks;if(n.transition){var a=n.transition;delete n.transition,n[e]=a}if(n.transform){var r=n.transform;delete n.transform,n[t]=r}}(e);var a=n.style,r={};for(var o in e)t&&(r[o]=a[o]||""),a[o]=e[o];return r}var Xs="transition",Ks="transform",Ws="transform",Zs="transitionend";var Ys=function(){},nl={enableGrab:!0,preloadImage:!1,closeOnWindowResize:!0,transitionDuration:.4,transitionTimingFunction:"cubic-bezier(0.4, 0, 0, 1)",bgColor:"rgb(255, 255, 255)",bgOpacity:1,scaleBase:1,scaleExtra:.5,scrollThreshold:40,zIndex:998,customSize:null,onOpen:Ys,onClose:Ys,onGrab:Ys,onMove:Ys,onRelease:Ys,onBeforeOpen:Ys,onBeforeClose:Ys,onBeforeGrab:Ys,onBeforeRelease:Ys,onImageLoading:Ys,onImageLoaded:Ys},el={init:function(n){var e,t;e=this,t=n,Object.getOwnPropertyNames(Object.getPrototypeOf(e)).forEach((function(n){e[n]=e[n].bind(t)}))},click:function(n){if(n.preventDefault(),al(n))return window.open(this.target.srcOriginal||n.currentTarget.src,"_blank");this.shown?this.released?this.close():this.release():this.open(n.currentTarget)},scroll:function(){var n=document.documentElement||document.body.parentNode||document.body,e=window.pageXOffset||n.scrollLeft,t=window.pageYOffset||n.scrollTop;null===this.lastScrollPosition&&(this.lastScrollPosition={x:e,y:t});var a=this.lastScrollPosition.x-e,r=this.lastScrollPosition.y-t,o=this.options.scrollThreshold;(Math.abs(r)>=o||Math.abs(a)>=o)&&(this.lastScrollPosition=null,this.close())},keydown:function(n){(function(n){return"Escape"===(n.key||n.code)||27===n.keyCode})(n)&&(this.released?this.close():this.release(this.close))},mousedown:function(n){if(tl(n)&&!al(n)){n.preventDefault();var e=n.clientX,t=n.clientY;this.pressTimer=setTimeout(function(){this.grab(e,t)}.bind(this),200)}},mousemove:function(n){this.released||this.move(n.clientX,n.clientY)},mouseup:function(n){tl(n)&&!al(n)&&(clearTimeout(this.pressTimer),this.released?this.close():this.release())},touchstart:function(n){n.preventDefault();var e=n.touches[0],t=e.clientX,a=e.clientY;this.pressTimer=setTimeout(function(){this.grab(t,a)}.bind(this),200)},touchmove:function(n){if(!this.released){var e=n.touches[0],t=e.clientX,a=e.clientY;this.move(t,a)}},touchend:function(n){(function(n){n.targetTouches.length})(n)||(clearTimeout(this.pressTimer),this.released?this.close():this.release())},clickOverlay:function(){this.close()},resizeWindow:function(){this.close()}};function tl(n){return 0===n.button}function al(n){return n.metaKey||n.ctrlKey}var rl={init:function(n){this.el=document.createElement("div"),this.instance=n,this.parent=document.body,Vs(this.el,{position:"fixed",top:0,left:0,right:0,bottom:0,opacity:0}),this.updateStyle(n.options),Hs(this.el,"click",n.handler.clickOverlay.bind(n))},updateStyle:function(n){Vs(this.el,{zIndex:n.zIndex,backgroundColor:n.bgColor,transition:"opacity\n        "+n.transitionDuration+"s\n        "+n.transitionTimingFunction})},insert:function(){this.parent.appendChild(this.el)},remove:function(){this.parent.removeChild(this.el)},fadeIn:function(){this.el.offsetWidth,this.el.style.opacity=this.instance.options.bgOpacity},fadeOut:function(){this.el.style.opacity=0}},ol="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(n){return typeof n}:function(n){return n&&"function"==typeof Symbol&&n.constructor===Symbol&&n!==Symbol.prototype?"symbol":typeof n},il=function(){function n(n,e){for(var t=0;t<e.length;t++){var a=e[t];a.enumerable=a.enumerable||!1,a.configurable=!0,"value"in a&&(a.writable=!0),Object.defineProperty(n,a.key,a)}}return function(e,t,a){return t&&n(e.prototype,t),a&&n(e,a),e}}(),sl=Object.assign||function(n){for(var e=1;e<arguments.length;e++){var t=arguments[e];for(var a in t)Object.prototype.hasOwnProperty.call(t,a)&&(n[a]=t[a])}return n},ll={init:function(n,e){this.el=n,this.instance=e,this.srcThumbnail=this.el.getAttribute("src"),this.srcset=this.el.getAttribute("srcset"),this.srcOriginal=Gs(this.el),this.rect=this.el.getBoundingClientRect(),this.translate=null,this.scale=null,this.styleOpen=null,this.styleClose=null},zoomIn:function(){var n=this.instance.options,e=n.zIndex,t=n.enableGrab,a=n.transitionDuration,r=n.transitionTimingFunction;this.translate=this.calculateTranslate(),this.scale=this.calculateScale(),this.styleOpen={position:"relative",zIndex:e+1,cursor:t?Qs:Ns,transition:Ws+"\n        "+a+"s\n        "+r,transform:"translate3d("+this.translate.x+"px, "+this.translate.y+"px, 0px)\n        scale("+this.scale.x+","+this.scale.y+")",height:this.rect.height+"px",width:this.rect.width+"px"},this.el.offsetWidth,this.styleClose=Vs(this.el,this.styleOpen,!0)},zoomOut:function(){this.el.offsetWidth,Vs(this.el,{transform:"none"})},grab:function(n,e,t){var a=cl(),r=a.x-n,o=a.y-e;Vs(this.el,{cursor:Us,transform:"translate3d(\n        "+(this.translate.x+r)+"px, "+(this.translate.y+o)+"px, 0px)\n        scale("+(this.scale.x+t)+","+(this.scale.y+t)+")"})},move:function(n,e,t){var a=cl(),r=a.x-n,o=a.y-e;Vs(this.el,{transition:Ws,transform:"translate3d(\n        "+(this.translate.x+r)+"px, "+(this.translate.y+o)+"px, 0px)\n        scale("+(this.scale.x+t)+","+(this.scale.y+t)+")"})},restoreCloseStyle:function(){Vs(this.el,this.styleClose)},restoreOpenStyle:function(){Vs(this.el,this.styleOpen)},upgradeSource:function(){if(this.srcOriginal){var n=this.el.parentNode;this.srcset&&this.el.removeAttribute("srcset");var e=this.el.cloneNode(!1);e.setAttribute("src",this.srcOriginal),e.style.position="fixed",e.style.visibility="hidden",n.appendChild(e),setTimeout(function(){this.el.setAttribute("src",this.srcOriginal),n.removeChild(e)}.bind(this),50)}},downgradeSource:function(){this.srcOriginal&&(this.srcset&&this.el.setAttribute("srcset",this.srcset),this.el.setAttribute("src",this.srcThumbnail))},calculateTranslate:function(){var n=cl(),e=this.rect.left+this.rect.width/2,t=this.rect.top+this.rect.height/2;return{x:n.x-e,y:n.y-t}},calculateScale:function(){var n=this.el.dataset,e=n.zoomingHeight,t=n.zoomingWidth,a=this.instance.options,r=a.customSize,o=a.scaleBase;if(!r&&e&&t)return{x:t/this.rect.width,y:e/this.rect.height};if(r&&"object"===(void 0===r?"undefined":ol(r)))return{x:r.width/this.rect.width,y:r.height/this.rect.height};var i=this.rect.width/2,s=this.rect.height/2,l=cl(),c={x:l.x-i,y:l.y-s},d=c.x/i,p=c.y/s,u=o+Math.min(d,p);if(r&&"string"==typeof r){var h=t||this.el.naturalWidth,m=e||this.el.naturalHeight,f=parseFloat(r)*h/(100*this.rect.width),g=parseFloat(r)*m/(100*this.rect.height);if(u>f||u>g)return{x:f,y:g}}return{x:u,y:u}}};function cl(){var n=document.documentElement;return{x:Math.min(n.clientWidth,window.innerWidth)/2,y:Math.min(n.clientHeight,window.innerHeight)/2}}function dl(n,e,t){["mousedown","mousemove","mouseup","touchstart","touchmove","touchend"].forEach((function(a){Hs(n,a,e[a],t)}))}var pl=function(){function n(e){!function(n,e){if(!(n instanceof e))throw new TypeError("Cannot call a class as a function")}(this,n),this.target=Object.create(ll),this.overlay=Object.create(rl),this.handler=Object.create(el),this.body=document.body,this.shown=!1,this.lock=!1,this.released=!0,this.lastScrollPosition=null,this.pressTimer=null,this.options=sl({},nl,e),this.overlay.init(this),this.handler.init(this)}return il(n,[{key:"listen",value:function(n){if("string"==typeof n)for(var e=document.querySelectorAll(n),t=e.length;t--;)this.listen(e[t]);else"IMG"===n.tagName&&(n.style.cursor=Fs,Hs(n,"click",this.handler.click),this.options.preloadImage&&$s(Gs(n)));return this}},{key:"config",value:function(n){return n?(sl(this.options,n),this.overlay.updateStyle(this.options),this):this.options}},{key:"open",value:function(n){var e=this,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:this.options.onOpen;if(!this.shown&&!this.lock){var a="string"==typeof n?document.querySelector(n):n;if("IMG"===a.tagName){if(this.options.onBeforeOpen(a),this.target.init(a,this),!this.options.preloadImage){var r=this.target.srcOriginal;null!=r&&(this.options.onImageLoading(a),$s(r,this.options.onImageLoaded))}this.shown=!0,this.lock=!0,this.target.zoomIn(),this.overlay.insert(),this.overlay.fadeIn(),Hs(document,"scroll",this.handler.scroll),Hs(document,"keydown",this.handler.keydown),this.options.closeOnWindowResize&&Hs(window,"resize",this.handler.resizeWindow);var o=function n(){Hs(a,Zs,n,!1),e.lock=!1,e.target.upgradeSource(),e.options.enableGrab&&dl(document,e.handler,!0),t(a)};return Hs(a,Zs,o),this}}}},{key:"close",value:function(){var n=this,e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:this.options.onClose;if(this.shown&&!this.lock){var t=this.target.el;this.options.onBeforeClose(t),this.lock=!0,this.body.style.cursor=qs,this.overlay.fadeOut(),this.target.zoomOut(),Hs(document,"scroll",this.handler.scroll,!1),Hs(document,"keydown",this.handler.keydown,!1),this.options.closeOnWindowResize&&Hs(window,"resize",this.handler.resizeWindow,!1);var a=function a(){Hs(t,Zs,a,!1),n.shown=!1,n.lock=!1,n.target.downgradeSource(),n.options.enableGrab&&dl(document,n.handler,!1),n.target.restoreCloseStyle(),n.overlay.remove(),e(t)};return Hs(t,Zs,a),this}}},{key:"grab",value:function(n,e){var t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:this.options.scaleExtra,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:this.options.onGrab;if(this.shown&&!this.lock){var r=this.target.el;this.options.onBeforeGrab(r),this.released=!1,this.target.grab(n,e,t);var o=function n(){Hs(r,Zs,n,!1),a(r)};return Hs(r,Zs,o),this}}},{key:"move",value:function(n,e){var t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:this.options.scaleExtra,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:this.options.onMove;if(this.shown&&!this.lock){this.released=!1,this.body.style.cursor=Us,this.target.move(n,e,t);var r=this.target.el,o=function n(){Hs(r,Zs,n,!1),a(r)};return Hs(r,Zs,o),this}}},{key:"release",value:function(){var n=this,e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:this.options.onRelease;if(this.shown&&!this.lock){var t=this.target.el;this.options.onBeforeRelease(t),this.lock=!0,this.body.style.cursor=qs,this.target.restoreOpenStyle();var a=function a(){Hs(t,Zs,a,!1),n.lock=!1,n.released=!0,e(t)};return Hs(t,Zs,a),this}}}]),n}();const ul=JSON.parse('{"bgColor":"rgba(0,0,0,0.6)"}'),hl=Number("500");class ml{constructor(){this.instance=new pl(ul)}update(n=".theme-vdoing-content img:not(.no-zoom)"){"undefined"!=typeof window&&this.instance.listen(n)}updateDelay(n=".theme-vdoing-content img:not(.no-zoom)",e=hl){setTimeout(()=>this.update(n),e)}}var fl=[gs,ws,Cs,Es,Js,{watch:{"$page.path"(){void 0!==this.$vuepress.zooming&&this.$vuepress.zooming.updateDelay()}},mounted(){this.$vuepress.zooming=new ml,this.$vuepress.zooming.updateDelay()}}],gl={name:"GlobalLayout",computed:{layout(){const n=this.getLayout();return ps("layout",n),$t.component(n)}},methods:{getLayout(){if(this.$page.path){const n=this.$page.frontmatter.layout;return n&&(this.$vuepress.getLayoutAsyncComponent(n)||this.$vuepress.getVueComponent(n))?n:"Layout"}return"NotFound"}}},vl=t(7),bl=Object(vl.a)(gl,(function(){return(0,this._self._c)(this.layout,{tag:"component"})}),[],!1,null,null,null).exports;!function(n,e,t){switch(e){case"components":n[e]||(n[e]={}),Object.assign(n[e],t);break;case"mixins":n[e]||(n[e]=[]),n[e].push(...t);break;default:throw new Error("Unknown option name.")}}(bl,"mixins",fl);const yl=[{name:"v-e78034fa",path:"/pages/java/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-e78034fa").then(t)}},{path:"/pages/java/index.html",redirect:"/pages/java/"},{path:"/01.Java/01.Java基础/01.Java汇总.html",redirect:"/pages/java/"},{name:"v-3e714d2a",path:"/pages/2ed256/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-3e714d2a").then(t)}},{path:"/pages/2ed256/index.html",redirect:"/pages/2ed256/"},{path:"/01.Java/01.Java基础/02.接口和抽象类的区别.html",redirect:"/pages/2ed256/"},{name:"v-407e7564",path:"/pages/66f85c/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-407e7564").then(t)}},{path:"/pages/66f85c/index.html",redirect:"/pages/66f85c/"},{path:"/01.Java/01.Java基础/03.反射相关.html",redirect:"/pages/66f85c/"},{name:"v-6a669cc4",path:"/pages/d95f75/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-6a669cc4").then(t)}},{path:"/pages/d95f75/index.html",redirect:"/pages/d95f75/"},{path:"/01.Java/01.Java基础/100.语法记录.html",redirect:"/pages/d95f75/"},{name:"v-3897df61",path:"/pages/collection/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-3897df61").then(t)}},{path:"/pages/collection/index.html",redirect:"/pages/collection/"},{path:"/01.Java/02.Java集合/01.ArrayList.html",redirect:"/pages/collection/"},{name:"v-5ddc5e71",path:"/pages/d249ac/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-5ddc5e71").then(t)}},{path:"/pages/d249ac/index.html",redirect:"/pages/d249ac/"},{path:"/01.Java/02.Java集合/02.HashMap.html",redirect:"/pages/d249ac/"},{name:"v-6f5fe4a4",path:"/pages/86b6a3/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-6f5fe4a4").then(t)}},{path:"/pages/86b6a3/index.html",redirect:"/pages/86b6a3/"},{path:"/01.Java/02.Java集合/03. BlockingQueue.html",redirect:"/pages/86b6a3/"},{name:"v-5ec93f7b",path:"/pages/jvm/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-5ec93f7b").then(t)}},{path:"/pages/jvm/index.html",redirect:"/pages/jvm/"},{path:"/01.Java/03.JVM/01.Java内存模型.html",redirect:"/pages/jvm/"},{name:"v-77eb69ec",path:"/pages/7d816e/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-77eb69ec").then(t)}},{path:"/pages/7d816e/index.html",redirect:"/pages/7d816e/"},{path:"/01.Java/03.JVM/02.类加载机制.html",redirect:"/pages/7d816e/"},{name:"v-410ac754",path:"/pages/cbcb60/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-410ac754").then(t)}},{path:"/pages/cbcb60/index.html",redirect:"/pages/cbcb60/"},{path:"/01.Java/02.Java集合/04.LinkedList和ArrayDeque.html",redirect:"/pages/cbcb60/"},{name:"v-d45608ea",path:"/pages/a934e8/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-d45608ea").then(t)}},{path:"/pages/a934e8/index.html",redirect:"/pages/a934e8/"},{path:"/01.Java/03.JVM/03.JVM垃圾回收.html",redirect:"/pages/a934e8/"},{name:"v-4a3cf55d",path:"/pages/8ffeca/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-4a3cf55d").then(t)}},{path:"/pages/8ffeca/index.html",redirect:"/pages/8ffeca/"},{path:"/01.Java/03.JVM/04.Java内存区域（运行时数据区）.html",redirect:"/pages/8ffeca/"},{name:"v-0a837972",path:"/pages/376408/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-0a837972").then(t)}},{path:"/pages/376408/index.html",redirect:"/pages/376408/"},{path:"/01.Java/03.JVM/05.虚拟机对象.html",redirect:"/pages/376408/"},{name:"v-89486e7a",path:"/pages/9a5ae7/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-89486e7a").then(t)}},{path:"/pages/9a5ae7/index.html",redirect:"/pages/9a5ae7/"},{path:"/01.Java/03.JVM/06.OutOfMemoryError.html",redirect:"/pages/9a5ae7/"},{name:"v-38ab7e32",path:"/pages/1a4e69/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-38ab7e32").then(t)}},{path:"/pages/1a4e69/index.html",redirect:"/pages/1a4e69/"},{path:"/01.Java/03.JVM/07.如何快速排查问题.html",redirect:"/pages/1a4e69/"},{name:"v-5367a4af",path:"/pages/1ee611/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-5367a4af").then(t)}},{path:"/pages/1ee611/index.html",redirect:"/pages/1ee611/"},{path:"/01.Java/03.JVM/08.JIT逃逸分析.html",redirect:"/pages/1ee611/"},{name:"v-63e48439",path:"/pages/9a3179/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-63e48439").then(t)}},{path:"/pages/9a3179/index.html",redirect:"/pages/9a3179/"},{path:"/01.Java/03.JVM/100.字节码增强技术.html",redirect:"/pages/9a3179/"},{name:"v-9f8ccf5e",path:"/pages/9cc971/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-9f8ccf5e").then(t)}},{path:"/pages/9cc971/index.html",redirect:"/pages/9cc971/"},{path:"/01.Java/03.JVM/101.《深入理解Java虚拟机》.html",redirect:"/pages/9cc971/"},{name:"v-99d6e044",path:"/pages/concurrent/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-99d6e044").then(t)}},{path:"/pages/concurrent/index.html",redirect:"/pages/concurrent/"},{path:"/01.Java/04.Java并发/01.synchronized和volatile.html",redirect:"/pages/concurrent/"},{name:"v-43826e72",path:"/pages/41602c/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-43826e72").then(t)}},{path:"/pages/41602c/index.html",redirect:"/pages/41602c/"},{path:"/01.Java/04.Java并发/02.TreadLocal.html",redirect:"/pages/41602c/"},{name:"v-c20babe6",path:"/pages/d1bd01/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-c20babe6").then(t)}},{path:"/pages/d1bd01/index.html",redirect:"/pages/d1bd01/"},{path:"/01.Java/04.Java并发/03.ReentrantLock.html",redirect:"/pages/d1bd01/"},{name:"v-08c71366",path:"/pages/019d22/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-08c71366").then(t)}},{path:"/pages/019d22/index.html",redirect:"/pages/019d22/"},{path:"/01.Java/04.Java并发/04.ConcurrentHashMap.html",redirect:"/pages/019d22/"},{name:"v-8ae87632",path:"/pages/854033/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-8ae87632").then(t)}},{path:"/pages/854033/index.html",redirect:"/pages/854033/"},{path:"/01.Java/04.Java并发/05.ThreadPoolExecutor.html",redirect:"/pages/854033/"},{name:"v-567fbe26",path:"/pages/9862ed/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-567fbe26").then(t)}},{path:"/pages/9862ed/index.html",redirect:"/pages/9862ed/"},{path:"/01.Java/04.Java并发/06.Future & CompletableFuture.html",redirect:"/pages/9862ed/"},{name:"v-0ba27c18",path:"/pages/646254/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-0ba27c18").then(t)}},{path:"/pages/646254/index.html",redirect:"/pages/646254/"},{path:"/01.Java/04.Java并发/07.从线程到Java的锁机制.html",redirect:"/pages/646254/"},{name:"v-3f862f67",path:"/pages/9c98d8/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-3f862f67").then(t)}},{path:"/pages/9c98d8/index.html",redirect:"/pages/9c98d8/"},{path:"/01.Java/04.Java并发/08.CopyOnWriteArrayList.html",redirect:"/pages/9c98d8/"},{name:"v-e30b8032",path:"/pages/7c31b2/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-e30b8032").then(t)}},{path:"/pages/7c31b2/index.html",redirect:"/pages/7c31b2/"},{path:"/01.Java/04.Java并发/10.CountDownLatch.html",redirect:"/pages/7c31b2/"},{name:"v-03e85d0e",path:"/pages/d5fcba/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-03e85d0e").then(t)}},{path:"/pages/d5fcba/index.html",redirect:"/pages/d5fcba/"},{path:"/01.Java/04.Java并发/100.并发编程.html",redirect:"/pages/d5fcba/"},{name:"v-6b463bfb",path:"/pages/109178/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-6b463bfb").then(t)}},{path:"/pages/109178/index.html",redirect:"/pages/109178/"},{path:"/01.Java/04.Java并发/12.AQS.html",redirect:"/pages/109178/"},{name:"v-74777bb3",path:"/pages/3c96b3/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-74777bb3").then(t)}},{path:"/pages/3c96b3/index.html",redirect:"/pages/3c96b3/"},{path:"/01.Java/04.Java并发/99.如何实现 ReentrantLock？.html",redirect:"/pages/3c96b3/"},{name:"v-6a709319",path:"/pages/mysql/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-6a709319").then(t)}},{path:"/pages/mysql/index.html",redirect:"/pages/mysql/"},{path:"/02.MySQL/00.MySQL.html",redirect:"/pages/mysql/"},{name:"v-135d0248",path:"/pages/26cff4/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-135d0248").then(t)}},{path:"/pages/26cff4/index.html",redirect:"/pages/26cff4/"},{path:"/02.MySQL/01.MySQL存储引擎.html",redirect:"/pages/26cff4/"},{name:"v-c3e7532c",path:"/pages/fa1dea/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-c3e7532c").then(t)}},{path:"/pages/fa1dea/index.html",redirect:"/pages/fa1dea/"},{path:"/01.Java/04.Java并发/11. CyclicBarrier.html",redirect:"/pages/fa1dea/"},{name:"v-571aeb12",path:"/pages/7ece7e/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-571aeb12").then(t)}},{path:"/pages/7ece7e/index.html",redirect:"/pages/7ece7e/"},{path:"/02.MySQL/02.索引.html",redirect:"/pages/7ece7e/"},{name:"v-d0afba64",path:"/pages/e88566/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-d0afba64").then(t)}},{path:"/pages/e88566/index.html",redirect:"/pages/e88566/"},{path:"/02.MySQL/03.事务.html",redirect:"/pages/e88566/"},{name:"v-5ddc1b80",path:"/pages/1d1ed2/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-5ddc1b80").then(t)}},{path:"/pages/1d1ed2/index.html",redirect:"/pages/1d1ed2/"},{path:"/02.MySQL/04.MySQL中的log.html",redirect:"/pages/1d1ed2/"},{name:"v-47a18848",path:"/pages/43cd7b/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-47a18848").then(t)}},{path:"/pages/43cd7b/index.html",redirect:"/pages/43cd7b/"},{path:"/02.MySQL/05.MVCC解决幻读问题.html",redirect:"/pages/43cd7b/"},{name:"v-e231d910",path:"/pages/9ed061/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-e231d910").then(t)}},{path:"/pages/9ed061/index.html",redirect:"/pages/9ed061/"},{path:"/02.MySQL/06.数据库三范式.html",redirect:"/pages/9ed061/"},{name:"v-5d98fa16",path:"/pages/a4281a/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-5d98fa16").then(t)}},{path:"/pages/a4281a/index.html",redirect:"/pages/a4281a/"},{path:"/02.MySQL/07.MySQL数据类型.html",redirect:"/pages/a4281a/"},{name:"v-2552a92f",path:"/pages/c10308/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-2552a92f").then(t)}},{path:"/pages/c10308/index.html",redirect:"/pages/c10308/"},{path:"/02.MySQL/08.范围查询导致索引失效问题.html",redirect:"/pages/c10308/"},{name:"v-273d7455",path:"/pages/b85e9d/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-273d7455").then(t)}},{path:"/pages/b85e9d/index.html",redirect:"/pages/b85e9d/"},{path:"/02.MySQL/09.Explain分析.html",redirect:"/pages/b85e9d/"},{name:"v-d5dc6db4",path:"/pages/92d4ca/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-d5dc6db4").then(t)}},{path:"/pages/92d4ca/index.html",redirect:"/pages/92d4ca/"},{path:"/02.MySQL/10.MySQL中的锁.html",redirect:"/pages/92d4ca/"},{name:"v-4a6be083",path:"/pages/1b8a9e/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-4a6be083").then(t)}},{path:"/pages/1b8a9e/index.html",redirect:"/pages/1b8a9e/"},{path:"/02.MySQL/100.SQL记录.html",redirect:"/pages/1b8a9e/"},{name:"v-783fbd46",path:"/pages/4f8fa0/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-783fbd46").then(t)}},{path:"/pages/4f8fa0/index.html",redirect:"/pages/4f8fa0/"},{path:"/02.MySQL/99.MySQL实战45讲.html",redirect:"/pages/4f8fa0/"},{name:"v-1c9fd64e",path:"/pages/b55c23/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-1c9fd64e").then(t)}},{path:"/pages/b55c23/index.html",redirect:"/pages/b55c23/"},{path:"/02.MySQL/test.html",redirect:"/pages/b55c23/"},{name:"v-5f0f30c6",path:"/pages/redis/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-5f0f30c6").then(t)}},{path:"/pages/redis/index.html",redirect:"/pages/redis/"},{path:"/03.Redis/01.redis总.html",redirect:"/pages/redis/"},{name:"v-51da0e54",path:"/pages/99d0e1/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-51da0e54").then(t)}},{path:"/pages/99d0e1/index.html",redirect:"/pages/99d0e1/"},{path:"/03.Redis/02.redis数据类型.html",redirect:"/pages/99d0e1/"},{name:"v-78eeb3d8",path:"/pages/f706e8/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-78eeb3d8").then(t)}},{path:"/pages/f706e8/index.html",redirect:"/pages/f706e8/"},{path:"/03.Redis/03.redis命令.html",redirect:"/pages/f706e8/"},{name:"v-26fa598d",path:"/pages/d7a25d/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-26fa598d").then(t)}},{path:"/pages/d7a25d/index.html",redirect:"/pages/d7a25d/"},{path:"/03.Redis/04.redis数据结构.html",redirect:"/pages/d7a25d/"},{name:"v-f5ed38f8",path:"/pages/bc6be1/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-f5ed38f8").then(t)}},{path:"/pages/bc6be1/index.html",redirect:"/pages/bc6be1/"},{path:"/03.Redis/05.redis持久化.html",redirect:"/pages/bc6be1/"},{name:"v-120df2fa",path:"/pages/effbd9/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-120df2fa").then(t)}},{path:"/pages/effbd9/index.html",redirect:"/pages/effbd9/"},{path:"/03.Redis/06.redis高可用.html",redirect:"/pages/effbd9/"},{name:"v-0082735a",path:"/pages/428106/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-0082735a").then(t)}},{path:"/pages/428106/index.html",redirect:"/pages/428106/"},{path:"/03.Redis/07.redis删除策略及内存淘汰机制.html",redirect:"/pages/428106/"},{name:"v-669c40a0",path:"/pages/87b330/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-669c40a0").then(t)}},{path:"/pages/87b330/index.html",redirect:"/pages/87b330/"},{path:"/03.Redis/08.缓存常见问题.html",redirect:"/pages/87b330/"},{name:"v-09ae1176",path:"/pages/c8420f/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-09ae1176").then(t)}},{path:"/pages/c8420f/index.html",redirect:"/pages/c8420f/"},{path:"/03.Redis/09.redis场景题.html",redirect:"/pages/c8420f/"},{name:"v-4050afac",path:"/pages/5f810a/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-4050afac").then(t)}},{path:"/pages/5f810a/index.html",redirect:"/pages/5f810a/"},{path:"/03.Redis/10.redis分布式锁.html",redirect:"/pages/5f810a/"},{name:"v-7dfe13a8",path:"/pages/fafd87/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-7dfe13a8").then(t)}},{path:"/pages/fafd87/index.html",redirect:"/pages/fafd87/"},{path:"/03.Redis/11.redis的rehash.html",redirect:"/pages/fafd87/"},{name:"v-3489417a",path:"/pages/network/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-3489417a").then(t)}},{path:"/pages/network/index.html",redirect:"/pages/network/"},{path:"/04.计算机网络/01.基础/01.网络协议分层.html",redirect:"/pages/network/"},{name:"v-f8c2901e",path:"/pages/f1d55e/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-f8c2901e").then(t)}},{path:"/pages/f1d55e/index.html",redirect:"/pages/f1d55e/"},{path:"/04.计算机网络/01.基础/02.浏览器存储.html",redirect:"/pages/f1d55e/"},{name:"v-053a73e8",path:"/pages/9ce3d9/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-053a73e8").then(t)}},{path:"/pages/9ce3d9/index.html",redirect:"/pages/9ce3d9/"},{path:"/04.计算机网络/01.基础/03.网络攻击.html",redirect:"/pages/9ce3d9/"},{name:"v-6379fc2e",path:"/pages/e1cd04/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-6379fc2e").then(t)}},{path:"/pages/e1cd04/index.html",redirect:"/pages/e1cd04/"},{path:"/04.计算机网络/02.应用层/01.http版本对比.html",redirect:"/pages/e1cd04/"},{name:"v-5140306c",path:"/pages/f502d9/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-5140306c").then(t)}},{path:"/pages/f502d9/index.html",redirect:"/pages/f502d9/"},{path:"/04.计算机网络/02.应用层/02.http.html",redirect:"/pages/f502d9/"},{name:"v-0b9e1aec",path:"/pages/43e2c1/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-0b9e1aec").then(t)}},{path:"/pages/43e2c1/index.html",redirect:"/pages/43e2c1/"},{path:"/04.计算机网络/02.应用层/03.https.html",redirect:"/pages/43e2c1/"},{name:"v-0bf64c24",path:"/pages/524e17/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-0bf64c24").then(t)}},{path:"/pages/524e17/index.html",redirect:"/pages/524e17/"},{path:"/04.计算机网络/02.应用层/04.dns.html",redirect:"/pages/524e17/"},{name:"v-2767b19c",path:"/pages/5e312c/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-2767b19c").then(t)}},{path:"/pages/5e312c/index.html",redirect:"/pages/5e312c/"},{path:"/04.计算机网络/03.传输层/01.tcp.html",redirect:"/pages/5e312c/"},{name:"v-1d611f27",path:"/pages/42791d/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-1d611f27").then(t)}},{path:"/pages/42791d/index.html",redirect:"/pages/42791d/"},{path:"/04.计算机网络/04.网络层/01.IP.html",redirect:"/pages/42791d/"},{name:"v-8153bf3c",path:"/pages/0b3887/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-8153bf3c").then(t)}},{path:"/pages/0b3887/index.html",redirect:"/pages/0b3887/"},{path:"/05.操作系统/02.Ctrl+C发生了什么.html",redirect:"/pages/0b3887/"},{name:"v-8f229662",path:"/pages/f45a99/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-8f229662").then(t)}},{path:"/pages/f45a99/index.html",redirect:"/pages/f45a99/"},{path:"/06.数据结构和算法/01.搜索效率为log的树.html",redirect:"/pages/f45a99/"},{name:"v-8bbcfd3a",path:"/pages/37ba80/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-8bbcfd3a").then(t)}},{path:"/pages/37ba80/index.html",redirect:"/pages/37ba80/"},{path:"/06.数据结构和算法/02.二分查找.html",redirect:"/pages/37ba80/"},{name:"v-45ced8ca",path:"/pages/os/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-45ced8ca").then(t)}},{path:"/pages/os/index.html",redirect:"/pages/os/"},{path:"/05.操作系统/01.操作系统.html",redirect:"/pages/os/"},{name:"v-50a497ba",path:"/pages/ceeb3f/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-50a497ba").then(t)}},{path:"/pages/ceeb3f/index.html",redirect:"/pages/ceeb3f/"},{path:"/05.操作系统/03.内存管理.html",redirect:"/pages/ceeb3f/"},{name:"v-d0cbc152",path:"/pages/d2945b/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-d0cbc152").then(t)}},{path:"/pages/d2945b/index.html",redirect:"/pages/d2945b/"},{path:"/06.数据结构和算法/03.二叉树.html",redirect:"/pages/d2945b/"},{name:"v-d35585c0",path:"/pages/redux/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-d35585c0").then(t)}},{path:"/pages/redux/index.html",redirect:"/pages/redux/"},{path:"/07.前端/01.React/01.redux.html",redirect:"/pages/redux/"},{name:"v-957f7b90",path:"/pages/2d7856/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-957f7b90").then(t)}},{path:"/pages/2d7856/index.html",redirect:"/pages/2d7856/"},{path:"/07.前端/01.React/02.概念.html",redirect:"/pages/2d7856/"},{name:"v-224a9095",path:"/pages/960017/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-224a9095").then(t)}},{path:"/pages/960017/index.html",redirect:"/pages/960017/"},{path:"/07.前端/01.React/快捷键.html",redirect:"/pages/960017/"},{name:"v-70032af0",path:"/pages/9ba4c3/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-70032af0").then(t)}},{path:"/pages/9ba4c3/index.html",redirect:"/pages/9ba4c3/"},{path:"/07.前端/01.js异步编程.html",redirect:"/pages/9ba4c3/"},{name:"v-10ca5dc4",path:"/pages/jwt/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-10ca5dc4").then(t)}},{path:"/pages/jwt/index.html",redirect:"/pages/jwt/"},{path:"/08.方案/01.JWT.html",redirect:"/pages/jwt/"},{name:"v-c92a649c",path:"/pages/8cac0f/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-c92a649c").then(t)}},{path:"/pages/8cac0f/index.html",redirect:"/pages/8cac0f/"},{path:"/08.方案/02.OAuth2.html",redirect:"/pages/8cac0f/"},{name:"v-76c98d70",path:"/pages/fcd0f1/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-76c98d70").then(t)}},{path:"/pages/fcd0f1/index.html",redirect:"/pages/fcd0f1/"},{path:"/08.方案/03.CORS的解决方案.html",redirect:"/pages/fcd0f1/"},{name:"v-ab00c88e",path:"/pages/95c00f/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-ab00c88e").then(t)}},{path:"/pages/95c00f/index.html",redirect:"/pages/95c00f/"},{path:"/08.方案/04.监控系统选型调研.html",redirect:"/pages/95c00f/"},{name:"v-6158f5dc",path:"/pages/165ba8/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-6158f5dc").then(t)}},{path:"/pages/165ba8/index.html",redirect:"/pages/165ba8/"},{path:"/08.方案/05.redis分布式锁实现.html",redirect:"/pages/165ba8/"},{name:"v-68d67e22",path:"/pages/spring/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-68d67e22").then(t)}},{path:"/pages/spring/index.html",redirect:"/pages/spring/"},{path:"/09.Java框架/01.Spring/01.Spring.html",redirect:"/pages/spring/"},{name:"v-097ed174",path:"/pages/581456/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-097ed174").then(t)}},{path:"/pages/581456/index.html",redirect:"/pages/581456/"},{path:"/09.Java框架/01.Spring/02.Spring boot 自动装配.html",redirect:"/pages/581456/"},{name:"v-629046d2",path:"/pages/0bf668/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-629046d2").then(t)}},{path:"/pages/0bf668/index.html",redirect:"/pages/0bf668/"},{path:"/09.Java框架/01.Spring/03.Spring IOC.html",redirect:"/pages/0bf668/"},{name:"v-80c46bea",path:"/pages/8c1a59/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-80c46bea").then(t)}},{path:"/pages/8c1a59/index.html",redirect:"/pages/8c1a59/"},{path:"/09.Java框架/01.Spring/04. Spring AOP.html",redirect:"/pages/8c1a59/"},{name:"v-1f84369c",path:"/pages/c3ac4e/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-1f84369c").then(t)}},{path:"/pages/c3ac4e/index.html",redirect:"/pages/c3ac4e/"},{path:"/09.Java框架/01.Spring/05.Spring MVC.html",redirect:"/pages/c3ac4e/"},{name:"v-e7bc6886",path:"/pages/e00296/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-e7bc6886").then(t)}},{path:"/pages/e00296/index.html",redirect:"/pages/e00296/"},{path:"/09.Java框架/01.Spring/06.Spring boot starter.html",redirect:"/pages/e00296/"},{name:"v-603745ce",path:"/pages/643d4f/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-603745ce").then(t)}},{path:"/pages/643d4f/index.html",redirect:"/pages/643d4f/"},{path:"/09.Java框架/01.Spring/07.BeanFactory和FactoryBean.html",redirect:"/pages/643d4f/"},{name:"v-4ae61c39",path:"/pages/329b73/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-4ae61c39").then(t)}},{path:"/pages/329b73/index.html",redirect:"/pages/329b73/"},{path:"/09.Java框架/01.Spring/08.Spring三级缓存解决循环依赖.html",redirect:"/pages/329b73/"},{name:"v-01e74dde",path:"/pages/40cb9b/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-01e74dde").then(t)}},{path:"/pages/40cb9b/index.html",redirect:"/pages/40cb9b/"},{path:"/10.中间件/01.Kafka/02.kafka零拷贝技术.html",redirect:"/pages/40cb9b/"},{name:"v-c9002668",path:"/pages/5e6384/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-c9002668").then(t)}},{path:"/pages/5e6384/index.html",redirect:"/pages/5e6384/"},{path:"/10.中间件/01.Kafka/Kafka多线程消费.html",redirect:"/pages/5e6384/"},{name:"v-129110e4",path:"/pages/279572/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-129110e4").then(t)}},{path:"/pages/279572/index.html",redirect:"/pages/279572/"},{path:"/10.中间件/02.RocketMQ.html",redirect:"/pages/279572/"},{name:"v-34c41a32",path:"/pages/0cf9ab/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-34c41a32").then(t)}},{path:"/pages/0cf9ab/index.html",redirect:"/pages/0cf9ab/"},{path:"/10.中间件/03.Flume快速上手.html",redirect:"/pages/0cf9ab/"},{name:"v-79517efc",path:"/pages/mq/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-79517efc").then(t)}},{path:"/pages/mq/index.html",redirect:"/pages/mq/"},{path:"/10.中间件/01.消息队列概述.html",redirect:"/pages/mq/"},{name:"v-6bc0f08b",path:"/pages/7c8ab7/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-6bc0f08b").then(t)}},{path:"/pages/7c8ab7/index.html",redirect:"/pages/7c8ab7/"},{path:"/10.中间件/04. RocketMQ 和 Kafka 对比.html",redirect:"/pages/7c8ab7/"},{name:"v-c1084aa0",path:"/pages/git/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-c1084aa0").then(t)}},{path:"/pages/git/index.html",redirect:"/pages/git/"},{path:"/100.工具/01.Git/01.Git commit message 规范.html",redirect:"/pages/git/"},{name:"v-4c9cf11f",path:"/pages/6f9bb5/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-4c9cf11f").then(t)}},{path:"/pages/6f9bb5/index.html",redirect:"/pages/6f9bb5/"},{path:"/100.工具/01.Git/02.合并提交-rebase.html",redirect:"/pages/6f9bb5/"},{name:"v-7181834a",path:"/pages/0974e8/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-7181834a").then(t)}},{path:"/pages/0974e8/index.html",redirect:"/pages/0974e8/"},{path:"/100.工具/01.Git/03.git pull和git fetch.html",redirect:"/pages/0974e8/"},{name:"v-ea66ad78",path:"/pages/c02964/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-ea66ad78").then(t)}},{path:"/pages/c02964/index.html",redirect:"/pages/c02964/"},{path:"/11. 设计模式/01.单例模式.html",redirect:"/pages/c02964/"},{name:"v-2ede7bc6",path:"/pages/aa154b/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-2ede7bc6").then(t)}},{path:"/pages/aa154b/index.html",redirect:"/pages/aa154b/"},{path:"/100.工具/03.Docker/01.Docker命令.html",redirect:"/pages/aa154b/"},{name:"v-165dc3de",path:"/pages/d3d9ca/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-165dc3de").then(t)}},{path:"/pages/d3d9ca/index.html",redirect:"/pages/d3d9ca/"},{path:"/100.工具/02.Linux/02.Linux命令.html",redirect:"/pages/d3d9ca/"},{name:"v-5798a127",path:"/pages/da6600/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-5798a127").then(t)}},{path:"/pages/da6600/index.html",redirect:"/pages/da6600/"},{path:"/11. 设计模式/02.工厂模式.html",redirect:"/pages/da6600/"},{name:"v-94d81df6",path:"/pages/aitools/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-94d81df6").then(t)}},{path:"/pages/aitools/index.html",redirect:"/pages/aitools/"},{path:"/12.AI/01.AI  tools.html",redirect:"/pages/aitools/"},{name:"v-49c893e5",path:"/pages/linux/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-49c893e5").then(t)}},{path:"/pages/linux/index.html",redirect:"/pages/linux/"},{path:"/100.工具/02.Linux/01.Linux常用命令.html",redirect:"/pages/linux/"},{name:"v-b28245d2",path:"/pages/e945bb/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-b28245d2").then(t)}},{path:"/pages/e945bb/index.html",redirect:"/pages/e945bb/"},{path:"/13.系统设计/01.集群搭建总思路.html",redirect:"/pages/e945bb/"},{name:"v-153f7b50",path:"/pages/27d05d/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-153f7b50").then(t)}},{path:"/pages/27d05d/index.html",redirect:"/pages/27d05d/"},{path:"/99.Code Snippet/01.QuickSort.html",redirect:"/pages/27d05d/"},{name:"v-be922ec8",path:"/pages/dfcd0a/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-be922ec8").then(t)}},{path:"/pages/dfcd0a/index.html",redirect:"/pages/dfcd0a/"},{path:"/99.Code Snippet/02.HeapSort.html",redirect:"/pages/dfcd0a/"},{name:"v-af878584",path:"/pages/c708a0/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-af878584").then(t)}},{path:"/pages/c708a0/index.html",redirect:"/pages/c708a0/"},{path:"/99.Code Snippet/03.Java实现生产者消费者模式.html",redirect:"/pages/c708a0/"},{name:"v-2ffbbf7d",path:"/pages/3c8ef8/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-2ffbbf7d").then(t)}},{path:"/pages/3c8ef8/index.html",redirect:"/pages/3c8ef8/"},{path:"/temp/chatgpt promt engineering for develpers.html",redirect:"/pages/3c8ef8/"},{name:"v-6d33b879",path:"/pages/a3d6e4/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-6d33b879").then(t)}},{path:"/pages/a3d6e4/index.html",redirect:"/pages/a3d6e4/"},{path:"/temp/gradle和maven对照.html",redirect:"/pages/a3d6e4/"},{name:"v-365b0049",path:"/pages/08f55c/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-365b0049").then(t)}},{path:"/pages/08f55c/index.html",redirect:"/pages/08f55c/"},{path:"/temp/jdk新特性.html",redirect:"/pages/08f55c/"},{name:"v-7ba276fa",path:"/pages/7a6f3c/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-7ba276fa").then(t)}},{path:"/pages/7a6f3c/index.html",redirect:"/pages/7a6f3c/"},{path:"/temp/juc-all.html",redirect:"/pages/7a6f3c/"},{name:"v-b0095412",path:"/pages/cf4cda/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-b0095412").then(t)}},{path:"/pages/cf4cda/index.html",redirect:"/pages/cf4cda/"},{path:"/temp/lombok的实现原理.html",redirect:"/pages/cf4cda/"},{name:"v-1689eec4",path:"/pages/252ef5/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-1689eec4").then(t)}},{path:"/pages/252ef5/index.html",redirect:"/pages/252ef5/"},{path:"/temp/prompt record.html",redirect:"/pages/252ef5/"},{name:"v-5aaf6e59",path:"/pages/144ecf/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-5aaf6e59").then(t)}},{path:"/pages/144ecf/index.html",redirect:"/pages/144ecf/"},{path:"/temp/sentinel.html",redirect:"/pages/144ecf/"},{name:"v-42d727d9",path:"/pages/d16eb4/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-42d727d9").then(t)}},{path:"/pages/d16eb4/index.html",redirect:"/pages/d16eb4/"},{path:"/temp/spring data rest.html",redirect:"/pages/d16eb4/"},{name:"v-91d0c51a",path:"/pages/cfda81/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-91d0c51a").then(t)}},{path:"/pages/cfda81/index.html",redirect:"/pages/cfda81/"},{path:"/temp/spring-temp.html",redirect:"/pages/cfda81/"},{name:"v-5bbea173",path:"/pages/9a2825/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-5bbea173").then(t)}},{path:"/pages/9a2825/index.html",redirect:"/pages/9a2825/"},{path:"/temp/springboot3.html",redirect:"/pages/9a2825/"},{name:"v-372121bc",path:"/pages/22b30f/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-372121bc").then(t)}},{path:"/pages/22b30f/index.html",redirect:"/pages/22b30f/"},{path:"/temp/tip: project oriented learning.html",redirect:"/pages/22b30f/"},{name:"v-4452d00c",path:"/pages/6796b2/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-4452d00c").then(t)}},{path:"/pages/6796b2/index.html",redirect:"/pages/6796b2/"},{path:"/temp/八股-mysql.html",redirect:"/pages/6796b2/"},{name:"v-5c5b6663",path:"/pages/7c006d/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-5c5b6663").then(t)}},{path:"/pages/7c006d/index.html",redirect:"/pages/7c006d/"},{path:"/temp/小知识.html",redirect:"/pages/7c006d/"},{name:"v-c4807e92",path:"/pages/fba198/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-c4807e92").then(t)}},{path:"/pages/fba198/index.html",redirect:"/pages/fba198/"},{path:"/temp/日语-promt.html",redirect:"/pages/fba198/"},{name:"v-3fb4f800",path:"/pages/5da819/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-3fb4f800").then(t)}},{path:"/pages/5da819/index.html",redirect:"/pages/5da819/"},{path:"/temp/日语动词.html",redirect:"/pages/5da819/"},{name:"v-dbde7360",path:"/pages/263c98/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-dbde7360").then(t)}},{path:"/pages/263c98/index.html",redirect:"/pages/263c98/"},{path:"/temp/集群和分布式.html",redirect:"/pages/263c98/"},{name:"v-61301819",path:"/archives/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-61301819").then(t)}},{path:"/archives/index.html",redirect:"/archives/"},{path:"/@pages/archivesPage.html",redirect:"/archives/"},{name:"v-262c459c",path:"/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-262c459c").then(t)}},{path:"/index.html",redirect:"/"},{name:"v-36ff78c4",path:"/pages/home/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-36ff78c4").then(t)}},{path:"/pages/home/index.html",redirect:"/pages/home/"},{path:"/知识体系总览.html",redirect:"/pages/home/"},{path:"*",component:bl}],kl={title:"Boundless wiki",description:"一个基于VuePress的 知识管理&博客 主题",base:"/",headTags:[["link",{rel:"icon",href:"/img/favicon.ico"}],["meta",{name:"keywords",content:"vuepress,theme,blog,vdoing"}],["meta",{name:"theme-color",content:"#11a8cd"}],["meta",{name:"wwads-cn-verify",content:"6c4b761a28b734fe93831e3fb400ce87"}],["script",{src:"https://cdn.wwads.cn/js/makemoney.js",type:"text/javascript"}]],pages:[{title:"Java 汇总",frontmatter:{title:"Java 汇总",date:"2023-03-16T23:35:49.000Z",permalink:"/pages/java/"},regularPath:"/01.Java/01.Java%E5%9F%BA%E7%A1%80/01.Java%E6%B1%87%E6%80%BB.html",relativePath:"01.Java/01.Java基础/01.Java汇总.md",key:"v-e78034fa",path:"/pages/java/",headers:[{level:2,title:"override和overload",slug:"override和overload",normalizedTitle:"override和overload",charIndex:2}],headersStr:"override和overload",content:"# override和overload\n\n * 重载 (Overload) 表示同一个类中可以有多个名称相同的方法，但这些方法的参数列表各不相同（即参数个数、类型或顺序不同）。\n * 重写 (Override) 表示子类中的方法可以与父类中的某个方法的名称 和参数完全相同，通过子类创建的实例对象调用这个方法时，将调用子类中的定义方法，这相当于把父类中定义的那 个完全相同的方法给覆盖了，这也是面向对象编程的多态性的一种表现。（备注：子类覆盖父类的方法时，只能比父类抛出更少的异常，或者是抛出父类抛出的异常 的子异常，因为子类可以解决父类的一些问题，不能比父类有更多的问题。子类方法的访问权限只能比父类的更大，不能更小。如果父类的方法 是 private 类型，那么，子类则不存在覆盖的限制，相当于子类中增加了一个全新的方法。）\n\n总之，重写 Overriding 是父类与子类之间多态性的一种表现，重载 Overloading 是一个类中多态性的一种表现。很重要的一点就是，Overloaded 的方法是可以改变返回值的类型。",normalizedContent:"# override和overload\n\n * 重载 (overload) 表示同一个类中可以有多个名称相同的方法，但这些方法的参数列表各不相同（即参数个数、类型或顺序不同）。\n * 重写 (override) 表示子类中的方法可以与父类中的某个方法的名称 和参数完全相同，通过子类创建的实例对象调用这个方法时，将调用子类中的定义方法，这相当于把父类中定义的那 个完全相同的方法给覆盖了，这也是面向对象编程的多态性的一种表现。（备注：子类覆盖父类的方法时，只能比父类抛出更少的异常，或者是抛出父类抛出的异常 的子异常，因为子类可以解决父类的一些问题，不能比父类有更多的问题。子类方法的访问权限只能比父类的更大，不能更小。如果父类的方法 是 private 类型，那么，子类则不存在覆盖的限制，相当于子类中增加了一个全新的方法。）\n\n总之，重写 overriding 是父类与子类之间多态性的一种表现，重载 overloading 是一个类中多态性的一种表现。很重要的一点就是，overloaded 的方法是可以改变返回值的类型。",charsets:{cjk:!0},lastUpdated:"2023/03/29, 21:03:43",lastUpdatedTimestamp:1680095023e3},{title:"接口和抽象类的区别",frontmatter:{title:"接口和抽象类的区别",date:"2023-03-18T09:27:04.000Z",permalink:"/pages/2ed256/"},regularPath:"/01.Java/01.Java%E5%9F%BA%E7%A1%80/02.%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB%E7%9A%84%E5%8C%BA%E5%88%AB.html",relativePath:"01.Java/01.Java基础/02.接口和抽象类的区别.md",key:"v-3e714d2a",path:"/pages/2ed256/",headers:[{level:2,title:"相同点：",slug:"相同点",normalizedTitle:"相同点：",charIndex:2},{level:2,title:"不同点：",slug:"不同点",normalizedTitle:"不同点：",charIndex:64},{level:2,title:"接口",slug:"接口",normalizedTitle:"接口",charIndex:23},{level:2,title:"抽象类",slug:"抽象类",normalizedTitle:"抽象类",charIndex:30}],headersStr:"相同点： 不同点： 接口 抽象类",content:"# 相同点：\n\n * 都不能被实例化。\n * 接口的实现类或抽象类的子类都只有实现了接口或抽象类中的方法后才能实例化。\n\n\n# 不同点：\n\n * 接口强调特定功能的实现，抽象类强调所属关系。\n * 接口的设计目的是对类的行为进行约束（一种“有”的约束）。抽象类的设计目的是代码复用。\n * 接口只能有定义，不能有方法的实现，Java1.8开始可以定义default方法。抽象类可以有定义和实现。\n * 接口成员变量默认为public static final，必须赋初值，不能被修改，成员方法都是public、abstract的。抽象类中的成员变量默认default，可在子类中被重新定义，重新赋值，抽象方法被abstract修饰，也可以有普通方法。\n * 一个类可以实现多个接口，但只能继承一个抽象类。\n\n一些理解：\n\n抽象类就是接口和普通类之间的过渡，抽象类初衷是代码复用，是因为他就是个类，但是用抽象方法这个东西也可以对子类进行一定程度上的约束，所以抽象类比较适合既有约束，又需要代码复用的场景。\n\n类通过继承实现抽象层次和具体实现的复用，但这样层次混乱，于是过渡到了抽象类，再演变为接口类+组合。\n\n接口主要是用来抽象方法功能。当你关注事物的本质的时候，请用抽象类；当你关注一种操作的时候，用接口。\n\n接口里面的方法只能声明，不能有具体的实现。这说明接口是设计的结果，抽象类是重构的结果。\n\n\n# 接口\n\n * Java中接口使用interface关键字修饰\n * 接口可以包含变量、方法；变量被隐式指定为public static final，方法被隐式指定为public abstract（JDK1.8之前）；（可以将接口方法标记为 public，将变量标记为 public static final。但 Java 语言规范建议不要书写这些多余的关键字。）\n * 接口支持多继承，即一个接口可以extends多个接口，间接的解决了Java中类的单继承问题；\n * 一个类可以实现多个接口；\n * JDK1.8中对接口增加了新的特性：\n   * 默认方法（default method）：JDK 1.8允许给接口添加非抽象的方法实现，但必须使用default关键字修饰；定义了default的方法可以不被实现子类所实现，但只能被实现子类的对象调用；如果子类实现了多个接口，并且这些接口包含一样的默认方法，则子类必须重写默认方法；\n   * 静态方法（static method）：JDK 1.8中允许使用static关键字修饰一个方法，并提供实现，称为接口静态方法。接口静态方法只能通过接口调用（接口名.静态方法名）。\n * 接口比抽象类还抽象。封装了接口的实现。可以降低代码的耦合度，提高代码的可维护性和可扩展性。\n\n\n# 抽象类\n\n * Java中被abstract关键字修饰的类称为抽象类，被abstract关键字修饰的方法称为抽象方法，抽象方法只有方法的声明，没有方法体。\n * 抽象类不能被实例化只能被继承；\n * 包含抽象方法的一定是抽象类，但是抽象类不一定含有抽象方法；\n * 抽象类中的抽象方法的修饰符只能为public或者protected，默认为public；\n * 一个子类继承一个抽象类，则子类必须实现父类抽象方法，否则子类也必须定义为抽象类；\n * 抽象类可以包含属性、方法、构造方法，但是构造方法不能用于实例化，主要用途是被子类调用。",normalizedContent:"# 相同点：\n\n * 都不能被实例化。\n * 接口的实现类或抽象类的子类都只有实现了接口或抽象类中的方法后才能实例化。\n\n\n# 不同点：\n\n * 接口强调特定功能的实现，抽象类强调所属关系。\n * 接口的设计目的是对类的行为进行约束（一种“有”的约束）。抽象类的设计目的是代码复用。\n * 接口只能有定义，不能有方法的实现，java1.8开始可以定义default方法。抽象类可以有定义和实现。\n * 接口成员变量默认为public static final，必须赋初值，不能被修改，成员方法都是public、abstract的。抽象类中的成员变量默认default，可在子类中被重新定义，重新赋值，抽象方法被abstract修饰，也可以有普通方法。\n * 一个类可以实现多个接口，但只能继承一个抽象类。\n\n一些理解：\n\n抽象类就是接口和普通类之间的过渡，抽象类初衷是代码复用，是因为他就是个类，但是用抽象方法这个东西也可以对子类进行一定程度上的约束，所以抽象类比较适合既有约束，又需要代码复用的场景。\n\n类通过继承实现抽象层次和具体实现的复用，但这样层次混乱，于是过渡到了抽象类，再演变为接口类+组合。\n\n接口主要是用来抽象方法功能。当你关注事物的本质的时候，请用抽象类；当你关注一种操作的时候，用接口。\n\n接口里面的方法只能声明，不能有具体的实现。这说明接口是设计的结果，抽象类是重构的结果。\n\n\n# 接口\n\n * java中接口使用interface关键字修饰\n * 接口可以包含变量、方法；变量被隐式指定为public static final，方法被隐式指定为public abstract（jdk1.8之前）；（可以将接口方法标记为 public，将变量标记为 public static final。但 java 语言规范建议不要书写这些多余的关键字。）\n * 接口支持多继承，即一个接口可以extends多个接口，间接的解决了java中类的单继承问题；\n * 一个类可以实现多个接口；\n * jdk1.8中对接口增加了新的特性：\n   * 默认方法（default method）：jdk 1.8允许给接口添加非抽象的方法实现，但必须使用default关键字修饰；定义了default的方法可以不被实现子类所实现，但只能被实现子类的对象调用；如果子类实现了多个接口，并且这些接口包含一样的默认方法，则子类必须重写默认方法；\n   * 静态方法（static method）：jdk 1.8中允许使用static关键字修饰一个方法，并提供实现，称为接口静态方法。接口静态方法只能通过接口调用（接口名.静态方法名）。\n * 接口比抽象类还抽象。封装了接口的实现。可以降低代码的耦合度，提高代码的可维护性和可扩展性。\n\n\n# 抽象类\n\n * java中被abstract关键字修饰的类称为抽象类，被abstract关键字修饰的方法称为抽象方法，抽象方法只有方法的声明，没有方法体。\n * 抽象类不能被实例化只能被继承；\n * 包含抽象方法的一定是抽象类，但是抽象类不一定含有抽象方法；\n * 抽象类中的抽象方法的修饰符只能为public或者protected，默认为public；\n * 一个子类继承一个抽象类，则子类必须实现父类抽象方法，否则子类也必须定义为抽象类；\n * 抽象类可以包含属性、方法、构造方法，但是构造方法不能用于实例化，主要用途是被子类调用。",charsets:{cjk:!0},lastUpdated:"2023/03/29, 21:03:43",lastUpdatedTimestamp:1680095023e3},{title:"反射相关",frontmatter:{title:"反射相关",date:"2023-09-05T23:47:07.000Z",permalink:"/pages/66f85c/"},regularPath:"/01.Java/01.Java%E5%9F%BA%E7%A1%80/03.%E5%8F%8D%E5%B0%84%E7%9B%B8%E5%85%B3.html",relativePath:"01.Java/01.Java基础/03.反射相关.md",key:"v-407e7564",path:"/pages/66f85c/",headers:[{level:2,title:"Class.getField和getDeclaredField的区别",slug:"class-getfield和getdeclaredfield的区别",normalizedTitle:"class.getfield和getdeclaredfield的区别",charIndex:2}],headersStr:"Class.getField和getDeclaredField的区别",content:'# Class.getField和getDeclaredField的区别\n\ngetField和getDeclaredField都是Class类的方法，反射成员变量时使用。(getMethod和getDeclaredMethod类似)\n\ngetField：获取一个类的 ==public成员变量，包括基类== 。\n\ngetDeclaredField：获取一个类的 ==所有成员变量，不包括基类== 。\n\nField.setAccessible：成员变量为private时，必须进行此操作。\n\npublic class MyUtil {    \n    \n    public static void main(String[] args) {    \n       testFields();    \n    }    \n        \n    public static void testFields() {    \n        try {    \n            System.out.println("Declared fields: ");    \n            Field[] fields = Dog.class.getDeclaredFields();    \n            for(int i = 0; i < fields.length; i++) {    \n                System.out.println(fields[i].getName()); // 此处结果是color, name, type, fur    \n            }    \n                \n            System.out.println("Public fields: ");    \n            fields = Dog.class.getFields();    \n            for(int i = 0; i < fields.length; i++) {    \n                System.out.println(fields[i].getName()); // 此处结果是color, location    \n            }    \n        } catch (Exception e) {    \n            e.printStackTrace();    \n        }    \n    }    \n    \n}    \n    \nclass Dog extends Animal {    \n    public int color;    \n    protected int name;    \n    private int type;    \n    int fur;    \n}    \n    \nclass Animal {    \n    public int location;    \n    protected int age;    \n    private int height;    \n    int length;        \n}\n',normalizedContent:'# class.getfield和getdeclaredfield的区别\n\ngetfield和getdeclaredfield都是class类的方法，反射成员变量时使用。(getmethod和getdeclaredmethod类似)\n\ngetfield：获取一个类的 ==public成员变量，包括基类== 。\n\ngetdeclaredfield：获取一个类的 ==所有成员变量，不包括基类== 。\n\nfield.setaccessible：成员变量为private时，必须进行此操作。\n\npublic class myutil {    \n    \n    public static void main(string[] args) {    \n       testfields();    \n    }    \n        \n    public static void testfields() {    \n        try {    \n            system.out.println("declared fields: ");    \n            field[] fields = dog.class.getdeclaredfields();    \n            for(int i = 0; i < fields.length; i++) {    \n                system.out.println(fields[i].getname()); // 此处结果是color, name, type, fur    \n            }    \n                \n            system.out.println("public fields: ");    \n            fields = dog.class.getfields();    \n            for(int i = 0; i < fields.length; i++) {    \n                system.out.println(fields[i].getname()); // 此处结果是color, location    \n            }    \n        } catch (exception e) {    \n            e.printstacktrace();    \n        }    \n    }    \n    \n}    \n    \nclass dog extends animal {    \n    public int color;    \n    protected int name;    \n    private int type;    \n    int fur;    \n}    \n    \nclass animal {    \n    public int location;    \n    protected int age;    \n    private int height;    \n    int length;        \n}\n',charsets:{cjk:!0}},{title:"语法记录",frontmatter:{title:"语法记录",date:"2023-03-26T11:18:05.000Z",permalink:"/pages/d95f75/"},regularPath:"/01.Java/01.Java%E5%9F%BA%E7%A1%80/100.%E8%AF%AD%E6%B3%95%E8%AE%B0%E5%BD%95.html",relativePath:"01.Java/01.Java基础/100.语法记录.md",key:"v-6a669cc4",path:"/pages/d95f75/",headers:[{level:2,title:"数组截取方法",slug:"数组截取方法",normalizedTitle:"数组截取方法",charIndex:2},{level:2,title:"lambda: set to array",slug:"lambda-set-to-array",normalizedTitle:"lambda: set to array",charIndex:250},{level:2,title:"筛选出所有年龄大于18岁的人，并按照姓名进行排序",slug:"筛选出所有年龄大于18岁的人-并按照姓名进行排序",normalizedTitle:"筛选出所有年龄大于18岁的人，并按照姓名进行排序",charIndex:367},{level:2,title:"Comparable.compareTo()和Comparator.compare()",slug:"comparable-compareto-和comparator-compare",normalizedTitle:"comparable.compareto()和comparator.compare()",charIndex:858},{level:2,title:"lambda mapToObj",slug:"lambda-maptoobj",normalizedTitle:"lambda maptoobj",charIndex:1147},{level:2,title:"lambda map",slug:"lambda-map",normalizedTitle:"lambda map",charIndex:1147},{level:2,title:"StringBuilder重用 清空数据方法",slug:"stringbuilder重用-清空数据方法",normalizedTitle:"stringbuilder重用 清空数据方法",charIndex:1595},{level:2,title:"List 转 int[]",slug:"list-转-int",normalizedTitle:"list 转 int[]",charIndex:1746}],headersStr:"数组截取方法 lambda: set to array 筛选出所有年龄大于18岁的人，并按照姓名进行排序 Comparable.compareTo()和Comparator.compare() lambda mapToObj lambda map StringBuilder重用 清空数据方法 List 转 int[]",content:'# 数组截取方法\n\n * System.arraycopy(source, sourceStartIndex, target, targetStartIndex, len);\n * int[] target = Arrays.copyOf(source, newLen);\n\n如果需要将一个数组的一部分复制到另一个数组中，并且已经有了目标数组，那么使用 System.arraycopy() 可能更加高效。如果需要复制整个数组并返回一个新的数组，则可以使用 Arrays.copyOf()。\n\n\n# lambda: set to array\n\nSet<Integer> set = new HashSet<>();\nint[] ints = set.stream().mapToInt(x -> x).toArray();\n\n\n\n# 筛选出所有年龄大于18岁的人，并按照姓名进行排序\n\nList<Person> people = Arrays.asList(new Person("John", 20), new Person("Mary", 25), new Person("Bob", 15));\n\nList<String> names = people.stream()\n                           .filter(person -> person.getAge() > 18)\n                           .sorted((p1, p2) -> p1.getName().compareTo(p2.getName()))\n                           .map(Person::getName)\n                           .collect(Collectors.toList());\n\n\n * compareTo\n\n * map\n\n * collect(Collectors.toList())\n\n\n# Comparable.compareTo()和Comparator.compare()\n\nComparable是一个接口，用于定义一个类的自然排序顺序，该接口中只有一个方法compareTo()。\n\nComparator是一个接口，用于定义一个比较器，该接口中只有一个方法compare()。\n\n两个方法的返回值都是一个整数，表示比较结果，如果返回负数表示比较者小于被比较者，返回0表示相等，返回正数表示比较者大于被比较者。\n\n它们的区别在于，Comparable.compareTo()方法用于自然排序，而Comparator.compare()方法用于自定义排序。\n\n\n# lambda mapToObj\n\nhttps://geek-docs.com/java/java-intstream/g_intstream-maptoobj-java.html\n\nString[] ss = Arrays.stream(nums).mapToObj(Integer::toString)\n        .sorted((s1, s2) -> (s1 + s2).compareTo(s2 + s1)).toArray(String[]::new);\n\n\n\n# lambda map\n\n整形数组在做很多操作之前要先boxed或者mapToObj\n\n整形数组转化为列表，需要先包装boxed\n\n Arrays.stream(nums).boxed().collect(Collectors.toList())\n Arrays.stream(buff).mapToObj(String::valueOf).collect(Collectors.joining(" "))\n\n\n\n# StringBuilder重用 清空数据方法\n\nStringBuilder 没有提供clear或empty方法。 清空有3种方法：\n\n 1. 新生成一个，旧的由系统自动回收 ;\n 2. 使用 sb.delete(0, sb.length());\n 3. 使用 sb.setLength(0);\n\n\n# List 转 int[]\n\nint[] arr = list.toArray(new int[0]);',normalizedContent:'# 数组截取方法\n\n * system.arraycopy(source, sourcestartindex, target, targetstartindex, len);\n * int[] target = arrays.copyof(source, newlen);\n\n如果需要将一个数组的一部分复制到另一个数组中，并且已经有了目标数组，那么使用 system.arraycopy() 可能更加高效。如果需要复制整个数组并返回一个新的数组，则可以使用 arrays.copyof()。\n\n\n# lambda: set to array\n\nset<integer> set = new hashset<>();\nint[] ints = set.stream().maptoint(x -> x).toarray();\n\n\n\n# 筛选出所有年龄大于18岁的人，并按照姓名进行排序\n\nlist<person> people = arrays.aslist(new person("john", 20), new person("mary", 25), new person("bob", 15));\n\nlist<string> names = people.stream()\n                           .filter(person -> person.getage() > 18)\n                           .sorted((p1, p2) -> p1.getname().compareto(p2.getname()))\n                           .map(person::getname)\n                           .collect(collectors.tolist());\n\n\n * compareto\n\n * map\n\n * collect(collectors.tolist())\n\n\n# comparable.compareto()和comparator.compare()\n\ncomparable是一个接口，用于定义一个类的自然排序顺序，该接口中只有一个方法compareto()。\n\ncomparator是一个接口，用于定义一个比较器，该接口中只有一个方法compare()。\n\n两个方法的返回值都是一个整数，表示比较结果，如果返回负数表示比较者小于被比较者，返回0表示相等，返回正数表示比较者大于被比较者。\n\n它们的区别在于，comparable.compareto()方法用于自然排序，而comparator.compare()方法用于自定义排序。\n\n\n# lambda maptoobj\n\nhttps://geek-docs.com/java/java-intstream/g_intstream-maptoobj-java.html\n\nstring[] ss = arrays.stream(nums).maptoobj(integer::tostring)\n        .sorted((s1, s2) -> (s1 + s2).compareto(s2 + s1)).toarray(string[]::new);\n\n\n\n# lambda map\n\n整形数组在做很多操作之前要先boxed或者maptoobj\n\n整形数组转化为列表，需要先包装boxed\n\n arrays.stream(nums).boxed().collect(collectors.tolist())\n arrays.stream(buff).maptoobj(string::valueof).collect(collectors.joining(" "))\n\n\n\n# stringbuilder重用 清空数据方法\n\nstringbuilder 没有提供clear或empty方法。 清空有3种方法：\n\n 1. 新生成一个，旧的由系统自动回收 ;\n 2. 使用 sb.delete(0, sb.length());\n 3. 使用 sb.setlength(0);\n\n\n# list 转 int[]\n\nint[] arr = list.toarray(new int[0]);',charsets:{cjk:!0},lastUpdated:"2023/03/29, 21:03:43",lastUpdatedTimestamp:1680095023e3},{title:"ArrayList",frontmatter:{title:"ArrayList",date:"2023-03-28T14:21:33.000Z",permalink:"/pages/collection/"},regularPath:"/01.Java/02.Java%E9%9B%86%E5%90%88/01.ArrayList.html",relativePath:"01.Java/02.Java集合/01.ArrayList.md",key:"v-3897df61",path:"/pages/collection/",headers:[{level:2,title:"ArrayList 和 LinkedList的区别",slug:"arraylist-和-linkedlist的区别",normalizedTitle:"arraylist 和 linkedlist的区别",charIndex:2},{level:2,title:"ArrayList的扩容机制",slug:"arraylist的扩容机制",normalizedTitle:"arraylist的扩容机制",charIndex:455},{level:2,title:"ArrayList的构造方法",slug:"arraylist的构造方法",normalizedTitle:"arraylist的构造方法",charIndex:832}],headersStr:"ArrayList 和 LinkedList的区别 ArrayList的扩容机制 ArrayList的构造方法",content:"# ArrayList 和 LinkedList的区别\n\nArrayList：底层是基于数组实现的，查找快，增删较慢；\n\nLinkedList：底层是基于链表实现的。确切的说是循环双向链表（JDK1.6 之前是双向循环链表、JDK1.7 之后取消了循环），查找慢、增删快。\n\nArrayList 的增删未必就是比 LinkedList 要慢：\n\n 1. 如果增删都是在末尾来操作【每次调用的都是 remove() 和 add()】，此时 ArrayList 就不需要移动和复制数组来进行操作了。如果数据量有百万级的时，速度是会比 LinkedList 要快的。\n 2. 如果删除操作的位置是在中间。由于 LinkedList 的消耗主要是在遍历上，ArrayList 的消耗主要是在移动和复制上（底层调用的是 arraycopy() 方法，是 native 方法）。LinkedList 的遍历速度是要慢于 ArrayList 的复制移动速度的如果数据量有百万级的时，还是 ArrayList 要快。\n\n\n# ArrayList的扩容机制\n\n 1. 当使用 add 方法的时候首先调用 ensureCapacityInternal 方法，传入 size+1 进去，检查是否需要扩充 elementData 数组的大小；\n 2. newCapacity = 扩充数组为原来的 1.5 倍(不能自定义)，如果还不够，就使用它指定要扩充的大小 minCapacity ，然后判断 minCapacity 是否大于 MAX_ARRAY_SIZE(Integer.MAX_VALUE – 8) ，如果大于，就取 Integer.MAX_VALUE；\n 3. 扩容的主要方法：grow；\n 4. ArrayList 中 copy 数组的核心就是 System.arraycopy 方法，将 original 数组的所有数据复制到 copy 数组中，这是一个本地方法。\n\n\n# ArrayList的构造方法\n\n * 无参构造（延迟初始化）\n   * 构造方法中将elementData初始化为空数组DEFAULTCAPACITY_EMPTY_ELEMENTDATA\n   * 当调用add方法添加第一个元素的时候，会进行扩容\n   * 扩容至大小为DEFAULT_CAPACITY=10\n * 有参构造 public ArrayList(int initialCapacity)\n   * 参数大于0，elementData初始化为initialCapacity大小的数组\n   * 参数等于0，elementData初始化为空数组\n   * 参数小于0，抛出异常",normalizedContent:"# arraylist 和 linkedlist的区别\n\narraylist：底层是基于数组实现的，查找快，增删较慢；\n\nlinkedlist：底层是基于链表实现的。确切的说是循环双向链表（jdk1.6 之前是双向循环链表、jdk1.7 之后取消了循环），查找慢、增删快。\n\narraylist 的增删未必就是比 linkedlist 要慢：\n\n 1. 如果增删都是在末尾来操作【每次调用的都是 remove() 和 add()】，此时 arraylist 就不需要移动和复制数组来进行操作了。如果数据量有百万级的时，速度是会比 linkedlist 要快的。\n 2. 如果删除操作的位置是在中间。由于 linkedlist 的消耗主要是在遍历上，arraylist 的消耗主要是在移动和复制上（底层调用的是 arraycopy() 方法，是 native 方法）。linkedlist 的遍历速度是要慢于 arraylist 的复制移动速度的如果数据量有百万级的时，还是 arraylist 要快。\n\n\n# arraylist的扩容机制\n\n 1. 当使用 add 方法的时候首先调用 ensurecapacityinternal 方法，传入 size+1 进去，检查是否需要扩充 elementdata 数组的大小；\n 2. newcapacity = 扩充数组为原来的 1.5 倍(不能自定义)，如果还不够，就使用它指定要扩充的大小 mincapacity ，然后判断 mincapacity 是否大于 max_array_size(integer.max_value – 8) ，如果大于，就取 integer.max_value；\n 3. 扩容的主要方法：grow；\n 4. arraylist 中 copy 数组的核心就是 system.arraycopy 方法，将 original 数组的所有数据复制到 copy 数组中，这是一个本地方法。\n\n\n# arraylist的构造方法\n\n * 无参构造（延迟初始化）\n   * 构造方法中将elementdata初始化为空数组defaultcapacity_empty_elementdata\n   * 当调用add方法添加第一个元素的时候，会进行扩容\n   * 扩容至大小为default_capacity=10\n * 有参构造 public arraylist(int initialcapacity)\n   * 参数大于0，elementdata初始化为initialcapacity大小的数组\n   * 参数等于0，elementdata初始化为空数组\n   * 参数小于0，抛出异常",charsets:{cjk:!0},lastUpdated:"2023/03/29, 21:03:43",lastUpdatedTimestamp:1680095023e3},{title:"HashMap",frontmatter:{title:"HashMap",date:"2023-03-28T14:22:29.000Z",permalink:"/pages/d249ac/"},regularPath:"/01.Java/02.Java%E9%9B%86%E5%90%88/02.HashMap.html",relativePath:"01.Java/02.Java集合/02.HashMap.md",key:"v-5ddc5e71",path:"/pages/d249ac/",headers:[{level:2,title:"HashMap的底层数据结构",slug:"hashmap的底层数据结构",normalizedTitle:"hashmap的底层数据结构",charIndex:2},{level:2,title:"HashMap的put方法执行过程",slug:"hashmap的put方法执行过程",normalizedTitle:"hashmap的put方法执行过程",charIndex:21},{level:2,title:"HashMap的get方法执行过程",slug:"hashmap的get方法执行过程",normalizedTitle:"hashmap的get方法执行过程",charIndex:43},{level:2,title:"HashMap的resize方法执行过程",slug:"hashmap的resize方法执行过程",normalizedTitle:"hashmap的resize方法执行过程",charIndex:65},{level:2,title:"HashMap的size为什么必须是2的整数次方",slug:"hashmap的size为什么必须是2的整数次方",normalizedTitle:"hashmap的size为什么必须是2的整数次方",charIndex:3276},{level:2,title:"HashMap多线程死循环问题",slug:"hashmap多线程死循环问题",normalizedTitle:"hashmap多线程死循环问题",charIndex:3606},{level:2,title:"HashMap 的 get 方法的返回值能否判断某个元素是否在 map 中",slug:"hashmap-的-get-方法的返回值能否判断某个元素是否在-map-中",normalizedTitle:"hashmap 的 get 方法的返回值能否判断某个元素是否在 map 中",charIndex:4406}],headersStr:"HashMap的底层数据结构 HashMap的put方法执行过程 HashMap的get方法执行过程 HashMap的resize方法执行过程 HashMap的size为什么必须是2的整数次方 HashMap多线程死循环问题 HashMap 的 get 方法的返回值能否判断某个元素是否在 map 中",content:'# HashMap的底层数据结构\n\n\n# HashMap的put方法执行过程\n\n\n# HashMap的get方法执行过程\n\n\n# HashMap的resize方法执行过程\n\n 1. 创建一个两倍的新数组 newCap = oldCap << 1\n 2. 循环旧数组，循环链表，对每个元素 rehash。\n    1. 新位置会是旧位置，或者是旧位置+原数组长度。所以就分了两个 node 链表去存。即原列表会分散成2个。\n\nfinal Node<K,V>[] resize() {\n        Node<K,V>[] oldTab = table;\n        int oldCap = (oldTab == null) ? 0 : oldTab.length;\n        int oldThr = threshold;\n        int newCap, newThr = 0;\n        if (oldCap > 0) {\n            if (oldCap >= MAXIMUM_CAPACITY) {\n                threshold = Integer.MAX_VALUE;\n                return oldTab;\n            }\n            else if ((newCap = oldCap << 1) < MAXIMUM_CAPACITY &&\n                     oldCap >= DEFAULT_INITIAL_CAPACITY)\n                newThr = oldThr << 1; // double threshold\n        }\n        else if (oldThr > 0) // initial capacity was placed in threshold\n            newCap = oldThr;\n        else {               // zero initial threshold signifies using defaults\n            newCap = DEFAULT_INITIAL_CAPACITY;\n            newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);\n        }\n        if (newThr == 0) {\n            float ft = (float)newCap * loadFactor;\n            newThr = (newCap < MAXIMUM_CAPACITY && ft < (float)MAXIMUM_CAPACITY ?\n                      (int)ft : Integer.MAX_VALUE);\n        }\n        threshold = newThr;\n        @SuppressWarnings({"rawtypes","unchecked"})\n        Node<K,V>[] newTab = (Node<K,V>[])new Node[newCap];\n        table = newTab;\n        if (oldTab != null) {\n            for (int j = 0; j < oldCap; ++j) {\n                Node<K,V> e;\n                if ((e = oldTab[j]) != null) {\n                    oldTab[j] = null;\n                    if (e.next == null)\n                        newTab[e.hash & (newCap - 1)] = e;\n                    else if (e instanceof TreeNode)\n                        ((TreeNode<K,V>)e).split(this, newTab, j, oldCap);\n                    else { // preserve order\n                        Node<K,V> loHead = null, loTail = null;\n                        Node<K,V> hiHead = null, hiTail = null;\n                        Node<K,V> next;\n                        do {\n                            next = e.next;\n                            if ((e.hash & oldCap) == 0) {\n                                if (loTail == null)\n                                    loHead = e;\n                                else\n                                    loTail.next = e;\n                                loTail = e;\n                            }\n                            else {\n                                if (hiTail == null)\n                                    hiHead = e;\n                                else\n                                    hiTail.next = e;\n                                hiTail = e;\n                            }\n                        } while ((e = next) != null);\n                        if (loTail != null) {\n                            loTail.next = null;\n                            newTab[j] = loHead;\n                        }\n                        if (hiTail != null) {\n                            hiTail.next = null;\n                            newTab[j + oldCap] = hiHead;\n                        }\n                    }\n                }\n            }\n        }\n        return newTab;\n    }\n\n\n\n# HashMap的size为什么必须是2的整数次方\n\n因为元素在数组中的位置是根据 hash & (size - 1)获取的，这个操作只有当size为2的n次幂时，才等价于取余操作。\n\n速度比直接取余快得多，并且没有空间浪费。\n\n如果 length 不是 2 的次幂，比如：length 为 15，则 length – 1 为 14，对应的二进制为 1110，在于 h 与操作，最后一位都为 0 ，而 0001，0011，0101，1001，1011，0111，1101 这几个位置永远都不能存放元素了，空间浪费相当大，更糟的是这种情况中，数组可以使用的位置比数组长度小了很多，这意味着进一步增加了碰撞的几率，减慢了查询的效率，这样就会造成空间的浪费。\n\n\n# HashMap多线程死循环问题\n\nJava 1.8前：\n\n在多线程环境下，使用HashMap可能会出现死循环问题，具体原因是由于HashMap在进行扩容（resize）操作时，如果多个线程同时执行resize操作，可能会导致其中一个线程扩容时对链表进行拆分时，另一个线程并不知道已经被拆分，仍然在原来的链表上遍历，从而造成死循环。扩容过程中使用头插法将oldTable中的单链表中的节点插入到newTable的单链表中，所以newTable中的单链表会倒置oldTable中的单链表。那么在多个线程同时扩容的情况下就可能导致扩容后的HashMap中存在一个有环的单链表，从而导致后续执行get操作的时候，会触发死循环，引起CPU的100%问题。\n\n解决该问题的方法一般有以下几种：\n\n 1. 使用线程安全的Map实现，如ConcurrentHashMap等。\n 2. 在多线程环境下，尽量避免对同一个HashMap进行并发修改操作，可以使用分段锁等方法进行同步控制。\n 3. 在HashMap中，将容量阈值设得足够大，以减少resize操作的频率，从而降低出现死循环的概率。\n 4. 使用其他的数据结构，如TreeMap、LinkedHashMap等，这些数据结构在一定程度上避免了哈希冲突的问题。\n\n虽然Java1.8采用尾插法解决了多线程下可能出现的死循环问题，但如果在多线程环境下对同一个HashMap进行并发修改操作，仍然可能会发生一些其他的线程安全问题，如并发插入（数据覆盖问题）、删除、遍历等操作可能会导致数据不一致或者ConcurrentModificationException异常等问题，因此在使用HashMap时仍然需要注意线程安全问题。为了避免这些问题，可以选择使用线程安全的Map实现，如ConcurrentHashMap，或者通过合适的同步控制方式来保证线程安全。\n\n\n# HashMap 的 get 方法的返回值能否判断某个元素是否在 map 中\n\n不能。因为 get 返回 null 有可能是不包含该 key，也有可能该 key 对应的 value 为 null。因为 HashMap 中允许 key 为 null，也允许 value 为 null。',normalizedContent:'# hashmap的底层数据结构\n\n\n# hashmap的put方法执行过程\n\n\n# hashmap的get方法执行过程\n\n\n# hashmap的resize方法执行过程\n\n 1. 创建一个两倍的新数组 newcap = oldcap << 1\n 2. 循环旧数组，循环链表，对每个元素 rehash。\n    1. 新位置会是旧位置，或者是旧位置+原数组长度。所以就分了两个 node 链表去存。即原列表会分散成2个。\n\nfinal node<k,v>[] resize() {\n        node<k,v>[] oldtab = table;\n        int oldcap = (oldtab == null) ? 0 : oldtab.length;\n        int oldthr = threshold;\n        int newcap, newthr = 0;\n        if (oldcap > 0) {\n            if (oldcap >= maximum_capacity) {\n                threshold = integer.max_value;\n                return oldtab;\n            }\n            else if ((newcap = oldcap << 1) < maximum_capacity &&\n                     oldcap >= default_initial_capacity)\n                newthr = oldthr << 1; // double threshold\n        }\n        else if (oldthr > 0) // initial capacity was placed in threshold\n            newcap = oldthr;\n        else {               // zero initial threshold signifies using defaults\n            newcap = default_initial_capacity;\n            newthr = (int)(default_load_factor * default_initial_capacity);\n        }\n        if (newthr == 0) {\n            float ft = (float)newcap * loadfactor;\n            newthr = (newcap < maximum_capacity && ft < (float)maximum_capacity ?\n                      (int)ft : integer.max_value);\n        }\n        threshold = newthr;\n        @suppresswarnings({"rawtypes","unchecked"})\n        node<k,v>[] newtab = (node<k,v>[])new node[newcap];\n        table = newtab;\n        if (oldtab != null) {\n            for (int j = 0; j < oldcap; ++j) {\n                node<k,v> e;\n                if ((e = oldtab[j]) != null) {\n                    oldtab[j] = null;\n                    if (e.next == null)\n                        newtab[e.hash & (newcap - 1)] = e;\n                    else if (e instanceof treenode)\n                        ((treenode<k,v>)e).split(this, newtab, j, oldcap);\n                    else { // preserve order\n                        node<k,v> lohead = null, lotail = null;\n                        node<k,v> hihead = null, hitail = null;\n                        node<k,v> next;\n                        do {\n                            next = e.next;\n                            if ((e.hash & oldcap) == 0) {\n                                if (lotail == null)\n                                    lohead = e;\n                                else\n                                    lotail.next = e;\n                                lotail = e;\n                            }\n                            else {\n                                if (hitail == null)\n                                    hihead = e;\n                                else\n                                    hitail.next = e;\n                                hitail = e;\n                            }\n                        } while ((e = next) != null);\n                        if (lotail != null) {\n                            lotail.next = null;\n                            newtab[j] = lohead;\n                        }\n                        if (hitail != null) {\n                            hitail.next = null;\n                            newtab[j + oldcap] = hihead;\n                        }\n                    }\n                }\n            }\n        }\n        return newtab;\n    }\n\n\n\n# hashmap的size为什么必须是2的整数次方\n\n因为元素在数组中的位置是根据 hash & (size - 1)获取的，这个操作只有当size为2的n次幂时，才等价于取余操作。\n\n速度比直接取余快得多，并且没有空间浪费。\n\n如果 length 不是 2 的次幂，比如：length 为 15，则 length – 1 为 14，对应的二进制为 1110，在于 h 与操作，最后一位都为 0 ，而 0001，0011，0101，1001，1011，0111，1101 这几个位置永远都不能存放元素了，空间浪费相当大，更糟的是这种情况中，数组可以使用的位置比数组长度小了很多，这意味着进一步增加了碰撞的几率，减慢了查询的效率，这样就会造成空间的浪费。\n\n\n# hashmap多线程死循环问题\n\njava 1.8前：\n\n在多线程环境下，使用hashmap可能会出现死循环问题，具体原因是由于hashmap在进行扩容（resize）操作时，如果多个线程同时执行resize操作，可能会导致其中一个线程扩容时对链表进行拆分时，另一个线程并不知道已经被拆分，仍然在原来的链表上遍历，从而造成死循环。扩容过程中使用头插法将oldtable中的单链表中的节点插入到newtable的单链表中，所以newtable中的单链表会倒置oldtable中的单链表。那么在多个线程同时扩容的情况下就可能导致扩容后的hashmap中存在一个有环的单链表，从而导致后续执行get操作的时候，会触发死循环，引起cpu的100%问题。\n\n解决该问题的方法一般有以下几种：\n\n 1. 使用线程安全的map实现，如concurrenthashmap等。\n 2. 在多线程环境下，尽量避免对同一个hashmap进行并发修改操作，可以使用分段锁等方法进行同步控制。\n 3. 在hashmap中，将容量阈值设得足够大，以减少resize操作的频率，从而降低出现死循环的概率。\n 4. 使用其他的数据结构，如treemap、linkedhashmap等，这些数据结构在一定程度上避免了哈希冲突的问题。\n\n虽然java1.8采用尾插法解决了多线程下可能出现的死循环问题，但如果在多线程环境下对同一个hashmap进行并发修改操作，仍然可能会发生一些其他的线程安全问题，如并发插入（数据覆盖问题）、删除、遍历等操作可能会导致数据不一致或者concurrentmodificationexception异常等问题，因此在使用hashmap时仍然需要注意线程安全问题。为了避免这些问题，可以选择使用线程安全的map实现，如concurrenthashmap，或者通过合适的同步控制方式来保证线程安全。\n\n\n# hashmap 的 get 方法的返回值能否判断某个元素是否在 map 中\n\n不能。因为 get 返回 null 有可能是不包含该 key，也有可能该 key 对应的 value 为 null。因为 hashmap 中允许 key 为 null，也允许 value 为 null。',charsets:{cjk:!0},lastUpdated:"2023/03/29, 21:03:43",lastUpdatedTimestamp:1680095023e3},{title:"BlockingQueue",frontmatter:{title:"BlockingQueue",date:"2023-04-02T19:22:58.000Z",permalink:"/pages/86b6a3/"},regularPath:"/01.Java/02.Java%E9%9B%86%E5%90%88/03.%20BlockingQueue.html",relativePath:"01.Java/02.Java集合/03. BlockingQueue.md",key:"v-6f5fe4a4",path:"/pages/86b6a3/",headers:[{level:2,title:"put",slug:"put",normalizedTitle:"put",charIndex:75},{level:2,title:"take",slug:"take",normalizedTitle:"take",charIndex:79}],headersStr:"put take",content:"三组功能类似的方法：\n\n * 抛出异常：add、remove、element\n * 返回结果但不抛出异常：offer、poll、peek\n * 阻塞：put、take\n\nadd、offer都是返回 boolean。\n\nremove、element、poll、peek都是返回element，poll、peek没有时返回null。\n\n区别仅在于：当队列满时无法添加元素，或队列空了无法移除元素时的不同处理方式。\n\n第一组的特点是在无法正常执行的情况下抛出异常；\n\n第二组的特点是在无法正常执行的情况下不抛出异常，但会用返回值提示运行失败；\n\n第三组的特点是在遇到特殊情况时让线程陷入阻塞状态，等到可以运行再继续执行。\n\n\n# put\n\nput 方法的作用是插入元素。通常在队列没满的时候是正常的插入，但是如果队列已满就无法继续插入，这时它既不会立刻返回 false 也不会抛出异常，而是让插入的线程陷入阻塞状态，直到队列里有了空闲空间，此时队列就会让之前的线程解除阻塞状态，并把刚才那个元素添加进去。\n\n\n# take\n\ntake 方法的作用是获取并移除队列的头结点。通常在队列里有数据的时候会正常取出数据并删除；但是如果执行 take 的时候队列里无数据，则阻塞，直到队列里有数据；一旦队列里有数据了，就会立刻解除阻塞状态，并且取到数据。",normalizedContent:"三组功能类似的方法：\n\n * 抛出异常：add、remove、element\n * 返回结果但不抛出异常：offer、poll、peek\n * 阻塞：put、take\n\nadd、offer都是返回 boolean。\n\nremove、element、poll、peek都是返回element，poll、peek没有时返回null。\n\n区别仅在于：当队列满时无法添加元素，或队列空了无法移除元素时的不同处理方式。\n\n第一组的特点是在无法正常执行的情况下抛出异常；\n\n第二组的特点是在无法正常执行的情况下不抛出异常，但会用返回值提示运行失败；\n\n第三组的特点是在遇到特殊情况时让线程陷入阻塞状态，等到可以运行再继续执行。\n\n\n# put\n\nput 方法的作用是插入元素。通常在队列没满的时候是正常的插入，但是如果队列已满就无法继续插入，这时它既不会立刻返回 false 也不会抛出异常，而是让插入的线程陷入阻塞状态，直到队列里有了空闲空间，此时队列就会让之前的线程解除阻塞状态，并把刚才那个元素添加进去。\n\n\n# take\n\ntake 方法的作用是获取并移除队列的头结点。通常在队列里有数据的时候会正常取出数据并删除；但是如果执行 take 的时候队列里无数据，则阻塞，直到队列里有数据；一旦队列里有数据了，就会立刻解除阻塞状态，并且取到数据。",charsets:{cjk:!0}},{title:"Java内存模型",frontmatter:{title:"Java内存模型",date:"2023-03-19T15:23:08.000Z",permalink:"/pages/jvm/"},regularPath:"/01.Java/03.JVM/01.Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.html",relativePath:"01.Java/03.JVM/01.Java内存模型.md",key:"v-5ec93f7b",path:"/pages/jvm/",headers:[{level:2,title:"volatile 和 synchronized",slug:"volatile-和-synchronized",normalizedTitle:"volatile 和 synchronized",charIndex:359}],headersStr:"volatile 和 synchronized",content:"Java Memory Model，JMM\n\n缓存会带来缓存一致性的问题。通常通过各种协议解决。\n\n这里的主内存、工作内存与Java内存区域中的Java堆、栈、方法区等不是一个概念，没有关系。\n\n * Java内存模型规定了所有的变量都存储在主内存中。\n * 每条线程还有自己的工作内存，线程中的工作内存中保存了被该线程使用的变量的主内存副本，线程对变量的所有操作（读取、赋值等）都必须在工作内存中进行，而不能直接读写主内存中的数据。\n * 不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量值的传递均需要通过主内存来完成。\n\n这里说的变量与java编程中的变量有所区别，它包括了实例字段、静态字段和构成数组对象的元素，但是不包括局部变量与方法参数，因为是线程私有的，不会被共享，不会存在竞争问题。\n\n\n# volatile 和 synchronized",normalizedContent:"java memory model，jmm\n\n缓存会带来缓存一致性的问题。通常通过各种协议解决。\n\n这里的主内存、工作内存与java内存区域中的java堆、栈、方法区等不是一个概念，没有关系。\n\n * java内存模型规定了所有的变量都存储在主内存中。\n * 每条线程还有自己的工作内存，线程中的工作内存中保存了被该线程使用的变量的主内存副本，线程对变量的所有操作（读取、赋值等）都必须在工作内存中进行，而不能直接读写主内存中的数据。\n * 不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量值的传递均需要通过主内存来完成。\n\n这里说的变量与java编程中的变量有所区别，它包括了实例字段、静态字段和构成数组对象的元素，但是不包括局部变量与方法参数，因为是线程私有的，不会被共享，不会存在竞争问题。\n\n\n# volatile 和 synchronized",charsets:{cjk:!0},lastUpdated:"2023/03/29, 21:03:43",lastUpdatedTimestamp:1680095023e3},{title:"类加载机制",frontmatter:{title:"类加载机制",date:"2023-03-19T15:24:12.000Z",permalink:"/pages/7d816e/"},regularPath:"/01.Java/03.JVM/02.%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6.html",relativePath:"01.Java/03.JVM/02.类加载机制.md",key:"v-77eb69ec",path:"/pages/7d816e/",headers:[{level:2,title:"类的生命周期",slug:"类的生命周期",normalizedTitle:"类的生命周期",charIndex:2},{level:2,title:"类加载",slug:"类加载",normalizedTitle:"类加载",charIndex:87},{level:2,title:"类加载器",slug:"类加载器",normalizedTitle:"类加载器",charIndex:726},{level:2,title:"双亲委派模型（Parents Delegation Model）",slug:"双亲委派模型-parents-delegation-model",normalizedTitle:"双亲委派模型（parents delegation model）",charIndex:1323},{level:2,title:"Java模块化系统（JDK 9）",slug:"java模块化系统-jdk-9",normalizedTitle:"java模块化系统（jdk 9）",charIndex:1761}],headersStr:"类的生命周期 类加载 类加载器 双亲委派模型（Parents Delegation Model） Java模块化系统（JDK 9）",content:"# 类的生命周期\n\nJava虚拟机把描述类的数据从class文件加载到内存，并对数据进行验证、解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这个过程被称作虚拟机的类加载机制。\n\n与那些在编译器需要进行连接的语言不同，在Java语言里，类型的加载、连接和初始化都是在程序运行期间完成的。\n\n一个类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期将会经历7个阶段。\n\n\n\n\n# 类加载\n\n类加载全过程：加载、验证、准备、解析、初始化。\n\n * 加载：主要是在内存中生成一个代表这个类的 Class 对象，作为方法区这个类的访问入口\n\n * 连接\n   \n   * 验证：确保 Class 文件的字节流满足“Java虚拟机规范”\n   * 准备：给类中定义的变量（static 修饰的静态变量）分配内存并设置初始值。\n   * 解析：将常量池中的符号引用替换为直接引用的过程。\n     * 符号引用是“Java虚拟机规范”所定义的 Class 文件格式。比如CONSTAN_class_info 这些变量\n     * 直接引用是可以直接指向目标的指针、相对偏移量或能间接定位到目标的句柄。有了直接引用，引用的对象必定在虚拟机的内存中存在。\n\n * 初始化：执行类构造器方法\n\n第一阶段，加载阶段（Loading）：虚拟完成三件事\n\n * 通过类的全限定名获取其定义的二进制字节流（.class）。【class loader】\n * 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。\n * 在 Java 堆中生成一个代表这个类的 java.lang.Class 对象，作为对方法区中这些数据的访问入口。\n\n\n\n\n# 类加载器\n\nJava虚拟机设计团队有意把类加载阶段中的“通过一个类的全限定名来获取描述该类的二进制字节流”这个动作放到Java虚拟机外部去实现， 以便让应用程序自己决定如何去获取所需的类。 实现这个动作的代码被称为“类加载器”（Class Loader） 。\n\nJDK 9 之前：\n\n绝大多数Java程序都会使用到以下3个系统提供的类加载器来进行加载。\n\n 1. 启动类加载器 Bootstrap Class Loader：负责加载存放在 <JAVA_HOME>\\lib目录，或被 -Xbootclasspath参数所指定的路径中存放的，并且是Java虚拟机能识别的类库加载到虚拟机的内存中。（eg：rt.jar、tools.jar）\n 2. 扩展类加载器 Extension Class Loader：负责加载 <JAVA_HOME>\\lib\\ext目录，或被 java.ext.dirs系统变量所指定的路径中所有的类库。\n 3. 应用程序类加载器/系统类加载器 Application Class Loader：负责加载用户类路径（ClassPath）上所有的类库。如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。\n\n如果有需要，还可以自定义类加载器。eg：增加除了磁盘位置之外的Class文件来源， 或者通过类加载器实现类的隔离、 重载等功能。\n\n\n# 双亲委派模型（Parents Delegation Model）\n\n双亲委派模型的工作过程是： 如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到最顶层的启动类加载器中，只有当父类加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去完成加载。\n\n使用双亲委派模型来组织类加载器之间的关系， 一个显而易见的好处就是Java中的类随着它的类加载器一起具备了一种带有优先级的层次关系。 例如类java.lang.Object， 它存放在rt.jar之中， 无论哪一个类加载器要加载这个类， 最终都是委派给处于模型最顶端的启动类加载器进行加载， 因此Object类在程序的各种类加载器环境中都能够保证是同一个类。\n\n优点：\n\n * 防止内存中出现多份同样字节码的系统类。\n * 保证 Java 程序安全稳定运行。\n\n\n# Java模块化系统（JDK 9）",normalizedContent:"# 类的生命周期\n\njava虚拟机把描述类的数据从class文件加载到内存，并对数据进行验证、解析和初始化，最终形成可以被虚拟机直接使用的java类型，这个过程被称作虚拟机的类加载机制。\n\n与那些在编译器需要进行连接的语言不同，在java语言里，类型的加载、连接和初始化都是在程序运行期间完成的。\n\n一个类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期将会经历7个阶段。\n\n\n\n\n# 类加载\n\n类加载全过程：加载、验证、准备、解析、初始化。\n\n * 加载：主要是在内存中生成一个代表这个类的 class 对象，作为方法区这个类的访问入口\n\n * 连接\n   \n   * 验证：确保 class 文件的字节流满足“java虚拟机规范”\n   * 准备：给类中定义的变量（static 修饰的静态变量）分配内存并设置初始值。\n   * 解析：将常量池中的符号引用替换为直接引用的过程。\n     * 符号引用是“java虚拟机规范”所定义的 class 文件格式。比如constan_class_info 这些变量\n     * 直接引用是可以直接指向目标的指针、相对偏移量或能间接定位到目标的句柄。有了直接引用，引用的对象必定在虚拟机的内存中存在。\n\n * 初始化：执行类构造器方法\n\n第一阶段，加载阶段（loading）：虚拟完成三件事\n\n * 通过类的全限定名获取其定义的二进制字节流（.class）。【class loader】\n * 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。\n * 在 java 堆中生成一个代表这个类的 java.lang.class 对象，作为对方法区中这些数据的访问入口。\n\n\n\n\n# 类加载器\n\njava虚拟机设计团队有意把类加载阶段中的“通过一个类的全限定名来获取描述该类的二进制字节流”这个动作放到java虚拟机外部去实现， 以便让应用程序自己决定如何去获取所需的类。 实现这个动作的代码被称为“类加载器”（class loader） 。\n\njdk 9 之前：\n\n绝大多数java程序都会使用到以下3个系统提供的类加载器来进行加载。\n\n 1. 启动类加载器 bootstrap class loader：负责加载存放在 <java_home>\\lib目录，或被 -xbootclasspath参数所指定的路径中存放的，并且是java虚拟机能识别的类库加载到虚拟机的内存中。（eg：rt.jar、tools.jar）\n 2. 扩展类加载器 extension class loader：负责加载 <java_home>\\lib\\ext目录，或被 java.ext.dirs系统变量所指定的路径中所有的类库。\n 3. 应用程序类加载器/系统类加载器 application class loader：负责加载用户类路径（classpath）上所有的类库。如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。\n\n如果有需要，还可以自定义类加载器。eg：增加除了磁盘位置之外的class文件来源， 或者通过类加载器实现类的隔离、 重载等功能。\n\n\n# 双亲委派模型（parents delegation model）\n\n双亲委派模型的工作过程是： 如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到最顶层的启动类加载器中，只有当父类加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去完成加载。\n\n使用双亲委派模型来组织类加载器之间的关系， 一个显而易见的好处就是java中的类随着它的类加载器一起具备了一种带有优先级的层次关系。 例如类java.lang.object， 它存放在rt.jar之中， 无论哪一个类加载器要加载这个类， 最终都是委派给处于模型最顶端的启动类加载器进行加载， 因此object类在程序的各种类加载器环境中都能够保证是同一个类。\n\n优点：\n\n * 防止内存中出现多份同样字节码的系统类。\n * 保证 java 程序安全稳定运行。\n\n\n# java模块化系统（jdk 9）",charsets:{cjk:!0},lastUpdated:"2023/03/29, 21:03:43",lastUpdatedTimestamp:1680095023e3},{title:"LinkedList和ArrayDeque",frontmatter:{title:"LinkedList和ArrayDeque",date:"2023-04-21T22:12:37.000Z",permalink:"/pages/cbcb60/"},regularPath:"/01.Java/02.Java%E9%9B%86%E5%90%88/04.LinkedList%E5%92%8CArrayDeque.html",relativePath:"01.Java/02.Java集合/04.LinkedList和ArrayDeque.md",key:"v-410ac754",path:"/pages/cbcb60/",headers:[{level:2,title:"LinkedList",slug:"linkedlist",normalizedTitle:"linkedlist",charIndex:2},{level:3,title:"LinkedList 如何实现线程安全？",slug:"linkedlist-如何实现线程安全",normalizedTitle:"linkedlist 如何实现线程安全？",charIndex:1035},{level:2,title:"ArrayDeque",slug:"arraydeque",normalizedTitle:"arraydeque",charIndex:1360},{level:3,title:"Queue 接口",slug:"queue-接口",normalizedTitle:"queue 接口",charIndex:2405},{level:3,title:"Deque 接口（继承于 Queue 接口）",slug:"deque-接口-继承于-queue-接口",normalizedTitle:"deque 接口（继承于 queue 接口）",charIndex:2727}],headersStr:"LinkedList LinkedList 如何实现线程安全？ ArrayDeque Queue 接口 Deque 接口（继承于 Queue 接口）",content:"# LinkedList\n\npublic class LinkedList<E>\n    extends AbstractSequentialList<E>\n    implements List<E>, Deque<E>, Cloneable, java.io.Serializable {\n\n    // 为什么字段都声明 transient 关键字？\n    // 元素个数\n    transient int size = 0;\n\n    // 头指针\n    transient Node<E> first;\n\n    // 尾指针\n    transient Node<E> last;\n\n    // 链表节点\n    private static class Node<E> {\n        // 节点数据\n        // （类型擦除后：Object item;）\n        E item;\n        // 前驱指针\n        Node<E> next;\n        // 后继指针\n        Node<E> prev;\n\n        Node(Node<E> prev, E element, Node<E> next) {\n            this.item = element;\n            this.next = next;\n            this.prev = prev;\n        }\n    }\n}\n\n\nLinkedList 是基于链表的线性表，同时具备 List、Queue 和 Stack 的行为；\n\n在链表中间添加节点时，会用到 node(index) 方法查询指定位置的节点。可以看到维持 first 和 last 头尾节点的作用又发挥出来了：\n\n * 如果索引位置小于 size/2，则从头节点开始找；\n * 如果索引位置大于 size/2，则从尾节点开始找。\n\n虽然，从复杂度分析的角度看，从哪个方向查询是没有区别的，时间复杂度都是 O(n)。但从工程分析的角度看还是有区别的，从更靠近目标节点的位置开始查询，实际执行的时间会更短。\n\n为什么字段都声明 transient 关键字？LinkedList 重写了序列化过程，不序列化链表节点，只处理链表节点中有效的元素；在反序列时，只需要按照对象顺序依次添加到链表的末尾，就能恢复链表的顺序。\n\n\n# LinkedList 如何实现线程安全？\n\n * 使用 Collections.synchronizedList 包装类： 原理也是在所有方法上增加 synchronized 关键字；\n * 使用 ConcurrentLinkedQueue 容器类： 基于 CAS 无锁实现的线程安全队列；\n * 使用 ConcurrentLinkedDeque 容器类： 基于 CAS 无锁实现的线程安全双端队列。\n * 使用 LinkedBlockingQueue 容器： 基于加锁的阻塞队列，适合于带阻塞操作的生产者消费者模型；\n * 使用 LinkedBlockingDeque 容器： 基于加锁的阻塞双端队列，适合于带阻塞操作的生产者消费者模型；\n\n\n# ArrayDeque\n\nDeque 接口表示一个双端队列（Double Ended Queue），允许在队列的首尾两端操作，所以既能实现队列行为，也能实现栈行为。\n\n * ArrayDeque 是基于动态数组的线性表，具备 Queue 和 Stack 的行为，但不具备 List 的行为；\n * ArrayDeque 的数组容量是 2 的整数幂，在扩容时容量会翻倍，且不支持 null 元素；（其实在 Deque 接口上并不严格禁止存储 null 元素，但是会强烈建议 Deque 的实现不提供存储 null 值的能力。因为 null 通常会作为一个特殊值来判断队列是否为空。）\n * ArrayDeque 和 LinkedList 的栈和队列行为都是 O(1) 时间复杂度，ArrayDeque 的入栈和入队有可能会触发扩容，但从均摊分析上看依然是 O(1) 时间复杂度；\n * ArrayDeque 是一块连续内存空间，基于局部性原理能够更好地命中 CPU 缓存行，而 LinkedList 是离散的内存空间对缓存行不友好；\n * ArrayDeque 和 LinkedList 都不考虑线程同步，不保证线程安全。\n\npublic class ArrayDeque<E> extends AbstractCollection<E>\n\t\timplements Deque<E>, Cloneable, Serializable\n{\n    // 底层数组\n    transient Object[] elements; // non-private to simplify nested class access\n\n    // 队头指针\n    transient int head;\n\n    // 队尾指针\n    transient int tail;\n\n    // new ArrayDeque(0) 最小初始容量\n    private static final int MIN_INITIAL_CAPACITY = 8;\n\n    // 尾指针 - 头指针\n    public int size() {\n        return (tail - head) & (elements.length - 1);\n    }\n}\n\n\n为什么 elements 字段不声明为泛型类型 E？ 因为泛型擦除后等于 Object[] elementData，没有区别。\n\n\n# Queue 接口\n\nQueue 的 API 可以分为 2 类，区别在于方法的拒绝策略上：\n\n * 抛异常：\n   * 向空队列取数据，会抛出 NoSuchElementException 异常；\n   * 向容量满的队列加数据，会抛出 IllegalStateException 异常。\n * 返回特殊值：\n   * 向空队列取数据，会返回 null；\n   * 向容量满的队列加数据，会返回 false。\n\n拒绝策略     抛异常         返回特殊值\n入队（队尾）   add(e)      offer(e)\n出队（队头）   remove()    poll()\n观察（队头）   element()   peek()\n\n\n# Deque 接口（继承于 Queue 接口）\n\nJava 没有提供标准的栈接口，而是放在 Deque 接口中：\n\n拒绝策略     抛异常       等价于\n入栈       push(e)   addFirst(e)\n出栈       pop()     removeFirst()\n观察（栈顶）   peek()    peekFirst()\n\n除了标准的队列和栈行为，Deque 接口还提供了 12 个在两端操作的方法：\n\n拒绝策略   抛异常                           返回值\n增加     addFirst(e)/ addLast(e)       offerFirst(e)/ offerLast(e)\n删除     removeFirst()/ removeLast()   pollFirst()/ pollLast()\n观察     getFirst()/ getLast()         peekFirst()/ peekLast()",normalizedContent:"# linkedlist\n\npublic class linkedlist<e>\n    extends abstractsequentiallist<e>\n    implements list<e>, deque<e>, cloneable, java.io.serializable {\n\n    // 为什么字段都声明 transient 关键字？\n    // 元素个数\n    transient int size = 0;\n\n    // 头指针\n    transient node<e> first;\n\n    // 尾指针\n    transient node<e> last;\n\n    // 链表节点\n    private static class node<e> {\n        // 节点数据\n        // （类型擦除后：object item;）\n        e item;\n        // 前驱指针\n        node<e> next;\n        // 后继指针\n        node<e> prev;\n\n        node(node<e> prev, e element, node<e> next) {\n            this.item = element;\n            this.next = next;\n            this.prev = prev;\n        }\n    }\n}\n\n\nlinkedlist 是基于链表的线性表，同时具备 list、queue 和 stack 的行为；\n\n在链表中间添加节点时，会用到 node(index) 方法查询指定位置的节点。可以看到维持 first 和 last 头尾节点的作用又发挥出来了：\n\n * 如果索引位置小于 size/2，则从头节点开始找；\n * 如果索引位置大于 size/2，则从尾节点开始找。\n\n虽然，从复杂度分析的角度看，从哪个方向查询是没有区别的，时间复杂度都是 o(n)。但从工程分析的角度看还是有区别的，从更靠近目标节点的位置开始查询，实际执行的时间会更短。\n\n为什么字段都声明 transient 关键字？linkedlist 重写了序列化过程，不序列化链表节点，只处理链表节点中有效的元素；在反序列时，只需要按照对象顺序依次添加到链表的末尾，就能恢复链表的顺序。\n\n\n# linkedlist 如何实现线程安全？\n\n * 使用 collections.synchronizedlist 包装类： 原理也是在所有方法上增加 synchronized 关键字；\n * 使用 concurrentlinkedqueue 容器类： 基于 cas 无锁实现的线程安全队列；\n * 使用 concurrentlinkeddeque 容器类： 基于 cas 无锁实现的线程安全双端队列。\n * 使用 linkedblockingqueue 容器： 基于加锁的阻塞队列，适合于带阻塞操作的生产者消费者模型；\n * 使用 linkedblockingdeque 容器： 基于加锁的阻塞双端队列，适合于带阻塞操作的生产者消费者模型；\n\n\n# arraydeque\n\ndeque 接口表示一个双端队列（double ended queue），允许在队列的首尾两端操作，所以既能实现队列行为，也能实现栈行为。\n\n * arraydeque 是基于动态数组的线性表，具备 queue 和 stack 的行为，但不具备 list 的行为；\n * arraydeque 的数组容量是 2 的整数幂，在扩容时容量会翻倍，且不支持 null 元素；（其实在 deque 接口上并不严格禁止存储 null 元素，但是会强烈建议 deque 的实现不提供存储 null 值的能力。因为 null 通常会作为一个特殊值来判断队列是否为空。）\n * arraydeque 和 linkedlist 的栈和队列行为都是 o(1) 时间复杂度，arraydeque 的入栈和入队有可能会触发扩容，但从均摊分析上看依然是 o(1) 时间复杂度；\n * arraydeque 是一块连续内存空间，基于局部性原理能够更好地命中 cpu 缓存行，而 linkedlist 是离散的内存空间对缓存行不友好；\n * arraydeque 和 linkedlist 都不考虑线程同步，不保证线程安全。\n\npublic class arraydeque<e> extends abstractcollection<e>\n\t\timplements deque<e>, cloneable, serializable\n{\n    // 底层数组\n    transient object[] elements; // non-private to simplify nested class access\n\n    // 队头指针\n    transient int head;\n\n    // 队尾指针\n    transient int tail;\n\n    // new arraydeque(0) 最小初始容量\n    private static final int min_initial_capacity = 8;\n\n    // 尾指针 - 头指针\n    public int size() {\n        return (tail - head) & (elements.length - 1);\n    }\n}\n\n\n为什么 elements 字段不声明为泛型类型 e？ 因为泛型擦除后等于 object[] elementdata，没有区别。\n\n\n# queue 接口\n\nqueue 的 api 可以分为 2 类，区别在于方法的拒绝策略上：\n\n * 抛异常：\n   * 向空队列取数据，会抛出 nosuchelementexception 异常；\n   * 向容量满的队列加数据，会抛出 illegalstateexception 异常。\n * 返回特殊值：\n   * 向空队列取数据，会返回 null；\n   * 向容量满的队列加数据，会返回 false。\n\n拒绝策略     抛异常         返回特殊值\n入队（队尾）   add(e)      offer(e)\n出队（队头）   remove()    poll()\n观察（队头）   element()   peek()\n\n\n# deque 接口（继承于 queue 接口）\n\njava 没有提供标准的栈接口，而是放在 deque 接口中：\n\n拒绝策略     抛异常       等价于\n入栈       push(e)   addfirst(e)\n出栈       pop()     removefirst()\n观察（栈顶）   peek()    peekfirst()\n\n除了标准的队列和栈行为，deque 接口还提供了 12 个在两端操作的方法：\n\n拒绝策略   抛异常                           返回值\n增加     addfirst(e)/ addlast(e)       offerfirst(e)/ offerlast(e)\n删除     removefirst()/ removelast()   pollfirst()/ polllast()\n观察     getfirst()/ getlast()         peekfirst()/ peeklast()",charsets:{cjk:!0}},{title:"JVM垃圾回收",frontmatter:{title:"JVM垃圾回收",date:"2023-03-19T15:24:52.000Z",permalink:"/pages/a934e8/"},regularPath:"/01.Java/03.JVM/03.JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6.html",relativePath:"01.Java/03.JVM/03.JVM垃圾回收.md",key:"v-d45608ea",path:"/pages/a934e8/",headers:[{level:2,title:"垃圾回收算法",slug:"垃圾回收算法",normalizedTitle:"垃圾回收算法",charIndex:2},{level:2,title:"垃圾回收器",slug:"垃圾回收器",normalizedTitle:"垃圾回收器",charIndex:72},{level:2,title:"对比",slug:"对比",normalizedTitle:"对比",charIndex:489},{level:2,title:"CMS（Concurrent Mark Sweep）",slug:"cms-concurrent-mark-sweep",normalizedTitle:"cms（concurrent mark sweep）",charIndex:833},{level:2,title:"G1",slug:"g1",normalizedTitle:"g1",charIndex:230},{level:2,title:"ZGC",slug:"zgc",normalizedTitle:"zgc",charIndex:247},{level:3,title:"着色指针",slug:"着色指针",normalizedTitle:"着色指针",charIndex:3525},{level:3,title:"读屏障",slug:"读屏障",normalizedTitle:"读屏障",charIndex:784},{level:2,title:"空间分配担保",slug:"空间分配担保",normalizedTitle:"空间分配担保",charIndex:4079},{level:2,title:"GC 的触发条件",slug:"gc-的触发条件",normalizedTitle:"gc 的触发条件",charIndex:4345},{level:2,title:"默认的垃圾回收器",slug:"默认的垃圾回收器",normalizedTitle:"默认的垃圾回收器",charIndex:4659},{level:2,title:"如何判断一个对象已经无效",slug:"如何判断一个对象已经无效",normalizedTitle:"如何判断一个对象已经无效",charIndex:4769},{level:2,title:"可以作为GC Roots的对象",slug:"可以作为gc-roots的对象",normalizedTitle:"可以作为gc roots的对象",charIndex:4985},{level:2,title:"引用",slug:"引用",normalizedTitle:"引用",charIndex:1652},{level:2,title:"常量池的位置",slug:"常量池的位置",normalizedTitle:"常量池的位置",charIndex:5503},{level:2,title:"如何判断一个类是无用的类",slug:"如何判断一个类是无用的类",normalizedTitle:"如何判断一个类是无用的类",charIndex:5881}],headersStr:"垃圾回收算法 垃圾回收器 对比 CMS（Concurrent Mark Sweep） G1 ZGC 着色指针 读屏障 空间分配担保 GC 的触发条件 默认的垃圾回收器 如何判断一个对象已经无效 可以作为GC Roots的对象 引用 常量池的位置 如何判断一个类是无用的类",content:'# 垃圾回收算法\n\n * 标记-清理 Mark-Sweep\n * 标记-复制：常用于新生代\n * 标记-整理 Mark-Compact\n\n\n# 垃圾回收器\n\n垃圾回收器分类：\n\n * 新生代\n\n * * Serial：单线程\n   * ParNew （只能跟CMS搭配）：多线程并行\n   * Parallel Scavenge\n\n * 老年代\n\n * * Serial Old\n   * Parallel Old\n   * CMS\n\n * 通用\n\n * * G1\n\n * 低延迟\n\n * * ZGC\n   * Shenandoah\n\n搭配：\n\n * Serial + Serial Old\n * Parallel Scavenge + Parallel Old\n * Parallel Scavenge + Serial Old\n * ParNew + CMS （ParNew和CMS唯一使用情况）\n * G1\n * ZGC\n * Shenandoah\n * Serial+ CMS （JDK 9移除）\n * ParNew + Serial Old（JDK 9移除）\n\n\n# 对比\n\n * Serial 是单线程版本，ParNew是Serial的多线程版本。\n * Parallel Scavenge 关注的是吞吐量（CPU用于运行用户代码的时间与总时间的比值），CMS关注的是线程的停顿时间（提高用户体验）。\n * G1关注低停顿+高吞吐。G1 从整体来看是基于“标记-整理”算法实现的收集器；从局部上来看是基于“标记-复制”算法实现的。\n * G1 收集器在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的 Region(这也就是它的名字 Garbage-First 的由来) 。\n * ZGC：基于Region 内存布局，不设分代，使用了读屏障、染色指针和内存多重映射等技术实现可并发的标记-整理算法，以低延迟为首要目标。\n\n\n\n\n# CMS（Concurrent Mark Sweep）\n\n执行步骤：\n\n 1. 初始标记：仅仅只是标记一下 GC Roots 能直接关联到的对象，速度很快，需要停顿。会导致swt。\n 2. 并发标记：与用户线程同时运行，进行 GC Roots Tracing 的过程，它在整个回收过程中耗时最长，不需要停顿。\n 3. 重新标记，会导致swt。为了修正并发标记期间因用户程序继续运作而导致标记变动的那一部分对象的标记记录，需要停顿。\n 4. 并发清理，不需要停顿。\n 5. 并发重置线程，等待下次CMS的触发\n\n缺点：\n\n * 吞吐量低: 低停顿时间是以牺牲吞吐量为代价的，导致 CPU 利用率不够高。\n\n * 对 CPU 资源敏感；\n\n * 无法处理浮动垃圾。浮动垃圾是指并发清除阶段由于用户线程继续运行而产生的垃圾，这部分垃圾只能到下一次 GC 时才能进行回收。由于浮动垃圾的存在，因此需要预留出一部分内存，意味着 CMS 收集不能像其它收集器那样等待老年代快满的时候再回收。如果预留的内存不够存放浮动垃圾，就会出现 Concurrent Mode Failure，这时虚拟机将临时启用 Serial Old 来替代 CMS。\n\n * 它使用的回收算法-“标记-清除”算法会导致收集结束时会有大量空间碎片产生。\n\n\n# G1\n\n引入Region分区的概念，弱化分代的概念。\n\nG1 把堆划分成多个大小相等的独立区域(Region)，新生代和老年代不再物理隔离。\n\n使得每个小空间可以单独进行垃圾回收。这种划分方法带来了很大的灵活性，使得可预测的停顿时间模型成为可能。通过记录每个 Region 垃圾回收时间以及回收所获得的空间(这两个值是通过过去回收的经验获得)，并维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的 Region。\n\n每个 Region 都有一个 Remembered Set，用来记录该 Region 对象的引用对象所在的 Region。通过使用 Remembered Set，在做可达性分析的时候就可以避免全堆扫描。\n\n\n\n执行步骤：\n\n 1. 初始标记\n 2. 并发标记\n 3. 最终标记（标记那些在并发标记阶段发生变化的对象，将被回收）\n 4. 筛选回收（首先对各个Regin的回收价值和成本进行排序，根据用户所期待的GC停顿时间指定回收计划，回收一部分Region）\n\n\n特点：\n\n * 空间整合: 整体来看是基于“标记 - 整理”算法实现的收集器，从局部(两个 Region 之间)上来看是基于“复制”算法实现的，这意味着运行期间不会产生内存空间碎片。\n\n * 可预测的停顿: 能让使用者明确指定在一个长度为 M 毫秒的时间片段内，消耗在 GC 上的时间不得超过 N 毫秒。\n\n\nG1的一些总结：\n\n * G1是一款非常优秀的垃圾收集器，不仅适合堆内存大的应用，同时也简化了调优的工作。通过主要的参数初始和最大堆空间、以及最大容忍的GC暂停目标，就能得到不错的性能。\n\n * 虽然G1也有类似CMS的收集动作：初始标记、并发标记、重新标记、清除、转移回收，并且也以一个串行收集器做担保机制。\n\n * G1的设计原则是"首先收集尽可能多的垃圾(Garbage First)"。因此，G1并不会等内存耗尽(串行、并行)或者快耗尽(CMS)的时候开始垃圾收集，而是在内部采用了启发式算法，在老年代找出具有高收集收益的分区进行收集。同时G1可以根据用户设置的暂停时间目标自动调整年轻代和总堆大小，暂停目标越短年轻代空间越小、总空间就越大；\n\n * G1采用内存分区(Region)的思路，将内存划分为一个个相等大小的内存分区，回收时则以分区为单位进行回收，存活的对象复制到另一个空闲分区中。由于都是以相等大小的分区为单位进行操作，因此G1天然就是一种压缩方案(局部压缩)；\n\n * G1虽然也是分代收集器，但整个内存分区不存在物理上的年轻代与老年代的区别，也不需要完全独立的survivor(to space)堆做复制准备。G1只有逻辑上的分代概念，或者说每个分区都可能随G1的运行在不同代之间前后切换；\n\n * G1的收集都是STW的，但年轻代和老年代的收集界限比较模糊，采用了混合(mixed)收集的方式。即每次收集既可能只收集年轻代分区(年轻代收集)，也可能在收集年轻代的同时，包含部分老年代分区(混合收集)，这样即使堆内存很大时，也可以限制收集范围，从而降低停顿。\n\n\nShenandoah与G1的3个明显不同：\n\n * 支持并发的整理算法（最重要）。G1的回收阶段是可以多线程并行的，但不能与用户线程并发。\n * 目前默认不使用分代回收\n * 摒弃G1中耗费大量内存和计算资源去维护的记忆集，使用“连接矩阵”的全局数据结构来记录跨Region的引用关系。\n\n\n# ZGC\n\nZGC（The Z Garbage Collector）是JDK 11中推出的一款低延迟垃圾回收器，它的设计目标包括：\n\n * 停顿时间不超过10ms；\n * 停顿时间不会随着堆的大小，或者活跃对象的大小而增加（对程序吞吐量影响小于15%）；\n * 支持8MB~4TB级别的堆（未来支持16TB）。\n\n标记复制算法的三个阶段：\n\n标记阶段，即从GC Roots集合开始，标记活跃对象；\n\n转移阶段，即把活跃对象复制到新的内存地址上；\n\n重定位阶段，因为转移导致对象的地址发生了变化，在重定位阶段，所有指向对象旧地址的指针都要调整到对象新的地址上。\n\n问题分析：停顿时间的主要瓶颈是是标记-复制中转移阶段的STW。标记-复制算法应用在CMS新生代（ParNew是CMS默认的新生代垃圾回收器）和G1垃圾回收器中。\n\n与CMS中的ParNew和G1类似，ZGC也采用标记-复制算法，不过ZGC对该算法做了重大改进：ZGC在标记、转移和重定位阶段几乎都是并发的，这是ZGC实现停顿时间小于10ms目标的最关键原因。\n\nZGC只有三个STW阶段：初始标记，再标记，初始转移。其中，初始标记和初始转移分别都只需要扫描所有GC Roots，其处理时间和GC Roots的数量成正比，一般情况耗时非常短；再标记阶段STW时间很短，最多1ms，超过1ms则再次进入并发标记阶段。即，ZGC几乎所有暂停都只依赖于GC Roots集合大小，停顿时间不会随着堆的大小或者活跃对象的大小而增加。与ZGC对比，G1的转移阶段完全STW的，且停顿时间随存活对象的大小增加而增加。\n\n\n\nZGC通过着色指针和读屏障技术，解决了转移过程中准确访问对象的问题，实现了并发转移。大致原理描述如下：并发转移中“并发”意味着GC线程在转移对象的过程中，应用线程也在不停地访问对象。假设对象发生转移，但对象地址未及时更新，那么应用线程可能访问到旧地址，从而造成错误。而在ZGC中，应用线程访问对象将触发“读屏障”，如果发现对象被移动了，那么“读屏障”会把读出来的指针更新到对象的新地址上，这样应用线程始终访问的都是对象的新地址。那么，JVM是如何判断对象被移动过呢？就是利用对象引用的地址，即着色指针。下面介绍着色指针和读屏障技术细节。\n\n\n# 着色指针\n\n着色指针是一种将信息存储在指针中的技术。\n\nZGC将对象存活信息存储在42~45位中，这与传统的垃圾回收并将对象存活信息放在对象头中完全不同。\n\n\n# 读屏障\n\n读屏障是JVM向应用代码插入一小段代码的技术。当应用线程从堆中读取对象引用时，就会执行这段代码。需要注意的是，仅“从堆中读取对象引用”才会触发这段代码。\n\nZGC中读屏障的代码作用：在对象标记和转移过程中，用于确定对象的引用地址是否满足条件，并作出相应动作。\n\n\n参考：\n\n * https://www.pdai.tech/md/java/jvm/java-jvm-gc-zgc.html\n\n\n# 空间分配担保\n\n在发生 Minor GC 之前，虚拟机先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果条件成立的话，那么 Minor GC 可以确认是安全的。\n\n如果不成立的话虚拟机会查看 HandlePromotionFailure 设置值是否允许担保失败，如果允许那么就会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次 Minor GC；如果小于，或者 HandlePromotionFailure 设置不允许冒险，那么就要进行一次 Full GC。\n\n\n# GC 的触发条件\n\nMinor GC：当 eden 满时，触发一次 minor GC。\n\nFull GC：\n\n * 调用 System.gc(); 只是建议虚拟机执行 Full GC，但是虚拟机不一定真正去执行。不建议使用这种方式，而是让虚拟机管理内存。\n * 老年代空间不足\n * 空间分配担保失败\n * JDK1.7 及之前，永久代空间不足。\n * Concurrent Mode Failure：执行 CMS GC 的过程中同时有对象要放入老年代，而此时老年代空间不足(可能是 GC 过程中浮动垃圾过多导致暂时性的空间不足)，便会报 Concurrent Mode Failure 错误，并触发 Full GC。\n\n\n# 默认的垃圾回收器\n\n * JDK8 默认使用的是 Parallel Scavenge + Parallel Old。但一般不用这个。常用ParNew+CMS吧（因为是唯一搭配呀）\n * JDK9~16 默认G1\n\n\n# 如何判断一个对象已经无效\n\n * 引用计数法\n\n * * 实现简单，效率高，但是目前主流的虚拟机中并没有选择这个算法来管理内存，其最主要的原因是它很难解决对象之间相互循环引用的问题。\n\n * 可达性分析法（JVM使用的）\n\n * * 通过一系列的称为 “GC Roots” 的对象作为起点，从这些节点开始向下搜索，节点所走过的路径称为引用链，当一个对象到 GC Roots 没有任何引用链相连的话，则证明此对象是不可用的。\n\n\n# 可以作为GC Roots的对象\n\n * 虚拟机栈（栈帧中的本地变量表）中引用的对象\n * 本地方法栈（Native方法）中引用的对象\n * 方法区中类静态属性引用的对象\n * 方法区中常量引用的对象\n * 所有被同步锁持有的对象\n\n\n# 引用\n\nJDK1.2 之前，Java 中引用的定义很传统：如果 reference 类型的数据存储的数值代表的是另一块内存的起始地址，就称这块内存代表一个引用。\n\nJDK1.2 以后，Java 对引用的概念进行了扩充，将引用分为强引用、软引用、弱引用、虚引用四种（引用强度逐渐减弱）\n\n * 强引用（StrongReference）：垃圾回收器绝不会回收它\n * 软引用（SoftReference）：如果内存空间足够，垃圾回收器就不会回收它，如果内存空间不足了，就会回收这些对象的内存。\n * 弱引用（WeakReference）：不管当前内存空间足够与否，都会回收它的内存。\n * 虚引用（PhantomReference）：如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收。为一个对象设置虚引用关联的唯一目的就是能在这个对象被回收时收到一个系统通知。\n\n\n# 常量池的位置\n\nJDK1.7 之前运行时常量池逻辑包含字符串常量池存放在方法区, 此时 hotspot 虚拟机对方法区的实现为永久代。\n\nJDK1.7 字符串常量池被从方法区拿到了堆中, 这里没有提到运行时常量池,也就是说字符串常量池被单独拿到堆,运行时常量池剩下的东西还在方法区, 也就是 hotspot 中的永久代 。\n\nJDK1.8 hotspot 移除了永久代用元空间(Metaspace)取而代之, 这时候字符串常量池还在堆, 运行时常量池还在方法区, 只不过方法区的实现从永久代变成了元空间(Metaspace)\n\n假如在字符串常量池中存在字符串 "abc"，如果当前没有任何 String 对象引用该字符串常量的话，就说明常量 "abc" 就是废弃常量，如果这时发生内存回收的话而且有必要的话，"abc" 就会被系统清理出常量池了。\n\n\n# 如何判断一个类是无用的类\n\n方法区主要回收的是无用的类，那么如何判断一个类是无用的类的呢？\n\n判定一个常量是否是“废弃常量”比较简单，而要判定一个类是否是“无用的类”的条件则相对苛刻许多。类需要同时满足下面 3 个条件才能算是 “无用的类” ：\n\n * 该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。\n * 加载该类的 ClassLoader 已经被回收。\n * 该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。\n\n虚拟机可以对满足上述 3 个条件的无用类进行回收，这里说的仅仅是“可以”，而并不是和对象一样不使用了就会必然被回收。',normalizedContent:'# 垃圾回收算法\n\n * 标记-清理 mark-sweep\n * 标记-复制：常用于新生代\n * 标记-整理 mark-compact\n\n\n# 垃圾回收器\n\n垃圾回收器分类：\n\n * 新生代\n\n * * serial：单线程\n   * parnew （只能跟cms搭配）：多线程并行\n   * parallel scavenge\n\n * 老年代\n\n * * serial old\n   * parallel old\n   * cms\n\n * 通用\n\n * * g1\n\n * 低延迟\n\n * * zgc\n   * shenandoah\n\n搭配：\n\n * serial + serial old\n * parallel scavenge + parallel old\n * parallel scavenge + serial old\n * parnew + cms （parnew和cms唯一使用情况）\n * g1\n * zgc\n * shenandoah\n * serial+ cms （jdk 9移除）\n * parnew + serial old（jdk 9移除）\n\n\n# 对比\n\n * serial 是单线程版本，parnew是serial的多线程版本。\n * parallel scavenge 关注的是吞吐量（cpu用于运行用户代码的时间与总时间的比值），cms关注的是线程的停顿时间（提高用户体验）。\n * g1关注低停顿+高吞吐。g1 从整体来看是基于“标记-整理”算法实现的收集器；从局部上来看是基于“标记-复制”算法实现的。\n * g1 收集器在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的 region(这也就是它的名字 garbage-first 的由来) 。\n * zgc：基于region 内存布局，不设分代，使用了读屏障、染色指针和内存多重映射等技术实现可并发的标记-整理算法，以低延迟为首要目标。\n\n\n\n\n# cms（concurrent mark sweep）\n\n执行步骤：\n\n 1. 初始标记：仅仅只是标记一下 gc roots 能直接关联到的对象，速度很快，需要停顿。会导致swt。\n 2. 并发标记：与用户线程同时运行，进行 gc roots tracing 的过程，它在整个回收过程中耗时最长，不需要停顿。\n 3. 重新标记，会导致swt。为了修正并发标记期间因用户程序继续运作而导致标记变动的那一部分对象的标记记录，需要停顿。\n 4. 并发清理，不需要停顿。\n 5. 并发重置线程，等待下次cms的触发\n\n缺点：\n\n * 吞吐量低: 低停顿时间是以牺牲吞吐量为代价的，导致 cpu 利用率不够高。\n\n * 对 cpu 资源敏感；\n\n * 无法处理浮动垃圾。浮动垃圾是指并发清除阶段由于用户线程继续运行而产生的垃圾，这部分垃圾只能到下一次 gc 时才能进行回收。由于浮动垃圾的存在，因此需要预留出一部分内存，意味着 cms 收集不能像其它收集器那样等待老年代快满的时候再回收。如果预留的内存不够存放浮动垃圾，就会出现 concurrent mode failure，这时虚拟机将临时启用 serial old 来替代 cms。\n\n * 它使用的回收算法-“标记-清除”算法会导致收集结束时会有大量空间碎片产生。\n\n\n# g1\n\n引入region分区的概念，弱化分代的概念。\n\ng1 把堆划分成多个大小相等的独立区域(region)，新生代和老年代不再物理隔离。\n\n使得每个小空间可以单独进行垃圾回收。这种划分方法带来了很大的灵活性，使得可预测的停顿时间模型成为可能。通过记录每个 region 垃圾回收时间以及回收所获得的空间(这两个值是通过过去回收的经验获得)，并维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的 region。\n\n每个 region 都有一个 remembered set，用来记录该 region 对象的引用对象所在的 region。通过使用 remembered set，在做可达性分析的时候就可以避免全堆扫描。\n\n\n\n执行步骤：\n\n 1. 初始标记\n 2. 并发标记\n 3. 最终标记（标记那些在并发标记阶段发生变化的对象，将被回收）\n 4. 筛选回收（首先对各个regin的回收价值和成本进行排序，根据用户所期待的gc停顿时间指定回收计划，回收一部分region）\n\n\n特点：\n\n * 空间整合: 整体来看是基于“标记 - 整理”算法实现的收集器，从局部(两个 region 之间)上来看是基于“复制”算法实现的，这意味着运行期间不会产生内存空间碎片。\n\n * 可预测的停顿: 能让使用者明确指定在一个长度为 m 毫秒的时间片段内，消耗在 gc 上的时间不得超过 n 毫秒。\n\n\ng1的一些总结：\n\n * g1是一款非常优秀的垃圾收集器，不仅适合堆内存大的应用，同时也简化了调优的工作。通过主要的参数初始和最大堆空间、以及最大容忍的gc暂停目标，就能得到不错的性能。\n\n * 虽然g1也有类似cms的收集动作：初始标记、并发标记、重新标记、清除、转移回收，并且也以一个串行收集器做担保机制。\n\n * g1的设计原则是"首先收集尽可能多的垃圾(garbage first)"。因此，g1并不会等内存耗尽(串行、并行)或者快耗尽(cms)的时候开始垃圾收集，而是在内部采用了启发式算法，在老年代找出具有高收集收益的分区进行收集。同时g1可以根据用户设置的暂停时间目标自动调整年轻代和总堆大小，暂停目标越短年轻代空间越小、总空间就越大；\n\n * g1采用内存分区(region)的思路，将内存划分为一个个相等大小的内存分区，回收时则以分区为单位进行回收，存活的对象复制到另一个空闲分区中。由于都是以相等大小的分区为单位进行操作，因此g1天然就是一种压缩方案(局部压缩)；\n\n * g1虽然也是分代收集器，但整个内存分区不存在物理上的年轻代与老年代的区别，也不需要完全独立的survivor(to space)堆做复制准备。g1只有逻辑上的分代概念，或者说每个分区都可能随g1的运行在不同代之间前后切换；\n\n * g1的收集都是stw的，但年轻代和老年代的收集界限比较模糊，采用了混合(mixed)收集的方式。即每次收集既可能只收集年轻代分区(年轻代收集)，也可能在收集年轻代的同时，包含部分老年代分区(混合收集)，这样即使堆内存很大时，也可以限制收集范围，从而降低停顿。\n\n\nshenandoah与g1的3个明显不同：\n\n * 支持并发的整理算法（最重要）。g1的回收阶段是可以多线程并行的，但不能与用户线程并发。\n * 目前默认不使用分代回收\n * 摒弃g1中耗费大量内存和计算资源去维护的记忆集，使用“连接矩阵”的全局数据结构来记录跨region的引用关系。\n\n\n# zgc\n\nzgc（the z garbage collector）是jdk 11中推出的一款低延迟垃圾回收器，它的设计目标包括：\n\n * 停顿时间不超过10ms；\n * 停顿时间不会随着堆的大小，或者活跃对象的大小而增加（对程序吞吐量影响小于15%）；\n * 支持8mb~4tb级别的堆（未来支持16tb）。\n\n标记复制算法的三个阶段：\n\n标记阶段，即从gc roots集合开始，标记活跃对象；\n\n转移阶段，即把活跃对象复制到新的内存地址上；\n\n重定位阶段，因为转移导致对象的地址发生了变化，在重定位阶段，所有指向对象旧地址的指针都要调整到对象新的地址上。\n\n问题分析：停顿时间的主要瓶颈是是标记-复制中转移阶段的stw。标记-复制算法应用在cms新生代（parnew是cms默认的新生代垃圾回收器）和g1垃圾回收器中。\n\n与cms中的parnew和g1类似，zgc也采用标记-复制算法，不过zgc对该算法做了重大改进：zgc在标记、转移和重定位阶段几乎都是并发的，这是zgc实现停顿时间小于10ms目标的最关键原因。\n\nzgc只有三个stw阶段：初始标记，再标记，初始转移。其中，初始标记和初始转移分别都只需要扫描所有gc roots，其处理时间和gc roots的数量成正比，一般情况耗时非常短；再标记阶段stw时间很短，最多1ms，超过1ms则再次进入并发标记阶段。即，zgc几乎所有暂停都只依赖于gc roots集合大小，停顿时间不会随着堆的大小或者活跃对象的大小而增加。与zgc对比，g1的转移阶段完全stw的，且停顿时间随存活对象的大小增加而增加。\n\n\n\nzgc通过着色指针和读屏障技术，解决了转移过程中准确访问对象的问题，实现了并发转移。大致原理描述如下：并发转移中“并发”意味着gc线程在转移对象的过程中，应用线程也在不停地访问对象。假设对象发生转移，但对象地址未及时更新，那么应用线程可能访问到旧地址，从而造成错误。而在zgc中，应用线程访问对象将触发“读屏障”，如果发现对象被移动了，那么“读屏障”会把读出来的指针更新到对象的新地址上，这样应用线程始终访问的都是对象的新地址。那么，jvm是如何判断对象被移动过呢？就是利用对象引用的地址，即着色指针。下面介绍着色指针和读屏障技术细节。\n\n\n# 着色指针\n\n着色指针是一种将信息存储在指针中的技术。\n\nzgc将对象存活信息存储在42~45位中，这与传统的垃圾回收并将对象存活信息放在对象头中完全不同。\n\n\n# 读屏障\n\n读屏障是jvm向应用代码插入一小段代码的技术。当应用线程从堆中读取对象引用时，就会执行这段代码。需要注意的是，仅“从堆中读取对象引用”才会触发这段代码。\n\nzgc中读屏障的代码作用：在对象标记和转移过程中，用于确定对象的引用地址是否满足条件，并作出相应动作。\n\n\n参考：\n\n * https://www.pdai.tech/md/java/jvm/java-jvm-gc-zgc.html\n\n\n# 空间分配担保\n\n在发生 minor gc 之前，虚拟机先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果条件成立的话，那么 minor gc 可以确认是安全的。\n\n如果不成立的话虚拟机会查看 handlepromotionfailure 设置值是否允许担保失败，如果允许那么就会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次 minor gc；如果小于，或者 handlepromotionfailure 设置不允许冒险，那么就要进行一次 full gc。\n\n\n# gc 的触发条件\n\nminor gc：当 eden 满时，触发一次 minor gc。\n\nfull gc：\n\n * 调用 system.gc(); 只是建议虚拟机执行 full gc，但是虚拟机不一定真正去执行。不建议使用这种方式，而是让虚拟机管理内存。\n * 老年代空间不足\n * 空间分配担保失败\n * jdk1.7 及之前，永久代空间不足。\n * concurrent mode failure：执行 cms gc 的过程中同时有对象要放入老年代，而此时老年代空间不足(可能是 gc 过程中浮动垃圾过多导致暂时性的空间不足)，便会报 concurrent mode failure 错误，并触发 full gc。\n\n\n# 默认的垃圾回收器\n\n * jdk8 默认使用的是 parallel scavenge + parallel old。但一般不用这个。常用parnew+cms吧（因为是唯一搭配呀）\n * jdk9~16 默认g1\n\n\n# 如何判断一个对象已经无效\n\n * 引用计数法\n\n * * 实现简单，效率高，但是目前主流的虚拟机中并没有选择这个算法来管理内存，其最主要的原因是它很难解决对象之间相互循环引用的问题。\n\n * 可达性分析法（jvm使用的）\n\n * * 通过一系列的称为 “gc roots” 的对象作为起点，从这些节点开始向下搜索，节点所走过的路径称为引用链，当一个对象到 gc roots 没有任何引用链相连的话，则证明此对象是不可用的。\n\n\n# 可以作为gc roots的对象\n\n * 虚拟机栈（栈帧中的本地变量表）中引用的对象\n * 本地方法栈（native方法）中引用的对象\n * 方法区中类静态属性引用的对象\n * 方法区中常量引用的对象\n * 所有被同步锁持有的对象\n\n\n# 引用\n\njdk1.2 之前，java 中引用的定义很传统：如果 reference 类型的数据存储的数值代表的是另一块内存的起始地址，就称这块内存代表一个引用。\n\njdk1.2 以后，java 对引用的概念进行了扩充，将引用分为强引用、软引用、弱引用、虚引用四种（引用强度逐渐减弱）\n\n * 强引用（strongreference）：垃圾回收器绝不会回收它\n * 软引用（softreference）：如果内存空间足够，垃圾回收器就不会回收它，如果内存空间不足了，就会回收这些对象的内存。\n * 弱引用（weakreference）：不管当前内存空间足够与否，都会回收它的内存。\n * 虚引用（phantomreference）：如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收。为一个对象设置虚引用关联的唯一目的就是能在这个对象被回收时收到一个系统通知。\n\n\n# 常量池的位置\n\njdk1.7 之前运行时常量池逻辑包含字符串常量池存放在方法区, 此时 hotspot 虚拟机对方法区的实现为永久代。\n\njdk1.7 字符串常量池被从方法区拿到了堆中, 这里没有提到运行时常量池,也就是说字符串常量池被单独拿到堆,运行时常量池剩下的东西还在方法区, 也就是 hotspot 中的永久代 。\n\njdk1.8 hotspot 移除了永久代用元空间(metaspace)取而代之, 这时候字符串常量池还在堆, 运行时常量池还在方法区, 只不过方法区的实现从永久代变成了元空间(metaspace)\n\n假如在字符串常量池中存在字符串 "abc"，如果当前没有任何 string 对象引用该字符串常量的话，就说明常量 "abc" 就是废弃常量，如果这时发生内存回收的话而且有必要的话，"abc" 就会被系统清理出常量池了。\n\n\n# 如何判断一个类是无用的类\n\n方法区主要回收的是无用的类，那么如何判断一个类是无用的类的呢？\n\n判定一个常量是否是“废弃常量”比较简单，而要判定一个类是否是“无用的类”的条件则相对苛刻许多。类需要同时满足下面 3 个条件才能算是 “无用的类” ：\n\n * 该类所有的实例都已经被回收，也就是 java 堆中不存在该类的任何实例。\n * 加载该类的 classloader 已经被回收。\n * 该类对应的 java.lang.class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。\n\n虚拟机可以对满足上述 3 个条件的无用类进行回收，这里说的仅仅是“可以”，而并不是和对象一样不使用了就会必然被回收。',charsets:{cjk:!0},lastUpdated:"2023/03/29, 21:03:43",lastUpdatedTimestamp:1680095023e3},{title:"Java内存区域（运行时数据区）",frontmatter:{title:"Java内存区域（运行时数据区）",date:"2023-03-19T16:13:20.000Z",permalink:"/pages/8ffeca/"},regularPath:"/01.Java/03.JVM/04.Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%EF%BC%88%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%EF%BC%89.html",relativePath:"01.Java/03.JVM/04.Java内存区域（运行时数据区）.md",key:"v-4a3cf55d",path:"/pages/8ffeca/",headers:[{level:2,title:"堆",slug:"堆",normalizedTitle:"堆",charIndex:28},{level:3,title:"将 -Xmx 和 -Xms 两个参数配置为相同的值",slug:"将-xmx-和-xms-两个参数配置为相同的值",normalizedTitle:"将 -xmx 和 -xms 两个参数配置为相同的值",charIndex:1174},{level:3,title:"Minor GC、Major GC、Full GC",slug:"minor-gc、major-gc、full-gc",normalizedTitle:"minor gc、major gc、full gc",charIndex:1429},{level:2,title:"方法区",slug:"方法区",normalizedTitle:"方法区",charIndex:30},{level:3,title:"类型信息",slug:"类型信息",normalizedTitle:"类型信息",charIndex:1905},{level:3,title:"对于方法区，Java8 之后的变化：",slug:"对于方法区-java8-之后的变化",normalizedTitle:"对于方法区，java8 之后的变化：",charIndex:2571},{level:3,title:"方法区的垃圾回收",slug:"方法区的垃圾回收",normalizedTitle:"方法区的垃圾回收",charIndex:2844},{level:2,title:"虚拟机栈",slug:"虚拟机栈",normalizedTitle:"虚拟机栈",charIndex:11},{level:2,title:"本地方法栈",slug:"本地方法栈",normalizedTitle:"本地方法栈",charIndex:16},{level:2,title:"程序计数器",slug:"程序计数器",normalizedTitle:"程序计数器",charIndex:5},{level:2,title:"本地内存（元空间、直接内存）",slug:"本地内存-元空间、直接内存",normalizedTitle:"本地内存（元空间、直接内存）",charIndex:4626},{level:2,title:"运行时常量池（Runtime Constant Pool）",slug:"运行时常量池-runtime-constant-pool",normalizedTitle:"运行时常量池（runtime constant pool）",charIndex:2009}],headersStr:"堆 将 -Xmx 和 -Xms 两个参数配置为相同的值 Minor GC、Major GC、Full GC 方法区 类型信息 对于方法区，Java8 之后的变化： 方法区的垃圾回收 虚拟机栈 本地方法栈 程序计数器 本地内存（元空间、直接内存） 运行时常量池（Runtime Constant Pool）",content:"线程私有：程序计数器、虚拟机栈、本地方法栈\n\n线程共享：堆、方法区、堆外内存（JDK8的元空间、代码缓存）\n\n栈是运行时的单位，而堆是存储的单位。\n\n栈解决程序的运行问题，即程序如何执行，或者说如何处理数据。堆解决的是数据存储的问题，即数据怎么放、放在哪。\n\n\n# 堆\n\n * 对象实例以及数组都在这里分配内存\n\n * 新生代：eden、from survivor、to survior 8:1:1\n   \n   * 当 Eden 空间被对象填充时，执行Minor GC，并将所有幸存者对象移动到一个幸存者空间中\n\n * 老年代：老年代垃圾收集称为 Major GC，通常需要更长的时间。\n\n * 永久代（JDK 8用元空间取代）。永久代物理是堆的一部分，和新生代，老年代地址是连续的（受垃圾回收器管理），而元空间存在于本地内存（我们常说的堆外内存，不受垃圾回收器管理），这样就不受 JVM 限制了，也比较难发生OOM（都会有溢出异常）。\n\n * 元空间存储类的元信息，静态变量和字符串常量池等并入堆中。相当于永久代的数据被分到了堆和元空间中。\n\n * 分代的目的是优化 GC 性能。\n\n堆配置：\n\n * -Xms: 配置堆的起始内存（最小内存）。等价于 -XX:InitialHeapSize。默认是物理内存1/64。\n * -Xmx: 配置堆的最大内存。等价于 -XX:MaxHeapSize。\n * 默认情况下新生代和老年代的比例是 1:2，可以通过 –XX:NewRatio 来配置\n * 新生代中的 Eden:From Survivor:To Survivor 的比例是 8:1:1，可以通过 -XX:SurvivorRatio 来配置\n * 若在 JDK 7 中开启了 -XX:+UseAdaptiveSizePolicy，JVM 会动态调整 JVM 堆中各个区域的大小以及进入老年代的年龄，此时 –XX:NewRatio 和 -XX:SurvivorRatio 将会失效，而 JDK 8 是默认开启-XX:+UseAdaptiveSizePolicy，在 JDK 8中，不要随意关闭-XX:+UseAdaptiveSizePolicy，除非对堆内存的划分有明确的规划。\n * 对象年轻计数器（-XX:MaxTenuringThreshold）\n * 如果分配的对象超过了-XX:PetenureSizeThreshold，对象会直接被分配到老年代\n * Java7 中我们通过-XX:PermSize 和 -xx:MaxPermSize 来设置永久代参数，Java8 之后，随着永久代的取消，这些参数也就随之失效了，改为通过-XX:MetaspaceSize 和 -XX:MaxMetaspaceSize 用来设置元空间参数\n\n\n# 将 -Xmx 和 -Xms 两个参数配置为相同的值\n\n如：常规的JVM参数使用\n\njava -Xms512m -Xmx1g\n\n\n在这种配置下，JVM启动时会分配512M的堆内存空间，随着程序的执行，所需的堆空间越来越大，则会逐渐增大堆内存空间，直到Xmx参数指定的堆最大空间1G。当堆内存使用率降低，则会逐渐减小该内存区域的大小。\n\n我们通常会将 -Xmx 和 -Xms 两个参数配置为相同的值，为了避免由于heap内存扩大或缩小导致应用停顿，降低延迟，同时避免每次垃圾回收完成后JVM重新分配内存。\n\n\n# Minor GC、Major GC、Full GC\n\n针对 HotSpot VM 的实现，它里面的 GC 按照回收区域又分为两大类：部分收集（Partial GC），整堆收集（Full GC）\n\n * 部分收集：不是完整收集整个 Java 堆的垃圾收集。其中又分为：\n   * 新生代收集（Minor GC/Young GC）：只是新生代的垃圾收集\n   * 老年代收集（Major GC/Old GC）：只是老年代的垃圾收集\n     * 目前，只有 CMS GC 会有单独收集老年代的行为\n     * 很多时候 Major GC 会和 Full GC 混合使用，需要具体分辨是老年代回收还是整堆回收\n   * 混合收集（Mixed GC）：收集整个新生代以及部分老年代的垃圾收集\n     * 目前只有 G1 GC 会有这种行为\n * 整堆收集（Full GC）：收集整个 Java 堆和方法区的垃圾\n\n\n# 方法区\n\n也称为非堆 non-heap\n\n方法区的实现JDK7用永久代，JDK8改用本地内存的元空间。\n\n方法区用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据。\n\n虽然 Java 虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫 Non-Heap（非堆），目的应该是与 Java 堆区分开。\n\n运行时常量池（Runtime Constant Pool）是方法区的一部分。Class 文件中除了有类的版本/字段/方法/接口等描述信息外，还有一项信息是常量池（Constant Pool Table），用于存放编译期生成的各种字面量和符号引用，这部分内容将类在加载后进入方法区的运行时常量池中存放。运行期间也可能将新的常量放入池中，这种特性被开发人员利用得比较多的是 String.intern()方法。受方法区内存的限制，当常量池无法再申请到内存时会抛出 OutOfMemoryError 异常。\n\n方法区的大小和堆空间一样，可以选择固定大小也可选择可扩展，方法区的大小决定了系统可以放多少个类，如果系统类太多，导致方法区溢出，虚拟机同样会抛出内存溢出错误。\n\n\n# 类型信息\n\n对每个加载的类型（类 class、接口 interface、枚举 enum、注解 annotation），JVM 必须在方法区中存储以下类型信息\n\n * 这个类型的完整有效名称（全名=包名.类名）\n * 这个类型直接父类的完整有效名（对于 interface或是 java.lang.Object，都没有父类）\n * 这个类型的修饰符（public，abstract，final 的某个子集）\n * 这个类型直接接口的一个有序列表\n\n\n# 对于方法区，Java8 之后的变化：\n\n * 移除了永久代（PermGen），替换为元空间（Metaspace）；\n * 永久代中的 class metadata 转移到了 native memory（本地内存，而不是虚拟机）；\n * 永久代中的 interned Strings （字符串常量池）和 class static variables （静态变量）转移到了 Java heap；\n * 永久代参数 （PermSize MaxPermSize） -> 元空间参数（MetaspaceSize MaxMetaspaceSize）\n\n\n# 方法区的垃圾回收\n\n方法区的垃圾收集主要回收两部分内容：常量池中废弃的常量和不再使用的类型。\n\n先来说说方法区内常量池之中主要存放的两大类常量：字面量和符号引用。字面量比较接近 Java 语言层次的常量概念，如文本字符串、被声明为 final 的常量值等。而符号引用则属于编译原理方面的概念，包括下面三类常量：\n\n * 类和接口的全限定名\n * 字段的名称和描述符\n * 方法的名称和描述符\n\nHotSpot 虚拟机对常量池的回收策略是很明确的，只要常量池中的常量没有被任何地方引用，就可以被回收\n\n判定一个类型是否属于“不再被使用的类”，需要同时满足三个条件：\n\n * 该类所有的实例都已经被回收，也就是 Java 堆中不存在该类及其任何派生子类的实例\n * 加载该类的类加载器已经被回收，这个条件除非是经过精心设计的可替换类加载器的场景，如 OSGi、JSP 的重加载等，否则通常很难达成\n * 该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法\n\nJava 虚拟机被允许堆满足上述三个条件的无用类进行回收，这里说的仅仅是“被允许”，而并不是和对象一样，不使用了就必然会回收。是否对类进行回收，HotSpot 虚拟机提供了 -Xnoclassgc 参数进行控制，还可以使用 -verbose:class 以及 -XX:+TraceClassLoading 、-XX:+TraceClassUnLoading 查看类加载和卸载信息。\n\n在大量使用反射、动态代理、CGLib 等 ByteCode 框架、动态生成 JSP 以及 OSGi 这类频繁自定义 ClassLoader 的场景都需要虚拟机具备类卸载的功能，以保证永久代不会溢出。\n\n\n# 虚拟机栈\n\n * 每个方法被执行时，都会创建一个栈帧（Stack Frame）用于存储局部变量表、操作数栈、动态连接、方法出口等信息。\n * 在一条活动线程中，一个时间点上，只会有一个活动的栈帧。即只有当前正在执行的方法的栈帧（栈顶栈帧）是有效的，这个栈帧被称为当前栈帧（Current Frame），与当前栈帧对应的方法就是当前方法（Current Method），定义这个方法的类就是当前类（Current Class）。\n * 执行引擎运行的所有字节码指令只针对当前栈帧进行操作。\n * 不同线程中所包含的栈帧是不允许存在相互引用的，即不可能在一个栈帧中引用另外一个线程的栈帧。\n * Java 方法有两种返回函数的方式，一种是正常的函数返回，使用 return 指令，另一种是抛出异常，不管用哪种方式，都会导致栈帧被弹出。\n * 栈不存在垃圾回收问题\n\n\n\n栈中可能出现的异常：\n\nJava 虚拟机规范允许 Java虚拟机栈的大小是动态的或者是固定不变的\n\n * 如果采用固定大小的 Java 虚拟机栈，那每个线程的 Java 虚拟机栈容量可以在线程创建的时候独立选定。如果线程请求分配的栈容量超过 Java 虚拟机栈允许的最大容量，Java 虚拟机将会抛出一个 StackOverflowError 异常\n * 如果 Java 虚拟机栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的虚拟机栈，那 Java 虚拟机将会抛出一个OutOfMemoryError异常\n\n可以通过参数-Xss来设置线程的最大栈空间，栈的大小直接决定了函数调用的最大可达深度。\n\n\n# 本地方法栈\n\n * 与虚拟机栈相似，只是服务的是native 方法。\n * Unsafe 类就有很多本地方法。\n\n\n# 程序计数器\n\n * 记录当前线程所执行的字节码的行号。JVM 中的 PC 寄存器是对物理 PC 寄存器的一种抽象模拟。\n\n * 因为CPU需要不停的切换各个线程，这时候切换回来以后，就得知道接着从哪开始继续执行。JVM的字节码解释器就需要通过改变PC寄存器的值来明确下一条应该执行什么样的字节码指令。\n\n * 它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。\n\n * 它是唯一一个在 JVM 规范中没有规定任何 OutOfMemoryError 情况的区域\n\n\n# 本地内存（元空间、直接内存）\n\n * 如NIO，分配堆外内存，避免了在 Java 堆和 Native 堆之间来回复制数据，可提高性能。\n\n\n# 运行时常量池（Runtime Constant Pool）\n\n运行时常量池（Runtime Constant Pool）是方法区的一部分。\n\n理解运行时常量池：\n\n字节码文件（Class 文件）中的包含一项信息常量池 Constant Pool，它可以看作是一张表，虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量等类型。\n\n常量池表（Constant Pool Table）是 Class 文件的一部分，用于存储编译期生成的各种字面量和符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。\n\nJDK1.7 之前运行时常量池逻辑包含字符串常量池存放在方法区, 此时 hotspot 虚拟机对方法区的实现为永久代。\n\nJDK1.7字符串常量池被从方法区拿到了堆中, 这里没有提到运行时常量池,也就是说字符串常量池被单独拿到堆,运行时常量池剩下的东西还在方法区, 也就是 hotspot 中的永久代。\n\nJDK1.8 hotspot 移除了永久代用元空间(Metaspace)取而代之, 这时候字符串常量池还在堆, 运行时常量池还在方法区, 只不过方法区的实现从永久代变成了元空间(Metaspace)。\n\n引申的问题：\n\n为什么要改永久代为元空间去实现方法区？\n\n因为用永久代实现导致Java应用更容易产生内存溢出问题。而改用本地内存实现的元空间则比较好。",normalizedContent:"线程私有：程序计数器、虚拟机栈、本地方法栈\n\n线程共享：堆、方法区、堆外内存（jdk8的元空间、代码缓存）\n\n栈是运行时的单位，而堆是存储的单位。\n\n栈解决程序的运行问题，即程序如何执行，或者说如何处理数据。堆解决的是数据存储的问题，即数据怎么放、放在哪。\n\n\n# 堆\n\n * 对象实例以及数组都在这里分配内存\n\n * 新生代：eden、from survivor、to survior 8:1:1\n   \n   * 当 eden 空间被对象填充时，执行minor gc，并将所有幸存者对象移动到一个幸存者空间中\n\n * 老年代：老年代垃圾收集称为 major gc，通常需要更长的时间。\n\n * 永久代（jdk 8用元空间取代）。永久代物理是堆的一部分，和新生代，老年代地址是连续的（受垃圾回收器管理），而元空间存在于本地内存（我们常说的堆外内存，不受垃圾回收器管理），这样就不受 jvm 限制了，也比较难发生oom（都会有溢出异常）。\n\n * 元空间存储类的元信息，静态变量和字符串常量池等并入堆中。相当于永久代的数据被分到了堆和元空间中。\n\n * 分代的目的是优化 gc 性能。\n\n堆配置：\n\n * -xms: 配置堆的起始内存（最小内存）。等价于 -xx:initialheapsize。默认是物理内存1/64。\n * -xmx: 配置堆的最大内存。等价于 -xx:maxheapsize。\n * 默认情况下新生代和老年代的比例是 1:2，可以通过 –xx:newratio 来配置\n * 新生代中的 eden:from survivor:to survivor 的比例是 8:1:1，可以通过 -xx:survivorratio 来配置\n * 若在 jdk 7 中开启了 -xx:+useadaptivesizepolicy，jvm 会动态调整 jvm 堆中各个区域的大小以及进入老年代的年龄，此时 –xx:newratio 和 -xx:survivorratio 将会失效，而 jdk 8 是默认开启-xx:+useadaptivesizepolicy，在 jdk 8中，不要随意关闭-xx:+useadaptivesizepolicy，除非对堆内存的划分有明确的规划。\n * 对象年轻计数器（-xx:maxtenuringthreshold）\n * 如果分配的对象超过了-xx:petenuresizethreshold，对象会直接被分配到老年代\n * java7 中我们通过-xx:permsize 和 -xx:maxpermsize 来设置永久代参数，java8 之后，随着永久代的取消，这些参数也就随之失效了，改为通过-xx:metaspacesize 和 -xx:maxmetaspacesize 用来设置元空间参数\n\n\n# 将 -xmx 和 -xms 两个参数配置为相同的值\n\n如：常规的jvm参数使用\n\njava -xms512m -xmx1g\n\n\n在这种配置下，jvm启动时会分配512m的堆内存空间，随着程序的执行，所需的堆空间越来越大，则会逐渐增大堆内存空间，直到xmx参数指定的堆最大空间1g。当堆内存使用率降低，则会逐渐减小该内存区域的大小。\n\n我们通常会将 -xmx 和 -xms 两个参数配置为相同的值，为了避免由于heap内存扩大或缩小导致应用停顿，降低延迟，同时避免每次垃圾回收完成后jvm重新分配内存。\n\n\n# minor gc、major gc、full gc\n\n针对 hotspot vm 的实现，它里面的 gc 按照回收区域又分为两大类：部分收集（partial gc），整堆收集（full gc）\n\n * 部分收集：不是完整收集整个 java 堆的垃圾收集。其中又分为：\n   * 新生代收集（minor gc/young gc）：只是新生代的垃圾收集\n   * 老年代收集（major gc/old gc）：只是老年代的垃圾收集\n     * 目前，只有 cms gc 会有单独收集老年代的行为\n     * 很多时候 major gc 会和 full gc 混合使用，需要具体分辨是老年代回收还是整堆回收\n   * 混合收集（mixed gc）：收集整个新生代以及部分老年代的垃圾收集\n     * 目前只有 g1 gc 会有这种行为\n * 整堆收集（full gc）：收集整个 java 堆和方法区的垃圾\n\n\n# 方法区\n\n也称为非堆 non-heap\n\n方法区的实现jdk7用永久代，jdk8改用本地内存的元空间。\n\n方法区用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据。\n\n虽然 java 虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫 non-heap（非堆），目的应该是与 java 堆区分开。\n\n运行时常量池（runtime constant pool）是方法区的一部分。class 文件中除了有类的版本/字段/方法/接口等描述信息外，还有一项信息是常量池（constant pool table），用于存放编译期生成的各种字面量和符号引用，这部分内容将类在加载后进入方法区的运行时常量池中存放。运行期间也可能将新的常量放入池中，这种特性被开发人员利用得比较多的是 string.intern()方法。受方法区内存的限制，当常量池无法再申请到内存时会抛出 outofmemoryerror 异常。\n\n方法区的大小和堆空间一样，可以选择固定大小也可选择可扩展，方法区的大小决定了系统可以放多少个类，如果系统类太多，导致方法区溢出，虚拟机同样会抛出内存溢出错误。\n\n\n# 类型信息\n\n对每个加载的类型（类 class、接口 interface、枚举 enum、注解 annotation），jvm 必须在方法区中存储以下类型信息\n\n * 这个类型的完整有效名称（全名=包名.类名）\n * 这个类型直接父类的完整有效名（对于 interface或是 java.lang.object，都没有父类）\n * 这个类型的修饰符（public，abstract，final 的某个子集）\n * 这个类型直接接口的一个有序列表\n\n\n# 对于方法区，java8 之后的变化：\n\n * 移除了永久代（permgen），替换为元空间（metaspace）；\n * 永久代中的 class metadata 转移到了 native memory（本地内存，而不是虚拟机）；\n * 永久代中的 interned strings （字符串常量池）和 class static variables （静态变量）转移到了 java heap；\n * 永久代参数 （permsize maxpermsize） -> 元空间参数（metaspacesize maxmetaspacesize）\n\n\n# 方法区的垃圾回收\n\n方法区的垃圾收集主要回收两部分内容：常量池中废弃的常量和不再使用的类型。\n\n先来说说方法区内常量池之中主要存放的两大类常量：字面量和符号引用。字面量比较接近 java 语言层次的常量概念，如文本字符串、被声明为 final 的常量值等。而符号引用则属于编译原理方面的概念，包括下面三类常量：\n\n * 类和接口的全限定名\n * 字段的名称和描述符\n * 方法的名称和描述符\n\nhotspot 虚拟机对常量池的回收策略是很明确的，只要常量池中的常量没有被任何地方引用，就可以被回收\n\n判定一个类型是否属于“不再被使用的类”，需要同时满足三个条件：\n\n * 该类所有的实例都已经被回收，也就是 java 堆中不存在该类及其任何派生子类的实例\n * 加载该类的类加载器已经被回收，这个条件除非是经过精心设计的可替换类加载器的场景，如 osgi、jsp 的重加载等，否则通常很难达成\n * 该类对应的 java.lang.class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法\n\njava 虚拟机被允许堆满足上述三个条件的无用类进行回收，这里说的仅仅是“被允许”，而并不是和对象一样，不使用了就必然会回收。是否对类进行回收，hotspot 虚拟机提供了 -xnoclassgc 参数进行控制，还可以使用 -verbose:class 以及 -xx:+traceclassloading 、-xx:+traceclassunloading 查看类加载和卸载信息。\n\n在大量使用反射、动态代理、cglib 等 bytecode 框架、动态生成 jsp 以及 osgi 这类频繁自定义 classloader 的场景都需要虚拟机具备类卸载的功能，以保证永久代不会溢出。\n\n\n# 虚拟机栈\n\n * 每个方法被执行时，都会创建一个栈帧（stack frame）用于存储局部变量表、操作数栈、动态连接、方法出口等信息。\n * 在一条活动线程中，一个时间点上，只会有一个活动的栈帧。即只有当前正在执行的方法的栈帧（栈顶栈帧）是有效的，这个栈帧被称为当前栈帧（current frame），与当前栈帧对应的方法就是当前方法（current method），定义这个方法的类就是当前类（current class）。\n * 执行引擎运行的所有字节码指令只针对当前栈帧进行操作。\n * 不同线程中所包含的栈帧是不允许存在相互引用的，即不可能在一个栈帧中引用另外一个线程的栈帧。\n * java 方法有两种返回函数的方式，一种是正常的函数返回，使用 return 指令，另一种是抛出异常，不管用哪种方式，都会导致栈帧被弹出。\n * 栈不存在垃圾回收问题\n\n\n\n栈中可能出现的异常：\n\njava 虚拟机规范允许 java虚拟机栈的大小是动态的或者是固定不变的\n\n * 如果采用固定大小的 java 虚拟机栈，那每个线程的 java 虚拟机栈容量可以在线程创建的时候独立选定。如果线程请求分配的栈容量超过 java 虚拟机栈允许的最大容量，java 虚拟机将会抛出一个 stackoverflowerror 异常\n * 如果 java 虚拟机栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的虚拟机栈，那 java 虚拟机将会抛出一个outofmemoryerror异常\n\n可以通过参数-xss来设置线程的最大栈空间，栈的大小直接决定了函数调用的最大可达深度。\n\n\n# 本地方法栈\n\n * 与虚拟机栈相似，只是服务的是native 方法。\n * unsafe 类就有很多本地方法。\n\n\n# 程序计数器\n\n * 记录当前线程所执行的字节码的行号。jvm 中的 pc 寄存器是对物理 pc 寄存器的一种抽象模拟。\n\n * 因为cpu需要不停的切换各个线程，这时候切换回来以后，就得知道接着从哪开始继续执行。jvm的字节码解释器就需要通过改变pc寄存器的值来明确下一条应该执行什么样的字节码指令。\n\n * 它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。\n\n * 它是唯一一个在 jvm 规范中没有规定任何 outofmemoryerror 情况的区域\n\n\n# 本地内存（元空间、直接内存）\n\n * 如nio，分配堆外内存，避免了在 java 堆和 native 堆之间来回复制数据，可提高性能。\n\n\n# 运行时常量池（runtime constant pool）\n\n运行时常量池（runtime constant pool）是方法区的一部分。\n\n理解运行时常量池：\n\n字节码文件（class 文件）中的包含一项信息常量池 constant pool，它可以看作是一张表，虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量等类型。\n\n常量池表（constant pool table）是 class 文件的一部分，用于存储编译期生成的各种字面量和符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。\n\njdk1.7 之前运行时常量池逻辑包含字符串常量池存放在方法区, 此时 hotspot 虚拟机对方法区的实现为永久代。\n\njdk1.7字符串常量池被从方法区拿到了堆中, 这里没有提到运行时常量池,也就是说字符串常量池被单独拿到堆,运行时常量池剩下的东西还在方法区, 也就是 hotspot 中的永久代。\n\njdk1.8 hotspot 移除了永久代用元空间(metaspace)取而代之, 这时候字符串常量池还在堆, 运行时常量池还在方法区, 只不过方法区的实现从永久代变成了元空间(metaspace)。\n\n引申的问题：\n\n为什么要改永久代为元空间去实现方法区？\n\n因为用永久代实现导致java应用更容易产生内存溢出问题。而改用本地内存实现的元空间则比较好。",charsets:{cjk:!0},lastUpdated:"2023/03/29, 21:03:43",lastUpdatedTimestamp:1680095023e3},{title:"虚拟机对象",frontmatter:{title:"虚拟机对象",date:"2023-03-19T19:37:22.000Z",permalink:"/pages/376408/"},regularPath:"/01.Java/03.JVM/05.%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AF%B9%E8%B1%A1.html",relativePath:"01.Java/03.JVM/05.虚拟机对象.md",key:"v-0a837972",path:"/pages/376408/",headersStr:null,content:'# Java对象的创建\n\n 1. 类加载检查\n 2. 分配内存\n 3. 初始化零值（为对象字段设置零值）\n 4. 设置对象头\n 5. 执行构造方法\n\n\n# Java对象的内存布局\n\n对象在堆中布局可以分为三个部分：\n\n * 对象头\n\n * * 存储对象自身的运行时数据（Mark Word）：哈希码、GC分代年龄、锁状态标志、线程持有的锁、偏向锁ID等\n   * 类型指针：对象指向它的类元数据的指针，表示是哪个类的实例。\n\n * 实例数据\n\n * 填充对齐\n\n\n# Java对象的访问定位\n\n通过虚拟机栈上的reference数据来操作堆上的具体对象。\n\n对象的访问方式由虚拟机的实现决定：主流的访问方式主要有使用句柄和直接指针两种。\n\n句柄： 如果使用句柄的话，那么Java堆中将会划分出一块内存来作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息；\n\n直接指针： 如果使用直接指针访问，那么 Java 堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，而reference 中存储的直接就是对象的地址。hotspot的使用方式\n\n这两种对象访问方式各有优势。使用句柄来访问的最大好处是 reference 中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而 reference 本身不需要修改。使用直接指针访问方式最大的好处就是速度快，减少了一次间接寻址。\n\n\n\n\n\n\n# 常量池问题\n\n直接使用双引号声明出来的String对象会直接存储在常量池中。\n\n对于基本数据类型来说，比较的是值。对于引用数据类型来说，比较的是对象的内存地址。\n\nJava 基本类型的包装类的大部分都实现了常量池技术。\n\nByte,Short,Integer,Long 这 4 种包装类默认创建了数值 [-128，127] 的相应类型的缓存数据，Character 创建了数值在 [0,127] 范围的缓存数据，Boolean 直接返回 True Or False。\n\n两种浮点数类型的包装类 Float,Double 并没有实现常量池技术。\n\n记住：所有整型包装类对象之间值的比较，全部使用 equals 方法比较。\n\n在编译过程中，Javac 编译器会进行一个叫做常量折叠(Constant Folding)的代码优化。常量折叠会把常量表达式的值求出来作为常量嵌在最终生成的代码中，这是 Javac 编译器会对源代码做的极少量优化措施之一(代码优化几乎都在即时编译器中进行)。\n\n一般来说，我们要尽量避免通过 new 的方式创建字符串。使用双引号声明的 String 对象（ String s1 = "java" ）更利于让编译器有机会优化我们的代码，同时也更易于阅读。\n\n被 Final 关键字修改之后的 String 会被编译器当做常量来处理，编译器程序编译期就可以确定它的值，其效果就想到于访问常量。',normalizedContent:'# java对象的创建\n\n 1. 类加载检查\n 2. 分配内存\n 3. 初始化零值（为对象字段设置零值）\n 4. 设置对象头\n 5. 执行构造方法\n\n\n# java对象的内存布局\n\n对象在堆中布局可以分为三个部分：\n\n * 对象头\n\n * * 存储对象自身的运行时数据（mark word）：哈希码、gc分代年龄、锁状态标志、线程持有的锁、偏向锁id等\n   * 类型指针：对象指向它的类元数据的指针，表示是哪个类的实例。\n\n * 实例数据\n\n * 填充对齐\n\n\n# java对象的访问定位\n\n通过虚拟机栈上的reference数据来操作堆上的具体对象。\n\n对象的访问方式由虚拟机的实现决定：主流的访问方式主要有使用句柄和直接指针两种。\n\n句柄： 如果使用句柄的话，那么java堆中将会划分出一块内存来作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息；\n\n直接指针： 如果使用直接指针访问，那么 java 堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，而reference 中存储的直接就是对象的地址。hotspot的使用方式\n\n这两种对象访问方式各有优势。使用句柄来访问的最大好处是 reference 中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而 reference 本身不需要修改。使用直接指针访问方式最大的好处就是速度快，减少了一次间接寻址。\n\n\n\n\n\n\n# 常量池问题\n\n直接使用双引号声明出来的string对象会直接存储在常量池中。\n\n对于基本数据类型来说，比较的是值。对于引用数据类型来说，比较的是对象的内存地址。\n\njava 基本类型的包装类的大部分都实现了常量池技术。\n\nbyte,short,integer,long 这 4 种包装类默认创建了数值 [-128，127] 的相应类型的缓存数据，character 创建了数值在 [0,127] 范围的缓存数据，boolean 直接返回 true or false。\n\n两种浮点数类型的包装类 float,double 并没有实现常量池技术。\n\n记住：所有整型包装类对象之间值的比较，全部使用 equals 方法比较。\n\n在编译过程中，javac 编译器会进行一个叫做常量折叠(constant folding)的代码优化。常量折叠会把常量表达式的值求出来作为常量嵌在最终生成的代码中，这是 javac 编译器会对源代码做的极少量优化措施之一(代码优化几乎都在即时编译器中进行)。\n\n一般来说，我们要尽量避免通过 new 的方式创建字符串。使用双引号声明的 string 对象（ string s1 = "java" ）更利于让编译器有机会优化我们的代码，同时也更易于阅读。\n\n被 final 关键字修改之后的 string 会被编译器当做常量来处理，编译器程序编译期就可以确定它的值，其效果就想到于访问常量。',charsets:{cjk:!0},lastUpdated:"2023/03/29, 21:03:43",lastUpdatedTimestamp:1680095023e3},{title:"OutOfMemoryError",frontmatter:{title:"OutOfMemoryError",date:"2023-03-20T19:19:34.000Z",permalink:"/pages/9a5ae7/"},regularPath:"/01.Java/03.JVM/06.OutOfMemoryError.html",relativePath:"01.Java/03.JVM/06.OutOfMemoryError.md",key:"v-89486e7a",path:"/pages/9a5ae7/",headers:[{level:2,title:"堆溢出",slug:"堆溢出",normalizedTitle:"堆溢出",charIndex:2},{level:2,title:"栈溢出",slug:"栈溢出",normalizedTitle:"栈溢出",charIndex:775},{level:2,title:"本机直接内存溢出",slug:"本机直接内存溢出",normalizedTitle:"本机直接内存溢出",charIndex:947}],headersStr:"堆溢出 栈溢出 本机直接内存溢出",content:"# 堆溢出\n\n将堆的最小值-Xms参数与最大值-Xmx参数设置为一样的话可避免堆自动扩展，即设置为不可扩展。\n\n要解决这个内存区域的异常， 常规的处理方法是首先通过内存映像分析工具（如MAT）对Dump出来的堆转储快照进行分析。 第一步首先应确认内存中导致OOM的对象是否是必要的， 也就是要先分清楚到底是出现了内存泄漏（Memory Leak） 还是内存溢出（Memory Overflow） 。\n\n如果是内存泄漏， 可进一步通过工具查看泄漏对象到GC Roots的引用链， 找到泄漏对象是通过怎样的引用路径、 与哪些GC Roots相关联， 才导致垃圾收集器无法回收它们， 根据泄漏对象的类型信息以及它到GC Roots引用链的信息， 一般可以比较准确地定位到这些对象创建的位置， 进而找出产生内存泄漏的代码的具体位置。\n\n如果不是内存泄漏， 换句话说就是内存中的对象确实都是必须存活的， 那就应当检查Java虚拟机的堆参数（-Xmx与-Xms） 设置， 与机器的内存对比， 看看是否还有向上调整的空间。 再从代码上检查是否存在某些对象生命周期过长、 持有状态时间过长、 存储结构设计不合理等情况， 尽量减少程序运行期的内存消耗。\n\n步骤：\n\n 1. 使用 jps或者 ps -ef | grep XXXX 查看运行的Java项目信息\n 2. 由使用 jmap dump内存快照时，如果当前用户与启动进程的用户不一致时，不允许进行快照的备份。查询进程启动所属：top -pid PID，其中 COMMAND 信息就是启动进程的所属，sudo 到这个所属用户即可。\n 3. dump 保存内存快照信息：jmap -dump:live, format=b, file=dump.hprof 2629\n 4. 使用 MAT 加载dump文件。\n\n\n# 栈溢出\n\n由于HotSpot虚拟机并不区分虚拟机栈和本地方法栈，所以栈容量只由 -Xss参数决定。\n\n 1. 如果线程请求的栈深度大于虚拟机所允许的最大深度， 将抛出StackOverflowError异常。\n 2. 如果虚拟机的栈内存允许动态扩展， 当扩展栈容量无法申请到足够的内存时， 将抛出OutOfMemoryError异常。\n\n\n# 本机直接内存溢出\n\n直接内存（Direct Memory） 的容量大小可通过-XX： MaxDirectMemorySize参数来指定， 如果不去指定， 则默认与Java堆最大值（由-Xmx指定） 一致。\n\n由直接内存导致的内存溢出， 一个明显的特征是在Heap Dump文件中不会看见有什么明显的异常情况， 如果读者发现内存溢出之后产生的Dump文件很小， 而程序中又直接或间接使用了DirectMemory（典型的间接使用就是NIO） ， 那就可以考虑重点检查一下直接内存方面的原因了。",normalizedContent:"# 堆溢出\n\n将堆的最小值-xms参数与最大值-xmx参数设置为一样的话可避免堆自动扩展，即设置为不可扩展。\n\n要解决这个内存区域的异常， 常规的处理方法是首先通过内存映像分析工具（如mat）对dump出来的堆转储快照进行分析。 第一步首先应确认内存中导致oom的对象是否是必要的， 也就是要先分清楚到底是出现了内存泄漏（memory leak） 还是内存溢出（memory overflow） 。\n\n如果是内存泄漏， 可进一步通过工具查看泄漏对象到gc roots的引用链， 找到泄漏对象是通过怎样的引用路径、 与哪些gc roots相关联， 才导致垃圾收集器无法回收它们， 根据泄漏对象的类型信息以及它到gc roots引用链的信息， 一般可以比较准确地定位到这些对象创建的位置， 进而找出产生内存泄漏的代码的具体位置。\n\n如果不是内存泄漏， 换句话说就是内存中的对象确实都是必须存活的， 那就应当检查java虚拟机的堆参数（-xmx与-xms） 设置， 与机器的内存对比， 看看是否还有向上调整的空间。 再从代码上检查是否存在某些对象生命周期过长、 持有状态时间过长、 存储结构设计不合理等情况， 尽量减少程序运行期的内存消耗。\n\n步骤：\n\n 1. 使用 jps或者 ps -ef | grep xxxx 查看运行的java项目信息\n 2. 由使用 jmap dump内存快照时，如果当前用户与启动进程的用户不一致时，不允许进行快照的备份。查询进程启动所属：top -pid pid，其中 command 信息就是启动进程的所属，sudo 到这个所属用户即可。\n 3. dump 保存内存快照信息：jmap -dump:live, format=b, file=dump.hprof 2629\n 4. 使用 mat 加载dump文件。\n\n\n# 栈溢出\n\n由于hotspot虚拟机并不区分虚拟机栈和本地方法栈，所以栈容量只由 -xss参数决定。\n\n 1. 如果线程请求的栈深度大于虚拟机所允许的最大深度， 将抛出stackoverflowerror异常。\n 2. 如果虚拟机的栈内存允许动态扩展， 当扩展栈容量无法申请到足够的内存时， 将抛出outofmemoryerror异常。\n\n\n# 本机直接内存溢出\n\n直接内存（direct memory） 的容量大小可通过-xx： maxdirectmemorysize参数来指定， 如果不去指定， 则默认与java堆最大值（由-xmx指定） 一致。\n\n由直接内存导致的内存溢出， 一个明显的特征是在heap dump文件中不会看见有什么明显的异常情况， 如果读者发现内存溢出之后产生的dump文件很小， 而程序中又直接或间接使用了directmemory（典型的间接使用就是nio） ， 那就可以考虑重点检查一下直接内存方面的原因了。",charsets:{cjk:!0},lastUpdated:"2023/03/29, 21:03:43",lastUpdatedTimestamp:1680095023e3},{title:"如何快速排查问题",frontmatter:{title:"如何快速排查问题",date:"2023-04-02T15:58:02.000Z",permalink:"/pages/1a4e69/"},regularPath:"/01.Java/03.JVM/07.%E5%A6%82%E4%BD%95%E5%BF%AB%E9%80%9F%E6%8E%92%E6%9F%A5%E9%97%AE%E9%A2%98.html",relativePath:"01.Java/03.JVM/07.如何快速排查问题.md",key:"v-38ab7e32",path:"/pages/1a4e69/",headers:[{level:2,title:"场景",slug:"场景",normalizedTitle:"场景",charIndex:2},{level:2,title:"可能原因",slug:"可能原因",normalizedTitle:"可能原因",charIndex:43},{level:2,title:"linux和macos中top命令的区别",slug:"linux和macos中top命令的区别",normalizedTitle:"linux和macos中top命令的区别",charIndex:899},{level:2,title:"jstack",slug:"jstack",normalizedTitle:"jstack",charIndex:339},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:1800}],headersStr:"场景 可能原因 linux和macos中top命令的区别 jstack 参考",content:'# 场景\n\n系统特别卡顿，很多页面都打不开了，作为后端开发如何快速定位问题？\n\n\n# 可能原因\n\n对于造成这种问题的可能原因，迅速的在头脑中闪过四种情况：\n\n1、某个接口响应时间超长，并且可能被频繁调用\n\n2、产生了过大的对象，造成频繁FGC\n\n3、代码出现死循环\n\n4、线程出现死锁\n\n登录到对应的服务器上执行了top命令，发现cpu飙升到100%，这种问题需要应该快速的定位到问题，否则会影响线上系统的正常作业。\n\n定位问题步骤：\n\n 1. top 查看到哪个进程\n 2. top -Hp pid 查看某个进程下的线程情况\n 3. printf "%x" threadid 将线程id转换为16进制，假设这里得到了3c41。因为堆栈里，线程id是用16进制表示的。\n 4. jstack pid | grep 0x3c41 -C50 --color 打印给定Java进程的Java堆栈信息，并通过管道符将其输出到 grep 命令中，在 grep 命令中查找包含字符串 "0x3c41" 的行，并显示其前后各 50 行（总计 101 行）的内容，同时将匹配到的字符串高亮显示。\n 5. 也可以执行命令 jstack -l 23002 >/data1/23002.statck 将对应的进程号的栈信息输入到指定目录\n\n如果有大对象产生，应该会有多个进程CPU占用都会超过80%，其中有多个进程在在进行GC，从而造成CPU飙升。如果只有一个线程CPU资源飙升，可以排除产生大对象问题。\n\n执行jstack的时候，执行用户需要和进程启动用户一直，否则会提示下面错误：Unable to open socket file: target process not responding or HotSpot VM not loaded The -F option can be used when the target process is not responding\n\njstat -gcutil 23002 2000 5 输出该进程在jvm中的占用情况 每2000毫秒执行一次 一共执行5次\n\n\n# linux和macos中top命令的区别\n\nLinux 和 macOS 中的 top 命令虽然在功能上类似，但是在实现上有些许差异。 Linux 和 macOS 中的 top 命令支持的参数略有不同。例如，Linux 中的 top 命令可以使用 -H 参数来显示进程的线程信息，也可以在交互界面使用H切换，而 macOS 中则不支持。\n\n虽然两个系统的 top 命令都能够显示进程的 CPU 占用率、内存使用情况等信息，但在显示方式上有所不同。例如，Linux 中的 top 命令默认情况下可以显示进程的 VIRT（虚拟内存）和 RES（实际使用内存）信息，而 macOS 中的 top 命令则默认不显示这些信息。\n\n\n# jstack\n\njstack 是一个 Java 虚拟机提供的命令行工具，用于生成当前 Java 应用程序的线程转储信息，可以帮助开发人员和运维人员诊断 Java 应用程序的性能问题和死锁问题。\n\njstack 命令可以通过命令行或者图形界面工具来运行，生成的线程转储信息包含了当前所有线程的调用栈信息，以及每个线程所持有的锁和等待的锁的信息等。这些信息可以帮助开发人员或者运维人员快速定位出应用程序中的性能问题、死锁问题等。\n\n下面是 jstack 命令的一些常用用法：jstack [options] <pid> 其中，options 是一些可选的命令参数，pid 表示 Java 应用程序的进程 ID。\n\n常用参数： -F：当 jstack 命令无法正常输出线程转储信息时，可以使用该参数进行强制输出。该参数可能会影响系统的性能。 -l：输出线程的锁信息。 -m：输出所有线程的 Native 堆栈信息。 -h：显示帮助信息。\n\n输出信息：jstack 命令输出的线程转储信息包括以下内容：\n\n * 线程 ID：每个线程的唯一标识符。\n * 线程状态：每个线程的状态，如 WAITING、BLOCKED、TIMED_WAITING 等。\n * 线程调用栈：每个线程的调用栈信息，包括方法名、方法签名、代码行数等。\n * 锁信息：每个线程所持有的锁和等待的锁的信息。\n\n\n# 参考\n\nhttps://developer.aliyun.com/article/1093780',normalizedContent:'# 场景\n\n系统特别卡顿，很多页面都打不开了，作为后端开发如何快速定位问题？\n\n\n# 可能原因\n\n对于造成这种问题的可能原因，迅速的在头脑中闪过四种情况：\n\n1、某个接口响应时间超长，并且可能被频繁调用\n\n2、产生了过大的对象，造成频繁fgc\n\n3、代码出现死循环\n\n4、线程出现死锁\n\n登录到对应的服务器上执行了top命令，发现cpu飙升到100%，这种问题需要应该快速的定位到问题，否则会影响线上系统的正常作业。\n\n定位问题步骤：\n\n 1. top 查看到哪个进程\n 2. top -hp pid 查看某个进程下的线程情况\n 3. printf "%x" threadid 将线程id转换为16进制，假设这里得到了3c41。因为堆栈里，线程id是用16进制表示的。\n 4. jstack pid | grep 0x3c41 -c50 --color 打印给定java进程的java堆栈信息，并通过管道符将其输出到 grep 命令中，在 grep 命令中查找包含字符串 "0x3c41" 的行，并显示其前后各 50 行（总计 101 行）的内容，同时将匹配到的字符串高亮显示。\n 5. 也可以执行命令 jstack -l 23002 >/data1/23002.statck 将对应的进程号的栈信息输入到指定目录\n\n如果有大对象产生，应该会有多个进程cpu占用都会超过80%，其中有多个进程在在进行gc，从而造成cpu飙升。如果只有一个线程cpu资源飙升，可以排除产生大对象问题。\n\n执行jstack的时候，执行用户需要和进程启动用户一直，否则会提示下面错误：unable to open socket file: target process not responding or hotspot vm not loaded the -f option can be used when the target process is not responding\n\njstat -gcutil 23002 2000 5 输出该进程在jvm中的占用情况 每2000毫秒执行一次 一共执行5次\n\n\n# linux和macos中top命令的区别\n\nlinux 和 macos 中的 top 命令虽然在功能上类似，但是在实现上有些许差异。 linux 和 macos 中的 top 命令支持的参数略有不同。例如，linux 中的 top 命令可以使用 -h 参数来显示进程的线程信息，也可以在交互界面使用h切换，而 macos 中则不支持。\n\n虽然两个系统的 top 命令都能够显示进程的 cpu 占用率、内存使用情况等信息，但在显示方式上有所不同。例如，linux 中的 top 命令默认情况下可以显示进程的 virt（虚拟内存）和 res（实际使用内存）信息，而 macos 中的 top 命令则默认不显示这些信息。\n\n\n# jstack\n\njstack 是一个 java 虚拟机提供的命令行工具，用于生成当前 java 应用程序的线程转储信息，可以帮助开发人员和运维人员诊断 java 应用程序的性能问题和死锁问题。\n\njstack 命令可以通过命令行或者图形界面工具来运行，生成的线程转储信息包含了当前所有线程的调用栈信息，以及每个线程所持有的锁和等待的锁的信息等。这些信息可以帮助开发人员或者运维人员快速定位出应用程序中的性能问题、死锁问题等。\n\n下面是 jstack 命令的一些常用用法：jstack [options] <pid> 其中，options 是一些可选的命令参数，pid 表示 java 应用程序的进程 id。\n\n常用参数： -f：当 jstack 命令无法正常输出线程转储信息时，可以使用该参数进行强制输出。该参数可能会影响系统的性能。 -l：输出线程的锁信息。 -m：输出所有线程的 native 堆栈信息。 -h：显示帮助信息。\n\n输出信息：jstack 命令输出的线程转储信息包括以下内容：\n\n * 线程 id：每个线程的唯一标识符。\n * 线程状态：每个线程的状态，如 waiting、blocked、timed_waiting 等。\n * 线程调用栈：每个线程的调用栈信息，包括方法名、方法签名、代码行数等。\n * 锁信息：每个线程所持有的锁和等待的锁的信息。\n\n\n# 参考\n\nhttps://developer.aliyun.com/article/1093780',charsets:{cjk:!0}},{title:"JIT逃逸分析",frontmatter:{title:"JIT逃逸分析",date:"2023-08-30T23:52:48.000Z",permalink:"/pages/1ee611/"},regularPath:"/01.Java/03.JVM/08.JIT%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90.html",relativePath:"01.Java/03.JVM/08.JIT逃逸分析.md",key:"v-5367a4af",path:"/pages/1ee611/",headers:[{level:2,title:"JIT",slug:"jit",normalizedTitle:"jit",charIndex:2},{level:2,title:"JIT 优化之逃逸分析",slug:"jit-优化之逃逸分析",normalizedTitle:"jit 优化之逃逸分析",charIndex:412},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:1264}],headersStr:"JIT JIT 优化之逃逸分析 参考",content:"# JIT\n\n在Java的编译体系中，一个Java的源代码文件变成计算机可执行的机器指令的过程中，需要经过两段编译，第一段是把.java文件转换成.class文件。第二段编译是把.class转换成机器指令的过程。\n\n第一段编译就是javac命令。\n\n在第二编译阶段，JVM 通过解释字节码将其翻译成对应的机器指令，逐条读入，逐条解释翻译。很显然，经过解释执行，其执行速度必然会比可执行的二进制字节码程序慢很多。这就是传统的JVM的解释器（Interpreter）的功能。为了解决这种效率问题，引入了 JIT（即时编译） 技术。\n\n引入了 JIT 技术后，Java程序还是通过解释器进行解释执行，当JVM发现某个方法或代码块运行特别频繁的时候，就会认为这是“热点代码”（Hot Spot Code)。然后JIT会把部分“热点代码”翻译成本地机器相关的机器码，并进行优化，然后再把翻译后的机器码缓存起来，以备下次使用。\n\n\n# JIT 优化之逃逸分析\n\nJIT优化中最重要的一个就是逃逸分析。\n\n逃逸分析的基本行为就是分析对象动态作用域：当一个对象在方法中被定义后，它可能被外部方法所引用，例如作为调用参数传递到其他地方中，称为方法逃逸。\n\npublic static StringBuffer craeteStringBuffer(String s1, String s2) {\n    StringBuffer sb = new StringBuffer();\n    sb.append(s1);\n    sb.append(s2);\n    return sb;\n}\n\npublic static String createStringBuffer(String s1, String s2) {\n    StringBuffer sb = new StringBuffer();\n    sb.append(s1);\n    sb.append(s2);\n    return sb.toString();\n}\n\n\n第一段代码中的sb就逃逸了，而第二段代码中的sb就没有逃逸。\n\n使用逃逸分析，编译器可以对代码做如下优化：\n\n一、同步省略。如果一个对象被发现只能从一个线程被访问到，那么对于这个对象的操作可以不考虑同步。\n\n二、将堆分配转化为栈分配。如果一个对象在子程序中被分配，要使指向该对象的指针永远不会逃逸，对象可能是栈分配的候选，而不是堆分配。\n\n三、分离对象或标量替换。有的对象可能不需要作为一个连续的内存结构存在也可以被访问到，那么对象的部分（或全部）可以不存储在内存，而是存储在CPU寄存器中。\n\n在Java代码运行时，通过JVM参数可指定是否开启逃逸分析，\n\n-XX:+DoEscapeAnalysis ： 表示开启逃逸分析\n\n-XX:-DoEscapeAnalysis ： 表示关闭逃逸分析 从jdk 1.7开始已经默认开始逃逸分析，如需关闭，需要指定-XX:-DoEscapeAnalysis\n\n\n# 参考\n\nhttps://juejin.cn/post/6844903639308304397",normalizedContent:"# jit\n\n在java的编译体系中，一个java的源代码文件变成计算机可执行的机器指令的过程中，需要经过两段编译，第一段是把.java文件转换成.class文件。第二段编译是把.class转换成机器指令的过程。\n\n第一段编译就是javac命令。\n\n在第二编译阶段，jvm 通过解释字节码将其翻译成对应的机器指令，逐条读入，逐条解释翻译。很显然，经过解释执行，其执行速度必然会比可执行的二进制字节码程序慢很多。这就是传统的jvm的解释器（interpreter）的功能。为了解决这种效率问题，引入了 jit（即时编译） 技术。\n\n引入了 jit 技术后，java程序还是通过解释器进行解释执行，当jvm发现某个方法或代码块运行特别频繁的时候，就会认为这是“热点代码”（hot spot code)。然后jit会把部分“热点代码”翻译成本地机器相关的机器码，并进行优化，然后再把翻译后的机器码缓存起来，以备下次使用。\n\n\n# jit 优化之逃逸分析\n\njit优化中最重要的一个就是逃逸分析。\n\n逃逸分析的基本行为就是分析对象动态作用域：当一个对象在方法中被定义后，它可能被外部方法所引用，例如作为调用参数传递到其他地方中，称为方法逃逸。\n\npublic static stringbuffer craetestringbuffer(string s1, string s2) {\n    stringbuffer sb = new stringbuffer();\n    sb.append(s1);\n    sb.append(s2);\n    return sb;\n}\n\npublic static string createstringbuffer(string s1, string s2) {\n    stringbuffer sb = new stringbuffer();\n    sb.append(s1);\n    sb.append(s2);\n    return sb.tostring();\n}\n\n\n第一段代码中的sb就逃逸了，而第二段代码中的sb就没有逃逸。\n\n使用逃逸分析，编译器可以对代码做如下优化：\n\n一、同步省略。如果一个对象被发现只能从一个线程被访问到，那么对于这个对象的操作可以不考虑同步。\n\n二、将堆分配转化为栈分配。如果一个对象在子程序中被分配，要使指向该对象的指针永远不会逃逸，对象可能是栈分配的候选，而不是堆分配。\n\n三、分离对象或标量替换。有的对象可能不需要作为一个连续的内存结构存在也可以被访问到，那么对象的部分（或全部）可以不存储在内存，而是存储在cpu寄存器中。\n\n在java代码运行时，通过jvm参数可指定是否开启逃逸分析，\n\n-xx:+doescapeanalysis ： 表示开启逃逸分析\n\n-xx:-doescapeanalysis ： 表示关闭逃逸分析 从jdk 1.7开始已经默认开始逃逸分析，如需关闭，需要指定-xx:-doescapeanalysis\n\n\n# 参考\n\nhttps://juejin.cn/post/6844903639308304397",charsets:{cjk:!0}},{title:"字节码增强技术",frontmatter:{title:"字节码增强技术",date:"2023-03-19T16:27:47.000Z",permalink:"/pages/9a3179/"},regularPath:"/01.Java/03.JVM/100.%E5%AD%97%E8%8A%82%E7%A0%81%E5%A2%9E%E5%BC%BA%E6%8A%80%E6%9C%AF.html",relativePath:"01.Java/03.JVM/100.字节码增强技术.md",key:"v-63e48439",path:"/pages/9a3179/",headersStr:null,content:"一般的字节码增强技术，如ASM，Javassist 只能在类加载前对类进行强化。而配合JVM提供的 Instrument 类，可以实现对运行时的类进行修改和重载。\n\n应用场景：\n\n * 热部署：不部署服务而对线上服务做修改，可以做打点、增加日志等操作。\n * Mock：测试时候对某些服务做Mock。\n * 性能诊断工具：比如bTrace就是利用Instrument，实现无侵入地跟踪一个正在运行的JVM，监控到类和方法级别的状态信息。\n\n字节码增强技术相当于是一把打开运行时JVM的钥匙，利用它可以动态地对运行中的程序做修改，也可以跟踪JVM运行中程序的状态。此外，我们平时使用的动态代理、AOP也与字节码增强密切相关，它们实质上还是利用各种手段生成符合规范的字节码文件。掌握字节码增强后可以高效地定位并快速修复一些棘手的问题（如线上性能问题、方法出现不可控的出入参需要紧急加日志等问题），也可以在开发中减少冗余代码，大大提高开发效率。\n\n参考：\n\n * https://www.pdai.tech/md/java/jvm/java-jvm-class-enhancer.html#%E8%BF%90%E8%A1%8C%E6%97%B6%E7%B1%BB%E7%9A%84%E9%87%8D%E8%BD%BD",normalizedContent:"一般的字节码增强技术，如asm，javassist 只能在类加载前对类进行强化。而配合jvm提供的 instrument 类，可以实现对运行时的类进行修改和重载。\n\n应用场景：\n\n * 热部署：不部署服务而对线上服务做修改，可以做打点、增加日志等操作。\n * mock：测试时候对某些服务做mock。\n * 性能诊断工具：比如btrace就是利用instrument，实现无侵入地跟踪一个正在运行的jvm，监控到类和方法级别的状态信息。\n\n字节码增强技术相当于是一把打开运行时jvm的钥匙，利用它可以动态地对运行中的程序做修改，也可以跟踪jvm运行中程序的状态。此外，我们平时使用的动态代理、aop也与字节码增强密切相关，它们实质上还是利用各种手段生成符合规范的字节码文件。掌握字节码增强后可以高效地定位并快速修复一些棘手的问题（如线上性能问题、方法出现不可控的出入参需要紧急加日志等问题），也可以在开发中减少冗余代码，大大提高开发效率。\n\n参考：\n\n * https://www.pdai.tech/md/java/jvm/java-jvm-class-enhancer.html#%e8%bf%90%e8%a1%8c%e6%97%b6%e7%b1%bb%e7%9a%84%e9%87%8d%e8%bd%bd",charsets:{cjk:!0},lastUpdated:"2023/03/29, 21:03:43",lastUpdatedTimestamp:1680095023e3},{title:"《深入理解Java虚拟机-第三版》",frontmatter:{title:"《深入理解Java虚拟机-第三版》",date:"2023-03-31T16:58:30.000Z",permalink:"/pages/9cc971/"},regularPath:"/01.Java/03.JVM/101.%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%8B.html",relativePath:"01.Java/03.JVM/101.《深入理解Java虚拟机》.md",key:"v-9f8ccf5e",path:"/pages/9cc971/",headers:[{level:2,title:"编译器和解释器",slug:"编译器和解释器",normalizedTitle:"编译器和解释器",charIndex:2},{level:2,title:"运行时数据区",slug:"运行时数据区",normalizedTitle:"运行时数据区",charIndex:1106},{level:3,title:"程序计数器",slug:"程序计数器",normalizedTitle:"程序计数器",charIndex:1223},{level:3,title:"Java虚拟机栈",slug:"java虚拟机栈",normalizedTitle:"java虚拟机栈",charIndex:1493},{level:3,title:"本地方法栈",slug:"本地方法栈",normalizedTitle:"本地方法栈",charIndex:2180},{level:3,title:"堆",slug:"堆",normalizedTitle:"堆",charIndex:2336},{level:3,title:"方法区",slug:"方法区",normalizedTitle:"方法区",charIndex:3315},{level:3,title:"直接内存",slug:"直接内存",normalizedTitle:"直接内存",charIndex:3370},{level:2,title:"Hotspot虚拟机对象探秘",slug:"hotspot虚拟机对象探秘",normalizedTitle:"hotspot虚拟机对象探秘",charIndex:6368},{level:3,title:"对象的创建",slug:"对象的创建",normalizedTitle:"对象的创建",charIndex:6474},{level:3,title:"对象的内存布局",slug:"对象的内存布局",normalizedTitle:"对象的内存布局",charIndex:7075},{level:3,title:"对象的访问定位",slug:"对象的访问定位",normalizedTitle:"对象的访问定位",charIndex:7491},{level:3,title:"字符串问题",slug:"字符串问题",normalizedTitle:"字符串问题",charIndex:7711},{level:2,title:"OutOfMemoryError异常",slug:"outofmemoryerror异常",normalizedTitle:"outofmemoryerror异常",charIndex:2014},{level:3,title:"Java堆溢出",slug:"java堆溢出",normalizedTitle:"java堆溢出",charIndex:8869},{level:3,title:"虚拟机栈或本地方法栈溢出",slug:"虚拟机栈或本地方法栈溢出",normalizedTitle:"虚拟机栈或本地方法栈溢出",charIndex:9414},{level:3,title:"方法区和运行时常量池溢出",slug:"方法区和运行时常量池溢出",normalizedTitle:"方法区和运行时常量池溢出",charIndex:10279},{level:3,title:"本机直接内存溢出",slug:"本机直接内存溢出",normalizedTitle:"本机直接内存溢出",charIndex:11129},{level:2,title:"垃圾回收算法",slug:"垃圾回收算法",normalizedTitle:"垃圾回收算法",charIndex:11481},{level:2,title:"并行和并发",slug:"并行和并发",normalizedTitle:"并行和并发",charIndex:11627},{level:2,title:"垃圾回收器图解",slug:"垃圾回收器图解",normalizedTitle:"垃圾回收器图解",charIndex:11768},{level:2,title:"垃圾回收器分类",slug:"垃圾回收器分类",normalizedTitle:"垃圾回收器分类",charIndex:12100},{level:2,title:"默认垃圾回收器：",slug:"默认垃圾回收器",normalizedTitle:"默认垃圾回收器：",charIndex:13171},{level:2,title:"如何判断一个对象已经无效？",slug:"如何判断一个对象已经无效",normalizedTitle:"如何判断一个对象已经无效？",charIndex:14520},{level:2,title:"可作为GC Roots的对象",slug:"可作为gc-roots的对象",normalizedTitle:"可作为gc roots的对象",charIndex:14735},{level:2,title:"引用",slug:"引用",normalizedTitle:"引用",charIndex:1703},{level:2,title:"常量池的位置",slug:"常量池的位置",normalizedTitle:"常量池的位置",charIndex:16197},{level:2,title:"如何判断一个类是无用的类",slug:"如何判断一个类是无用的类",normalizedTitle:"如何判断一个类是无用的类",charIndex:16575},{level:2,title:"6个常用的命令行工具：",slug:"_6个常用的命令行工具",normalizedTitle:"6个常用的命令行工具：",charIndex:16908},{level:2,title:"4个常用的可视化工具：",slug:"_4个常用的可视化工具",normalizedTitle:"4个常用的可视化工具：",charIndex:17414},{level:2,title:"JMX",slug:"jmx",normalizedTitle:"jmx",charIndex:17596},{level:2,title:"类文件结构",slug:"类文件结构",normalizedTitle:"类文件结构",charIndex:18004},{level:2,title:"虚拟机类加载机制",slug:"虚拟机类加载机制",normalizedTitle:"虚拟机类加载机制",charIndex:18037},{level:2,title:"类加载的过程",slug:"类加载的过程",normalizedTitle:"类加载的过程",charIndex:19005},{level:3,title:"加载",slug:"加载",normalizedTitle:"加载",charIndex:4181},{level:3,title:"验证",slug:"验证",normalizedTitle:"验证",charIndex:18240},{level:3,title:"准备",slug:"准备",normalizedTitle:"准备",charIndex:4878},{level:3,title:"解析",slug:"解析",normalizedTitle:"解析",charIndex:6564},{level:3,title:"初始化",slug:"初始化",normalizedTitle:"初始化",charIndex:6567},{level:2,title:"类加载器",slug:"类加载器",normalizedTitle:"类加载器",charIndex:20518},{level:3,title:"三层类加载器",slug:"三层类加载器",normalizedTitle:"三层类加载器",charIndex:21386},{level:3,title:"双亲委派模型（Parents Delegation Model）",slug:"双亲委派模型-parents-delegation-model",normalizedTitle:"双亲委派模型（parents delegation model）",charIndex:21908},{level:3,title:"Java模块化系统",slug:"java模块化系统",normalizedTitle:"java模块化系统",charIndex:23149},{level:2,title:"硬件的效率与一致性",slug:"硬件的效率与一致性",normalizedTitle:"硬件的效率与一致性",charIndex:23616},{level:2,title:"Java内存模型",slug:"java内存模型-2",normalizedTitle:"java内存模型",charIndex:23603},{level:2,title:"先行发生（Happens-Before）原则",slug:"先行发生-happens-before-原则",normalizedTitle:"先行发生（happens-before）原则",charIndex:24975},{level:2,title:"Java 与线程",slug:"java-与线程",normalizedTitle:"java 与线程",charIndex:25874},{level:2,title:"Java 与协程【不是很理解】",slug:"java-与协程【不是很理解】",normalizedTitle:"java 与协程【不是很理解】",charIndex:26121},{level:2,title:"线程安全",slug:"线程安全",normalizedTitle:"线程安全",charIndex:6679},{level:3,title:"互斥同步（阻塞同步）",slug:"互斥同步-阻塞同步",normalizedTitle:"互斥同步（阻塞同步）",charIndex:26810},{level:3,title:"非阻塞同步",slug:"非阻塞同步",normalizedTitle:"非阻塞同步",charIndex:28108},{level:3,title:"无同步方案",slug:"无同步方案",normalizedTitle:"无同步方案",charIndex:29283},{level:2,title:"锁优化",slug:"锁优化",normalizedTitle:"锁优化",charIndex:27756},{level:3,title:"自旋锁与自适应自旋",slug:"自旋锁与自适应自旋",normalizedTitle:"自旋锁与自适应自旋",charIndex:30071},{level:3,title:"锁消除",slug:"锁消除",normalizedTitle:"锁消除",charIndex:29973},{level:3,title:"锁粗化",slug:"锁粗化",normalizedTitle:"锁粗化",charIndex:30763},{level:3,title:"轻量级锁",slug:"轻量级锁",normalizedTitle:"轻量级锁",charIndex:30020},{level:3,title:"偏向锁",slug:"偏向锁",normalizedTitle:"偏向锁",charIndex:7039}],headersStr:"编译器和解释器 运行时数据区 程序计数器 Java虚拟机栈 本地方法栈 堆 方法区 直接内存 Hotspot虚拟机对象探秘 对象的创建 对象的内存布局 对象的访问定位 字符串问题 OutOfMemoryError异常 Java堆溢出 虚拟机栈或本地方法栈溢出 方法区和运行时常量池溢出 本机直接内存溢出 垃圾回收算法 并行和并发 垃圾回收器图解 垃圾回收器分类 默认垃圾回收器： 如何判断一个对象已经无效？ 可作为GC Roots的对象 引用 常量池的位置 如何判断一个类是无用的类 6个常用的命令行工具： 4个常用的可视化工具： JMX 类文件结构 虚拟机类加载机制 类加载的过程 加载 验证 准备 解析 初始化 类加载器 三层类加载器 双亲委派模型（Parents Delegation Model） Java模块化系统 硬件的效率与一致性 Java内存模型 先行发生（Happens-Before）原则 Java 与线程 Java 与协程【不是很理解】 线程安全 互斥同步（阻塞同步） 非阻塞同步 无同步方案 锁优化 自旋锁与自适应自旋 锁消除 锁粗化 轻量级锁 偏向锁",content:'# 编译器和解释器\n\n * 类型1：C、C++\n * 类型2：JavaScript、Python、PHP\n * 类型3：Java\n\n对于类型1，我们一般称为编译型语言，也就是需要用到编译器进行编译。\n\n对于类型2，我们一般称为解释型语言，或是脚本语言，也就是要用解释器进行解释。\n\n编译器与解释器就类似于笔译工作者与口译工作者的区别，编译器就是笔译工作者，而解释器就是口译工作者。\n\n * 编译器在编译的过程中，读入源程序文件，输出一份等价的二进制可执行文件，就和笔译工作者一样，他们都会输出一份翻译后的文件。\n * 解释器在解释的过程中，读入源程序文件，输出的是执行的结果，就和口译工作者一样，他们输出的是已经完成翻译的结果。\n\n解释器：\n\n * 优点：跨平台、启动速度快、开发效率高\n\n * 缺点：执行速度慢，执行效率低\n\n编译器：\n\n * 优点：执行速度快、执行效率高\n * 缺点：平台相关性高，编译速度（启动速度）慢，开发效率低\n\nJava既有编译器（不止一个）又有解释器。\n\nJava中编译器比较多，它包含一个前端编译器，一个后端编译器（JIT）以及一个静态预编译器（AOT）。\n\n * 前端编译器的功能是从源代码生成Java字节码，也就是中间代码；\n * 后端编译器，也叫作即时编译器（JIT）它是包含在了JVM中，用于在执行的过程中，将热点代码（也就是执行次数比较多的代码）转化为本地机器码，并做一些优化，以加速执行效率。\n * 静态预编译器（AOT）它是直接将java源代码编译成本地机器码，也就是传统意义上的编译器，但用的不多，因为这样会使java的一些特性丢失。\n\nJava中的解释器与JIT一起打包，作为JVM中的执行引擎，解释器主要将字节码进行解释执行，同时配合JIT进行代码的优化操作。\n\njava解释器就是把在java虚拟机上运行的目标代码（字节码）解释成为具体平台的机器码的程序。即jdk或jre目录下bin目录中的java.exe文件，而javac.exe是编译器。\n\n运行java程序的过程是先用javac编译，然后用java解释。而一经编译成功后，就可以直接用java.exe随处解释运行了。\n\nJVM负责运行字节码：JVM把每一条要执行的字节码交给解释器，翻译成对应的机器码，然后由解释器执行。JVM解释执行字节码文件就是JVM操作Java解释器进行解释执行字节码文件的过程。\n\n\n# Java内存区域\n\nJava把控制内存的权利交给了Java 虚拟机，一旦出现内存泄漏和溢出方面的问题，如果不了解虚拟机是怎样使用内存的，那排查错误、修正问题将成为一项艰难的工作。\n\n\n# 运行时数据区\n\n《Java虚拟机规范》 ：“概念模型”这个词会经常被提及， 它代表了所有虚拟机的统一外观， 但各款具体的Java虚拟机并不 一定要完全照着概念模型的定义来进行设计， 可能会通过一些更高效率的等价方式去实现它。\n\n\n# 程序计数器\n\n当前线程所执行的字节码的行号。字节码解释器就是通过改变这个计数器的值来选取下一条需要执行的字节码指令。\n\n程序计数器主要有两个作用：\n\n 1. 字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。\n 2. 在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。\n\n注意：程序计数器是唯一一个不会出现 OutOfMemoryError 的内存区域，它的生命周期随着线程的创建而创建，随着线程的结束而死亡。\n\n\n# Java虚拟机栈\n\n描述的是Java方法执行的线程内存模型，每个方法被执行时，Java虚拟机都会同步创建一个栈帧（Stack Frame）用于存储局部变量表、操作数栈、动态连接、方法出口等信息。每个方法从被调用到执行完毕的过程，就对应这一个栈帧在虚拟机栈的入栈和出栈过程。\n\n局部变量表主要存放了编译期可知的各种数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference 类型，它不同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）。\n\nJava 虚拟机栈会出现两种错误：StackOverFlowError 和 OutOfMemoryError。\n\n * StackOverFlowError： 若 Java 虚拟机栈的内存大小不允许动态扩展，那么当线程请求栈的深度超过当前 Java 虚拟机栈的最大深度的时候，就抛出 StackOverFlowError 错误。\n * OutOfMemoryError： Java 虚拟机栈的内存大小可以动态扩展， 如果虚拟机在动态扩展栈时无法申请到足够的内存空间，则抛出OutOfMemoryError异常。\n\nHotSpot虚拟机的栈容量是不可以动态扩展的， 以前的Classic虚拟机倒是可以。 所以在HotSpot虚拟机上是不会由于虚拟机栈无法扩展而导致OutOfMemoryError异常——只要线程申请栈空间成功了就不会有OOM， 但是如果申请时就失败， 仍然是会出现OOM异常的。\n\n\n# 本地方法栈\n\n本地方法栈（Native Method Stacks） 与虚拟机栈所发挥的作用是非常相似的， 其区别只是虚拟机栈为虚拟机执行Java方法（也就是字节码） 服务， 而本地方法栈则是为虚拟机使用到的本地（Native）方法服务。\n\n在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。\n\n\n# 堆\n\nJava 虚拟机所管理的内存中最大的一块，Java 堆是所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存。\n\nJava 世界中“几乎”所有的对象都在堆中分配，但是，随着 JIT 编译器的发展与逃逸分析技术逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化，所有的对象都分配到堆上也渐渐变得不那么“绝对”了。从 JDK 1.7 开始已经默认开启逃逸分析，如果某些方法中的对象引用没有被返回或者未被外面使用（也就是未逃逸出去），那么对象可以直接在栈上分配内存。\n\nJava 堆是垃圾收集器管理的主要区域，因此也被称作GC 堆（Garbage Collected Heap）。从垃圾回收的角度，由于现在收集器基本都采用分代垃圾收集算法，所以 Java 堆还可以细分为：新生代和老年代；再细致一点有：Eden 空间、From Survivor、To Survivor 空间等。进一步划分的目的是更好地回收内存，或者更快地分配内存。\n\n从回收内存的角度看， 由于现代垃圾收集器大部分都是基于分代收集理论设计的， 所以Java堆中经常会出现“新生代”“老年代”“永久代”“Eden空间”“From Survivor空间”“To Survivor空间”等名词， 这些区域划分仅仅是一部分垃圾收集器的共同特性或者说设计风格而已， 而非某个Java虚拟机具体实现的固有内存布局， 更不是《Java虚拟机规范》 里对Java堆的进一步细致划分。 不少资料上经常写着类似于“Java虚拟机的堆内存分为新生代、 老年代、 永久代、 Eden、 Survivor……”这样的内容。 在十年之前（以G1收集器的出现为分界） ， 作为业界绝对主流的HotSpot虚拟机， 它内部的垃圾收集器全部都基于“经典分代”[3]来设计， 需要新生代、 老年代收集器搭配才能工作， 但现在不可同日而语，也出现了不采用分代设计的垃圾回收器。\n\n在 JDK 7 版本及 JDK 7 版本之前，堆内存被通常分为下面三部分：\n\n 1. 新生代内存(Young Generation)\n 2. 老生代(Old Generation)\n 3. 永生代(Permanent Generation)\n\nJDK 8 版本之后方法区（HotSpot 的永久代）被彻底移除了（JDK1.7 就已经开始了），取而代之是元空间，元空间使用的是直接内存。\n\n上图所示的 Eden 区、两个 Survivor 区都属于新生代（为了区分，这两个 Survivor 区域按照顺序被命名为 from 和 to），中间一层属于老年代。\n\n大部分情况，对象都会首先在 Eden 区域分配，在一次新生代垃圾回收后，如果对象还存活，则会进入 s0 或者 s1，并且对象的年龄还会加 1(Eden 区->Survivor 区后对象的初始年龄变为 1)，当它的年龄增加到一定程度（默认为 15 岁），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 -XX:MaxTenuringThreshold 来设置。\n\nHotspot 遍历所有对象时，按照年龄从小到大对其所占用的大小进行累积，当累积的某个年龄大小超过了 survivor 区的一半时，取这个年龄和 MaxTenuringThreshold 中更小的一个值，作为新的晋升年龄阈值。\n\n堆这里最容易出现的就是 OutOfMemoryError 错误，并且出现这种错误之后的表现形式还会有几种，比如：\n\n 1. java.lang.OutOfMemoryError: GC Overhead Limit Exceeded ： 当 JVM 花太多时间执行垃圾回收并且只能回收很少的堆空间时，就会发生此错误。\n 2. java.lang.OutOfMemoryError: Java heap space :假如在创建新的对象时, 堆内存中的空间不足以存放新创建的对象, 就会引发此错误。(和配置的最大堆内存有关，且受制于物理内存大小。最大堆内存可通过-Xmx参数配置，-Xms设置初始堆内存，若没有特别配置，将会使用默认值，详见：Default Java 8 max heap size (opens new window))\n\n\n# 方法区\n\n方法区与 Java 堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。虽然 Java 虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做 Non-Heap（非堆），目的应该是与 Java 堆区分开来。\n\n说到方法区， 不得不提一下“永久代”这个概念， 尤其是在JDK 8以前， 许多Java程序员都习惯在HotSpot虚拟机上开发、 部署程序， 很多人都更愿意把方法区称呼为“永久代”（Permanent Generation） ， 或将两者混为一谈。 本质上这两者并不是等价的， 因为仅仅是当时的HotSpot虚拟机设计团队选择把收集器的分代设计扩展至方法区， 或者说使用永久代来实现方法区而已， 这样使得HotSpot的垃圾收集器能够像管理Java堆一样管理这部分内存， 省去专门为方法区编写内存管理代码的工作。 但是对于其他虚拟机实现， 譬如BEA JRockit、 IBM J9等来说， 是不存在永久代的概念的。 原则上如何实现方法区属于虚拟机实现细节， 不受《Java虚拟机规范》 管束， 并不要求统一。 但现在回头来看， 当年使用永久代来实现方法区的决定并不是一个好主意， 这种设计导致了Java应用更容易遇到内存溢出的问题（永久代有-XX： MaxPermSize的上限， 即使不设置也有默认大小， 而J9和JRockit只要没有触碰到进程可用内存的上限， 例如32位系统中的4GB限制， 就不会出问题） ， 而且有极少数方法（例如String::intern()） 会因永久代的原因而导致不同虚拟机下有不同的表现。 当Oracle收购BEA获得了JRockit的所有权后， 准备把JRockit中的优秀功能， 譬如Java Mission Control管理工具， 移植到HotSpot虚拟机时， 但因为两者对方法区实现的差异而面临诸多困难。\n\n考虑到HotSpot未来的发展， 在JDK 6的时候HotSpot开发团队就有放弃永久代， 逐步改为采用本地内存（Native Memory） 来实现方法区的计划了[1]， 到了JDK 7的HotSpot， 已经把原本放在永久代的字符串常量池、 静态变量等移出， 而到了JDK 8， 终于完全废弃了永久代的概念， 改用与JRockit、 J9一样在本地内存中实现的元空间（Metaspace） 来代替， 把JDK 7中永久代还剩余的内容（主要是类型信息） 全部移到元空间中。\n\n//JDK 1.8 之前永久代还没被彻底移除的时候通常通过下面这些参数来调节方法区大小\n-XX:PermSize=N //方法区 (永久代) 初始大小\n-XX:MaxPermSize=N //方法区 (永久代) 最大大小,超过这个值将会抛出 OutOfMemoryError 异常:java.lang.OutOfMemoryError: PermGen\n\n\nJDK 1.8 的时候，方法区（HotSpot 的永久代）被彻底移除了（JDK1.7 就已经开始了），取而代之是元空间，元空间使用的是直接内存。\n\n//一些常用参数：\n-XX:MetaspaceSize=N //设置 Metaspace 的初始（和最小大小）\n-XX:MaxMetaspaceSize=N //设置 Metaspace 的最大大小\n\n\n与永久代很大的不同就是，如果不指定大小的话，随着更多类的创建，虚拟机会耗尽所有可用的系统内存。\n\n运行时常量池是方法区的一部分。Class 文件中除了有类的版本、字段、方法、接口等描述信息外，还有常量池表（用于存放编译期生成的各种字面量和符号引用）。既然运行时常量池是方法区的一部分，自然受到方法区内存的限制，当常量池无法再申请到内存时会抛出 OutOfMemoryError 错误。\n\nJDK1.7 之前运行时常量池逻辑包含字符串常量池存放在方法区, 此时 hotspot 虚拟机对方法区的实现为永久代。\n\nJDK1.7字符串常量池被从方法区拿到了堆中, 这里没有提到运行时常量池,也就是说字符串常量池被单独拿到堆,运行时常量池剩下的东西还在方法区, 也就是 hotspot 中的永久代。\n\nJDK1.8 hotspot 移除了永久代用元空间(Metaspace)取而代之, 这时候字符串常量池还在堆, 运行时常量池还在方法区, 只不过方法区的实现从永久代变成了元空间(Metaspace)。\n\n\n# 直接内存\n\n直接内存并不是虚拟机运行时数据区的一部分，也不是虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使用。而且也可能导致 OutOfMemoryError 错误出现。\n\nJDK1.4 中新加入的 NIO(New Input/Output) 类，引入了一种基于通道（Channel）与缓存区（Buffer）的 I/O 方式，它可以直接使用 Native 函数库直接分配堆外内存，然后通过一个存储在 Java 堆中的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样就能在一些场景中显著提高性能，因为避免了在 Java 堆和 Native 堆之间来回复制数据。\n\n本机直接内存的分配不会受到 Java 堆的限制，但是，既然是内存就会受到本机总内存大小以及处理器寻址空间的限制。\n\n\n# Hotspot虚拟机对象探秘\n\n> 基于实用优先的原则， 以最常用的虚拟机HotSpot和最常用的内存区域Java堆为例， 深入探讨一下HotSpot虚拟机在Java堆中对象分配、 布局和访问的全过程。\n\n\n# 对象的创建\n\n\n\n 1. 类加载检查：虚拟机遇到一条 new 指令时，首先将去检查这个指令的参数是否能在常量池中定位到这个类的符号引用，并且检查这个符号引用代表的类是否已被加载过、解析和初始化过。如果没有，那必须先执行相应的类加载过程。\n 2. 分配内存：\n    1. 分配方式：有“指针碰撞”和“空闲列表”两种，取决于Java堆是否规整，这又由垃圾回收器是否带有压缩整理功能决定。\n    2. 虚拟机保证线程安全：\n       1. CAS+失败重试： CAS 是乐观锁的一种实现方式。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。虚拟机采用 CAS 配上失败重试的方式保证更新操作的原子性。\n       2. TLAB（本地线程分配缓存）： 为每一个线程预先在 Eden 区分配一块儿内存，JVM 在给线程中的对象分配内存时，首先在 TLAB 分配，当对象大于 TLAB 中的剩余内存或 TLAB 的内存已用尽时，再采用上述的 CAS 进行内存分配。\n 3. 初始化零值\n 4. 设置对象头：例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息。 这些信息存放在对象头中。 另外，根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。\n 5. 执行init方法\n\n\n# 对象的内存布局\n\n在HotSpot虚拟机中，对象在堆内存中的存储布局可以分为三个部分：对象头、实例数据和对齐填充。\n\nHotspot 虚拟机的对象头包括两部分信息，第一部分用于存储对象自身的运行时数据（哈希码、GC 分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等等），官方称为“Mark Word”。另一部分是类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是那个类的实例。\n\n实例数据部分是对象真正存储的有效信息，也是在程序中所定义的各种类型的字段内容。\n\n对齐填充部分不是必然存在的，也没有什么特别的含义，仅仅起占位作用。 因为 Hotspot 虚拟机的自动内存管理系统要求对象起始地址必须是 8 字节的整数倍，换句话说就是对象的大小必须是 8 字节的整数倍。而对象头部分正好是 8 字节的倍数（1 倍或 2 倍），因此，当对象实例数据部分没有对齐时，就需要通过对齐填充来补全。\n\n\n# 对象的访问定位\n\nJava程序会通过栈上reference数据来操作堆上的具体对象。\n\n对象的访问方式由虚拟机的实现决定：主流的访问方式主要有使用句柄和直接指针两种。\n\n这两种对象访问方式各有优势。使用句柄来访问的最大好处是 reference 中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而 reference 本身不需要修改。使用直接指针访问方式最大的好处就是速度快，它节省了一次指针定位的时间开销。\n\n\n# 字符串问题\n\n * 直接使用双引号声明出来的String对象会直接存储在常量池中。\n * 如果不是用双引号声明的String对象，可以使用String提供的intern方法。intern 方法会从字符串常量池中查询当前字符串是否存在，若不存在就会将当前字符串放入常量池中。\n * （String.intern() 是一个 Native 方法，它的作用是：如果运行时常量池中已经包含一个等于此 String 对象内容的字符串，则返回常量池中该字符串的引用；如果没有，JDK1.7 之前（不包含 1.7）的处理方式是在常量池中创建与此 String 内容相同的字符串，并返回常量池中创建的字符串的引用，JDK1.7 以及之后，字符串常量池被从方法区拿到了堆中，jvm 不会在常量池中创建该对象，而是将堆中这个对象的引用直接放到常量池中，减少不必要的内存开销。）\n\n对于基本数据类型来说，比较的是值。对于引用数据类型来说，比较的是对象的内存地址。\n\n在编译过程中，Javac 编译器会进行一个叫做 常量折叠(Constant Folding) 的代码优化。常量折叠会把常量表达式的值求出来作为常量嵌在最终生成的代码中，这是 Javac 编译器会对源代码做的极少量优化措施之一(代码优化几乎都在即时编译器中进行)。\n\n一般来说，我们要尽量避免通过 new 的方式创建字符串。使用双引号声明的 String 对象（ String s1 = "java" ）更利于让编译器有机会优化我们的代码，同时也更易于阅读。\n\n被 final 关键字修改之后的 String 会被编译器当做常量来处理，编译器程序编译期就可以确定它的值，其效果就想到于访问常量。\n\nString s1 = new String("abc");这句话创建了几个字符串对象？\n\n会创建 1 或 2 个字符串：\n\n * 如果字符串常量池中已存在字符串常量“abc”，则只会在堆空间创建一个字符串常量“abc”。\n * 如果字符串常量池中没有字符串常量“abc”，那么它将首先在字符串常量池中创建，然后在堆空间中创建，因此将创建总共 2 个字符串对象。\n\nJava 基本类型的包装类的大部分都实现了常量池技术。\n\nByte,Short,Integer,Long 这 4 种包装类默认创建了数值 [-128，127] 的相应类型的缓存数据，Character 创建了数值在 [0,127] 范围的缓存数据，Boolean 直接返回 True Or False。\n\n两种浮点数类型的包装类 Float,Double 并没有实现常量池技术。\n\n记住：所有整型包装类对象之间值的比较，全部使用 equals 方法比较。\n\n\n# OutOfMemoryError异常\n\n\n# Java堆溢出\n\n将堆的最小值-Xms参数与最大值-Xmx参数设置为一样的话可避免堆自动扩展，即设置为不可扩展。\n\n要解决这个内存区域的异常， 常规的处理方法是首先通过内存映像分析工具（如Eclipse Memory Analyzer） 对Dump出来的堆转储快照进行分析。 第一步首先应确认内存中导致OOM的对象是否是必要的， 也就是要先分清楚到底是出现了内存泄漏（Memory Leak） 还是内存溢出（Memory Overflow） 。\n\n如果是内存泄漏， 可进一步通过工具查看泄漏对象到GC Roots的引用链， 找到泄漏对象是通过怎样的引用路径、 与哪些GC Roots相关联， 才导致垃圾收集器无法回收它们， 根据泄漏对象的类型信息以及它到GC Roots引用链的信息， 一般可以比较准确地定位到这些对象创建的位置， 进而找出产生内存泄漏的代码的具体位置。\n\n如果不是内存泄漏， 换句话说就是内存中的对象确实都是必须存活的， 那就应当检查Java虚拟机的堆参数（-Xmx与-Xms） 设置， 与机器的内存对比， 看看是否还有向上调整的空间。 再从代码上检查是否存在某些对象生命周期过长、 持有状态时间过长、 存储结构设计不合理等情况， 尽量减少程序运行期的内存消耗。\n\n\n# 虚拟机栈或本地方法栈溢出\n\n由于HotSpot虚拟机并不区分虚拟机栈和本地方法栈，所以栈容量只由 -Xss参数决定。\n\n关于虚拟机栈和本地方法栈， 在《Java虚拟机规范》 中描述了两种异常：\n\n 1. 如果线程请求的栈深度大于虚拟机所允许的最大深度， 将抛出StackOverflowError异常。\n 2. 如果虚拟机的栈内存允许动态扩展， 当扩展栈容量无法申请到足够的内存时， 将抛出OutOfMemoryError异常。\n\n《Java虚拟机规范》 明确允许Java虚拟机实现自行选择是否支持栈的动态扩展， 而HotSpot虚拟机的选择是不支持扩展， 所以除非在创建线程申请内存时就因无法获得足够内存而出现OutOfMemoryError异常， 否则在线程运行时是不会因为扩展而导致内存溢出的， 只会因为栈容量无法容纳新的栈帧而导致StackOverflowError异常。\n\n出现StackOverflowError异常时， 会有明确错误堆栈可供分析， 相对而言比较容易定位到问题所在。 如果使用HotSpot虚拟机默认参数， 栈深度在大多数情况下（因为每个方法压入栈的帧大小并不是一样的， 所以只能说大多数情况下） 到达1000~2000是完全没有问题， 对于正常的方法调用（包括不能做尾递归优化的递归调用） ，这个深度应该完全够用了。\n\n但是， 如果是建立过多线程导致的内存溢出， 在不能减少线程数量或者更换64位虚拟机的情况下， 就只能通过减少最大堆和减少栈容量来换取更多的线程。 这种通过“减少内存”的手段来解决内存溢出的方式， 如果没有这方面处理经验， 一般比较难以想到， 这一点读者需要在开发32位系统的多线程应用时注意。 也是由于这种问题较为隐蔽， 从JDK 7起， 以上提示信息中“unable to create native thread”后面， 虚拟机会特别注明原因可能是“possiblyout of memory or process/resource limits reached”。\n\n\n# 方法区和运行时常量池溢出\n\n以下面的例子为例：\n\nString::intern()是一个本地方法， 它的作用是如果字符串常量池中已经包含一个等于此String对象的字符串， 则返回代表池中这个字符串的String对象的引用； 否则， 会将此String对象包含的字符串添加到常量池中， 并且返回此String对象的引用。\n\n自JDK 7起， 原本存放在永久代的字符串常量池被移至Java堆之中。\n\n当前的很多主流框架， 如Spring、 Hibernate对类进行增强时， 都会使用到CGLib这类字节码技术， 当增强的类越多， 就需要越大的方法区以保证动态生成的新类型可以载入内存。\n\n方法区溢出也是一种常见的内存溢出异常， 一个类如果要被垃圾收集器回收， 要达成的条件是比较苛刻的。\n\n在JDK 8以后， 永久代便完全退出了历史舞台， 元空间作为其替代者登场。 在默认设置下， 正常的动态创建新类型已经很难再迫使虚拟机产生方法区的溢出异常了。 不过为了让使用者有预防实际应用里出现的破坏性的操作， HotSpot还是提供了一些参数作为元空间的防御措施， 主要包括：\n\n * -XX：MaxMetaspaceSize： 设置元空间最大值， 默认是-1， 即不限制， 或者说只受限于本地内存大小。\n * -XX：MetaspaceSize： 指定元空间的初始空间大小， 以字节为单位， 达到该值就会触发垃圾收集进行类型卸载， 同时收集器会对该值进行调整： 如果释放了大量的空间， 就适当降低该值； 如果释放了很少的空间， 那么在不超过-XX： MaxMetaspaceSize（如果设置了的话） 的情况下， 适当提高该值。\n * -XX：MinMetaspaceFreeRatio： 作用是在垃圾收集之后控制最小的元空间剩余容量的百分比， 可减少因为元空间不足导致的垃圾收集的频率。 类似的还有-XX： Max-MetaspaceFreeRatio， 用于控制最大的元空间剩余容量的百分比。\n\n\n# 本机直接内存溢出\n\n直接内存（Direct Memory） 的容量大小可通过-XX： MaxDirectMemorySize参数来指定， 如果不去指定， 则默认与Java堆最大值（由-Xmx指定） 一致。\n\n由直接内存导致的内存溢出， 一个明显的特征是在Heap Dump文件中不会看见有什么明显的异常情况， 如果读者发现内存溢出之后产生的Dump文件很小， 而程序中又直接或间接使用了DirectMemory（典型的间接使用就是NIO） ， 那就可以考虑重点检查一下直接内存方面的原因了。\n\n\n# JVM垃圾回收\n\n问题：\n\n * 内存是如何分配和回收的？\n * 哪些内存需要回收？\n * 什么时候回收？\n * 如何回收？\n * parNew 和parallel scavenge 的区别是？\n\n\n# 垃圾回收算法\n\n * 标记-清除 Mark-Sweep\n * 标记-复制：常用于新生代\n * 标记-整理 Mark-Compact\n\n分代回收：只是根据对象存活周期的不同将内存分为几块。一般将 java 堆分为新生代和老年代，这样我们就可以根据各个年代的特点选择合适的垃圾收集算法。\n\n\n# 并行和并发\n\n * 并行（Parallel） ：指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态。\n * 并发（Concurrent）：指用户线程与垃圾收集线程同时执行（但不一定是并行，可能会交替执行），用户程序在继续运行，而垃圾收集器运行在另一个 CPU 上。\n\n\n# 垃圾回收器图解\n\n\n\nSerial 是单线程的收集器\n\nParNew 收集器实质上是Serial收集器的多线程并行版本。除了同时使用多条线程进行垃圾收集之外， 其余的行为包括Serial收集器可用的所有控制参数（例如： -XX： SurvivorRatio、 -XX：PretenureSizeThreshold、 -XX： HandlePromotionFailure等） 、 收集算法、 Stop The World、 对象分配规则、 回收策略等都与Serial收集器完全一致， 在实现上这两种收集器也共用了相当多的代码。\n\nParNew收集器除了支持多线程并行收集之外， 其他与Serial收集器相比并没有太多创新之处。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n# 垃圾回收器分类\n\n * 经典垃圾回收器\n   * 新生代\n     * Serial：新生代采用标记-复制算法，老年代采用标记-整理算法。\n     * ParNew：serial的多线程版\n     * Parallel Scavenge：新生代采用标记-复制算法，老年代采用标记-整理算法。\n       * Parallel Scavenge 收集器关注点是吞吐量（高效率的利用 CPU）。CMS 等垃圾收集器的关注点更多的是用户线程的停顿时间（提高用户体验）。所谓吞吐量就是 CPU 中用于运行用户代码的时间与 CPU 总消耗时间的比值。 Parallel Scavenge 收集器提供了很多参数供用户找到最合适的停顿时间或最大吞吐量，如果对于收集器运作不太了解，手工优化存在困难的时候，使用 Parallel Scavenge 收集器配合自适应调节策略，把内存管理优化交给虚拟机去完成也是一个不错的选择。\n   * 老年代：\n     * Serial Old\n     * Parallel Old：多线程+标记整理\n     * CMS：Concurrent Mark Sweep，采用标记-清除算法。目标最短回收停顿时间。\n   * G1：面向服务器的垃圾收集器,主要针对配备多颗处理器及大容量内存的机器. 以极高概率满足 GC 停顿时间要求的同时,还具备高吞吐量性能特征.（低停顿+高吞吐）。G1 从整体来看是基于“标记-整理”算法实现的收集器；从局部上来看是基于“标记-复制”算法实现的。\n     * G1 收集器在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的 Region(这也就是它的名字 Garbage-First 的由来) 。\n * 低延迟垃圾回收器\n   * ZGC：基于Region 内存布局，不设分代，使用了读屏障、染色指针和内存多重映射等技术实现可并发的标记-整理算法，以低延迟为首要目标。\n   * Shenandoah\n\nCMS缺点：\n\n * 对 CPU 资源敏感；\n * 无法处理浮动垃圾；\n * 它使用的回收算法-“标记-清除”算法会导致收集结束时会有大量空间碎片产生。\n\nShenandoah与G1的3个明显不同：\n\n * 支持并发的整理算法（最重要）。G1的回收阶段是可以多线程并行的，但不能与用户线程并发。\n * 目前默认不使用分代回收\n * 摒弃G1中耗费大量内存和计算资源去维护的记忆集，使用“连接矩阵”的全局数据结构来记录跨Region的引用关系。\n\n\n# 默认垃圾回收器：\n\n * JDK8 默认使用的是 Parallel Scavenge + Parallel Old。但一般不用这个。常用ParNew+CMS吧（因为是唯一搭配呀）\n * JDK9~16 默认G1\n\n在JVM中是+XX配置实现的搭配组合：\n\n * -XX:+UseSerialGC，虚拟机运行在Client模式下的默认值，Serial+Serial Old。\n * -XX:+UseParNewGC，ParNew+Serial Old，在JDK1.8被废弃，在JDK1.7还可以使用。\n * -XX:+UseConcMarkSweepGC，ParNew+CMS+Serial Old。\n * -XX:+UseParallelGC，虚拟机运行在Server模式下的默认值，Parallel Scavenge+Serial Old(PS Mark Sweep)。\n * -XX:+UseParallelOldGC，Parallel Scavenge+Parallel Old。\n * -XX:+UseG1GC，G1+G1。\n\n\n\n\n\n堆内存常见分配策略：\n\n * 对象优先分配在eden区\n * 大对象直接分配到老年代。大对象就是需要大量连续内存空间的对象（比如：字符串、数组）。\n * 长期存活的对象进入老年代\n\n空间分配担保：目的是确保Minor GC之前老年代有足够空间容纳新生代所有对象\n\nJDK 6 Update 24 之前，在发生 Minor GC 之前，虚拟机必须先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果这个条件成立，那这一次 Minor GC 可以确保是安全的。如果不成立，则虚拟机会先查看 -XX:HandlePromotionFailure 参数的设置值是否允许担保失败(Handle Promotion Failure);如果允许，那会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试进行一次 Minor GC，尽管这次 Minor GC 是有风险的;如果小于，或者 -XX: HandlePromotionFailure 设置不允许冒险，那这时就要改为进行一次 Full GC。\n\nJDK 6 Update 24之后的规则变为只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小，就会进行 Minor GC，否则将进行 Full GC。\n\n动态对象年龄判定：Hotspot 遍历所有对象时，按照年龄从小到大对其所占用的大小进行累积，当累积的某个年龄大小超过了 survivor 区的 50% 时（默认值是 50%，可以通过 -XX:TargetSurvivorRatio=percent 来设置 ），取这个年龄和 MaxTenuringThreshold（默认15岁） 中更小的一个值，作为新的晋升年龄阈值”。\n\nGC分类\n\n * Partial GC:\n   \n   * Minor GC/Young GC\n   \n   * Major GC/Old GC\n   \n   * Mixed GC：对整个新生代和老年代进行垃圾回收\n\n * Full GC：收集整个Java堆和方法区\n\n\n# 如何判断一个对象已经无效？\n\n * 引用计数法\n   \n   * 实现简单，效率高，但是目前主流的虚拟机中并没有选择这个算法来管理内存，其最主要的原因是它很难解决对象之间相互循环引用的问题。\n\n * 可达性分析法\n   \n   * 通过一系列的称为 “GC Roots” 的对象作为起点，从这些节点开始向下搜索，节点所走过的路径称为引用链，当一个对象到 GC Roots 没有任何引用链相连的话，则证明此对象是不可用的。\n\n\n# 可作为GC Roots的对象\n\n * 虚拟机栈（栈帧中的本地变量表）中引用的对象\n * 本地方法栈（Native方法）中引用的对象\n * 方法区中类静态属性引用的对象\n * 方法区中常量引用的对象\n * 所有被同步锁持有的对象\n\n\n# 引用\n\nJDK1.2 之前，Java 中引用的定义很传统：如果 reference 类型的数据存储的数值代表的是另一块内存的起始地址，就称这块内存代表一个引用。\n\nJDK1.2 以后，Java 对引用的概念进行了扩充，将引用分为强引用、软引用、弱引用、虚引用四种（引用强度逐渐减弱）\n\n * 强引用（StrongReference）\n   \n   以前我们使用的大部分引用实际上都是强引用，这是使用最普遍的引用。如果一个对象具有强引用，那就类似于必不可少的生活用品，垃圾回收器绝不会回收它。当内存空间不足，Java 虚拟机宁愿抛出 OutOfMemoryError 错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足问题。\n\n * 软引用（SoftReference）\n   \n   如果一个对象只具有软引用，那就类似于可有可无的生活用品。**如果内存空间足够，垃圾回收器就不会回收它，如果内存空间不足了，就会回收这些对象的内存。**只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存。\n   \n   软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收，JAVA 虚拟机就会把这个软引用加入到与之关联的引用队列中。\n\n * 弱引用（WeakReference）\n   \n   如果一个对象只具有弱引用，那就类似于可有可无的生活用品。弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程， 因此不一定会很快发现那些只具有弱引用的对象。\n   \n   弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java 虚拟机就会把这个弱引用加入到与之关联的引用队列中。\n\n * 虚引用（PhantomReference）\n   \n   "虚引用"顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收。\n   \n   虚引用主要用来跟踪对象被垃圾回收的活动。\n   \n   虚引用与软引用和弱引用的一个区别在于： 虚引用必须和引用队列（ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。程序如果发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。\n   \n   特别注意，在程序设计中一般很少使用弱引用与虚引用，使用软引用的情况较多，这是因为软引用可以加速 JVM 对垃圾内存的回收速度，可以维护系统的运行安全，防止内存溢出（OutOfMemory）等问题的产生。\n\n你会使用软引用和弱引用吗？软引用和弱引用的例子不错。\n\n\n# 常量池的位置\n\nJDK1.7 之前运行时常量池逻辑包含字符串常量池存放在方法区, 此时 hotspot 虚拟机对方法区的实现为永久代。\n\nJDK1.7 字符串常量池被从方法区拿到了堆中, 这里没有提到运行时常量池,也就是说字符串常量池被单独拿到堆,运行时常量池剩下的东西还在方法区, 也就是 hotspot 中的永久代 。\n\nJDK1.8 hotspot 移除了永久代用元空间(Metaspace)取而代之, 这时候字符串常量池还在堆, 运行时常量池还在方法区, 只不过方法区的实现从永久代变成了元空间(Metaspace)\n\n假如在字符串常量池中存在字符串 "abc"，如果当前没有任何 String 对象引用该字符串常量的话，就说明常量 "abc" 就是废弃常量，如果这时发生内存回收的话而且有必要的话，"abc" 就会被系统清理出常量池了。\n\n\n# 如何判断一个类是无用的类\n\n方法区主要回收的是无用的类，那么如何判断一个类是无用的类的呢？\n\n判定一个常量是否是“废弃常量”比较简单，而要判定一个类是否是“无用的类”的条件则相对苛刻许多。类需要同时满足下面 3 个条件才能算是 “无用的类” ：\n\n * 该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。\n * 加载该类的 ClassLoader 已经被回收。\n * 该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。\n\n虚拟机可以对满足上述 3 个条件的无用类进行回收，这里说的仅仅是“可以”，而并不是和对象一样不使用了就会必然被回收。\n\n\n# 虚拟机性能监控、故障处理工具\n\n\n# 6个常用的命令行工具：\n\n工具       功能\njps      虚拟机进程状况工具。可列出正在运行的虚拟机进程，并现实虚拟机执行主类。\njstat    虚拟机统计信息监视工具。虚拟机信息主要有3类：类加载、垃圾收集、运行期编译状况\njinfo    Java配置信息工具。实时查看和调整虚拟机各项参数。\njmap     Java内存映像工具。用于生成堆转储快照（heap dump或dump文件）。\njhat     虚拟机堆转储快照分析工具。搭配jmap使用，分析jmap生成的堆转储快照。一般不用，用VisualVM或其他。\njstack   Java堆栈跟踪工具。用于生成虚拟机当前时刻的线程快照（threaddump或javacore文件）。线程快照就是当前虚拟机内每一条线程正在执行的方法的堆栈的集合。\n\n其他工具：\n\n工具      功能\njava    用于运行class文件或jar文件\njavac   编译器，将.java文件编译成.class\njavap   用于分析字节码。反编译得到字节码指令。也可用其他工具将class文件转换成特定平台上的汇编代码。\n        \n\n\n# 4个常用的可视化工具：\n\n可视化工具                  功能\nJHSDB                  基于服务性代理的调试工具\nJConsole               Java监视与管理控制台\nVisualVM               多合-故障处理工具\nJava Mission Control   可持续在线的监控工具\n\n\n# JMX\n\nJMX（Java Management Extensions）， Java 管理扩展，用来管理和监测 Java 程序。最常用到的就是对于 JVM 的监测和管理，比如 JVM 内存、CPU 使用率、线程数、垃圾收集情况等等。另外，还可以用作日志级别的动态修改，比如 log4j 就支持 JMX 方式动态修改线上服务的日志级别。最主要的还是被用来做各种监控工具，比如 Spring Boot Actuator、JConsole、VisualVM 等。\n\nJMX 既是 Java 管理系统的一个标准，一个规范，也是一个接口，一个框架。有标准、有规范是为了让开发者可以定制开发自己的扩展功能，而且作为一个框架来讲，JDK 已经帮我们实现了常用的功能，尤其是对 JVM 的监控和管理。\n\nhttps://www.cnblogs.com/fengzheng/p/13431845.html\n\n\n# 类加载机制\n\n\n# 类文件结构\n\n\n\n可用 javap 分析class文件。\n\n\n# 虚拟机类加载机制\n\nJava虚拟机把描述类的数据从class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这个过程被称作虚拟机的类加载机制。\n\n与那些在编译器需要进行连接的语言不同，在Java语言里，类型的加载、连接和初始化都是在程序运行期间完成的。\n\n一个类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期将会经历7个阶段。\n\n\n\n加载、 验证、 准备、 初始化和卸载这五个阶段的顺序是确定的， 类型的加载过程必须按照这种顺序按部就班地开始， 而解析阶段则不一定： 它在某些情况下可以在初始化阶段之后再开始，这是为了支持Java语言的运行时绑定特性（也称为动态绑定或晚期绑定） 。\n\n对于什么时候开始类加载过程的第一个阶段“加载”，《Java虚拟机规范》没有强制约束。\n\n但对于初始化阶段，则严格规定了有且只有以下六种情况必须对类进行“初始化”（而加载、验证、准备自然需要在此之前开始）：\n\n 1. 遇到 new、getstatic、putstatic、invokestatic这四条字节码指令时。能够生成这四条指令的典型Java代码场景有：\n    * 使用new关键字实例化对象时。\n    * 读取或设置一个类型的静态字段（被final修饰、已在编译器把结果放入常量池的静态字段除外）的时候。\n    * 调用一个类型的静态方法时。\n 2. 使用 java.lang.reflect包的方法对类型进行反射调用时。\n 3. 当初始化类时，如果发现其父类还没进行过初始化，则需要先触发其父类的初始化。\n 4. 当虚拟机启动时，用户需要指定一个要执行的主类（包含main()的那个类），虚拟机会先初始化这个类。\n 5. 当使用JDK 7新加入的动态语言支持时， 如果一个java.lang.invoke.MethodHandle实例最后的解析结果为REF_getStatic、 REF_putStatic、 REF_invokeStatic、 REF_newInvokeSpecial四种类型的方法句柄， 并且这个方法句柄对应的类没有进行过初始化， 则需要先触发其初始化。\n 6. 当一个接口中定义了JDK 8加入的默认方法（被default修饰的接口方法）。\n\n\n# 类加载的过程\n\n类加载的全过程：加载、验证、准备、解析和初始化五个阶段。\n\n\n# 加载\n\n这里的加载（Loading）阶段是指整个类加载（Class Loading）过程中的一个阶段。\n\n虚拟机需要完成三件事：\n\n 1. 通过一个类的全限定名来获取定义此类的二进制字节流。\n 2. 将这个字节流所代表的静态存储结构转换为方法区的运行时数据结构。\n 3. 在内存中生成一个代表这个类的 java.lang.Class对象，作为方法区这个类的各种数据的访问入口。\n\n加载阶段结束后， Java虚拟机外部的二进制字节流就按照虚拟机所设定的格式存储在方法区之中了， 方法区中的数据存储格式完全由虚拟机实现自行定义， 《Java虚拟机规范》 未规定此区域的具体数据结构。 类型数据妥善安置在方法区之后， 会在Java堆内存中实例化一个java.lang.Class类的对象，这个对象将作为程序访问方法区中的类型数据的外部接口。\n\n\n# 验证\n\n验证是连接阶段的第一步， 这一阶段的目的是确保Class文件的字节流中包含的信息符合《Java虚拟机规范》 的全部约束要求， 保证这些信息被当作代码运行后不会危害虚拟机自身的安全。\n\n从整体上看， 验证阶段大致上会完成下面四个阶段的检验动作： 文件格式验证、 元数据验证、 字节码验证和符号引用验证。\n\n\n# 准备\n\n准备阶段是正式为类中定义的变量（即静态变量， 被static修饰的变量） 分配内存并设置类变量初始值的阶段。\n\n这时候进行内存分配的仅包括类变量， 而不包括实例变量， 实例变量将会在对象实例化时随着对象一起分配在Java堆中。\n\n\n# 解析\n\n解析阶段是Java虚拟机将常量池内的符号引用替换为直接引用的过程。\n\n * 符号引用（Symbolic References） ： 符号引用以一组符号来描述所引用的目标， 符号可以是任何形式的字面量， 只要使用时能无歧义地定位到目标即可。 符号引用与虚拟机实现的内存布局无关， 引用的目标并不一定是已经加载到虚拟机内存当中的内容。 各种虚拟机实现的内存布局可以各不相同，但是它们能接受的符号引用必须都是一致的， 因为符号引用的字面量形式明确定义在《Java虚拟机规范》 的Class文件格式中。eg：在Class文件中 CONSTANT_Class_info、CONSTANT_Fieldref_info、 CONSTANT_Methodref_info等类型的常量出现。\n * 直接引用（Direct References） ： 直接引用是可以直接指向目标的指针、 相对偏移量或者是一个能间接定位到目标的句柄。 直接引用是和虚拟机实现的内存布局直接相关的， 同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不会相同。 如果有了直接引用， 那引用的目标必定已经在虚拟机的内存中存在。\n\n解析动作主要针对类或接口、 字段、 类方法、 接口方法、 方法类型、 方法句柄和调用点限定符这7类符号引用进行， 分别对应于常量池的CONSTANT_Class_info、 CON-STANT_Fieldref_info、CONSTANT_Methodref_info、 CONSTANT_InterfaceMethodref_info、CONSTANT_MethodType_info、 CONSTANT_MethodHandle_info、 CONSTANT_Dyna-mic_info和CONSTANT_InvokeDynamic_info 8种常量类型。\n\n\n# 初始化\n\n在之前类加载动作中，除了在加载阶段应用程序可以通过自定义类加载器的方式局部参与外，其余动作都完全由Java虚拟机来主导控制。直到初始化阶段，Java虚拟机才真正可是执行类中编写的Java程序代码，将主导权交给应用程序。\n\n进行准备阶段时， 变量已经赋过一次系统要求的初始零值， 而在初始化阶段， 则会根据程序员通过程序编码制定的主观计划去初始化类变量和其他资源。 我们也可以从另外一种更直接的形式来表达： 初始化阶段就是执行类构造器<clinit>()方法的过程。 <clinit>()并不是程序员在Java代码中直接编写的方法， 它是Javac编译器的自动生成物。\n\n\n# 类加载器\n\nJava虚拟机设计团队有意把类加载阶段中的“通过一个类的全限定名来获取描述该类的二进制字节流”这个动作放到Java虚拟机外部去实现， 以便让应用程序自己决定如何去获取所需的类。 实现这个动作的代码被称为“类加载器”（Class Loader） 。\n\n对于任意一个类，都必须由加载它的类加载器和这个类本身一起共同确立其在Java虚拟机中的唯一性。\n\n每一个类加载器，都拥有一个独立的类名词空间。\n\n比较两个类是否“相等”，只有在这两个类是由同一个类加载器加载的前提下才有意义。否则，即使这两个类来源于同一个Class文件，被同一个Java虚拟机加载，只要加载它们的类加载器不同，那这两个类就必定不相等。\n\n这里所指的“相等”， 包括代表类的Class对象的equals()方法、 isAssignableFrom()方法、 isInstance()方法的返回结果， 也包括了使用instanceof关键字做对象所属关系判定等各种情况。\n\n从Java虚拟机的角度来看，只存在两种不同的类加载器：\n\n 1. 启动类加载器（Bootstrap ClassLoader）：这个类加载器是使用C++实现的，是虚拟机自身的一部分。\n 2. 其他所有的类加载器，这些类加载器都由Java实现的，独立于虚拟机外部，并且全部继承自抽象类 java.lang.ClassLoader\n\n自JDK 1.2以来，Java一直保持着三层类加载器、双亲委派的类加载架构。（在Java模块化后有一些调整，但主体结构没变）。\n\n\n# 三层类加载器\n\nJDK 9 之前：\n\n绝大多数Java程序都会使用到以下3个系统提供的类加载器来进行加载。\n\n 1. 启动类加载器 Bootstrap Class Loader：负责加载存放在 <JAVA_HOME>\\lib目录，或被 -Xbootclasspath参数所指定的路径中存放的，并且是Java虚拟机能识别的类库加载到虚拟机的内存中。（eg：rt.jar、tools.jar）\n 2. 扩展类加载器 Extension Class Loader：负责加载 <JAVA_HOME>\\lib\\ext目录，或被 java.ext.dirs系统变量所指定的路径中所有的类库。\n 3. 应用程序类加载器/系统类加载器 Application Class Loader：负责加载用户类路径（ClassPath）上所有的类库。如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。\n\n如果有需要，还可以自定义类加载器。eg：增加除了磁盘位置之外的Class文件来源， 或者通过类加载器实现类的隔离、 重载等功能。\n\n\n# 双亲委派模型（Parents Delegation Model）\n\n各种类加载器支给件的层次关系就被称为类加载器的双亲委派模型。\n\n双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应有自己的父类加载器。不过这里类加载器之间的父子关系一般不是继承（inheritance）的关系来实现的，而是使用组合（composition）关系来复用父类加载器的代码。\n\n**双亲委派模型的工作过程是：**如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到最顶层的启动类加载器中，只有当父类加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去完成加载。\n\n使用双亲委派模型来组织类加载器之间的关系， 一个显而易见的好处就是Java中的类随着它的类加载器一起具备了一种带有优先级的层次关系。 例如类java.lang.Object， 它存放在rt.jar之中， 无论哪一个类加载器要加载这个类， 最终都是委派给处于模型最顶端的启动类加载器进行加载， 因此Object类在程序的各种类加载器环境中都能够保证是同一个类。\n\n双亲委派模型的实现：\n\n//java.lang.ClassLoader的loadClass()\nprotected synchronized Class<?> loadClass(String name, boolean resolve) throws ClassNotFoundException\n{\n// 首先， 检查请求的类是否已经被加载过了\nClass c = findLoadedClass(name);\nif (c == null) {\ntry {\nif (parent != null) {\nc = parent.loadClass(name, false);\n} else {\nc = findBootstrapClassOrNull(name);\n}}\ncatch (ClassNotFoundException e) {\n// 如果父类加载器抛出ClassNotFoundException\n// 说明父类加载器无法完成加载请求\n}i\nf (c == null) {\n// 在父类加载器无法加载时\n// 再调用本身的findClass方法来进行类加载\nc = findClass(name);\n}\n}i\nf (resolve) {\nresolveClass(c);\n}return c;\n}\n\n\n先检查请求加载的类型是否已经被加载过， 若没有则调用父加载器的loadClass()方法， 若父加载器为空则默认使用启动类加载器作为父加载器。 假如父类加载器加载失败， 抛出ClassNotFoundException异常的话， 才调用自己的findClass()方法尝试进行加载。\n\n\n# Java模块化系统\n\nJDK 9 中引入了Java模块化系统（Java Platform Module System, JPMS）。\n\n（模块化到底怎么样，没看懂）\n\n为了保证兼容性， JDK 9并没有从根本上动摇从JDK 1.2以来运行了二十年之久的三层类加载器架构以及双亲委派模型。 但是为了模块化系统的顺利施行， 模块化下的类加载器仍然发生了一些应该被注意到变动， 主要包括以下几个方面：\n\n 1. 扩展类加载器（Extension Class Loader） 被平台类加载器（Platform Class Loader） 取代。\n 2. JDK 9中虽然仍然维持着三层类加载器和双亲委派的架构， 但类加载的委派关系也发生了变动。 当平台及应用程序类加载器收到类加载请求， 在委派给父加载器加载前， 要先判断该类是否能够归属到某一个系统模块中， 如果可以找到这样的归属关系， 就要优先委派给负责那个模块的加载器完成加载。\n\n在Java模块化系统明确的规定了三个类加载器负责各自加载的模块。\n\n\n\n\n# Java内存模型\n\n\n# 硬件的效率与一致性\n\n\n\n基于告诉缓存的存储交互很好的解决了处理器与内存速度之间的矛盾，但带来了一个新问题：缓存一致性（Cache Coherence）。为了解决一致性问题，需要各个处理器访问缓存时都遵循一些协议。这类协议有：MSI、MESI、MOSI。。。\n\nJava虚拟机也有自己的内存模型，并且和这里的内存访问操作及硬件的缓存操作觉有高度的可类比性。\n\n\n# Java内存模型\n\nJava Memory Model，JMM\n\n\n\n这里的主内存、工作内存与Java内存区域中的Java堆、栈、方法区等不是一个概念，没有关系。\n\n * Java内存模型规定了所有的变量都存储在主内存中。\n\n * 每条线程还有自己的工作内存，线程中的工作内存中保存了被该线程使用的变量的主内存副本，线程对变量的所有操作（读取、赋值等）都必须在工作内存中进行，而不能直接读写主内存中的数据。\n\n * 不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量值的传递均需要通过主内存来完成。\n\n这里说的变量与java编程中的变量有所区别，它包括了实例字段、静态字段和构成数组对象的元素，但是不包括局部变量与方法参数，因为是线程私有的，不会被共享，不会存在竞争问题。\n\n对于主内存和工作内存之间的交互协议，Java内存模型中定义了8种操作来完成，Java虚拟机实现时必须保证这8种操作每一个都是原子的。后来，简化为 read, write, lock, unlock 四种。\n\nvolatile 可以说是Java虚拟机提供的最轻量级的同步机制。当一个变量被定为成 volatile 之后，它将具备两个特性：\n\n 1. 保证变量对所有线程的可见性。（并不保证原子性，即使编译出来只有一条字节码指令，也不意味着这条指令就是一个原子操作）\n 2. 禁止指令重排序优化。\n\n大多数情况下 volatile 的总开下比锁要低，因此我们在 volatile 与锁的选择中，唯一判断依据便是 volatile的语义能否满足使用场景的需求。\n\n对于 volatile 变量的特殊规则：\n\n * 在工作内存中，每次使用前都必须先从主内存刷新最新的值，保证能看起其他线程对变量所做的修改。\n * 在工作内存中，每次修改后都必须立刻同步回主内存中，保证其他线程可以看到自己对变量的修改。\n * 修饰的变量不会被指令重排序优化，从而保证代码的执行顺序与程序的顺序相同。\n\n原子性：\n\n尽管虚拟机未把 lock 和 unlock 操作直接开放给用户使用，但是却提供了更高层次的字节码指令 monitorenter 和 monitorexit 来隐式的使用这两个操作。这两个字节码指令反映到java代码中就是同步快synchronized关键字。\n\n可见性：\n\n除了 volatile 之外，Java还有两个关键字可以实现可见性，synchronized 和 final。\n\nfinal 的可见性是指：被final修饰的字段在构造器中一旦被初始化完成，并且构造没有把 this 的引用传递出去，那么在其他线程中就能看见 final 字段的值。\n\n有序性：\n\n如果在本线程内观察，所有操作都是有序的。\n\n如果在一个线程观察另一个线程，所有的操作都是无序的。\n\n\n# 先行发生（Happens-Before）原则\n\n如果Java 内存模型中所有的有序性都只靠 volatile 和 synchronized 来完成，那么很多操作将会变得非常啰嗦。\n\n而Java通过先行发生（Happens-Before）原则，对数据是否存在竞争，线程是否安全进行了判断。\n\n先行发生是指：Java内存模型中定义的两项操作之间的偏序关系，如果操作A先行发生与操作B，那就是说在发送操作B之前，操作A产生的影响能被操作B观察到。影响包括修改了内存中共享变量的值、发送了消息、调用了方法等。\n\n以下是Java内存模型中的先行发生关系：（如果两个操作之间的关系不在此列， 无法从下列规则推导出来， 则它们就没有顺序性保障， 虚拟机可以对它们随意地进行重排序。）\n\n * 程序次序规则 Program Order Rule：在一个线程内，按照控制流程顺序，书写在前面的操作先行发生与书写在后面的操作\n * 管程锁定规则 Monitor Lock Rule：一个unlock 操作先行发生与后面对同一个锁的lock操作。\n * 线程启动规则 Thread Start Rule：Thread对象的start()方法先行发生与此线程的每一个动作。\n * 线程终止规则 Thead Termination Rule：线程中的所有操作都先行发生于对此线程的终止检测，可以通过 Thread::jion() 方法是否结束、Thread::isAlive()的返回值等手段检测线程是否已经终止执行。\n * 线程中断规则 Thread Interruption Rule：对线程interrput()方法的调用先行发生于被中断线程的代码检测到众中断事件的发生，可以通过 Thread::interrupted()方法检测到是否有中断发生。\n * 对象终结规则 Finalize Rule：一个对象的初始化完成（构造函数执行结束）先行发生于它的finalize()方法的开始。\n * 传递性 Transitivity：如果操作A先行发生与操作B，操作B先行发生与操作C，那么操作A先行发生于操作C。\n\n\n# Java 与线程\n\n线程是比进程更轻量级的调度执行单位，引入了线程，可以把一个进程的资源分配和执行调度分开，各个线程既可以共享进程资源（内存地址、文件I/O等），又可以独立调度。\n\n目前线程是Java进行处理器资源调度的最基本单位。\n\n主流Java虚拟机的线程模型都是基于操作系统原生线程模型来实现的，即采用1：1线程模型。\n\n阻塞和等待的区别：\n\n * 阻塞：在等待获取一个排他锁，这个事件将在另一个线程放弃这个锁的时候发生\n * 等待：则是在等待一段时间，或者唤醒动作的发生。\n\n\n\n\n# Java 与协程【不是很理解】\n\n1： 1的内核线程模型是如今Java虚拟机线程实现的主流选择， 但是这种映射到操作系统上的线程天然的缺陷是切换、 调度成本高昂， 系统能容纳的线程数量也很有限。\n\n传统的Java Web服务器的线程池的容量通常在几十个到两百之间， 当程序员把数以百万计的请求往线程池里面灌时， 系统即使能处理得过来， 但其中的切换损耗也是相当可观的。\n\n内核线程的调度成本主要来自于用户态与核心态之间的状态转换， 而这两种状态转换的开销主要来自于响应中断、 保护和恢复执行现场的成本。\n\n后来， 操作系统开始提供多线程的支持， 靠应用自己模拟多线程的做法自然是变少了许多， 但也并没有完全消失， 而是演化为用户线程继续存在。 由于最初多数的用户线程是被设计成协同式调度（Cooperative Scheduling） 的， 所以它有了一个别名——“协程”（Coroutine） 。 又由于这时候的协程会完整地做调用栈的保护、 恢复工作， 所以今天也被称为“有栈协程”（Stackfull Coroutine） ， 起这样的名字是为了便于跟后来的“无栈协程”（Stackless Coroutine） 区分开。 无栈协程不是本节的主角， 不过还是可以简单提一下它的典型应用， 即各种语言中的await、 async、 yield这类关键字。 无栈协程本质上是一种有限状态机， 状态保存在闭包里， 自然比有栈协程恢复调用栈要轻量得多， 但功能也相对更有限。\n\n对于有栈协程， 有一种特例实现名为纤程（Fiber）\n\n\n# 线程安全\n\n线程安全的实现方法：\n\n\n# 互斥同步（阻塞同步）\n\n互斥是手段，同步是目的。\n\n临界区（critical section）、互斥量（mutex）、信号量（semaphore）都是常见的互斥实现方法。\n\n在Java中，最基本的互斥同步手段就是 synchronized ，这是一种块结构（block structured）的同步语法。\n\nsynchronized 经过javac 编译后，会在同步块前后分别形成 monitorenter 和monitorexit两个字节码指令。这两个字节码指令都需要一个reference类型的参数来指明要锁定和解锁的对象。如果代码中synchronized明确指明了对象参数，那就以这个对象的引用作为reference（即获得的是你传入的，传入对象就是对象锁【this也是对象锁】，传入类就是类锁），如果没有明确指定，将根据synchronized修饰的方法类型（实例方法还是类方法），来决定是获取对象实例还是类型对应的Class对象来作为线程要持有的锁（即修饰实例方法获取的是对象锁，修饰静态方法获取的是类锁）。\n\n被 synchronized 修饰的同步块对同一条线程来说是可重入的。这意味着同一线程反复进入同步块也不会出现把自己锁死的情况。\n\n被 synchronized 修饰的同步块在持有锁的线程执行完毕并释放锁之前，会无条件的阻塞后面其他线程的进入。\n\nJDK 5起，Java提供了java.util.concurrent包（J.U.T包），其中java.util.concurrent.locks.Lock接口便成了Java的另一种全新的互斥同步手段。基于Lock接口，用户能够以非块结构（Non-Block Structured）来实现互斥同步，从而摆脱语言特性的束缚，在类库层面去实现同步。\n\n重入锁（ReentrantLock）是Lock接口最常见的一种实现。在基本用法上，ReentrantLock 和 synchronized相似，只是写法稍微不同，且 ReentrantLock 比 synchronized 多了一些高级功能，主要有3项：\n\n 1. 等待可中断\n 2. 可实现公平锁\n 3. 可绑定多个条件\n\nJDK 6 开始对synchronized进行了锁优化，ReentrantLock 和 synchronized 的性能基本能持平，因此性能已不再是选择 ReentrantLock 或 synchronized 的判断因素。\n\n推荐在 synchronized 和 ReentrantLock 都能满足的场景优先使用 synchronized，原因如下：\n\n * synchronized 足够清晰，简单。\n * Lock要确保在finally中释放锁。synchronized由Java虚拟机来保证。\n * 从长远看，Java虚拟机更容易针对synchronized进行优化。因为Java虚拟机通过在线程和对象的元数据中记录synchronized中锁的相关信息，使用Lock的话，Java虚拟机很难得知具体哪些锁对象是由特定线程所持有的。\n\n\n# 非阻塞同步\n\n互斥同步面临的主要问题是进行线程阻塞和唤醒锁带来的性能开销，因此这种同步也被称为阻塞同步（Blocking Synchronization），属于悲观的并发策略。\n\n非阻塞同步（Non-Blocking Synchronization）是基于冲突检测的乐观并发策略，冲突了再进行补偿，最常用的补偿措施是不断重试，直到没有竞争的共享数据位置。也称为无锁（Lock-Free）编程。\n\n乐观并发策略需要依赖硬件指令集的发展，因为要保证操作和冲突检测这两个步骤具备原子性。\n\n这类指令通常用：\n\n * 测试并设置（Test and Set）\n * 获取并增加（Fetch and Increment）\n * 交换（Swap）\n * 比较并交换（Compare and Swap，CAS）\n * 加载链接/条件存储（Load Linked/Store Conditional，LL/SC）\n\nJava里最终暴露出来的是CAS操作，CAS指令需要有3个操作数，分别是变量的内存地址V，旧的预期值A，准备设置的新值B。CAS指令执行时，当且仅当V符合A时，处理器才会用B更新V的值，否则不执行更新。但无论是否执行更新，都会返回V的旧值。\n\n在JDK 5之后， Java类库中才开始使用CAS操作， 该操作由sun.misc.Unsafe类里面的compareAndSwapInt()和compareAndSwapLong()等几个方法包装提供。 HotSpot虚拟机在内部对这些方法做了特殊处理， 即时编译出来的结果就是一条平台相关的处理器CAS指令， 没有方法调用的过程。 不过由于Unsafe类在设计上就不是提供给用户程序调用的类（Unsafe::getUnsafe()的代码中限制了只有启动类加载器（Bootstrap ClassLoader） 加载的Class才能访问它） ， 因此在JDK 9之前只有Java类库可以使用CAS， 譬如J.U.C包里面的整数原子类， 其中的compareAndSet()和getAndIncrement()等方法都使用了Unsafe类的CAS操作来实现。 而如果用户程序也有使用CAS操作的需求， 那要么就采用反射手段突破Unsafe的访问限制， 要么就只能通过Java类库API来间接使用它。 直到JDK 9之后， Java类库才在VarHandle类里开放了面向用户程序使用的CAS操作。\n\n为了解决CAS的ABA问题，J.U.C包提供了一个带有标记的原子引用类AtomicStampedReference，它可以通过控制变量值的版本来保证CAS的正确性。不管目前这个类相当鸡肋，大部分情况下ABA问题不会影响程序并发的正确性，如果需要解决ABA问题，采用传统的互斥同步可能会比原子类更高效。\n\n\n# 无同步方案\n\n线程本地存储（Thread Local Storage）：如果一段代码中所需要的数据必须与其他代码共享，那就看看这些共享数据的代码能否保证只在同一个线程中执行。如果能保证，就可以把共享数据的可见范围限制在同一个线程之内，这样无须同步也能保证线程之间不出现数据竞争的问题。\n\n符合这种特点的应用并不少见，大部分使用消费队列的架构模式（eg：生产者-消费者模式）都会将产品的消费过程限制在一个线程中消费完，其中最重要的一种应用实例就是经典Web交互模型中的“一个请求对应一个服务器线程”（Thread-pre-Request）的处理方式，这种处理方式的广泛应用使得很多Web服务端应用都可以使用线程本地存储来解决线程安全问题。\n\nJava中，如果一个变量要被多线程访问，可以使用 volatile将其声明为“易变的”。如果一个变量只要被某个线程独享，可以通过 java.lang.ThreadLocal类来实现线程本地存储的功能。每一个线程的Thread对象中都有一个ThreadLocalMap对象，这个对象存储了一组以ThreadLocal.threadLocalHashCode为键，以本地线程变量为值的键值对，ThreadLocal对象就是当前线程的ThreadLocalMap的访问入口，每一个ThreadLocal对象都包含了一个独一无二的threadLocalHashCode，这个值就可以在线程键值对中找到对应的本地线程变量。\n\n\n# 锁优化\n\nJDK 6，虚拟机团队锁进行了多种优化，有：\n\n * 适应性自旋 Adaptive Spinning\n * 锁消除 Lock Elimination\n * 锁膨胀 Lock Coarsening\n * 轻量级锁 Lightweight Locking\n * 偏向锁 Biased Locking\n\n\n# 自旋锁与自适应自旋\n\n互斥同步对性能最大的影响是阻塞的实现， 挂起线程和恢复线程的操作都需要转入内核态中完成， 这些操作给Java虚拟机的并发性能带来了很大的压力。 同时， 我们注意到在许多应用上， 共享数据的锁定状态只会持续很短的一段时间， 为了这段时间去挂起和恢复线程并不值得。如果物理机器有一个以上的处理器或者处理器核心， 能让两个或以上的线程同时并行执行， 我们 就可以让后面请求锁的那个线程“稍等一会”， 但不放弃处理器的执行时间， 看看持有锁的线程是否很快就会释放锁。 为了让线程等待， 我们只须让线程执行一个忙循环（自旋） ， 这项技术就是所谓的自旋锁。\n\n自旋锁在1.4.2中就引进了，不过默认是关闭的。JDK 6开始改为默认开启。默认自旋10次。\n\nJDK 6 对自旋锁的优化，引入了自适应的自旋。自适应自旋意味着自旋次数不再是固定的了，由前一次在同一个锁上的自旋时间以及锁的拥有者的状态决定。如果同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也很有可能再次成功，进而允许自旋等待持续更长的时间。如果队友某个锁，自旋很少成功获得过锁，那以后要获取这个锁将可能直接省略自旋过程。\n\n\n# 锁消除\n\n锁消除是指虚拟机即时编译器在运行时，对一些代码要求同步，但是对被检测到不可能存在共享数据竞争的锁进行消除。\n\n锁消除的主要判断依据来源于逃逸分析的数据支持。\n\n如果判断到一段代码，在堆上的所有数据都不会逃逸出去被其他线程访问到，那就可以把他们当做栈上数据对待，认为他们是线程私有的，同步加锁自然就不用再进行了。\n\n\n# 锁粗化\n\n如果虚拟机检测到有一串零碎的操作都对同一个对象加锁，就会把加锁同步的范围粗化到整个操作序列的外部。\n\n\n# 轻量级锁\n\n轻量级锁并不是来替代重量级锁的，它的设计初衷是在没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量的性能消耗。\n\n\n\n在代码即将进入同步块时，如果此同步对象没有被锁定（锁标志位为“01”状态），虚拟机首先将在当前线程的栈帧中简历一个名为锁记录（Lock Record）的空间，用于存储锁对象目前的Mark Word的拷贝。\n\n然后虚拟机将使用 CAS操作尝试把对象的Mark Word更新为指向Lock Record 的指针。\n\n如果更新动作成功了，代表该线程拥有了这个对象的锁，并且对象Mark Word的锁标志位（Mark Word的最后两个比特）将变为“00”，表示此对象正处于轻量级锁定状态。\n\n如果更新操作失败了，意味着有线程与当前线程竞争该对象的锁。虚拟机首先会检查对象的Mark Word是否指向当前线程的栈帧，如果是，说明当前线程已经拥有了这个对象的锁，直接进入同步块。否则说明这个锁对象给其他线程抢占了，此时轻量级锁升级为重量级锁，锁标志位状态变为“10”。\n\n轻量级锁能提升程序同步性能的依据是“对于绝大部分的锁，在整个同步周期内都是不存在竞争的”。如果没有竞争，轻量级锁便通过CAS操作成功避免了使用互斥量的开销。但如果确实存在锁竞争，除了互斥量本身的开销外，还额外发生了CAS的开销。因此在有竞争的情况下，轻量级锁反而会比传统的重量级锁更慢。\n\n\n# 偏向锁\n\n偏向锁的目的是消除数据在无竞争情况下的同步原语。如果说轻量级锁是在无竞争的情况下使用CAS操作去消除同步使用的互斥量，那偏向锁就是在无竞争情况下把整个同步都消除掉，连CAS操作都不做。\n\n这个锁会偏向于第一个获得它的线程，如果在接下来的执行过程中，该锁一直没有被其他的线程获取，则持有偏向锁的线程将永远不需要再进行同步。\n\n偏向锁默认是开启的。当锁对象第一次被线程获取时，虚拟机会把对象头中的标志位设置为“01”、把偏向模式设置为1，表示进入偏向模式。同时使用CAS操作把获取到这个锁的线程ID记录在对象的Mark Word中。果CAS操作成功， 持有偏向锁的线程以后每次进入这个锁相关的同步块时， 虚拟机都可以不再进行任何同步操作（例如加锁、 解锁及对Mark Word的更新操作等）。\n\n一旦出现另外一个线程去尝试获取这个锁的情况， 偏向模式就马上宣告结束。 根据锁对象目前是否处于被锁定的状态决定是否撤销偏向（偏向模式设置为“0”） ， 撤销后标志位恢复到未锁定（标志位为“01”） 或轻量级锁定（标志位为“00”） 的状态， 后续的同步操作就按照上面介绍的轻量级锁那样去执行。\n\n\n\n如果程序中大多数的锁都总是被多个不同的线程访问，那么偏向模式就是多余的。有时使用参数 -XX:-UseBisedLocking=false来禁止偏向锁优化反而可以提升性能。\n\n（JDK 15 废弃偏向锁）',normalizedContent:'# 编译器和解释器\n\n * 类型1：c、c++\n * 类型2：javascript、python、php\n * 类型3：java\n\n对于类型1，我们一般称为编译型语言，也就是需要用到编译器进行编译。\n\n对于类型2，我们一般称为解释型语言，或是脚本语言，也就是要用解释器进行解释。\n\n编译器与解释器就类似于笔译工作者与口译工作者的区别，编译器就是笔译工作者，而解释器就是口译工作者。\n\n * 编译器在编译的过程中，读入源程序文件，输出一份等价的二进制可执行文件，就和笔译工作者一样，他们都会输出一份翻译后的文件。\n * 解释器在解释的过程中，读入源程序文件，输出的是执行的结果，就和口译工作者一样，他们输出的是已经完成翻译的结果。\n\n解释器：\n\n * 优点：跨平台、启动速度快、开发效率高\n\n * 缺点：执行速度慢，执行效率低\n\n编译器：\n\n * 优点：执行速度快、执行效率高\n * 缺点：平台相关性高，编译速度（启动速度）慢，开发效率低\n\njava既有编译器（不止一个）又有解释器。\n\njava中编译器比较多，它包含一个前端编译器，一个后端编译器（jit）以及一个静态预编译器（aot）。\n\n * 前端编译器的功能是从源代码生成java字节码，也就是中间代码；\n * 后端编译器，也叫作即时编译器（jit）它是包含在了jvm中，用于在执行的过程中，将热点代码（也就是执行次数比较多的代码）转化为本地机器码，并做一些优化，以加速执行效率。\n * 静态预编译器（aot）它是直接将java源代码编译成本地机器码，也就是传统意义上的编译器，但用的不多，因为这样会使java的一些特性丢失。\n\njava中的解释器与jit一起打包，作为jvm中的执行引擎，解释器主要将字节码进行解释执行，同时配合jit进行代码的优化操作。\n\njava解释器就是把在java虚拟机上运行的目标代码（字节码）解释成为具体平台的机器码的程序。即jdk或jre目录下bin目录中的java.exe文件，而javac.exe是编译器。\n\n运行java程序的过程是先用javac编译，然后用java解释。而一经编译成功后，就可以直接用java.exe随处解释运行了。\n\njvm负责运行字节码：jvm把每一条要执行的字节码交给解释器，翻译成对应的机器码，然后由解释器执行。jvm解释执行字节码文件就是jvm操作java解释器进行解释执行字节码文件的过程。\n\n\n# java内存区域\n\njava把控制内存的权利交给了java 虚拟机，一旦出现内存泄漏和溢出方面的问题，如果不了解虚拟机是怎样使用内存的，那排查错误、修正问题将成为一项艰难的工作。\n\n\n# 运行时数据区\n\n《java虚拟机规范》 ：“概念模型”这个词会经常被提及， 它代表了所有虚拟机的统一外观， 但各款具体的java虚拟机并不 一定要完全照着概念模型的定义来进行设计， 可能会通过一些更高效率的等价方式去实现它。\n\n\n# 程序计数器\n\n当前线程所执行的字节码的行号。字节码解释器就是通过改变这个计数器的值来选取下一条需要执行的字节码指令。\n\n程序计数器主要有两个作用：\n\n 1. 字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。\n 2. 在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。\n\n注意：程序计数器是唯一一个不会出现 outofmemoryerror 的内存区域，它的生命周期随着线程的创建而创建，随着线程的结束而死亡。\n\n\n# java虚拟机栈\n\n描述的是java方法执行的线程内存模型，每个方法被执行时，java虚拟机都会同步创建一个栈帧（stack frame）用于存储局部变量表、操作数栈、动态连接、方法出口等信息。每个方法从被调用到执行完毕的过程，就对应这一个栈帧在虚拟机栈的入栈和出栈过程。\n\n局部变量表主要存放了编译期可知的各种数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference 类型，它不同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）。\n\njava 虚拟机栈会出现两种错误：stackoverflowerror 和 outofmemoryerror。\n\n * stackoverflowerror： 若 java 虚拟机栈的内存大小不允许动态扩展，那么当线程请求栈的深度超过当前 java 虚拟机栈的最大深度的时候，就抛出 stackoverflowerror 错误。\n * outofmemoryerror： java 虚拟机栈的内存大小可以动态扩展， 如果虚拟机在动态扩展栈时无法申请到足够的内存空间，则抛出outofmemoryerror异常。\n\nhotspot虚拟机的栈容量是不可以动态扩展的， 以前的classic虚拟机倒是可以。 所以在hotspot虚拟机上是不会由于虚拟机栈无法扩展而导致outofmemoryerror异常——只要线程申请栈空间成功了就不会有oom， 但是如果申请时就失败， 仍然是会出现oom异常的。\n\n\n# 本地方法栈\n\n本地方法栈（native method stacks） 与虚拟机栈所发挥的作用是非常相似的， 其区别只是虚拟机栈为虚拟机执行java方法（也就是字节码） 服务， 而本地方法栈则是为虚拟机使用到的本地（native）方法服务。\n\n在 hotspot 虚拟机中和 java 虚拟机栈合二为一。\n\n\n# 堆\n\njava 虚拟机所管理的内存中最大的一块，java 堆是所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存。\n\njava 世界中“几乎”所有的对象都在堆中分配，但是，随着 jit 编译器的发展与逃逸分析技术逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化，所有的对象都分配到堆上也渐渐变得不那么“绝对”了。从 jdk 1.7 开始已经默认开启逃逸分析，如果某些方法中的对象引用没有被返回或者未被外面使用（也就是未逃逸出去），那么对象可以直接在栈上分配内存。\n\njava 堆是垃圾收集器管理的主要区域，因此也被称作gc 堆（garbage collected heap）。从垃圾回收的角度，由于现在收集器基本都采用分代垃圾收集算法，所以 java 堆还可以细分为：新生代和老年代；再细致一点有：eden 空间、from survivor、to survivor 空间等。进一步划分的目的是更好地回收内存，或者更快地分配内存。\n\n从回收内存的角度看， 由于现代垃圾收集器大部分都是基于分代收集理论设计的， 所以java堆中经常会出现“新生代”“老年代”“永久代”“eden空间”“from survivor空间”“to survivor空间”等名词， 这些区域划分仅仅是一部分垃圾收集器的共同特性或者说设计风格而已， 而非某个java虚拟机具体实现的固有内存布局， 更不是《java虚拟机规范》 里对java堆的进一步细致划分。 不少资料上经常写着类似于“java虚拟机的堆内存分为新生代、 老年代、 永久代、 eden、 survivor……”这样的内容。 在十年之前（以g1收集器的出现为分界） ， 作为业界绝对主流的hotspot虚拟机， 它内部的垃圾收集器全部都基于“经典分代”[3]来设计， 需要新生代、 老年代收集器搭配才能工作， 但现在不可同日而语，也出现了不采用分代设计的垃圾回收器。\n\n在 jdk 7 版本及 jdk 7 版本之前，堆内存被通常分为下面三部分：\n\n 1. 新生代内存(young generation)\n 2. 老生代(old generation)\n 3. 永生代(permanent generation)\n\njdk 8 版本之后方法区（hotspot 的永久代）被彻底移除了（jdk1.7 就已经开始了），取而代之是元空间，元空间使用的是直接内存。\n\n上图所示的 eden 区、两个 survivor 区都属于新生代（为了区分，这两个 survivor 区域按照顺序被命名为 from 和 to），中间一层属于老年代。\n\n大部分情况，对象都会首先在 eden 区域分配，在一次新生代垃圾回收后，如果对象还存活，则会进入 s0 或者 s1，并且对象的年龄还会加 1(eden 区->survivor 区后对象的初始年龄变为 1)，当它的年龄增加到一定程度（默认为 15 岁），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 -xx:maxtenuringthreshold 来设置。\n\nhotspot 遍历所有对象时，按照年龄从小到大对其所占用的大小进行累积，当累积的某个年龄大小超过了 survivor 区的一半时，取这个年龄和 maxtenuringthreshold 中更小的一个值，作为新的晋升年龄阈值。\n\n堆这里最容易出现的就是 outofmemoryerror 错误，并且出现这种错误之后的表现形式还会有几种，比如：\n\n 1. java.lang.outofmemoryerror: gc overhead limit exceeded ： 当 jvm 花太多时间执行垃圾回收并且只能回收很少的堆空间时，就会发生此错误。\n 2. java.lang.outofmemoryerror: java heap space :假如在创建新的对象时, 堆内存中的空间不足以存放新创建的对象, 就会引发此错误。(和配置的最大堆内存有关，且受制于物理内存大小。最大堆内存可通过-xmx参数配置，-xms设置初始堆内存，若没有特别配置，将会使用默认值，详见：default java 8 max heap size (opens new window))\n\n\n# 方法区\n\n方法区与 java 堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。虽然 java 虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做 non-heap（非堆），目的应该是与 java 堆区分开来。\n\n说到方法区， 不得不提一下“永久代”这个概念， 尤其是在jdk 8以前， 许多java程序员都习惯在hotspot虚拟机上开发、 部署程序， 很多人都更愿意把方法区称呼为“永久代”（permanent generation） ， 或将两者混为一谈。 本质上这两者并不是等价的， 因为仅仅是当时的hotspot虚拟机设计团队选择把收集器的分代设计扩展至方法区， 或者说使用永久代来实现方法区而已， 这样使得hotspot的垃圾收集器能够像管理java堆一样管理这部分内存， 省去专门为方法区编写内存管理代码的工作。 但是对于其他虚拟机实现， 譬如bea jrockit、 ibm j9等来说， 是不存在永久代的概念的。 原则上如何实现方法区属于虚拟机实现细节， 不受《java虚拟机规范》 管束， 并不要求统一。 但现在回头来看， 当年使用永久代来实现方法区的决定并不是一个好主意， 这种设计导致了java应用更容易遇到内存溢出的问题（永久代有-xx： maxpermsize的上限， 即使不设置也有默认大小， 而j9和jrockit只要没有触碰到进程可用内存的上限， 例如32位系统中的4gb限制， 就不会出问题） ， 而且有极少数方法（例如string::intern()） 会因永久代的原因而导致不同虚拟机下有不同的表现。 当oracle收购bea获得了jrockit的所有权后， 准备把jrockit中的优秀功能， 譬如java mission control管理工具， 移植到hotspot虚拟机时， 但因为两者对方法区实现的差异而面临诸多困难。\n\n考虑到hotspot未来的发展， 在jdk 6的时候hotspot开发团队就有放弃永久代， 逐步改为采用本地内存（native memory） 来实现方法区的计划了[1]， 到了jdk 7的hotspot， 已经把原本放在永久代的字符串常量池、 静态变量等移出， 而到了jdk 8， 终于完全废弃了永久代的概念， 改用与jrockit、 j9一样在本地内存中实现的元空间（metaspace） 来代替， 把jdk 7中永久代还剩余的内容（主要是类型信息） 全部移到元空间中。\n\n//jdk 1.8 之前永久代还没被彻底移除的时候通常通过下面这些参数来调节方法区大小\n-xx:permsize=n //方法区 (永久代) 初始大小\n-xx:maxpermsize=n //方法区 (永久代) 最大大小,超过这个值将会抛出 outofmemoryerror 异常:java.lang.outofmemoryerror: permgen\n\n\njdk 1.8 的时候，方法区（hotspot 的永久代）被彻底移除了（jdk1.7 就已经开始了），取而代之是元空间，元空间使用的是直接内存。\n\n//一些常用参数：\n-xx:metaspacesize=n //设置 metaspace 的初始（和最小大小）\n-xx:maxmetaspacesize=n //设置 metaspace 的最大大小\n\n\n与永久代很大的不同就是，如果不指定大小的话，随着更多类的创建，虚拟机会耗尽所有可用的系统内存。\n\n运行时常量池是方法区的一部分。class 文件中除了有类的版本、字段、方法、接口等描述信息外，还有常量池表（用于存放编译期生成的各种字面量和符号引用）。既然运行时常量池是方法区的一部分，自然受到方法区内存的限制，当常量池无法再申请到内存时会抛出 outofmemoryerror 错误。\n\njdk1.7 之前运行时常量池逻辑包含字符串常量池存放在方法区, 此时 hotspot 虚拟机对方法区的实现为永久代。\n\njdk1.7字符串常量池被从方法区拿到了堆中, 这里没有提到运行时常量池,也就是说字符串常量池被单独拿到堆,运行时常量池剩下的东西还在方法区, 也就是 hotspot 中的永久代。\n\njdk1.8 hotspot 移除了永久代用元空间(metaspace)取而代之, 这时候字符串常量池还在堆, 运行时常量池还在方法区, 只不过方法区的实现从永久代变成了元空间(metaspace)。\n\n\n# 直接内存\n\n直接内存并不是虚拟机运行时数据区的一部分，也不是虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使用。而且也可能导致 outofmemoryerror 错误出现。\n\njdk1.4 中新加入的 nio(new input/output) 类，引入了一种基于通道（channel）与缓存区（buffer）的 i/o 方式，它可以直接使用 native 函数库直接分配堆外内存，然后通过一个存储在 java 堆中的 directbytebuffer 对象作为这块内存的引用进行操作。这样就能在一些场景中显著提高性能，因为避免了在 java 堆和 native 堆之间来回复制数据。\n\n本机直接内存的分配不会受到 java 堆的限制，但是，既然是内存就会受到本机总内存大小以及处理器寻址空间的限制。\n\n\n# hotspot虚拟机对象探秘\n\n> 基于实用优先的原则， 以最常用的虚拟机hotspot和最常用的内存区域java堆为例， 深入探讨一下hotspot虚拟机在java堆中对象分配、 布局和访问的全过程。\n\n\n# 对象的创建\n\n\n\n 1. 类加载检查：虚拟机遇到一条 new 指令时，首先将去检查这个指令的参数是否能在常量池中定位到这个类的符号引用，并且检查这个符号引用代表的类是否已被加载过、解析和初始化过。如果没有，那必须先执行相应的类加载过程。\n 2. 分配内存：\n    1. 分配方式：有“指针碰撞”和“空闲列表”两种，取决于java堆是否规整，这又由垃圾回收器是否带有压缩整理功能决定。\n    2. 虚拟机保证线程安全：\n       1. cas+失败重试： cas 是乐观锁的一种实现方式。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。虚拟机采用 cas 配上失败重试的方式保证更新操作的原子性。\n       2. tlab（本地线程分配缓存）： 为每一个线程预先在 eden 区分配一块儿内存，jvm 在给线程中的对象分配内存时，首先在 tlab 分配，当对象大于 tlab 中的剩余内存或 tlab 的内存已用尽时，再采用上述的 cas 进行内存分配。\n 3. 初始化零值\n 4. 设置对象头：例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 gc 分代年龄等信息。 这些信息存放在对象头中。 另外，根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。\n 5. 执行init方法\n\n\n# 对象的内存布局\n\n在hotspot虚拟机中，对象在堆内存中的存储布局可以分为三个部分：对象头、实例数据和对齐填充。\n\nhotspot 虚拟机的对象头包括两部分信息，第一部分用于存储对象自身的运行时数据（哈希码、gc 分代年龄、锁状态标志、线程持有的锁、偏向线程id、偏向时间戳等等），官方称为“mark word”。另一部分是类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是那个类的实例。\n\n实例数据部分是对象真正存储的有效信息，也是在程序中所定义的各种类型的字段内容。\n\n对齐填充部分不是必然存在的，也没有什么特别的含义，仅仅起占位作用。 因为 hotspot 虚拟机的自动内存管理系统要求对象起始地址必须是 8 字节的整数倍，换句话说就是对象的大小必须是 8 字节的整数倍。而对象头部分正好是 8 字节的倍数（1 倍或 2 倍），因此，当对象实例数据部分没有对齐时，就需要通过对齐填充来补全。\n\n\n# 对象的访问定位\n\njava程序会通过栈上reference数据来操作堆上的具体对象。\n\n对象的访问方式由虚拟机的实现决定：主流的访问方式主要有使用句柄和直接指针两种。\n\n这两种对象访问方式各有优势。使用句柄来访问的最大好处是 reference 中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而 reference 本身不需要修改。使用直接指针访问方式最大的好处就是速度快，它节省了一次指针定位的时间开销。\n\n\n# 字符串问题\n\n * 直接使用双引号声明出来的string对象会直接存储在常量池中。\n * 如果不是用双引号声明的string对象，可以使用string提供的intern方法。intern 方法会从字符串常量池中查询当前字符串是否存在，若不存在就会将当前字符串放入常量池中。\n * （string.intern() 是一个 native 方法，它的作用是：如果运行时常量池中已经包含一个等于此 string 对象内容的字符串，则返回常量池中该字符串的引用；如果没有，jdk1.7 之前（不包含 1.7）的处理方式是在常量池中创建与此 string 内容相同的字符串，并返回常量池中创建的字符串的引用，jdk1.7 以及之后，字符串常量池被从方法区拿到了堆中，jvm 不会在常量池中创建该对象，而是将堆中这个对象的引用直接放到常量池中，减少不必要的内存开销。）\n\n对于基本数据类型来说，比较的是值。对于引用数据类型来说，比较的是对象的内存地址。\n\n在编译过程中，javac 编译器会进行一个叫做 常量折叠(constant folding) 的代码优化。常量折叠会把常量表达式的值求出来作为常量嵌在最终生成的代码中，这是 javac 编译器会对源代码做的极少量优化措施之一(代码优化几乎都在即时编译器中进行)。\n\n一般来说，我们要尽量避免通过 new 的方式创建字符串。使用双引号声明的 string 对象（ string s1 = "java" ）更利于让编译器有机会优化我们的代码，同时也更易于阅读。\n\n被 final 关键字修改之后的 string 会被编译器当做常量来处理，编译器程序编译期就可以确定它的值，其效果就想到于访问常量。\n\nstring s1 = new string("abc");这句话创建了几个字符串对象？\n\n会创建 1 或 2 个字符串：\n\n * 如果字符串常量池中已存在字符串常量“abc”，则只会在堆空间创建一个字符串常量“abc”。\n * 如果字符串常量池中没有字符串常量“abc”，那么它将首先在字符串常量池中创建，然后在堆空间中创建，因此将创建总共 2 个字符串对象。\n\njava 基本类型的包装类的大部分都实现了常量池技术。\n\nbyte,short,integer,long 这 4 种包装类默认创建了数值 [-128，127] 的相应类型的缓存数据，character 创建了数值在 [0,127] 范围的缓存数据，boolean 直接返回 true or false。\n\n两种浮点数类型的包装类 float,double 并没有实现常量池技术。\n\n记住：所有整型包装类对象之间值的比较，全部使用 equals 方法比较。\n\n\n# outofmemoryerror异常\n\n\n# java堆溢出\n\n将堆的最小值-xms参数与最大值-xmx参数设置为一样的话可避免堆自动扩展，即设置为不可扩展。\n\n要解决这个内存区域的异常， 常规的处理方法是首先通过内存映像分析工具（如eclipse memory analyzer） 对dump出来的堆转储快照进行分析。 第一步首先应确认内存中导致oom的对象是否是必要的， 也就是要先分清楚到底是出现了内存泄漏（memory leak） 还是内存溢出（memory overflow） 。\n\n如果是内存泄漏， 可进一步通过工具查看泄漏对象到gc roots的引用链， 找到泄漏对象是通过怎样的引用路径、 与哪些gc roots相关联， 才导致垃圾收集器无法回收它们， 根据泄漏对象的类型信息以及它到gc roots引用链的信息， 一般可以比较准确地定位到这些对象创建的位置， 进而找出产生内存泄漏的代码的具体位置。\n\n如果不是内存泄漏， 换句话说就是内存中的对象确实都是必须存活的， 那就应当检查java虚拟机的堆参数（-xmx与-xms） 设置， 与机器的内存对比， 看看是否还有向上调整的空间。 再从代码上检查是否存在某些对象生命周期过长、 持有状态时间过长、 存储结构设计不合理等情况， 尽量减少程序运行期的内存消耗。\n\n\n# 虚拟机栈或本地方法栈溢出\n\n由于hotspot虚拟机并不区分虚拟机栈和本地方法栈，所以栈容量只由 -xss参数决定。\n\n关于虚拟机栈和本地方法栈， 在《java虚拟机规范》 中描述了两种异常：\n\n 1. 如果线程请求的栈深度大于虚拟机所允许的最大深度， 将抛出stackoverflowerror异常。\n 2. 如果虚拟机的栈内存允许动态扩展， 当扩展栈容量无法申请到足够的内存时， 将抛出outofmemoryerror异常。\n\n《java虚拟机规范》 明确允许java虚拟机实现自行选择是否支持栈的动态扩展， 而hotspot虚拟机的选择是不支持扩展， 所以除非在创建线程申请内存时就因无法获得足够内存而出现outofmemoryerror异常， 否则在线程运行时是不会因为扩展而导致内存溢出的， 只会因为栈容量无法容纳新的栈帧而导致stackoverflowerror异常。\n\n出现stackoverflowerror异常时， 会有明确错误堆栈可供分析， 相对而言比较容易定位到问题所在。 如果使用hotspot虚拟机默认参数， 栈深度在大多数情况下（因为每个方法压入栈的帧大小并不是一样的， 所以只能说大多数情况下） 到达1000~2000是完全没有问题， 对于正常的方法调用（包括不能做尾递归优化的递归调用） ，这个深度应该完全够用了。\n\n但是， 如果是建立过多线程导致的内存溢出， 在不能减少线程数量或者更换64位虚拟机的情况下， 就只能通过减少最大堆和减少栈容量来换取更多的线程。 这种通过“减少内存”的手段来解决内存溢出的方式， 如果没有这方面处理经验， 一般比较难以想到， 这一点读者需要在开发32位系统的多线程应用时注意。 也是由于这种问题较为隐蔽， 从jdk 7起， 以上提示信息中“unable to create native thread”后面， 虚拟机会特别注明原因可能是“possiblyout of memory or process/resource limits reached”。\n\n\n# 方法区和运行时常量池溢出\n\n以下面的例子为例：\n\nstring::intern()是一个本地方法， 它的作用是如果字符串常量池中已经包含一个等于此string对象的字符串， 则返回代表池中这个字符串的string对象的引用； 否则， 会将此string对象包含的字符串添加到常量池中， 并且返回此string对象的引用。\n\n自jdk 7起， 原本存放在永久代的字符串常量池被移至java堆之中。\n\n当前的很多主流框架， 如spring、 hibernate对类进行增强时， 都会使用到cglib这类字节码技术， 当增强的类越多， 就需要越大的方法区以保证动态生成的新类型可以载入内存。\n\n方法区溢出也是一种常见的内存溢出异常， 一个类如果要被垃圾收集器回收， 要达成的条件是比较苛刻的。\n\n在jdk 8以后， 永久代便完全退出了历史舞台， 元空间作为其替代者登场。 在默认设置下， 正常的动态创建新类型已经很难再迫使虚拟机产生方法区的溢出异常了。 不过为了让使用者有预防实际应用里出现的破坏性的操作， hotspot还是提供了一些参数作为元空间的防御措施， 主要包括：\n\n * -xx：maxmetaspacesize： 设置元空间最大值， 默认是-1， 即不限制， 或者说只受限于本地内存大小。\n * -xx：metaspacesize： 指定元空间的初始空间大小， 以字节为单位， 达到该值就会触发垃圾收集进行类型卸载， 同时收集器会对该值进行调整： 如果释放了大量的空间， 就适当降低该值； 如果释放了很少的空间， 那么在不超过-xx： maxmetaspacesize（如果设置了的话） 的情况下， 适当提高该值。\n * -xx：minmetaspacefreeratio： 作用是在垃圾收集之后控制最小的元空间剩余容量的百分比， 可减少因为元空间不足导致的垃圾收集的频率。 类似的还有-xx： max-metaspacefreeratio， 用于控制最大的元空间剩余容量的百分比。\n\n\n# 本机直接内存溢出\n\n直接内存（direct memory） 的容量大小可通过-xx： maxdirectmemorysize参数来指定， 如果不去指定， 则默认与java堆最大值（由-xmx指定） 一致。\n\n由直接内存导致的内存溢出， 一个明显的特征是在heap dump文件中不会看见有什么明显的异常情况， 如果读者发现内存溢出之后产生的dump文件很小， 而程序中又直接或间接使用了directmemory（典型的间接使用就是nio） ， 那就可以考虑重点检查一下直接内存方面的原因了。\n\n\n# jvm垃圾回收\n\n问题：\n\n * 内存是如何分配和回收的？\n * 哪些内存需要回收？\n * 什么时候回收？\n * 如何回收？\n * parnew 和parallel scavenge 的区别是？\n\n\n# 垃圾回收算法\n\n * 标记-清除 mark-sweep\n * 标记-复制：常用于新生代\n * 标记-整理 mark-compact\n\n分代回收：只是根据对象存活周期的不同将内存分为几块。一般将 java 堆分为新生代和老年代，这样我们就可以根据各个年代的特点选择合适的垃圾收集算法。\n\n\n# 并行和并发\n\n * 并行（parallel） ：指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态。\n * 并发（concurrent）：指用户线程与垃圾收集线程同时执行（但不一定是并行，可能会交替执行），用户程序在继续运行，而垃圾收集器运行在另一个 cpu 上。\n\n\n# 垃圾回收器图解\n\n\n\nserial 是单线程的收集器\n\nparnew 收集器实质上是serial收集器的多线程并行版本。除了同时使用多条线程进行垃圾收集之外， 其余的行为包括serial收集器可用的所有控制参数（例如： -xx： survivorratio、 -xx：pretenuresizethreshold、 -xx： handlepromotionfailure等） 、 收集算法、 stop the world、 对象分配规则、 回收策略等都与serial收集器完全一致， 在实现上这两种收集器也共用了相当多的代码。\n\nparnew收集器除了支持多线程并行收集之外， 其他与serial收集器相比并没有太多创新之处。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n# 垃圾回收器分类\n\n * 经典垃圾回收器\n   * 新生代\n     * serial：新生代采用标记-复制算法，老年代采用标记-整理算法。\n     * parnew：serial的多线程版\n     * parallel scavenge：新生代采用标记-复制算法，老年代采用标记-整理算法。\n       * parallel scavenge 收集器关注点是吞吐量（高效率的利用 cpu）。cms 等垃圾收集器的关注点更多的是用户线程的停顿时间（提高用户体验）。所谓吞吐量就是 cpu 中用于运行用户代码的时间与 cpu 总消耗时间的比值。 parallel scavenge 收集器提供了很多参数供用户找到最合适的停顿时间或最大吞吐量，如果对于收集器运作不太了解，手工优化存在困难的时候，使用 parallel scavenge 收集器配合自适应调节策略，把内存管理优化交给虚拟机去完成也是一个不错的选择。\n   * 老年代：\n     * serial old\n     * parallel old：多线程+标记整理\n     * cms：concurrent mark sweep，采用标记-清除算法。目标最短回收停顿时间。\n   * g1：面向服务器的垃圾收集器,主要针对配备多颗处理器及大容量内存的机器. 以极高概率满足 gc 停顿时间要求的同时,还具备高吞吐量性能特征.（低停顿+高吞吐）。g1 从整体来看是基于“标记-整理”算法实现的收集器；从局部上来看是基于“标记-复制”算法实现的。\n     * g1 收集器在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的 region(这也就是它的名字 garbage-first 的由来) 。\n * 低延迟垃圾回收器\n   * zgc：基于region 内存布局，不设分代，使用了读屏障、染色指针和内存多重映射等技术实现可并发的标记-整理算法，以低延迟为首要目标。\n   * shenandoah\n\ncms缺点：\n\n * 对 cpu 资源敏感；\n * 无法处理浮动垃圾；\n * 它使用的回收算法-“标记-清除”算法会导致收集结束时会有大量空间碎片产生。\n\nshenandoah与g1的3个明显不同：\n\n * 支持并发的整理算法（最重要）。g1的回收阶段是可以多线程并行的，但不能与用户线程并发。\n * 目前默认不使用分代回收\n * 摒弃g1中耗费大量内存和计算资源去维护的记忆集，使用“连接矩阵”的全局数据结构来记录跨region的引用关系。\n\n\n# 默认垃圾回收器：\n\n * jdk8 默认使用的是 parallel scavenge + parallel old。但一般不用这个。常用parnew+cms吧（因为是唯一搭配呀）\n * jdk9~16 默认g1\n\n在jvm中是+xx配置实现的搭配组合：\n\n * -xx:+useserialgc，虚拟机运行在client模式下的默认值，serial+serial old。\n * -xx:+useparnewgc，parnew+serial old，在jdk1.8被废弃，在jdk1.7还可以使用。\n * -xx:+useconcmarksweepgc，parnew+cms+serial old。\n * -xx:+useparallelgc，虚拟机运行在server模式下的默认值，parallel scavenge+serial old(ps mark sweep)。\n * -xx:+useparalleloldgc，parallel scavenge+parallel old。\n * -xx:+useg1gc，g1+g1。\n\n\n\n\n\n堆内存常见分配策略：\n\n * 对象优先分配在eden区\n * 大对象直接分配到老年代。大对象就是需要大量连续内存空间的对象（比如：字符串、数组）。\n * 长期存活的对象进入老年代\n\n空间分配担保：目的是确保minor gc之前老年代有足够空间容纳新生代所有对象\n\njdk 6 update 24 之前，在发生 minor gc 之前，虚拟机必须先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果这个条件成立，那这一次 minor gc 可以确保是安全的。如果不成立，则虚拟机会先查看 -xx:handlepromotionfailure 参数的设置值是否允许担保失败(handle promotion failure);如果允许，那会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试进行一次 minor gc，尽管这次 minor gc 是有风险的;如果小于，或者 -xx: handlepromotionfailure 设置不允许冒险，那这时就要改为进行一次 full gc。\n\njdk 6 update 24之后的规则变为只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小，就会进行 minor gc，否则将进行 full gc。\n\n动态对象年龄判定：hotspot 遍历所有对象时，按照年龄从小到大对其所占用的大小进行累积，当累积的某个年龄大小超过了 survivor 区的 50% 时（默认值是 50%，可以通过 -xx:targetsurvivorratio=percent 来设置 ），取这个年龄和 maxtenuringthreshold（默认15岁） 中更小的一个值，作为新的晋升年龄阈值”。\n\ngc分类\n\n * partial gc:\n   \n   * minor gc/young gc\n   \n   * major gc/old gc\n   \n   * mixed gc：对整个新生代和老年代进行垃圾回收\n\n * full gc：收集整个java堆和方法区\n\n\n# 如何判断一个对象已经无效？\n\n * 引用计数法\n   \n   * 实现简单，效率高，但是目前主流的虚拟机中并没有选择这个算法来管理内存，其最主要的原因是它很难解决对象之间相互循环引用的问题。\n\n * 可达性分析法\n   \n   * 通过一系列的称为 “gc roots” 的对象作为起点，从这些节点开始向下搜索，节点所走过的路径称为引用链，当一个对象到 gc roots 没有任何引用链相连的话，则证明此对象是不可用的。\n\n\n# 可作为gc roots的对象\n\n * 虚拟机栈（栈帧中的本地变量表）中引用的对象\n * 本地方法栈（native方法）中引用的对象\n * 方法区中类静态属性引用的对象\n * 方法区中常量引用的对象\n * 所有被同步锁持有的对象\n\n\n# 引用\n\njdk1.2 之前，java 中引用的定义很传统：如果 reference 类型的数据存储的数值代表的是另一块内存的起始地址，就称这块内存代表一个引用。\n\njdk1.2 以后，java 对引用的概念进行了扩充，将引用分为强引用、软引用、弱引用、虚引用四种（引用强度逐渐减弱）\n\n * 强引用（strongreference）\n   \n   以前我们使用的大部分引用实际上都是强引用，这是使用最普遍的引用。如果一个对象具有强引用，那就类似于必不可少的生活用品，垃圾回收器绝不会回收它。当内存空间不足，java 虚拟机宁愿抛出 outofmemoryerror 错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足问题。\n\n * 软引用（softreference）\n   \n   如果一个对象只具有软引用，那就类似于可有可无的生活用品。**如果内存空间足够，垃圾回收器就不会回收它，如果内存空间不足了，就会回收这些对象的内存。**只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存。\n   \n   软引用可以和一个引用队列（referencequeue）联合使用，如果软引用所引用的对象被垃圾回收，java 虚拟机就会把这个软引用加入到与之关联的引用队列中。\n\n * 弱引用（weakreference）\n   \n   如果一个对象只具有弱引用，那就类似于可有可无的生活用品。弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程， 因此不一定会很快发现那些只具有弱引用的对象。\n   \n   弱引用可以和一个引用队列（referencequeue）联合使用，如果弱引用所引用的对象被垃圾回收，java 虚拟机就会把这个弱引用加入到与之关联的引用队列中。\n\n * 虚引用（phantomreference）\n   \n   "虚引用"顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收。\n   \n   虚引用主要用来跟踪对象被垃圾回收的活动。\n   \n   虚引用与软引用和弱引用的一个区别在于： 虚引用必须和引用队列（referencequeue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。程序如果发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。\n   \n   特别注意，在程序设计中一般很少使用弱引用与虚引用，使用软引用的情况较多，这是因为软引用可以加速 jvm 对垃圾内存的回收速度，可以维护系统的运行安全，防止内存溢出（outofmemory）等问题的产生。\n\n你会使用软引用和弱引用吗？软引用和弱引用的例子不错。\n\n\n# 常量池的位置\n\njdk1.7 之前运行时常量池逻辑包含字符串常量池存放在方法区, 此时 hotspot 虚拟机对方法区的实现为永久代。\n\njdk1.7 字符串常量池被从方法区拿到了堆中, 这里没有提到运行时常量池,也就是说字符串常量池被单独拿到堆,运行时常量池剩下的东西还在方法区, 也就是 hotspot 中的永久代 。\n\njdk1.8 hotspot 移除了永久代用元空间(metaspace)取而代之, 这时候字符串常量池还在堆, 运行时常量池还在方法区, 只不过方法区的实现从永久代变成了元空间(metaspace)\n\n假如在字符串常量池中存在字符串 "abc"，如果当前没有任何 string 对象引用该字符串常量的话，就说明常量 "abc" 就是废弃常量，如果这时发生内存回收的话而且有必要的话，"abc" 就会被系统清理出常量池了。\n\n\n# 如何判断一个类是无用的类\n\n方法区主要回收的是无用的类，那么如何判断一个类是无用的类的呢？\n\n判定一个常量是否是“废弃常量”比较简单，而要判定一个类是否是“无用的类”的条件则相对苛刻许多。类需要同时满足下面 3 个条件才能算是 “无用的类” ：\n\n * 该类所有的实例都已经被回收，也就是 java 堆中不存在该类的任何实例。\n * 加载该类的 classloader 已经被回收。\n * 该类对应的 java.lang.class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。\n\n虚拟机可以对满足上述 3 个条件的无用类进行回收，这里说的仅仅是“可以”，而并不是和对象一样不使用了就会必然被回收。\n\n\n# 虚拟机性能监控、故障处理工具\n\n\n# 6个常用的命令行工具：\n\n工具       功能\njps      虚拟机进程状况工具。可列出正在运行的虚拟机进程，并现实虚拟机执行主类。\njstat    虚拟机统计信息监视工具。虚拟机信息主要有3类：类加载、垃圾收集、运行期编译状况\njinfo    java配置信息工具。实时查看和调整虚拟机各项参数。\njmap     java内存映像工具。用于生成堆转储快照（heap dump或dump文件）。\njhat     虚拟机堆转储快照分析工具。搭配jmap使用，分析jmap生成的堆转储快照。一般不用，用visualvm或其他。\njstack   java堆栈跟踪工具。用于生成虚拟机当前时刻的线程快照（threaddump或javacore文件）。线程快照就是当前虚拟机内每一条线程正在执行的方法的堆栈的集合。\n\n其他工具：\n\n工具      功能\njava    用于运行class文件或jar文件\njavac   编译器，将.java文件编译成.class\njavap   用于分析字节码。反编译得到字节码指令。也可用其他工具将class文件转换成特定平台上的汇编代码。\n        \n\n\n# 4个常用的可视化工具：\n\n可视化工具                  功能\njhsdb                  基于服务性代理的调试工具\njconsole               java监视与管理控制台\nvisualvm               多合-故障处理工具\njava mission control   可持续在线的监控工具\n\n\n# jmx\n\njmx（java management extensions）， java 管理扩展，用来管理和监测 java 程序。最常用到的就是对于 jvm 的监测和管理，比如 jvm 内存、cpu 使用率、线程数、垃圾收集情况等等。另外，还可以用作日志级别的动态修改，比如 log4j 就支持 jmx 方式动态修改线上服务的日志级别。最主要的还是被用来做各种监控工具，比如 spring boot actuator、jconsole、visualvm 等。\n\njmx 既是 java 管理系统的一个标准，一个规范，也是一个接口，一个框架。有标准、有规范是为了让开发者可以定制开发自己的扩展功能，而且作为一个框架来讲，jdk 已经帮我们实现了常用的功能，尤其是对 jvm 的监控和管理。\n\nhttps://www.cnblogs.com/fengzheng/p/13431845.html\n\n\n# 类加载机制\n\n\n# 类文件结构\n\n\n\n可用 javap 分析class文件。\n\n\n# 虚拟机类加载机制\n\njava虚拟机把描述类的数据从class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的java类型，这个过程被称作虚拟机的类加载机制。\n\n与那些在编译器需要进行连接的语言不同，在java语言里，类型的加载、连接和初始化都是在程序运行期间完成的。\n\n一个类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期将会经历7个阶段。\n\n\n\n加载、 验证、 准备、 初始化和卸载这五个阶段的顺序是确定的， 类型的加载过程必须按照这种顺序按部就班地开始， 而解析阶段则不一定： 它在某些情况下可以在初始化阶段之后再开始，这是为了支持java语言的运行时绑定特性（也称为动态绑定或晚期绑定） 。\n\n对于什么时候开始类加载过程的第一个阶段“加载”，《java虚拟机规范》没有强制约束。\n\n但对于初始化阶段，则严格规定了有且只有以下六种情况必须对类进行“初始化”（而加载、验证、准备自然需要在此之前开始）：\n\n 1. 遇到 new、getstatic、putstatic、invokestatic这四条字节码指令时。能够生成这四条指令的典型java代码场景有：\n    * 使用new关键字实例化对象时。\n    * 读取或设置一个类型的静态字段（被final修饰、已在编译器把结果放入常量池的静态字段除外）的时候。\n    * 调用一个类型的静态方法时。\n 2. 使用 java.lang.reflect包的方法对类型进行反射调用时。\n 3. 当初始化类时，如果发现其父类还没进行过初始化，则需要先触发其父类的初始化。\n 4. 当虚拟机启动时，用户需要指定一个要执行的主类（包含main()的那个类），虚拟机会先初始化这个类。\n 5. 当使用jdk 7新加入的动态语言支持时， 如果一个java.lang.invoke.methodhandle实例最后的解析结果为ref_getstatic、 ref_putstatic、 ref_invokestatic、 ref_newinvokespecial四种类型的方法句柄， 并且这个方法句柄对应的类没有进行过初始化， 则需要先触发其初始化。\n 6. 当一个接口中定义了jdk 8加入的默认方法（被default修饰的接口方法）。\n\n\n# 类加载的过程\n\n类加载的全过程：加载、验证、准备、解析和初始化五个阶段。\n\n\n# 加载\n\n这里的加载（loading）阶段是指整个类加载（class loading）过程中的一个阶段。\n\n虚拟机需要完成三件事：\n\n 1. 通过一个类的全限定名来获取定义此类的二进制字节流。\n 2. 将这个字节流所代表的静态存储结构转换为方法区的运行时数据结构。\n 3. 在内存中生成一个代表这个类的 java.lang.class对象，作为方法区这个类的各种数据的访问入口。\n\n加载阶段结束后， java虚拟机外部的二进制字节流就按照虚拟机所设定的格式存储在方法区之中了， 方法区中的数据存储格式完全由虚拟机实现自行定义， 《java虚拟机规范》 未规定此区域的具体数据结构。 类型数据妥善安置在方法区之后， 会在java堆内存中实例化一个java.lang.class类的对象，这个对象将作为程序访问方法区中的类型数据的外部接口。\n\n\n# 验证\n\n验证是连接阶段的第一步， 这一阶段的目的是确保class文件的字节流中包含的信息符合《java虚拟机规范》 的全部约束要求， 保证这些信息被当作代码运行后不会危害虚拟机自身的安全。\n\n从整体上看， 验证阶段大致上会完成下面四个阶段的检验动作： 文件格式验证、 元数据验证、 字节码验证和符号引用验证。\n\n\n# 准备\n\n准备阶段是正式为类中定义的变量（即静态变量， 被static修饰的变量） 分配内存并设置类变量初始值的阶段。\n\n这时候进行内存分配的仅包括类变量， 而不包括实例变量， 实例变量将会在对象实例化时随着对象一起分配在java堆中。\n\n\n# 解析\n\n解析阶段是java虚拟机将常量池内的符号引用替换为直接引用的过程。\n\n * 符号引用（symbolic references） ： 符号引用以一组符号来描述所引用的目标， 符号可以是任何形式的字面量， 只要使用时能无歧义地定位到目标即可。 符号引用与虚拟机实现的内存布局无关， 引用的目标并不一定是已经加载到虚拟机内存当中的内容。 各种虚拟机实现的内存布局可以各不相同，但是它们能接受的符号引用必须都是一致的， 因为符号引用的字面量形式明确定义在《java虚拟机规范》 的class文件格式中。eg：在class文件中 constant_class_info、constant_fieldref_info、 constant_methodref_info等类型的常量出现。\n * 直接引用（direct references） ： 直接引用是可以直接指向目标的指针、 相对偏移量或者是一个能间接定位到目标的句柄。 直接引用是和虚拟机实现的内存布局直接相关的， 同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不会相同。 如果有了直接引用， 那引用的目标必定已经在虚拟机的内存中存在。\n\n解析动作主要针对类或接口、 字段、 类方法、 接口方法、 方法类型、 方法句柄和调用点限定符这7类符号引用进行， 分别对应于常量池的constant_class_info、 con-stant_fieldref_info、constant_methodref_info、 constant_interfacemethodref_info、constant_methodtype_info、 constant_methodhandle_info、 constant_dyna-mic_info和constant_invokedynamic_info 8种常量类型。\n\n\n# 初始化\n\n在之前类加载动作中，除了在加载阶段应用程序可以通过自定义类加载器的方式局部参与外，其余动作都完全由java虚拟机来主导控制。直到初始化阶段，java虚拟机才真正可是执行类中编写的java程序代码，将主导权交给应用程序。\n\n进行准备阶段时， 变量已经赋过一次系统要求的初始零值， 而在初始化阶段， 则会根据程序员通过程序编码制定的主观计划去初始化类变量和其他资源。 我们也可以从另外一种更直接的形式来表达： 初始化阶段就是执行类构造器<clinit>()方法的过程。 <clinit>()并不是程序员在java代码中直接编写的方法， 它是javac编译器的自动生成物。\n\n\n# 类加载器\n\njava虚拟机设计团队有意把类加载阶段中的“通过一个类的全限定名来获取描述该类的二进制字节流”这个动作放到java虚拟机外部去实现， 以便让应用程序自己决定如何去获取所需的类。 实现这个动作的代码被称为“类加载器”（class loader） 。\n\n对于任意一个类，都必须由加载它的类加载器和这个类本身一起共同确立其在java虚拟机中的唯一性。\n\n每一个类加载器，都拥有一个独立的类名词空间。\n\n比较两个类是否“相等”，只有在这两个类是由同一个类加载器加载的前提下才有意义。否则，即使这两个类来源于同一个class文件，被同一个java虚拟机加载，只要加载它们的类加载器不同，那这两个类就必定不相等。\n\n这里所指的“相等”， 包括代表类的class对象的equals()方法、 isassignablefrom()方法、 isinstance()方法的返回结果， 也包括了使用instanceof关键字做对象所属关系判定等各种情况。\n\n从java虚拟机的角度来看，只存在两种不同的类加载器：\n\n 1. 启动类加载器（bootstrap classloader）：这个类加载器是使用c++实现的，是虚拟机自身的一部分。\n 2. 其他所有的类加载器，这些类加载器都由java实现的，独立于虚拟机外部，并且全部继承自抽象类 java.lang.classloader\n\n自jdk 1.2以来，java一直保持着三层类加载器、双亲委派的类加载架构。（在java模块化后有一些调整，但主体结构没变）。\n\n\n# 三层类加载器\n\njdk 9 之前：\n\n绝大多数java程序都会使用到以下3个系统提供的类加载器来进行加载。\n\n 1. 启动类加载器 bootstrap class loader：负责加载存放在 <java_home>\\lib目录，或被 -xbootclasspath参数所指定的路径中存放的，并且是java虚拟机能识别的类库加载到虚拟机的内存中。（eg：rt.jar、tools.jar）\n 2. 扩展类加载器 extension class loader：负责加载 <java_home>\\lib\\ext目录，或被 java.ext.dirs系统变量所指定的路径中所有的类库。\n 3. 应用程序类加载器/系统类加载器 application class loader：负责加载用户类路径（classpath）上所有的类库。如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。\n\n如果有需要，还可以自定义类加载器。eg：增加除了磁盘位置之外的class文件来源， 或者通过类加载器实现类的隔离、 重载等功能。\n\n\n# 双亲委派模型（parents delegation model）\n\n各种类加载器支给件的层次关系就被称为类加载器的双亲委派模型。\n\n双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应有自己的父类加载器。不过这里类加载器之间的父子关系一般不是继承（inheritance）的关系来实现的，而是使用组合（composition）关系来复用父类加载器的代码。\n\n**双亲委派模型的工作过程是：**如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到最顶层的启动类加载器中，只有当父类加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去完成加载。\n\n使用双亲委派模型来组织类加载器之间的关系， 一个显而易见的好处就是java中的类随着它的类加载器一起具备了一种带有优先级的层次关系。 例如类java.lang.object， 它存放在rt.jar之中， 无论哪一个类加载器要加载这个类， 最终都是委派给处于模型最顶端的启动类加载器进行加载， 因此object类在程序的各种类加载器环境中都能够保证是同一个类。\n\n双亲委派模型的实现：\n\n//java.lang.classloader的loadclass()\nprotected synchronized class<?> loadclass(string name, boolean resolve) throws classnotfoundexception\n{\n// 首先， 检查请求的类是否已经被加载过了\nclass c = findloadedclass(name);\nif (c == null) {\ntry {\nif (parent != null) {\nc = parent.loadclass(name, false);\n} else {\nc = findbootstrapclassornull(name);\n}}\ncatch (classnotfoundexception e) {\n// 如果父类加载器抛出classnotfoundexception\n// 说明父类加载器无法完成加载请求\n}i\nf (c == null) {\n// 在父类加载器无法加载时\n// 再调用本身的findclass方法来进行类加载\nc = findclass(name);\n}\n}i\nf (resolve) {\nresolveclass(c);\n}return c;\n}\n\n\n先检查请求加载的类型是否已经被加载过， 若没有则调用父加载器的loadclass()方法， 若父加载器为空则默认使用启动类加载器作为父加载器。 假如父类加载器加载失败， 抛出classnotfoundexception异常的话， 才调用自己的findclass()方法尝试进行加载。\n\n\n# java模块化系统\n\njdk 9 中引入了java模块化系统（java platform module system, jpms）。\n\n（模块化到底怎么样，没看懂）\n\n为了保证兼容性， jdk 9并没有从根本上动摇从jdk 1.2以来运行了二十年之久的三层类加载器架构以及双亲委派模型。 但是为了模块化系统的顺利施行， 模块化下的类加载器仍然发生了一些应该被注意到变动， 主要包括以下几个方面：\n\n 1. 扩展类加载器（extension class loader） 被平台类加载器（platform class loader） 取代。\n 2. jdk 9中虽然仍然维持着三层类加载器和双亲委派的架构， 但类加载的委派关系也发生了变动。 当平台及应用程序类加载器收到类加载请求， 在委派给父加载器加载前， 要先判断该类是否能够归属到某一个系统模块中， 如果可以找到这样的归属关系， 就要优先委派给负责那个模块的加载器完成加载。\n\n在java模块化系统明确的规定了三个类加载器负责各自加载的模块。\n\n\n\n\n# java内存模型\n\n\n# 硬件的效率与一致性\n\n\n\n基于告诉缓存的存储交互很好的解决了处理器与内存速度之间的矛盾，但带来了一个新问题：缓存一致性（cache coherence）。为了解决一致性问题，需要各个处理器访问缓存时都遵循一些协议。这类协议有：msi、mesi、mosi。。。\n\njava虚拟机也有自己的内存模型，并且和这里的内存访问操作及硬件的缓存操作觉有高度的可类比性。\n\n\n# java内存模型\n\njava memory model，jmm\n\n\n\n这里的主内存、工作内存与java内存区域中的java堆、栈、方法区等不是一个概念，没有关系。\n\n * java内存模型规定了所有的变量都存储在主内存中。\n\n * 每条线程还有自己的工作内存，线程中的工作内存中保存了被该线程使用的变量的主内存副本，线程对变量的所有操作（读取、赋值等）都必须在工作内存中进行，而不能直接读写主内存中的数据。\n\n * 不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量值的传递均需要通过主内存来完成。\n\n这里说的变量与java编程中的变量有所区别，它包括了实例字段、静态字段和构成数组对象的元素，但是不包括局部变量与方法参数，因为是线程私有的，不会被共享，不会存在竞争问题。\n\n对于主内存和工作内存之间的交互协议，java内存模型中定义了8种操作来完成，java虚拟机实现时必须保证这8种操作每一个都是原子的。后来，简化为 read, write, lock, unlock 四种。\n\nvolatile 可以说是java虚拟机提供的最轻量级的同步机制。当一个变量被定为成 volatile 之后，它将具备两个特性：\n\n 1. 保证变量对所有线程的可见性。（并不保证原子性，即使编译出来只有一条字节码指令，也不意味着这条指令就是一个原子操作）\n 2. 禁止指令重排序优化。\n\n大多数情况下 volatile 的总开下比锁要低，因此我们在 volatile 与锁的选择中，唯一判断依据便是 volatile的语义能否满足使用场景的需求。\n\n对于 volatile 变量的特殊规则：\n\n * 在工作内存中，每次使用前都必须先从主内存刷新最新的值，保证能看起其他线程对变量所做的修改。\n * 在工作内存中，每次修改后都必须立刻同步回主内存中，保证其他线程可以看到自己对变量的修改。\n * 修饰的变量不会被指令重排序优化，从而保证代码的执行顺序与程序的顺序相同。\n\n原子性：\n\n尽管虚拟机未把 lock 和 unlock 操作直接开放给用户使用，但是却提供了更高层次的字节码指令 monitorenter 和 monitorexit 来隐式的使用这两个操作。这两个字节码指令反映到java代码中就是同步快synchronized关键字。\n\n可见性：\n\n除了 volatile 之外，java还有两个关键字可以实现可见性，synchronized 和 final。\n\nfinal 的可见性是指：被final修饰的字段在构造器中一旦被初始化完成，并且构造没有把 this 的引用传递出去，那么在其他线程中就能看见 final 字段的值。\n\n有序性：\n\n如果在本线程内观察，所有操作都是有序的。\n\n如果在一个线程观察另一个线程，所有的操作都是无序的。\n\n\n# 先行发生（happens-before）原则\n\n如果java 内存模型中所有的有序性都只靠 volatile 和 synchronized 来完成，那么很多操作将会变得非常啰嗦。\n\n而java通过先行发生（happens-before）原则，对数据是否存在竞争，线程是否安全进行了判断。\n\n先行发生是指：java内存模型中定义的两项操作之间的偏序关系，如果操作a先行发生与操作b，那就是说在发送操作b之前，操作a产生的影响能被操作b观察到。影响包括修改了内存中共享变量的值、发送了消息、调用了方法等。\n\n以下是java内存模型中的先行发生关系：（如果两个操作之间的关系不在此列， 无法从下列规则推导出来， 则它们就没有顺序性保障， 虚拟机可以对它们随意地进行重排序。）\n\n * 程序次序规则 program order rule：在一个线程内，按照控制流程顺序，书写在前面的操作先行发生与书写在后面的操作\n * 管程锁定规则 monitor lock rule：一个unlock 操作先行发生与后面对同一个锁的lock操作。\n * 线程启动规则 thread start rule：thread对象的start()方法先行发生与此线程的每一个动作。\n * 线程终止规则 thead termination rule：线程中的所有操作都先行发生于对此线程的终止检测，可以通过 thread::jion() 方法是否结束、thread::isalive()的返回值等手段检测线程是否已经终止执行。\n * 线程中断规则 thread interruption rule：对线程interrput()方法的调用先行发生于被中断线程的代码检测到众中断事件的发生，可以通过 thread::interrupted()方法检测到是否有中断发生。\n * 对象终结规则 finalize rule：一个对象的初始化完成（构造函数执行结束）先行发生于它的finalize()方法的开始。\n * 传递性 transitivity：如果操作a先行发生与操作b，操作b先行发生与操作c，那么操作a先行发生于操作c。\n\n\n# java 与线程\n\n线程是比进程更轻量级的调度执行单位，引入了线程，可以把一个进程的资源分配和执行调度分开，各个线程既可以共享进程资源（内存地址、文件i/o等），又可以独立调度。\n\n目前线程是java进行处理器资源调度的最基本单位。\n\n主流java虚拟机的线程模型都是基于操作系统原生线程模型来实现的，即采用1：1线程模型。\n\n阻塞和等待的区别：\n\n * 阻塞：在等待获取一个排他锁，这个事件将在另一个线程放弃这个锁的时候发生\n * 等待：则是在等待一段时间，或者唤醒动作的发生。\n\n\n\n\n# java 与协程【不是很理解】\n\n1： 1的内核线程模型是如今java虚拟机线程实现的主流选择， 但是这种映射到操作系统上的线程天然的缺陷是切换、 调度成本高昂， 系统能容纳的线程数量也很有限。\n\n传统的java web服务器的线程池的容量通常在几十个到两百之间， 当程序员把数以百万计的请求往线程池里面灌时， 系统即使能处理得过来， 但其中的切换损耗也是相当可观的。\n\n内核线程的调度成本主要来自于用户态与核心态之间的状态转换， 而这两种状态转换的开销主要来自于响应中断、 保护和恢复执行现场的成本。\n\n后来， 操作系统开始提供多线程的支持， 靠应用自己模拟多线程的做法自然是变少了许多， 但也并没有完全消失， 而是演化为用户线程继续存在。 由于最初多数的用户线程是被设计成协同式调度（cooperative scheduling） 的， 所以它有了一个别名——“协程”（coroutine） 。 又由于这时候的协程会完整地做调用栈的保护、 恢复工作， 所以今天也被称为“有栈协程”（stackfull coroutine） ， 起这样的名字是为了便于跟后来的“无栈协程”（stackless coroutine） 区分开。 无栈协程不是本节的主角， 不过还是可以简单提一下它的典型应用， 即各种语言中的await、 async、 yield这类关键字。 无栈协程本质上是一种有限状态机， 状态保存在闭包里， 自然比有栈协程恢复调用栈要轻量得多， 但功能也相对更有限。\n\n对于有栈协程， 有一种特例实现名为纤程（fiber）\n\n\n# 线程安全\n\n线程安全的实现方法：\n\n\n# 互斥同步（阻塞同步）\n\n互斥是手段，同步是目的。\n\n临界区（critical section）、互斥量（mutex）、信号量（semaphore）都是常见的互斥实现方法。\n\n在java中，最基本的互斥同步手段就是 synchronized ，这是一种块结构（block structured）的同步语法。\n\nsynchronized 经过javac 编译后，会在同步块前后分别形成 monitorenter 和monitorexit两个字节码指令。这两个字节码指令都需要一个reference类型的参数来指明要锁定和解锁的对象。如果代码中synchronized明确指明了对象参数，那就以这个对象的引用作为reference（即获得的是你传入的，传入对象就是对象锁【this也是对象锁】，传入类就是类锁），如果没有明确指定，将根据synchronized修饰的方法类型（实例方法还是类方法），来决定是获取对象实例还是类型对应的class对象来作为线程要持有的锁（即修饰实例方法获取的是对象锁，修饰静态方法获取的是类锁）。\n\n被 synchronized 修饰的同步块对同一条线程来说是可重入的。这意味着同一线程反复进入同步块也不会出现把自己锁死的情况。\n\n被 synchronized 修饰的同步块在持有锁的线程执行完毕并释放锁之前，会无条件的阻塞后面其他线程的进入。\n\njdk 5起，java提供了java.util.concurrent包（j.u.t包），其中java.util.concurrent.locks.lock接口便成了java的另一种全新的互斥同步手段。基于lock接口，用户能够以非块结构（non-block structured）来实现互斥同步，从而摆脱语言特性的束缚，在类库层面去实现同步。\n\n重入锁（reentrantlock）是lock接口最常见的一种实现。在基本用法上，reentrantlock 和 synchronized相似，只是写法稍微不同，且 reentrantlock 比 synchronized 多了一些高级功能，主要有3项：\n\n 1. 等待可中断\n 2. 可实现公平锁\n 3. 可绑定多个条件\n\njdk 6 开始对synchronized进行了锁优化，reentrantlock 和 synchronized 的性能基本能持平，因此性能已不再是选择 reentrantlock 或 synchronized 的判断因素。\n\n推荐在 synchronized 和 reentrantlock 都能满足的场景优先使用 synchronized，原因如下：\n\n * synchronized 足够清晰，简单。\n * lock要确保在finally中释放锁。synchronized由java虚拟机来保证。\n * 从长远看，java虚拟机更容易针对synchronized进行优化。因为java虚拟机通过在线程和对象的元数据中记录synchronized中锁的相关信息，使用lock的话，java虚拟机很难得知具体哪些锁对象是由特定线程所持有的。\n\n\n# 非阻塞同步\n\n互斥同步面临的主要问题是进行线程阻塞和唤醒锁带来的性能开销，因此这种同步也被称为阻塞同步（blocking synchronization），属于悲观的并发策略。\n\n非阻塞同步（non-blocking synchronization）是基于冲突检测的乐观并发策略，冲突了再进行补偿，最常用的补偿措施是不断重试，直到没有竞争的共享数据位置。也称为无锁（lock-free）编程。\n\n乐观并发策略需要依赖硬件指令集的发展，因为要保证操作和冲突检测这两个步骤具备原子性。\n\n这类指令通常用：\n\n * 测试并设置（test and set）\n * 获取并增加（fetch and increment）\n * 交换（swap）\n * 比较并交换（compare and swap，cas）\n * 加载链接/条件存储（load linked/store conditional，ll/sc）\n\njava里最终暴露出来的是cas操作，cas指令需要有3个操作数，分别是变量的内存地址v，旧的预期值a，准备设置的新值b。cas指令执行时，当且仅当v符合a时，处理器才会用b更新v的值，否则不执行更新。但无论是否执行更新，都会返回v的旧值。\n\n在jdk 5之后， java类库中才开始使用cas操作， 该操作由sun.misc.unsafe类里面的compareandswapint()和compareandswaplong()等几个方法包装提供。 hotspot虚拟机在内部对这些方法做了特殊处理， 即时编译出来的结果就是一条平台相关的处理器cas指令， 没有方法调用的过程。 不过由于unsafe类在设计上就不是提供给用户程序调用的类（unsafe::getunsafe()的代码中限制了只有启动类加载器（bootstrap classloader） 加载的class才能访问它） ， 因此在jdk 9之前只有java类库可以使用cas， 譬如j.u.c包里面的整数原子类， 其中的compareandset()和getandincrement()等方法都使用了unsafe类的cas操作来实现。 而如果用户程序也有使用cas操作的需求， 那要么就采用反射手段突破unsafe的访问限制， 要么就只能通过java类库api来间接使用它。 直到jdk 9之后， java类库才在varhandle类里开放了面向用户程序使用的cas操作。\n\n为了解决cas的aba问题，j.u.c包提供了一个带有标记的原子引用类atomicstampedreference，它可以通过控制变量值的版本来保证cas的正确性。不管目前这个类相当鸡肋，大部分情况下aba问题不会影响程序并发的正确性，如果需要解决aba问题，采用传统的互斥同步可能会比原子类更高效。\n\n\n# 无同步方案\n\n线程本地存储（thread local storage）：如果一段代码中所需要的数据必须与其他代码共享，那就看看这些共享数据的代码能否保证只在同一个线程中执行。如果能保证，就可以把共享数据的可见范围限制在同一个线程之内，这样无须同步也能保证线程之间不出现数据竞争的问题。\n\n符合这种特点的应用并不少见，大部分使用消费队列的架构模式（eg：生产者-消费者模式）都会将产品的消费过程限制在一个线程中消费完，其中最重要的一种应用实例就是经典web交互模型中的“一个请求对应一个服务器线程”（thread-pre-request）的处理方式，这种处理方式的广泛应用使得很多web服务端应用都可以使用线程本地存储来解决线程安全问题。\n\njava中，如果一个变量要被多线程访问，可以使用 volatile将其声明为“易变的”。如果一个变量只要被某个线程独享，可以通过 java.lang.threadlocal类来实现线程本地存储的功能。每一个线程的thread对象中都有一个threadlocalmap对象，这个对象存储了一组以threadlocal.threadlocalhashcode为键，以本地线程变量为值的键值对，threadlocal对象就是当前线程的threadlocalmap的访问入口，每一个threadlocal对象都包含了一个独一无二的threadlocalhashcode，这个值就可以在线程键值对中找到对应的本地线程变量。\n\n\n# 锁优化\n\njdk 6，虚拟机团队锁进行了多种优化，有：\n\n * 适应性自旋 adaptive spinning\n * 锁消除 lock elimination\n * 锁膨胀 lock coarsening\n * 轻量级锁 lightweight locking\n * 偏向锁 biased locking\n\n\n# 自旋锁与自适应自旋\n\n互斥同步对性能最大的影响是阻塞的实现， 挂起线程和恢复线程的操作都需要转入内核态中完成， 这些操作给java虚拟机的并发性能带来了很大的压力。 同时， 我们注意到在许多应用上， 共享数据的锁定状态只会持续很短的一段时间， 为了这段时间去挂起和恢复线程并不值得。如果物理机器有一个以上的处理器或者处理器核心， 能让两个或以上的线程同时并行执行， 我们 就可以让后面请求锁的那个线程“稍等一会”， 但不放弃处理器的执行时间， 看看持有锁的线程是否很快就会释放锁。 为了让线程等待， 我们只须让线程执行一个忙循环（自旋） ， 这项技术就是所谓的自旋锁。\n\n自旋锁在1.4.2中就引进了，不过默认是关闭的。jdk 6开始改为默认开启。默认自旋10次。\n\njdk 6 对自旋锁的优化，引入了自适应的自旋。自适应自旋意味着自旋次数不再是固定的了，由前一次在同一个锁上的自旋时间以及锁的拥有者的状态决定。如果同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也很有可能再次成功，进而允许自旋等待持续更长的时间。如果队友某个锁，自旋很少成功获得过锁，那以后要获取这个锁将可能直接省略自旋过程。\n\n\n# 锁消除\n\n锁消除是指虚拟机即时编译器在运行时，对一些代码要求同步，但是对被检测到不可能存在共享数据竞争的锁进行消除。\n\n锁消除的主要判断依据来源于逃逸分析的数据支持。\n\n如果判断到一段代码，在堆上的所有数据都不会逃逸出去被其他线程访问到，那就可以把他们当做栈上数据对待，认为他们是线程私有的，同步加锁自然就不用再进行了。\n\n\n# 锁粗化\n\n如果虚拟机检测到有一串零碎的操作都对同一个对象加锁，就会把加锁同步的范围粗化到整个操作序列的外部。\n\n\n# 轻量级锁\n\n轻量级锁并不是来替代重量级锁的，它的设计初衷是在没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量的性能消耗。\n\n\n\n在代码即将进入同步块时，如果此同步对象没有被锁定（锁标志位为“01”状态），虚拟机首先将在当前线程的栈帧中简历一个名为锁记录（lock record）的空间，用于存储锁对象目前的mark word的拷贝。\n\n然后虚拟机将使用 cas操作尝试把对象的mark word更新为指向lock record 的指针。\n\n如果更新动作成功了，代表该线程拥有了这个对象的锁，并且对象mark word的锁标志位（mark word的最后两个比特）将变为“00”，表示此对象正处于轻量级锁定状态。\n\n如果更新操作失败了，意味着有线程与当前线程竞争该对象的锁。虚拟机首先会检查对象的mark word是否指向当前线程的栈帧，如果是，说明当前线程已经拥有了这个对象的锁，直接进入同步块。否则说明这个锁对象给其他线程抢占了，此时轻量级锁升级为重量级锁，锁标志位状态变为“10”。\n\n轻量级锁能提升程序同步性能的依据是“对于绝大部分的锁，在整个同步周期内都是不存在竞争的”。如果没有竞争，轻量级锁便通过cas操作成功避免了使用互斥量的开销。但如果确实存在锁竞争，除了互斥量本身的开销外，还额外发生了cas的开销。因此在有竞争的情况下，轻量级锁反而会比传统的重量级锁更慢。\n\n\n# 偏向锁\n\n偏向锁的目的是消除数据在无竞争情况下的同步原语。如果说轻量级锁是在无竞争的情况下使用cas操作去消除同步使用的互斥量，那偏向锁就是在无竞争情况下把整个同步都消除掉，连cas操作都不做。\n\n这个锁会偏向于第一个获得它的线程，如果在接下来的执行过程中，该锁一直没有被其他的线程获取，则持有偏向锁的线程将永远不需要再进行同步。\n\n偏向锁默认是开启的。当锁对象第一次被线程获取时，虚拟机会把对象头中的标志位设置为“01”、把偏向模式设置为1，表示进入偏向模式。同时使用cas操作把获取到这个锁的线程id记录在对象的mark word中。果cas操作成功， 持有偏向锁的线程以后每次进入这个锁相关的同步块时， 虚拟机都可以不再进行任何同步操作（例如加锁、 解锁及对mark word的更新操作等）。\n\n一旦出现另外一个线程去尝试获取这个锁的情况， 偏向模式就马上宣告结束。 根据锁对象目前是否处于被锁定的状态决定是否撤销偏向（偏向模式设置为“0”） ， 撤销后标志位恢复到未锁定（标志位为“01”） 或轻量级锁定（标志位为“00”） 的状态， 后续的同步操作就按照上面介绍的轻量级锁那样去执行。\n\n\n\n如果程序中大多数的锁都总是被多个不同的线程访问，那么偏向模式就是多余的。有时使用参数 -xx:-usebisedlocking=false来禁止偏向锁优化反而可以提升性能。\n\n（jdk 15 废弃偏向锁）',charsets:{cjk:!0}},{title:"synchronized和volatile",frontmatter:{title:"synchronized和volatile",date:"2023-03-28T18:31:38.000Z",permalink:"/pages/concurrent/"},regularPath:"/01.Java/04.Java%E5%B9%B6%E5%8F%91/01.synchronized%E5%92%8Cvolatile.html",relativePath:"01.Java/04.Java并发/01.synchronized和volatile.md",key:"v-99d6e044",path:"/pages/concurrent/",headers:[{level:2,title:"synchronized的理解",slug:"synchronized的理解",normalizedTitle:"synchronized的理解",charIndex:2},{level:2,title:"synchronized的使用",slug:"synchronized的使用",normalizedTitle:"synchronized的使用",charIndex:435},{level:3,title:"双重校验锁实现单例模式",slug:"双重校验锁实现单例模式",normalizedTitle:"双重校验锁实现单例模式",charIndex:1191},{level:2,title:"synchronized 关键字底层原理",slug:"synchronized-关键字底层原理",normalizedTitle:"synchronized 关键字底层原理",charIndex:1925},{level:3,title:"synchronized 同步语句块的底层实现",slug:"synchronized-同步语句块的底层实现",normalizedTitle:"synchronized 同步语句块的底层实现",charIndex:2022},{level:3,title:"synchronized 修饰方法的底层实现",slug:"synchronized-修饰方法的底层实现",normalizedTitle:"synchronized 修饰方法的底层实现",charIndex:2409},{level:2,title:"synchronized 锁升级",slug:"synchronized-锁升级",normalizedTitle:"synchronized 锁升级",charIndex:3043},{level:2,title:"volatile",slug:"volatile",normalizedTitle:"volatile",charIndex:1272},{level:3,title:"如何实现可见性",slug:"如何实现可见性",normalizedTitle:"如何实现可见性",charIndex:4349},{level:3,title:"为什么不能实现原子性",slug:"为什么不能实现原子性",normalizedTitle:"为什么不能实现原子性",charIndex:4842},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:5314}],headersStr:"synchronized的理解 synchronized的使用 双重校验锁实现单例模式 synchronized 关键字底层原理 synchronized 同步语句块的底层实现 synchronized 修饰方法的底层实现 synchronized 锁升级 volatile 如何实现可见性 为什么不能实现原子性 参考",content:"# synchronized的理解\n\nsynchronized关键字解决的是多个线程之间访问资源的同步性，synchronized 关键字可以保证被它修饰的方法或者代码块在任意时刻只能有一个线程执行。\n\n在 Java 早期版本中，synchronized 属于重量级锁，效率低下，因为监视器锁（monitor）是依赖于底层的操作系统的 Mutex Lock 来实现的，Java 的线程是映射到操作系统的原生线程之上的。如果要挂起或者唤醒一个线程，都需要操作系统帮忙完成，而操作系统实现线程之间的切换时需要从用户态转换到内核态，这个状态之间的转换需要相对比较长的时间，时间成本相对较高。\n\n在 JDK6 之后 Java 官方对从 JVM 层面对synchronized 较大优化，所以现在的 synchronized 锁效率也优化得很不错了。JDK6 对锁的实现引入了大量的优化，如自旋锁、适应性自旋锁、锁消除、锁粗化、偏向锁、轻量级锁等技术来减少锁操作的开销。\n\n\n# synchronized的使用\n\n根据修饰对象的分类：\n\n * 修饰代码块\n   * synchronized(this|object)\n   * synchronized(类.class)\n * 修饰方法\n   * 修饰非静态方法\n   * 修饰静态方法\n\n根据获取的锁来分类：\n\n * 获取对象锁\n   * synchronized(this|object)\n   * 修改非静态方法\n * 获取类锁\n   * synchronized(类.class)\n   * 修饰静态方法\n\n1、 修饰实例方法：作用于当前对象实例加锁，进入同步代码前要获得当前对象实例的锁；\n\n2、修饰静态方法：作用于当前类对象加锁，进入同步代码前要获得当前类对象的锁 。也就是给当前类加锁，会作用于类的所有对象实例，因为静态成员不属于任何一个实例对象，是类成员。所以如果一个线程 A 调用一个实例对象的非静态 synchronized 方法，而线程 B 需要调用这个实例对象所属类的静态 synchronized 方法，是允许的，不会发生互斥现象，因为访问静态 synchronized 方法占用的锁是当前类的锁，而访问非静态 synchronized 方法占用的锁是当前实例对象锁；\n\n3、 修饰代码块：指定加锁对象，对给定对象加锁，进入同步代码库前要获得给定对象的锁。和 synchronized 方法一样，synchronized(this) 代码块也是锁定当前对象的。synchronized 关键字加到 static 静态方法和 synchronized(class) 代码块上都是是给 Class 类上锁。尽量不要使用 synchronized(String a) 因为 JVM 中，字符串常量池具有缓冲功能。\n\n\n# 双重校验锁实现单例模式\n\n使用 synchronized 双重校验锁的方法实现单例模式：\n\npublic class Singleton {\n  private volatile static Singleton instance;\n  private Singleton(){}\n  public static Singleton getInstance() {\n    if (instance == null) {\n      synchronized(Singleton.class) {\n        if (instance == null) instance = new Singleton();\n      }\n    }\n    return instance;\n  }\n}\n\n\n另外，需要注意 instance 采用 volatile 关键字修饰也是很有必要。 因为 instance = new Singleton(); 这段代码其实是分为三步执行：\n\n 1. 为 instance 分配内存空间\n 2. 初始化 instance\n 3. 将 instance 指向分配的内存地址\n\n但是由于 JVM 具有指令重排的特性，执行顺序有可能变成 1 -> 3 -> 2。指令重排在单线程环境下不会出现问题，但是在多线程环境下会导致一个线程获得还没有初始化的实例。例如，线程 T1 执行了 1 和 3，此时 T2 调用 getInstance() 后发现 instance 不为空，因此返回 instance，但此时 instance 还未被初始化。\n\n使用 volatile 可以禁止 JVM 的指令重排，保证在多线程环境下也能正常运行。\n\n\n# synchronized 关键字底层原理\n\nsynchronized 关键字底层原理属于 JVM 层面。\n\nsynchronized 使用的锁对象是存储在Java对象头里的标记字段里。\n\n\n# synchronized 同步语句块的底层实现\n\nsynchronized 同步语句块的实现使用的是 monitorenter 和 monitorexit 指令，其中 monitorenter 指令指向同步代码块的开始位置，monitorexit 指令则指明同步代码块的结束位置。\n\n当执行 monitorenter 指令时，线程试图获取锁也就是获取 monitor的持有权。monitor 对象存在于每个 Java 对象的对象头中，synchronized 锁便是通过这种方式获取锁的，也是为什么 Java 中任意对象可以作为锁的原因。当计数器为 0 则可以成功获取，获取后将锁计数器设为 1 也就是加 1。相应的在执行 monitorexit 指令后，将锁计数器设为 0，表明锁被释放。如果获取对象锁失败，那当前线程就要阻塞等待，直到锁被另外一个线程释放为止。\n\n\n# synchronized 修饰方法的底层实现\n\nsynchronized 修饰的方法并没有 monitorenter 指令和 monitorexit 指令，取得代之的确实是 ACC_SYNCHRONIZED 标识，该标识指明了该方法是一个同步方法，JVM 通过该 ACC_SYNCHRONIZED 访问标志来辨别一个方法是否声明为同步方法，从而执行相应的同步调用。\n\n * ACC_SYNCHRONIZED标志表示方法为同步方法\n * 无 ACC_STATIC标志 为普通同步方法\n * 有 ACC_STATIC标志 为静态同步方法\n\n在java中，synchronized在编译后，会在同步块的前后分别形成一个monitorenter和monitorexit这两个字节码指令，这两个字节码都需要一个reference类型的参数来指明要锁定和解锁的对象，如果java程序中明确指定了对象，那就是这个对象的reference，如果没有指明，那么根据synchronized修饰的是实例方法还是类方法，去取对应的对象实例或者类Class对象来做锁对象。\n\n在执行monitorenter时，首先会尝试获取对象的锁，如果这个对象没有锁，或者当前线程已经拥有了这个对象的锁，那个锁的计数器加1，相应的，在执行monitorexit时指令时，会将锁计数器减1，当计数器为0时，这个锁就被释放。如果获取对象锁失败，那当前线程就要阻塞等待，直到对象锁被另一个线程释放为止。\n\n\n# synchronized 锁升级\n\n锁升级的过程：\n\n 1. 一开始是处于无锁状态的\n\n 2. 当有一个线程访问同步代码块时，升级成偏向锁（Mark Word 里存储锁偏向的线程 ID ，在线程进入和退出同步块时不再通过 CAS 操作来加锁和解锁，而是检测 Mark Word 里是否存储着指向当前线程的偏向锁）\n\n 3. 有锁竞争时，升级为轻量级锁，自旋获取锁\n\n 4. 自旋十次失败后，升级成重量级锁（线程阻塞）\n\n锁的对比：\n\n锁      优点                                 缺点                         适用场景\n偏向锁    加锁和解锁不需要额外的消耗，和执行非同步方法相比仅有纳秒级的差距   如果线程间存在锁竞争，会带来额外的锁撤销的消耗    适用于只有一个线程访问同步块的场景\n轻量级锁   竞争的线程不会阻塞，提高了程序的响应速度               如果竞争的线程始终得不到锁，是用自旋会消耗CPU   追求响应速度，痛不哭执行速度非常快\n重量级锁   线程竞争不使用自旋，不会消耗CPU                  线程阻塞，响应时间缓慢                追求吞吐量，同步快执行速度较慢\n\nhttps://zhuanlan.zhihu.com/p/482639650\n\n\n# volatile\n\nvolatile是Java虚拟机系统的轻量级同步机制。\n\n其特点有：\n\n * 保证可见性\n * 不保证原子性\n * 禁止指令重排序。\n   * 避免了多线程环境下程序出现乱序执行的现象。\n   * 指令重排只会保证串行语义的执行的一致性（单线程），但并不关心多线程间的语义一致性。\n   * 对 volatile 变量的读和写操作会在指令序列中插入内存屏障，保证了volatile变量的读写操作不会被指令重排序所影响。\n\n内存屏障（Memory Barrier）是一个 CPU 指令，作用有两个：\n\n 1. 保证特定操作的执行顺序\n 2. 保证某些变量的内存可见性（利用该特性实现 volatile 的可见性）\n\n应用场景：\n\n单例模式下DCL不一定线程安全，由于指令重排，所以程序有小概率会出现 instance != null，但 instance 的引用对象可能还没完成初始化。所以当一个线程访问 instance != null时，instance未必已经初始化完成，造成了线程安全问题。\n\n因为 instance = new Singleton();可以为被分为三步：\n\nmemory = allocate();// 1. 分配对象内存空间\ninstance(memory); // 2.初始化对象\ninstance = memory; // 3. 设置 instance 执行刚分配的内存地址，此时 instance != null\n\n\n解决方案可以在实例上加上 volatile：private static volatile Singleton instance = null;\n\n\n# 如何实现可见性\n\nvolatile 关键字可以保证可见性的原因是，它会告诉 Java 编译器和运行时系统，每次读取该变量时都必须从主内存中重新获取最新的值，而不是使用本地缓存的副本。\n\n具体来说，当一个线程修改一个 volatile 变量的值时，这个值会立即被写回到主内存中，而不是被缓存在该线程的本地缓存中。同时，当其他线程需要读取这个变量的值时，它们也会从主内存中获取最新的值，而不是从本地缓存中获取旧值。\n\n这种强制刷新内存的行为确保了变量的可见性，即使有多个线程同时对变量进行读取和修改，也能够看到最新的值。\n\nvolatile 变量的内存可见性是基于内存屏障(Memory Barrier)实现:\n\n * 内存屏障，又称内存栅栏，是一个 CPU 指令。\n * 在程序运行时，为了提高执行性能，编译器和处理器会对指令进行重排序，JMM 为了保证在不同的编译器和 CPU 上有相同的结果，通过插入特定类型的内存屏障来禁止+ 特定类型的编译器重排序和处理器重排序，插入一条内存屏障会告诉编译器和 CPU：不管什么指令都不能和这条 Memory Barrier 指令重排序。\n\n\n# 为什么不能实现原子性\n\n（因为只保证可见性的情况下，是无法实现原子性的。。。所以不能实现原子性）\n\nvolatile 关键字不能保证原子性的原因是，它只是保证变量的读写操作对所有线程的可见性，但并不能保证在多个线程同时访问同一个变量时，操作的顺序和正确性。\n\n例如，在一个多线程程序中，如果有两个线程同时对一个 volatile 变量进行自增操作\n\nvolatile int count = 0;\n\npublic void increment() {\n    count++;\n}\n\n\n那么可能会发生以下情况：\n\n 1. 线程 A 从内存中读取变量值为 0。\n 2. 线程 B 从内存中读取变量值为 0。\n 3. 线程 A 将变量值加 1 得到 1。\n 4. 线程 B 将变量值加 1 得到 1。\n 5. 线程 A 将变量值写回内存。\n 6. 线程 B 将变量值写回内存。\n\n在这个例子中，虽然 volatile 关键字保证了线程 A 和线程 B 都能够看到最新的变量值，但它无法保证操作的原子性，导致最终的变量值为 1 而不是 2。\n\n\n# 参考\n\n * https://segmentfault.com/a/1190000041268785\n\n * https://zhuanlan.zhihu.com/p/482639650",normalizedContent:"# synchronized的理解\n\nsynchronized关键字解决的是多个线程之间访问资源的同步性，synchronized 关键字可以保证被它修饰的方法或者代码块在任意时刻只能有一个线程执行。\n\n在 java 早期版本中，synchronized 属于重量级锁，效率低下，因为监视器锁（monitor）是依赖于底层的操作系统的 mutex lock 来实现的，java 的线程是映射到操作系统的原生线程之上的。如果要挂起或者唤醒一个线程，都需要操作系统帮忙完成，而操作系统实现线程之间的切换时需要从用户态转换到内核态，这个状态之间的转换需要相对比较长的时间，时间成本相对较高。\n\n在 jdk6 之后 java 官方对从 jvm 层面对synchronized 较大优化，所以现在的 synchronized 锁效率也优化得很不错了。jdk6 对锁的实现引入了大量的优化，如自旋锁、适应性自旋锁、锁消除、锁粗化、偏向锁、轻量级锁等技术来减少锁操作的开销。\n\n\n# synchronized的使用\n\n根据修饰对象的分类：\n\n * 修饰代码块\n   * synchronized(this|object)\n   * synchronized(类.class)\n * 修饰方法\n   * 修饰非静态方法\n   * 修饰静态方法\n\n根据获取的锁来分类：\n\n * 获取对象锁\n   * synchronized(this|object)\n   * 修改非静态方法\n * 获取类锁\n   * synchronized(类.class)\n   * 修饰静态方法\n\n1、 修饰实例方法：作用于当前对象实例加锁，进入同步代码前要获得当前对象实例的锁；\n\n2、修饰静态方法：作用于当前类对象加锁，进入同步代码前要获得当前类对象的锁 。也就是给当前类加锁，会作用于类的所有对象实例，因为静态成员不属于任何一个实例对象，是类成员。所以如果一个线程 a 调用一个实例对象的非静态 synchronized 方法，而线程 b 需要调用这个实例对象所属类的静态 synchronized 方法，是允许的，不会发生互斥现象，因为访问静态 synchronized 方法占用的锁是当前类的锁，而访问非静态 synchronized 方法占用的锁是当前实例对象锁；\n\n3、 修饰代码块：指定加锁对象，对给定对象加锁，进入同步代码库前要获得给定对象的锁。和 synchronized 方法一样，synchronized(this) 代码块也是锁定当前对象的。synchronized 关键字加到 static 静态方法和 synchronized(class) 代码块上都是是给 class 类上锁。尽量不要使用 synchronized(string a) 因为 jvm 中，字符串常量池具有缓冲功能。\n\n\n# 双重校验锁实现单例模式\n\n使用 synchronized 双重校验锁的方法实现单例模式：\n\npublic class singleton {\n  private volatile static singleton instance;\n  private singleton(){}\n  public static singleton getinstance() {\n    if (instance == null) {\n      synchronized(singleton.class) {\n        if (instance == null) instance = new singleton();\n      }\n    }\n    return instance;\n  }\n}\n\n\n另外，需要注意 instance 采用 volatile 关键字修饰也是很有必要。 因为 instance = new singleton(); 这段代码其实是分为三步执行：\n\n 1. 为 instance 分配内存空间\n 2. 初始化 instance\n 3. 将 instance 指向分配的内存地址\n\n但是由于 jvm 具有指令重排的特性，执行顺序有可能变成 1 -> 3 -> 2。指令重排在单线程环境下不会出现问题，但是在多线程环境下会导致一个线程获得还没有初始化的实例。例如，线程 t1 执行了 1 和 3，此时 t2 调用 getinstance() 后发现 instance 不为空，因此返回 instance，但此时 instance 还未被初始化。\n\n使用 volatile 可以禁止 jvm 的指令重排，保证在多线程环境下也能正常运行。\n\n\n# synchronized 关键字底层原理\n\nsynchronized 关键字底层原理属于 jvm 层面。\n\nsynchronized 使用的锁对象是存储在java对象头里的标记字段里。\n\n\n# synchronized 同步语句块的底层实现\n\nsynchronized 同步语句块的实现使用的是 monitorenter 和 monitorexit 指令，其中 monitorenter 指令指向同步代码块的开始位置，monitorexit 指令则指明同步代码块的结束位置。\n\n当执行 monitorenter 指令时，线程试图获取锁也就是获取 monitor的持有权。monitor 对象存在于每个 java 对象的对象头中，synchronized 锁便是通过这种方式获取锁的，也是为什么 java 中任意对象可以作为锁的原因。当计数器为 0 则可以成功获取，获取后将锁计数器设为 1 也就是加 1。相应的在执行 monitorexit 指令后，将锁计数器设为 0，表明锁被释放。如果获取对象锁失败，那当前线程就要阻塞等待，直到锁被另外一个线程释放为止。\n\n\n# synchronized 修饰方法的底层实现\n\nsynchronized 修饰的方法并没有 monitorenter 指令和 monitorexit 指令，取得代之的确实是 acc_synchronized 标识，该标识指明了该方法是一个同步方法，jvm 通过该 acc_synchronized 访问标志来辨别一个方法是否声明为同步方法，从而执行相应的同步调用。\n\n * acc_synchronized标志表示方法为同步方法\n * 无 acc_static标志 为普通同步方法\n * 有 acc_static标志 为静态同步方法\n\n在java中，synchronized在编译后，会在同步块的前后分别形成一个monitorenter和monitorexit这两个字节码指令，这两个字节码都需要一个reference类型的参数来指明要锁定和解锁的对象，如果java程序中明确指定了对象，那就是这个对象的reference，如果没有指明，那么根据synchronized修饰的是实例方法还是类方法，去取对应的对象实例或者类class对象来做锁对象。\n\n在执行monitorenter时，首先会尝试获取对象的锁，如果这个对象没有锁，或者当前线程已经拥有了这个对象的锁，那个锁的计数器加1，相应的，在执行monitorexit时指令时，会将锁计数器减1，当计数器为0时，这个锁就被释放。如果获取对象锁失败，那当前线程就要阻塞等待，直到对象锁被另一个线程释放为止。\n\n\n# synchronized 锁升级\n\n锁升级的过程：\n\n 1. 一开始是处于无锁状态的\n\n 2. 当有一个线程访问同步代码块时，升级成偏向锁（mark word 里存储锁偏向的线程 id ，在线程进入和退出同步块时不再通过 cas 操作来加锁和解锁，而是检测 mark word 里是否存储着指向当前线程的偏向锁）\n\n 3. 有锁竞争时，升级为轻量级锁，自旋获取锁\n\n 4. 自旋十次失败后，升级成重量级锁（线程阻塞）\n\n锁的对比：\n\n锁      优点                                 缺点                         适用场景\n偏向锁    加锁和解锁不需要额外的消耗，和执行非同步方法相比仅有纳秒级的差距   如果线程间存在锁竞争，会带来额外的锁撤销的消耗    适用于只有一个线程访问同步块的场景\n轻量级锁   竞争的线程不会阻塞，提高了程序的响应速度               如果竞争的线程始终得不到锁，是用自旋会消耗cpu   追求响应速度，痛不哭执行速度非常快\n重量级锁   线程竞争不使用自旋，不会消耗cpu                  线程阻塞，响应时间缓慢                追求吞吐量，同步快执行速度较慢\n\nhttps://zhuanlan.zhihu.com/p/482639650\n\n\n# volatile\n\nvolatile是java虚拟机系统的轻量级同步机制。\n\n其特点有：\n\n * 保证可见性\n * 不保证原子性\n * 禁止指令重排序。\n   * 避免了多线程环境下程序出现乱序执行的现象。\n   * 指令重排只会保证串行语义的执行的一致性（单线程），但并不关心多线程间的语义一致性。\n   * 对 volatile 变量的读和写操作会在指令序列中插入内存屏障，保证了volatile变量的读写操作不会被指令重排序所影响。\n\n内存屏障（memory barrier）是一个 cpu 指令，作用有两个：\n\n 1. 保证特定操作的执行顺序\n 2. 保证某些变量的内存可见性（利用该特性实现 volatile 的可见性）\n\n应用场景：\n\n单例模式下dcl不一定线程安全，由于指令重排，所以程序有小概率会出现 instance != null，但 instance 的引用对象可能还没完成初始化。所以当一个线程访问 instance != null时，instance未必已经初始化完成，造成了线程安全问题。\n\n因为 instance = new singleton();可以为被分为三步：\n\nmemory = allocate();// 1. 分配对象内存空间\ninstance(memory); // 2.初始化对象\ninstance = memory; // 3. 设置 instance 执行刚分配的内存地址，此时 instance != null\n\n\n解决方案可以在实例上加上 volatile：private static volatile singleton instance = null;\n\n\n# 如何实现可见性\n\nvolatile 关键字可以保证可见性的原因是，它会告诉 java 编译器和运行时系统，每次读取该变量时都必须从主内存中重新获取最新的值，而不是使用本地缓存的副本。\n\n具体来说，当一个线程修改一个 volatile 变量的值时，这个值会立即被写回到主内存中，而不是被缓存在该线程的本地缓存中。同时，当其他线程需要读取这个变量的值时，它们也会从主内存中获取最新的值，而不是从本地缓存中获取旧值。\n\n这种强制刷新内存的行为确保了变量的可见性，即使有多个线程同时对变量进行读取和修改，也能够看到最新的值。\n\nvolatile 变量的内存可见性是基于内存屏障(memory barrier)实现:\n\n * 内存屏障，又称内存栅栏，是一个 cpu 指令。\n * 在程序运行时，为了提高执行性能，编译器和处理器会对指令进行重排序，jmm 为了保证在不同的编译器和 cpu 上有相同的结果，通过插入特定类型的内存屏障来禁止+ 特定类型的编译器重排序和处理器重排序，插入一条内存屏障会告诉编译器和 cpu：不管什么指令都不能和这条 memory barrier 指令重排序。\n\n\n# 为什么不能实现原子性\n\n（因为只保证可见性的情况下，是无法实现原子性的。。。所以不能实现原子性）\n\nvolatile 关键字不能保证原子性的原因是，它只是保证变量的读写操作对所有线程的可见性，但并不能保证在多个线程同时访问同一个变量时，操作的顺序和正确性。\n\n例如，在一个多线程程序中，如果有两个线程同时对一个 volatile 变量进行自增操作\n\nvolatile int count = 0;\n\npublic void increment() {\n    count++;\n}\n\n\n那么可能会发生以下情况：\n\n 1. 线程 a 从内存中读取变量值为 0。\n 2. 线程 b 从内存中读取变量值为 0。\n 3. 线程 a 将变量值加 1 得到 1。\n 4. 线程 b 将变量值加 1 得到 1。\n 5. 线程 a 将变量值写回内存。\n 6. 线程 b 将变量值写回内存。\n\n在这个例子中，虽然 volatile 关键字保证了线程 a 和线程 b 都能够看到最新的变量值，但它无法保证操作的原子性，导致最终的变量值为 1 而不是 2。\n\n\n# 参考\n\n * https://segmentfault.com/a/1190000041268785\n\n * https://zhuanlan.zhihu.com/p/482639650",charsets:{cjk:!0},lastUpdated:"2023/03/29, 21:03:43",lastUpdatedTimestamp:1680095023e3},{title:"ThreadLocal",frontmatter:{title:"ThreadLocal",date:"2023-03-29T23:17:11.000Z",permalink:"/pages/41602c/"},regularPath:"/01.Java/04.Java%E5%B9%B6%E5%8F%91/02.TreadLocal.html",relativePath:"01.Java/04.Java并发/02.TreadLocal.md",key:"v-43826e72",path:"/pages/41602c/",headers:[{level:2,title:"对ThreadLocal的理解",slug:"对threadlocal的理解",normalizedTitle:"对threadlocal的理解",charIndex:2},{level:2,title:"ThreadLocal的实现原理",slug:"threadlocal的实现原理",normalizedTitle:"threadlocal的实现原理",charIndex:705},{level:2,title:"ThreadLocal的使用场景",slug:"threadlocal的使用场景",normalizedTitle:"threadlocal的使用场景",charIndex:1550},{level:3,title:"代替参数的显示传递",slug:"代替参数的显示传递",normalizedTitle:"代替参数的显示传递",charIndex:1571},{level:3,title:"全局存储用户信息",slug:"全局存储用户信息",normalizedTitle:"全局存储用户信息",charIndex:1824},{level:3,title:"解决线程安全问题",slug:"解决线程安全问题",normalizedTitle:"解决线程安全问题",charIndex:2400},{level:3,title:"慎用的场景",slug:"慎用的场景",normalizedTitle:"慎用的场景",charIndex:3861}],headersStr:"对ThreadLocal的理解 ThreadLocal的实现原理 ThreadLocal的使用场景 代替参数的显示传递 全局存储用户信息 解决线程安全问题 慎用的场景",content:'# 对ThreadLocal的理解\n\nThreadLocal是一个Java类，用于在多线程编程中维护线程本地变量。每个线程都有自己的ThreadLocal变量副本，线程之间互不干扰。\n\nThreadLocal可以用于在多线程环境下避免共享变量的竞争问题，可以提高多线程程序的性能和并发度。\n\nThreadLocal常用的方法包括get()、set()和remove()。其中，get()方法用于获取当前线程的ThreadLocal变量值，如果当前线程没有设置过该变量，则返回null。set()方法用于设置当前线程的ThreadLocal变量值，remove()方法用于删除当前线程的ThreadLocal变量值。\n\n需要注意的是，使用ThreadLocal时需要小心避免内存泄漏问题，尤其是在长时间运行的多线程应用中。当一个线程结束时，如果没有手动删除ThreadLocal变量值，则可能导致该值一直存储在ThreadLocalMap中，从而引发内存泄漏。为避免这种情况，可以使用ThreadLocal的remove()方法来手动删除ThreadLocal变量值。\n\nJava 的 Web 项目大部分都是基于 Tomcat。每次访问都是一个新的线程，每一个线程都独享一个 ThreadLocal，我们可以在接收请求的时候 set 特定内容，在需要的时候 get 这个值。\n\npublic T get() {...}\npublic void set(T value) {...}\npublic void remove() {...}\nprotected T initialValue() {...}\n\n\n\n# ThreadLocal的实现原理\n\nThreadLocal的实现原理可以简单概括为：每个Thread对象维护一个ThreadLocalMap对象，ThreadLocalMap对象的key为ThreadLocal对象，value为ThreadLocal对象对应的值。\n\n具体来说，ThreadLocal类中有一个ThreadLocalMap类型的成员变量threadLocals，每个Thread对象都有一个该成员变量的实例。ThreadLocalMap类是ThreadLocal类的内部类，它用于存储ThreadLocal对象及其对应的值。ThreadLocalMap类中的Entry类表示一个键值对，其中key为ThreadLocal对象，value为ThreadLocal对象对应的值。\n\n当调用ThreadLocal的set()方法时，会获取当前线程的ThreadLocalMap对象，将ThreadLocal对象作为key，设置value为指定的值。当调用ThreadLocal的get()方法时，同样会获取当前线程的ThreadLocalMap对象，从中获取ThreadLocal对象对应的值。如果当前线程没有设置过该ThreadLocal对象的值，则返回ThreadLocal对象的初始值。当ThreadLocal对象被垃圾回收时，对应的Entry对象也会被从ThreadLocalMap中移除。\n\n需要注意的是，ThreadLocal虽然可以实现线程间数据隔离，但是在多线程并发访问时，可能会出现内存泄漏问题。这是因为ThreadLocalMap中的Entry对象的key持有的是ThreadLocal对象的弱引用，如果ThreadLocal对象没有被外部强引用持有，就可能被垃圾回收。但是，由于ThreadLocalMap中的Entry对象没有被及时清理，就可能导致内存泄漏。因此，使用ThreadLocal时需要注意及时清理不再需要的ThreadLocal对象。\n\n\n# ThreadLocal的使用场景\n\n\n# 代替参数的显示传递\n\n当我们在写API接口的时候，通常Controller层会接受来自前端的入参，当这个接口功能比较复杂的时候，可能我们调用的Service层内部还调用了很多其他的很多方法，通常情况下，我们会在每个调用的方法上加上需要传递的参数。可以避免参数的层层传递。\n\n但是如果我们将参数存入ThreadLocal中，那么就不用显式的传递参数了，而是只需要ThreadLocal中获取即可。\n\n这个场景其实使用的比较少，一方面显式传参比较容易理解，另一方面我们可以将多个参数封装为对象去传递。\n\n\n# 全局存储用户信息\n\n在现在的系统设计中，前后端分离已基本成为常态，分离之后如何获取用户信息就成了一件麻烦事，通常在用户登录后， 用户信息会保存在Session或者Token中。这个时候，我们如果使用常规的手段去获取用户信息会很费劲，拿Session来说，我们要在接口参数中加上HttpServletRequest对象，然后调用 getSession方法，且每一个需要用户信息的接口都要加上这个参数，才能获取Session，这样实现就很麻烦了。\n\n在实际的系统设计中，我们肯定不会采用上面所说的这种方式，而是使用ThreadLocal，我们会选择在拦截器的业务中， 获取到保存的用户信息，然后存入ThreadLocal，那么当前线程在任何地方如果需要拿到用户信息都可以使用ThreadLocal的get()方法 (异步程序中ThreadLocal是不可靠的)\n\n这个场景使用的比较多，当用户登录后，会将用户信息存入Token中返回前端，当用户调用需要授权的接口时，需要在header中携带 Token，然后拦截器中解析Token，获取用户信息，调用自定义的类(AuthNHolder)存入ThreadLocal中，当请求结束的时候，将ThreadLocal存储数据清空， 中间的过程无需在关注如何获取用户信息，只需要使用工具类的get方法即可。\n\n\n# 解决线程安全问题\n\n在Spring的Web项目中，我们通常会将业务分为Controller层，Service层，Dao层， 我们都知道@Autowired注解默认使用单例模式，那么不同请求线程进来之后，由于Dao层使用单例，那么负责数据库连接的Connection也只有一个， 如果每个请求线程都去连接数据库，那么就会造成线程不安全的问题，Spring是如何解决这个问题的呢？\n\n在Spring项目中Dao层中装配的Connection肯定是线程安全的，其解决方案就是采用ThreadLocal方法，当每个请求线程使用Connection的时候， 都会从ThreadLocal获取一次，如果为null，说明没有进行过数据库连接，连接后存入ThreadLocal中，如此一来，每一个请求线程都保存有一份 自己的Connection。于是便解决了线程安全问题。\n\nThreadLocal在设计之初就是为解决并发问题而提供一种方案，每个线程维护一份自己的数据，达到线程隔离的效果。\n\n比如日期格式化：在多线程环境中，日期格式化是一个常见的问题。由于SimpleDateFormat是非线程安全的，因此为每个线程维护自己的SimpleDateFormat对象副本是一种解决方案。\n\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\n\npublic class DateFormatThreadLocal {\n    private static final ThreadLocal<SimpleDateFormat> DATE_FORMAT_THREAD_LOCAL = new ThreadLocal<SimpleDateFormat>() {\n        @Override\n        protected SimpleDateFormat initialValue() {\n            return new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");\n        }\n    };\n\n    public static void main(String[] args) {\n        Thread thread1 = new Thread(() -> {\n            SimpleDateFormat dateFormat = DATE_FORMAT_THREAD_LOCAL.get();\n            System.out.println("Thread 1 formatted date: " + dateFormat.format(new Date()));\n        });\n\n        Thread thread2 = new Thread(() -> {\n            SimpleDateFormat dateFormat = DATE_FORMAT_THREAD_LOCAL.get();\n            System.out.println("Thread 2 formatted date: " + dateFormat.format(new Date()));\n        });\n\n        thread1.start();\n        thread2.start();\n    }\n}\n\n\n\n# 慎用的场景\n\n1.线程池中线程调用使用ThreadLocal ，由于线程池中对线程管理都是采用线程复用的方法。在线程池中线程非常难结束甚至于永远不会结束。这将意味着线程持续的时间将不可预測，甚至与JVM的生命周期一致\n\n2.异步程序中，ThreadLocal的參数传递是不靠谱的， 由于线程将请求发送后。就不再等待远程返回结果继续向下运行了，真正的返回结果得到后，处理的线程可能是其他的线程。Java8中的并发流也要考虑这种情况\n\n3.使用完ThreadLocal ，最好手动调用 remove() 方法，防止出现内存溢出，因为中使用的key为ThreadLocal的弱引用， 如果ThreadLocal 没有被外部强引用的情况下，在垃圾回收的时候会被清理掉的，但是如果value是强引用，不会被清理， 这样一来就会出现 key 为 null 的 value。',normalizedContent:'# 对threadlocal的理解\n\nthreadlocal是一个java类，用于在多线程编程中维护线程本地变量。每个线程都有自己的threadlocal变量副本，线程之间互不干扰。\n\nthreadlocal可以用于在多线程环境下避免共享变量的竞争问题，可以提高多线程程序的性能和并发度。\n\nthreadlocal常用的方法包括get()、set()和remove()。其中，get()方法用于获取当前线程的threadlocal变量值，如果当前线程没有设置过该变量，则返回null。set()方法用于设置当前线程的threadlocal变量值，remove()方法用于删除当前线程的threadlocal变量值。\n\n需要注意的是，使用threadlocal时需要小心避免内存泄漏问题，尤其是在长时间运行的多线程应用中。当一个线程结束时，如果没有手动删除threadlocal变量值，则可能导致该值一直存储在threadlocalmap中，从而引发内存泄漏。为避免这种情况，可以使用threadlocal的remove()方法来手动删除threadlocal变量值。\n\njava 的 web 项目大部分都是基于 tomcat。每次访问都是一个新的线程，每一个线程都独享一个 threadlocal，我们可以在接收请求的时候 set 特定内容，在需要的时候 get 这个值。\n\npublic t get() {...}\npublic void set(t value) {...}\npublic void remove() {...}\nprotected t initialvalue() {...}\n\n\n\n# threadlocal的实现原理\n\nthreadlocal的实现原理可以简单概括为：每个thread对象维护一个threadlocalmap对象，threadlocalmap对象的key为threadlocal对象，value为threadlocal对象对应的值。\n\n具体来说，threadlocal类中有一个threadlocalmap类型的成员变量threadlocals，每个thread对象都有一个该成员变量的实例。threadlocalmap类是threadlocal类的内部类，它用于存储threadlocal对象及其对应的值。threadlocalmap类中的entry类表示一个键值对，其中key为threadlocal对象，value为threadlocal对象对应的值。\n\n当调用threadlocal的set()方法时，会获取当前线程的threadlocalmap对象，将threadlocal对象作为key，设置value为指定的值。当调用threadlocal的get()方法时，同样会获取当前线程的threadlocalmap对象，从中获取threadlocal对象对应的值。如果当前线程没有设置过该threadlocal对象的值，则返回threadlocal对象的初始值。当threadlocal对象被垃圾回收时，对应的entry对象也会被从threadlocalmap中移除。\n\n需要注意的是，threadlocal虽然可以实现线程间数据隔离，但是在多线程并发访问时，可能会出现内存泄漏问题。这是因为threadlocalmap中的entry对象的key持有的是threadlocal对象的弱引用，如果threadlocal对象没有被外部强引用持有，就可能被垃圾回收。但是，由于threadlocalmap中的entry对象没有被及时清理，就可能导致内存泄漏。因此，使用threadlocal时需要注意及时清理不再需要的threadlocal对象。\n\n\n# threadlocal的使用场景\n\n\n# 代替参数的显示传递\n\n当我们在写api接口的时候，通常controller层会接受来自前端的入参，当这个接口功能比较复杂的时候，可能我们调用的service层内部还调用了很多其他的很多方法，通常情况下，我们会在每个调用的方法上加上需要传递的参数。可以避免参数的层层传递。\n\n但是如果我们将参数存入threadlocal中，那么就不用显式的传递参数了，而是只需要threadlocal中获取即可。\n\n这个场景其实使用的比较少，一方面显式传参比较容易理解，另一方面我们可以将多个参数封装为对象去传递。\n\n\n# 全局存储用户信息\n\n在现在的系统设计中，前后端分离已基本成为常态，分离之后如何获取用户信息就成了一件麻烦事，通常在用户登录后， 用户信息会保存在session或者token中。这个时候，我们如果使用常规的手段去获取用户信息会很费劲，拿session来说，我们要在接口参数中加上httpservletrequest对象，然后调用 getsession方法，且每一个需要用户信息的接口都要加上这个参数，才能获取session，这样实现就很麻烦了。\n\n在实际的系统设计中，我们肯定不会采用上面所说的这种方式，而是使用threadlocal，我们会选择在拦截器的业务中， 获取到保存的用户信息，然后存入threadlocal，那么当前线程在任何地方如果需要拿到用户信息都可以使用threadlocal的get()方法 (异步程序中threadlocal是不可靠的)\n\n这个场景使用的比较多，当用户登录后，会将用户信息存入token中返回前端，当用户调用需要授权的接口时，需要在header中携带 token，然后拦截器中解析token，获取用户信息，调用自定义的类(authnholder)存入threadlocal中，当请求结束的时候，将threadlocal存储数据清空， 中间的过程无需在关注如何获取用户信息，只需要使用工具类的get方法即可。\n\n\n# 解决线程安全问题\n\n在spring的web项目中，我们通常会将业务分为controller层，service层，dao层， 我们都知道@autowired注解默认使用单例模式，那么不同请求线程进来之后，由于dao层使用单例，那么负责数据库连接的connection也只有一个， 如果每个请求线程都去连接数据库，那么就会造成线程不安全的问题，spring是如何解决这个问题的呢？\n\n在spring项目中dao层中装配的connection肯定是线程安全的，其解决方案就是采用threadlocal方法，当每个请求线程使用connection的时候， 都会从threadlocal获取一次，如果为null，说明没有进行过数据库连接，连接后存入threadlocal中，如此一来，每一个请求线程都保存有一份 自己的connection。于是便解决了线程安全问题。\n\nthreadlocal在设计之初就是为解决并发问题而提供一种方案，每个线程维护一份自己的数据，达到线程隔离的效果。\n\n比如日期格式化：在多线程环境中，日期格式化是一个常见的问题。由于simpledateformat是非线程安全的，因此为每个线程维护自己的simpledateformat对象副本是一种解决方案。\n\nimport java.text.simpledateformat;\nimport java.util.date;\n\npublic class dateformatthreadlocal {\n    private static final threadlocal<simpledateformat> date_format_thread_local = new threadlocal<simpledateformat>() {\n        @override\n        protected simpledateformat initialvalue() {\n            return new simpledateformat("yyyy-mm-dd hh:mm:ss");\n        }\n    };\n\n    public static void main(string[] args) {\n        thread thread1 = new thread(() -> {\n            simpledateformat dateformat = date_format_thread_local.get();\n            system.out.println("thread 1 formatted date: " + dateformat.format(new date()));\n        });\n\n        thread thread2 = new thread(() -> {\n            simpledateformat dateformat = date_format_thread_local.get();\n            system.out.println("thread 2 formatted date: " + dateformat.format(new date()));\n        });\n\n        thread1.start();\n        thread2.start();\n    }\n}\n\n\n\n# 慎用的场景\n\n1.线程池中线程调用使用threadlocal ，由于线程池中对线程管理都是采用线程复用的方法。在线程池中线程非常难结束甚至于永远不会结束。这将意味着线程持续的时间将不可预測，甚至与jvm的生命周期一致\n\n2.异步程序中，threadlocal的參数传递是不靠谱的， 由于线程将请求发送后。就不再等待远程返回结果继续向下运行了，真正的返回结果得到后，处理的线程可能是其他的线程。java8中的并发流也要考虑这种情况\n\n3.使用完threadlocal ，最好手动调用 remove() 方法，防止出现内存溢出，因为中使用的key为threadlocal的弱引用， 如果threadlocal 没有被外部强引用的情况下，在垃圾回收的时候会被清理掉的，但是如果value是强引用，不会被清理， 这样一来就会出现 key 为 null 的 value。',charsets:{cjk:!0}},{title:"ReentranLock",frontmatter:{title:"ReentranLock",date:"2023-03-30T17:30:51.000Z",permalink:"/pages/d1bd01/"},regularPath:"/01.Java/04.Java%E5%B9%B6%E5%8F%91/03.ReentrantLock.html",relativePath:"01.Java/04.Java并发/03.ReentrantLock.md",key:"v-c20babe6",path:"/pages/d1bd01/",headers:[{level:2,title:"ReentrantLock 实现原理",slug:"reentrantlock-实现原理",normalizedTitle:"reentrantlock 实现原理",charIndex:69},{level:2,title:"公平锁和非公平锁",slug:"公平锁和非公平锁",normalizedTitle:"公平锁和非公平锁",charIndex:2136},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:2849}],headersStr:"ReentrantLock 实现原理 公平锁和非公平锁 参考",content:'ReentrantLock 是可重入的独占锁，只能有一个线程可以获取该锁，其它获取该锁的线程会被阻塞而被放入该锁的阻塞队列里面。\n\n\n# ReentrantLock 实现原理\n\n * RenentrantLock实现了Lock接口，Lock接口提供了锁的通用api,比如加锁lock，解锁unlock等操作。\n * RenentrantLock底层加锁是通过AQS实现的，两个内部类FairSync服务于公平锁，NofaireSync服务于非公平锁的实现，他们统一继承自AQS。\n\n// ReentrantLock.Sync#initialTryLock\nabstract boolean initialTryLock();\n\n// ReentrantLock.Sync#lock\nfinal void lock() {\n  if (!initialTryLock())\n    acquire(1);\n}\n\n// ReentrantLock.FairSync#initialTryLock\nfinal boolean initialTryLock() {\n  Thread current = Thread.currentThread();\n  int c = getState();\n  if (c == 0) {\n    if (!hasQueuedThreads() && compareAndSetState(0, 1)) {\n      setExclusiveOwnerThread(current);\n      return true;\n    }\n  } else if (getExclusiveOwnerThread() == current) {\n    if (++c < 0) // overflow\n      throw new Error("Maximum lock count exceeded");\n    setState(c);\n    return true;\n  }\n  return false;\n}\n\n// ReentrantLock.NonfairSync#initialTryLock\nfinal boolean initialTryLock() {\n  Thread current = Thread.currentThread();\n  if (compareAndSetState(0, 1)) { // first attempt is unguarded\n    setExclusiveOwnerThread(current);\n    return true;\n  } else if (getExclusiveOwnerThread() == current) {\n    int c = getState() + 1;\n    if (c < 0) // overflow\n      throw new Error("Maximum lock count exceeded");\n    setState(c);\n    return true;\n  } else\n    return false;\n}\n\n\n\n// AbstractQueuedSynchronizer#acquire\npublic final void acquire(int arg) {\n  if (!tryAcquire(arg))\n    acquire(null, arg, false, false, false, 0L);\n}\n\n// ReentrantLock.FairSync#tryAcquire\n// Acquires only if thread is first waiter or empty\nprotected final boolean tryAcquire(int acquires) {\n  if (getState() == 0 && !hasQueuedPredecessors() &&\n      compareAndSetState(0, acquires)) {\n    setExclusiveOwnerThread(Thread.currentThread());\n    return true;\n  }\n  return false;\n}\n\n// ReentrantLock.NonFairSync#tryAcquire\n// Acquire for non-reentrant cases after initialTryLock prescreen\nprotected final boolean tryAcquire(int acquires) {\n  if (getState() == 0 && compareAndSetState(0, acquires)) {\n    setExclusiveOwnerThread(Thread.currentThread());\n    return true;\n  }\n  return false;\n}\n\n\n\n# 公平锁和非公平锁\n\n公平锁 FairSync\n\n * 公平锁是指多个线程按照申请锁的顺序来获取锁，线程直接进入队列中排队，队列中的第一个线程才能获得锁\n\n * 公平锁的优点是等待锁的线程不会饿死。缺点是整体吞吐效率相对非公平锁要低，等待队列中除第一个线程以外的所有线程都会阻塞，CPU 唤醒阻塞线程的开销比非公平锁大\n\n非公平锁 NonfairSync （默认）\n\n * 非公平锁是多个线程加锁时直接尝试获取锁，获取不到才会到等待队列的队尾等待。但如果此时锁刚好可用，那么这个线程可以无需阻塞直接获取到锁\n * 非公平锁的优点是可以减少唤起线程的开销，整体的吞吐效率高，因为线程有几率不阻塞直接获得锁，CPU 不必唤醒所有线程。缺点是处于等待队列中的线程可能会饿死，或者等很久才会获得锁\n\n\n\n非公平锁和公平锁的两处不同：\n\n 1. 非公平锁在调用 lock 后，首先就会调用 CAS 进行一次抢锁，如果这个时候恰巧锁没有被占用，那么直接就获取到锁返回了。\n 2. 非公平锁在 CAS 失败后，和公平锁一样都会进入到 tryAcquire 方法，在 tryAcquire 方法中，如果发现锁这个时候被释放了（state == 0），非公平锁会直接 CAS 抢锁，但是公平锁会判断等待队列是否有线程处于等待状态，如果有则不去抢锁，乖乖排到后面。\n\n公平锁和非公平锁就这两点区别，如果两次 CAS 都不成功，那么后面非公平锁和公平锁是一样的，都要进入到阻塞队列等待唤醒。\n\n相对来说，非公平锁会有更好的性能，因为它的吞吐量比较大。当然，非公平锁让获取锁的时间变得更加不确定，可能会导致在阻塞队列中的线程长期处于饥饿状态。\n\n\n# 参考\n\n * 图解ReentrantLock公平锁和非公平锁实现原理\n * ',normalizedContent:'reentrantlock 是可重入的独占锁，只能有一个线程可以获取该锁，其它获取该锁的线程会被阻塞而被放入该锁的阻塞队列里面。\n\n\n# reentrantlock 实现原理\n\n * renentrantlock实现了lock接口，lock接口提供了锁的通用api,比如加锁lock，解锁unlock等操作。\n * renentrantlock底层加锁是通过aqs实现的，两个内部类fairsync服务于公平锁，nofairesync服务于非公平锁的实现，他们统一继承自aqs。\n\n// reentrantlock.sync#initialtrylock\nabstract boolean initialtrylock();\n\n// reentrantlock.sync#lock\nfinal void lock() {\n  if (!initialtrylock())\n    acquire(1);\n}\n\n// reentrantlock.fairsync#initialtrylock\nfinal boolean initialtrylock() {\n  thread current = thread.currentthread();\n  int c = getstate();\n  if (c == 0) {\n    if (!hasqueuedthreads() && compareandsetstate(0, 1)) {\n      setexclusiveownerthread(current);\n      return true;\n    }\n  } else if (getexclusiveownerthread() == current) {\n    if (++c < 0) // overflow\n      throw new error("maximum lock count exceeded");\n    setstate(c);\n    return true;\n  }\n  return false;\n}\n\n// reentrantlock.nonfairsync#initialtrylock\nfinal boolean initialtrylock() {\n  thread current = thread.currentthread();\n  if (compareandsetstate(0, 1)) { // first attempt is unguarded\n    setexclusiveownerthread(current);\n    return true;\n  } else if (getexclusiveownerthread() == current) {\n    int c = getstate() + 1;\n    if (c < 0) // overflow\n      throw new error("maximum lock count exceeded");\n    setstate(c);\n    return true;\n  } else\n    return false;\n}\n\n\n\n// abstractqueuedsynchronizer#acquire\npublic final void acquire(int arg) {\n  if (!tryacquire(arg))\n    acquire(null, arg, false, false, false, 0l);\n}\n\n// reentrantlock.fairsync#tryacquire\n// acquires only if thread is first waiter or empty\nprotected final boolean tryacquire(int acquires) {\n  if (getstate() == 0 && !hasqueuedpredecessors() &&\n      compareandsetstate(0, acquires)) {\n    setexclusiveownerthread(thread.currentthread());\n    return true;\n  }\n  return false;\n}\n\n// reentrantlock.nonfairsync#tryacquire\n// acquire for non-reentrant cases after initialtrylock prescreen\nprotected final boolean tryacquire(int acquires) {\n  if (getstate() == 0 && compareandsetstate(0, acquires)) {\n    setexclusiveownerthread(thread.currentthread());\n    return true;\n  }\n  return false;\n}\n\n\n\n# 公平锁和非公平锁\n\n公平锁 fairsync\n\n * 公平锁是指多个线程按照申请锁的顺序来获取锁，线程直接进入队列中排队，队列中的第一个线程才能获得锁\n\n * 公平锁的优点是等待锁的线程不会饿死。缺点是整体吞吐效率相对非公平锁要低，等待队列中除第一个线程以外的所有线程都会阻塞，cpu 唤醒阻塞线程的开销比非公平锁大\n\n非公平锁 nonfairsync （默认）\n\n * 非公平锁是多个线程加锁时直接尝试获取锁，获取不到才会到等待队列的队尾等待。但如果此时锁刚好可用，那么这个线程可以无需阻塞直接获取到锁\n * 非公平锁的优点是可以减少唤起线程的开销，整体的吞吐效率高，因为线程有几率不阻塞直接获得锁，cpu 不必唤醒所有线程。缺点是处于等待队列中的线程可能会饿死，或者等很久才会获得锁\n\n\n\n非公平锁和公平锁的两处不同：\n\n 1. 非公平锁在调用 lock 后，首先就会调用 cas 进行一次抢锁，如果这个时候恰巧锁没有被占用，那么直接就获取到锁返回了。\n 2. 非公平锁在 cas 失败后，和公平锁一样都会进入到 tryacquire 方法，在 tryacquire 方法中，如果发现锁这个时候被释放了（state == 0），非公平锁会直接 cas 抢锁，但是公平锁会判断等待队列是否有线程处于等待状态，如果有则不去抢锁，乖乖排到后面。\n\n公平锁和非公平锁就这两点区别，如果两次 cas 都不成功，那么后面非公平锁和公平锁是一样的，都要进入到阻塞队列等待唤醒。\n\n相对来说，非公平锁会有更好的性能，因为它的吞吐量比较大。当然，非公平锁让获取锁的时间变得更加不确定，可能会导致在阻塞队列中的线程长期处于饥饿状态。\n\n\n# 参考\n\n * 图解reentrantlock公平锁和非公平锁实现原理\n * ',charsets:{cjk:!0}},{title:"ConcurrentHashMap",frontmatter:{title:"ConcurrentHashMap",date:"2023-03-30T17:31:10.000Z",permalink:"/pages/019d22/"},regularPath:"/01.Java/04.Java%E5%B9%B6%E5%8F%91/04.ConcurrentHashMap.html",relativePath:"01.Java/04.Java并发/04.ConcurrentHashMap.md",key:"v-08c71366",path:"/pages/019d22/",headers:[{level:2,title:"对比总结",slug:"对比总结",normalizedTitle:"对比总结",charIndex:2},{level:2,title:"JDK 1.5 ～ 1.7 ConcurrentHashMap 的实现",slug:"jdk-1-5-1-7-concurrenthashmap-的实现",normalizedTitle:"jdk 1.5 ～ 1.7 concurrenthashmap 的实现",charIndex:153},{level:3,title:"get",slug:"get",normalizedTitle:"get",charIndex:419},{level:3,title:"put",slug:"put",normalizedTitle:"put",charIndex:42},{level:2,title:"JDK 1.8 ConcurrentHashMap 的实现",slug:"jdk-1-8-concurrenthashmap-的实现",normalizedTitle:"jdk 1.8 concurrenthashmap 的实现",charIndex:723},{level:3,title:"get",slug:"get-2",normalizedTitle:"get",charIndex:419},{level:3,title:"put",slug:"put-2",normalizedTitle:"put",charIndex:42},{level:2,title:"CAS",slug:"cas",normalizedTitle:"cas",charIndex:126},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:1942}],headersStr:"对比总结 JDK 1.5 ～ 1.7 ConcurrentHashMap 的实现 get put JDK 1.8 ConcurrentHashMap 的实现 get put CAS 参考",content:"# 对比总结\n\n * HashTable : 使用了synchronized关键字对put等操作进行加锁;\n * ConcurrentHashMap JDK1.7: 使用分段锁机制实现;\n * ConcurrentHashMap JDK1.8: 则使用CAS + synchronized 实现;\n\n\n# JDK 1.5 ～ 1.7 ConcurrentHashMap 的实现\n\nJava使用了分段锁机制实现ConcurrentHashMap。其最大并发度受Segment的个数限制。默认是有16个 segment，且初始化后不可扩容。\n\nConcurrentHashMap在对象中保存了一个Segment数组，即将整个Hash表划分为多个分段；而每个Segment元素，即每个分段则类似于一个Hashtable；这样，在执行put操作时首先根据hash算法定位到元素属于哪个Segment，然后对该Segment加锁即可。\n\n\n\n\n# get\n\n 1. 为输入的Key做Hash运算，得到hash值。\n 2. 通过hash值，定位到对应的Segment对象\n 3. 再次通过hash值，定位到Segment当中数组的具体位置。\n\n\n# put\n\n 1. 为输入的Key做Hash运算，得到hash值。\n 2. 通过hash值，定位到对应的Segment对象\n 3. 调用 reentrantLock.tryLock() 方法尝试获取锁。获取失败的话，自旋再次获取while(!tryLock()) {}\n 4. 再次通过hash值，定位到Segment当中数组的具体位置。\n 5. 插入或覆盖HashEntry对象。\n 6. 释放锁。\n\n\n# JDK 1.8 ConcurrentHashMap 的实现\n\n使用CAS + synchronized 实现。\n\n\n\n\n# get\n\n 1. 计算 hash 值\n 2. 根据 hash 值找到数组对应位置: (n - 1) & h\n 3. 根据该位置处结点性质进行相应查找\n\n * 如果该位置为 null，那么直接返回 null 就可以了\n * 如果该位置处的节点刚好就是我们需要的，返回该节点的值即可\n * 如果该位置节点的 hash 值小于 0，说明正在扩容，或者是红黑树\n * 如果以上 3 条都不满足，那就是链表，进行遍历比对即可\n\n\n# put\n\n 1. 首先会判断 key、value是否为空，如果为空就抛异常；\n 2. 接着会判断容器数组是否为空，如果为空就初始化数组；\n 3. 获取 hash 值对应的数组下标，得到头节点 f。\n    1. 如果 f 为空，代表当前数组下标是否第一次插入，如果是就通过 CAS 方式插入；如果 CAS 失败，代表有并发操作，循环重试。\n    2. 如果 f 的 hash 等于 MOVED，表示有其它线程正在扩容，则一起进行扩容操作（帮助数据迁移）。\n    3. 其他的情况，即如果头节点 f 不为空，获取数组该位置的头节点的监视器锁 synchronized(f) {}，把新的Node节点按链表或红黑树的方式插入到合适的位置；\n 4. 节点插入完成之后，接着判断链表长度是否超过8，如果超过8个，就将链表转化为红黑树结构；\n 5. 最后，插入完成之后，进行扩容判断。\n\n其他细节\n\n * 扩容: tryPresize\n * 数据迁移: transfer\n\n\n# CAS\n\ncompare-and-swap。CAS需要有3个操作数：内存地址V，旧的预期值A，即将要更新的目标值B。\n\nCAS指令执行时，当且仅当内存地址V的值与预期值A相等时，将内存地址V的值修改为 B ，并返回 true ；否则就什么都不做，并返回 false。整个比较并替换的操作是一个原子操作。\n\nJava 中 CAS 的实现是调用了 Unsafe 的方法。 sun.misc.Unsafe 类，它可以提供硬件级别的原子操作，它可以获取某个属性在内存中的位置，也可以修改对象的字段值，只不过该类对一般开发而言，很少会用到，其底层是用 C/C++ 实现的，所以它的方式都是被 native 关键字修饰过的。\n\nCAS虽然很高效的解决了原子操作问题，但是CAS仍然存在三大问题。\n\n 1. 循环时间长开销很大：一般如果CAS失败，会一直进行尝试。如果CAS长时间一直不成功，可能会给CPU带来很大的开销。\n 2. 只能保证一个共享变量的原子操作。\n 3. ABA问题：Java提供了一个带有标记的原子引用类 AtomicStampedReference，它可以通过控制变量值的版本来保证CAS的正确性。\n\n\n# 参考\n\n * https://pdai.tech/md/java/thread/java-thread-x-juc-collection-ConcurrentHashMap.html#concurrenthashmap-jdk-1-8\n * https://juejin.cn/post/7064061605185028110#heading-13",normalizedContent:"# 对比总结\n\n * hashtable : 使用了synchronized关键字对put等操作进行加锁;\n * concurrenthashmap jdk1.7: 使用分段锁机制实现;\n * concurrenthashmap jdk1.8: 则使用cas + synchronized 实现;\n\n\n# jdk 1.5 ～ 1.7 concurrenthashmap 的实现\n\njava使用了分段锁机制实现concurrenthashmap。其最大并发度受segment的个数限制。默认是有16个 segment，且初始化后不可扩容。\n\nconcurrenthashmap在对象中保存了一个segment数组，即将整个hash表划分为多个分段；而每个segment元素，即每个分段则类似于一个hashtable；这样，在执行put操作时首先根据hash算法定位到元素属于哪个segment，然后对该segment加锁即可。\n\n\n\n\n# get\n\n 1. 为输入的key做hash运算，得到hash值。\n 2. 通过hash值，定位到对应的segment对象\n 3. 再次通过hash值，定位到segment当中数组的具体位置。\n\n\n# put\n\n 1. 为输入的key做hash运算，得到hash值。\n 2. 通过hash值，定位到对应的segment对象\n 3. 调用 reentrantlock.trylock() 方法尝试获取锁。获取失败的话，自旋再次获取while(!trylock()) {}\n 4. 再次通过hash值，定位到segment当中数组的具体位置。\n 5. 插入或覆盖hashentry对象。\n 6. 释放锁。\n\n\n# jdk 1.8 concurrenthashmap 的实现\n\n使用cas + synchronized 实现。\n\n\n\n\n# get\n\n 1. 计算 hash 值\n 2. 根据 hash 值找到数组对应位置: (n - 1) & h\n 3. 根据该位置处结点性质进行相应查找\n\n * 如果该位置为 null，那么直接返回 null 就可以了\n * 如果该位置处的节点刚好就是我们需要的，返回该节点的值即可\n * 如果该位置节点的 hash 值小于 0，说明正在扩容，或者是红黑树\n * 如果以上 3 条都不满足，那就是链表，进行遍历比对即可\n\n\n# put\n\n 1. 首先会判断 key、value是否为空，如果为空就抛异常；\n 2. 接着会判断容器数组是否为空，如果为空就初始化数组；\n 3. 获取 hash 值对应的数组下标，得到头节点 f。\n    1. 如果 f 为空，代表当前数组下标是否第一次插入，如果是就通过 cas 方式插入；如果 cas 失败，代表有并发操作，循环重试。\n    2. 如果 f 的 hash 等于 moved，表示有其它线程正在扩容，则一起进行扩容操作（帮助数据迁移）。\n    3. 其他的情况，即如果头节点 f 不为空，获取数组该位置的头节点的监视器锁 synchronized(f) {}，把新的node节点按链表或红黑树的方式插入到合适的位置；\n 4. 节点插入完成之后，接着判断链表长度是否超过8，如果超过8个，就将链表转化为红黑树结构；\n 5. 最后，插入完成之后，进行扩容判断。\n\n其他细节\n\n * 扩容: trypresize\n * 数据迁移: transfer\n\n\n# cas\n\ncompare-and-swap。cas需要有3个操作数：内存地址v，旧的预期值a，即将要更新的目标值b。\n\ncas指令执行时，当且仅当内存地址v的值与预期值a相等时，将内存地址v的值修改为 b ，并返回 true ；否则就什么都不做，并返回 false。整个比较并替换的操作是一个原子操作。\n\njava 中 cas 的实现是调用了 unsafe 的方法。 sun.misc.unsafe 类，它可以提供硬件级别的原子操作，它可以获取某个属性在内存中的位置，也可以修改对象的字段值，只不过该类对一般开发而言，很少会用到，其底层是用 c/c++ 实现的，所以它的方式都是被 native 关键字修饰过的。\n\ncas虽然很高效的解决了原子操作问题，但是cas仍然存在三大问题。\n\n 1. 循环时间长开销很大：一般如果cas失败，会一直进行尝试。如果cas长时间一直不成功，可能会给cpu带来很大的开销。\n 2. 只能保证一个共享变量的原子操作。\n 3. aba问题：java提供了一个带有标记的原子引用类 atomicstampedreference，它可以通过控制变量值的版本来保证cas的正确性。\n\n\n# 参考\n\n * https://pdai.tech/md/java/thread/java-thread-x-juc-collection-concurrenthashmap.html#concurrenthashmap-jdk-1-8\n * https://juejin.cn/post/7064061605185028110#heading-13",charsets:{cjk:!0}},{title:"ThreadPoolExecutor",frontmatter:{title:"ThreadPoolExecutor",date:"2023-03-30T17:32:00.000Z",permalink:"/pages/854033/"},regularPath:"/01.Java/04.Java%E5%B9%B6%E5%8F%91/05.ThreadPoolExecutor.html",relativePath:"01.Java/04.Java并发/05.ThreadPoolExecutor.md",key:"v-8ae87632",path:"/pages/854033/",headers:[{level:2,title:"Java线程池为什么不设计成先扩大线程数再加入阻塞队列？",slug:"java线程池为什么不设计成先扩大线程数再加入阻塞队列",normalizedTitle:"java线程池为什么不设计成先扩大线程数再加入阻塞队列？",charIndex:2},{level:2,title:"核心参数",slug:"核心参数",normalizedTitle:"核心参数",charIndex:369},{level:2,title:"阻塞队列 BlockingQueue",slug:"阻塞队列-blockingqueue",normalizedTitle:"阻塞队列 blockingqueue",charIndex:758},{level:2,title:"拒绝策略",slug:"拒绝策略",normalizedTitle:"拒绝策略",charIndex:1184},{level:2,title:"threadFactory",slug:"threadfactory",normalizedTitle:"threadfactory",charIndex:674},{level:2,title:"执行过程",slug:"执行过程",normalizedTitle:"执行过程",charIndex:1506},{level:2,title:"为什么线程池不允许使用Executors去创建? 推荐方式是什么?",slug:"为什么线程池不允许使用executors去创建-推荐方式是什么",normalizedTitle:"为什么线程池不允许使用executors去创建? 推荐方式是什么?",charIndex:1728},{level:2,title:"配置线程池需要考虑因素",slug:"配置线程池需要考虑因素",normalizedTitle:"配置线程池需要考虑因素",charIndex:2085}],headersStr:"Java线程池为什么不设计成先扩大线程数再加入阻塞队列？ 核心参数 阻塞队列 BlockingQueue 拒绝策略 threadFactory 执行过程 为什么线程池不允许使用Executors去创建? 推荐方式是什么? 配置线程池需要考虑因素",content:"# Java线程池为什么不设计成先扩大线程数再加入阻塞队列？\n\n 1. 资源利用率： 在大多数情况下，线程的创建和销毁都比较昂贵。如果每个新任务都立即创建一个新线程，这会导致频繁的线程创建和销毁，浪费系统资源。通过将任务放入阻塞队列，可以将任务排队，以便线程可以重用，从而更有效地利用资源。\n 2. 控制并发度： 通过将任务放入队列，线程池可以更好地控制并发度。线程池可以根据负载和资源情况来决定是否需要创建新线程，以保持合适的并发度。这可以防止系统过载，避免创建过多的线程导致性能下降或资源竞争。\n 3. 避免线程爆炸： 如果不使用阻塞队列，当有大量任务同时到达时，会导致大量线程同时创建，这可能会导致系统的线程数急剧增加，从而增加了上下文切换的开销，甚至可能导致系统崩溃。通过使用阻塞队列，可以平滑地处理任务，避免线程爆炸。\n\n\n# 核心参数\n\npublic ThreadPoolExecutor(int corePoolSize,\n                              int maximumPoolSize,\n                              long keepAliveTime,\n                              TimeUnit unit,\n                              BlockingQueue<Runnable> workQueue,\n                              ThreadFactory threadFactory,\n                              RejectedExecutionHandler handler)\n\n\n\n# 阻塞队列 BlockingQueue\n\nArrayBlockingQueue: 基于数组结构的有界阻塞队列，按FIFO排序任务；\n\nLinkedBlockingQueue: 基于链表结构的阻塞队列，按FIFO排序任务，吞吐量通常要高于ArrayBlockingQueue；\n\nSynchronousQueue: 一个不存储元素的阻塞队列，每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于LinkedBlockingQueue；\n\nPriorityBlockingQueue: 具有优先级的无界阻塞队列；\n\nLinkedBlockingQueue比ArrayBlockingQueue在插入删除节点性能方面更优，但是二者在put(), take()任务的时均需要加锁，SynchronousQueue使用无锁算法，根据节点的状态判断执行，而不需要用到锁，其核心是Transfer.transfer().\n\n\n# 拒绝策略\n\nAbortPolicy: 直接抛出异常，默认策略；\n\nCallerRunsPolicy: 用调用者所在的线程来执行任务；\n\nDiscardOldestPolicy: 丢弃阻塞队列中最老的任务，将此任务加入到阻塞队列中；\n\nDiscardPolicy: 直接丢弃任务；\n\n也可以根据应用场景实现RejectedExecutionHandler接口，自定义饱和策略，如记录日志或持久化存储不能处理的任务。\n\n\n# threadFactory\n\nthreadFactory创建线程的工厂，通过自定义的线程工厂可以给每个新建的线程设置一个具有识别度的线程名。默认为Executors.defaultThreadFactory()。\n\n\n# 执行过程\n\n 1. 线程池首先当前运行的线程数量是否少于corePoolSize。如果是，则创建一个新的工作线程来执行任务。如果都在执行任务，则进入2.\n\n 2. 判断BlockingQueue是否已经满了，倘若还没有满，则将线程放入BlockingQueue。否则进入3.\n\n 3. 创建一个新的工作线程，如果使当前运行的线程数量超过maximumPoolSize，则交给RejectedExecutionHandler来处理任务。\n\n\n# 为什么线程池不允许使用Executors去创建? 推荐方式是什么?\n\n线程池不允许使用Executors去创建，而是通过ThreadPoolExecutor的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。\n\n说明：Executors各个方法的弊端：\n\n * newFixedThreadPool和newSingleThreadExecutor：主要问题是堆积的请求处理队列（LinkedBlockingQueue<Runnable>的无界队列）可能会耗费非常大的内存，甚至OOM。\n * newCachedThreadPool和newScheduledThreadPool：主要问题是线程数最大数是Integer.MAX_VALUE，可能会创建数量非常多的线程，甚至OOM。\n\n\n# 配置线程池需要考虑因素\n\n从任务的优先级，任务的执行时间长短，任务的性质(CPU密集/ IO密集)，任务的依赖关系这四个角度来分析。并且近可能地使用有界的工作队列。\n\n性质不同的任务可用使用不同规模的线程池分开处理:\n\n * CPU密集型: 尽可能少的线程，Ncpu+1\n * IO密集型: 尽可能多的线程, Ncpu*2，比如数据库连接池\n * 混合型: CPU密集型的任务与IO密集型任务的执行时间差别较小，否则没有必要拆分。\n\n【待验证】\n\n 1. 任务的优先级： 如果你的应用程序中有不同优先级的任务，可以考虑使用ThreadPoolExecutor的构造函数中的ThreadFactory参数来为不同优先级的任务分配不同的线程池。这允许你为高优先级的任务分配更多的线程资源，以确保它们能够及时执行。此外，你还可以使用优先级队列来管理任务的执行顺序，确保高优先级任务优先执行。\n 2. 任务的执行时间长短： 如果你的应用程序包含执行时间长的任务，可以考虑调整线程池的核心线程数和最大线程数。如果执行时间长的任务较多，可能需要增加线程池的最大线程数，以防止任务排队过长。另外，你还可以使用合适的任务拒绝策略来处理执行时间过长的任务，例如CallerRunsPolicy，它可以将任务在调用线程上执行，而不是放入队列等待。\n 3. 任务的性质（CPU密集/IO密集）： 任务的性质决定了线程池的类型。如果任务是CPU密集型，即它们主要消耗CPU资源而不涉及大量的IO操作，可以考虑使用固定大小的线程池，以充分利用CPU核心。对于IO密集型任务，你可以使用可缩放的线程池，允许根据需求自动调整线程数，以最大程度地利用IO等待时间。\n 4. 任务的依赖关系： 如果任务之间存在依赖关系，需要确保线程池能够正确处理这些依赖关系。你可以使用ExecutorCompletionService来等待任务的完成，并按照它们的完成顺序处理结果。另外，如果任务之间存在依赖关系，要确保线程池的线程数足够大，以避免由于等待依赖任务而导致的性能下降。",normalizedContent:"# java线程池为什么不设计成先扩大线程数再加入阻塞队列？\n\n 1. 资源利用率： 在大多数情况下，线程的创建和销毁都比较昂贵。如果每个新任务都立即创建一个新线程，这会导致频繁的线程创建和销毁，浪费系统资源。通过将任务放入阻塞队列，可以将任务排队，以便线程可以重用，从而更有效地利用资源。\n 2. 控制并发度： 通过将任务放入队列，线程池可以更好地控制并发度。线程池可以根据负载和资源情况来决定是否需要创建新线程，以保持合适的并发度。这可以防止系统过载，避免创建过多的线程导致性能下降或资源竞争。\n 3. 避免线程爆炸： 如果不使用阻塞队列，当有大量任务同时到达时，会导致大量线程同时创建，这可能会导致系统的线程数急剧增加，从而增加了上下文切换的开销，甚至可能导致系统崩溃。通过使用阻塞队列，可以平滑地处理任务，避免线程爆炸。\n\n\n# 核心参数\n\npublic threadpoolexecutor(int corepoolsize,\n                              int maximumpoolsize,\n                              long keepalivetime,\n                              timeunit unit,\n                              blockingqueue<runnable> workqueue,\n                              threadfactory threadfactory,\n                              rejectedexecutionhandler handler)\n\n\n\n# 阻塞队列 blockingqueue\n\narrayblockingqueue: 基于数组结构的有界阻塞队列，按fifo排序任务；\n\nlinkedblockingqueue: 基于链表结构的阻塞队列，按fifo排序任务，吞吐量通常要高于arrayblockingqueue；\n\nsynchronousqueue: 一个不存储元素的阻塞队列，每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于linkedblockingqueue；\n\npriorityblockingqueue: 具有优先级的无界阻塞队列；\n\nlinkedblockingqueue比arrayblockingqueue在插入删除节点性能方面更优，但是二者在put(), take()任务的时均需要加锁，synchronousqueue使用无锁算法，根据节点的状态判断执行，而不需要用到锁，其核心是transfer.transfer().\n\n\n# 拒绝策略\n\nabortpolicy: 直接抛出异常，默认策略；\n\ncallerrunspolicy: 用调用者所在的线程来执行任务；\n\ndiscardoldestpolicy: 丢弃阻塞队列中最老的任务，将此任务加入到阻塞队列中；\n\ndiscardpolicy: 直接丢弃任务；\n\n也可以根据应用场景实现rejectedexecutionhandler接口，自定义饱和策略，如记录日志或持久化存储不能处理的任务。\n\n\n# threadfactory\n\nthreadfactory创建线程的工厂，通过自定义的线程工厂可以给每个新建的线程设置一个具有识别度的线程名。默认为executors.defaultthreadfactory()。\n\n\n# 执行过程\n\n 1. 线程池首先当前运行的线程数量是否少于corepoolsize。如果是，则创建一个新的工作线程来执行任务。如果都在执行任务，则进入2.\n\n 2. 判断blockingqueue是否已经满了，倘若还没有满，则将线程放入blockingqueue。否则进入3.\n\n 3. 创建一个新的工作线程，如果使当前运行的线程数量超过maximumpoolsize，则交给rejectedexecutionhandler来处理任务。\n\n\n# 为什么线程池不允许使用executors去创建? 推荐方式是什么?\n\n线程池不允许使用executors去创建，而是通过threadpoolexecutor的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。\n\n说明：executors各个方法的弊端：\n\n * newfixedthreadpool和newsinglethreadexecutor：主要问题是堆积的请求处理队列（linkedblockingqueue<runnable>的无界队列）可能会耗费非常大的内存，甚至oom。\n * newcachedthreadpool和newscheduledthreadpool：主要问题是线程数最大数是integer.max_value，可能会创建数量非常多的线程，甚至oom。\n\n\n# 配置线程池需要考虑因素\n\n从任务的优先级，任务的执行时间长短，任务的性质(cpu密集/ io密集)，任务的依赖关系这四个角度来分析。并且近可能地使用有界的工作队列。\n\n性质不同的任务可用使用不同规模的线程池分开处理:\n\n * cpu密集型: 尽可能少的线程，ncpu+1\n * io密集型: 尽可能多的线程, ncpu*2，比如数据库连接池\n * 混合型: cpu密集型的任务与io密集型任务的执行时间差别较小，否则没有必要拆分。\n\n【待验证】\n\n 1. 任务的优先级： 如果你的应用程序中有不同优先级的任务，可以考虑使用threadpoolexecutor的构造函数中的threadfactory参数来为不同优先级的任务分配不同的线程池。这允许你为高优先级的任务分配更多的线程资源，以确保它们能够及时执行。此外，你还可以使用优先级队列来管理任务的执行顺序，确保高优先级任务优先执行。\n 2. 任务的执行时间长短： 如果你的应用程序包含执行时间长的任务，可以考虑调整线程池的核心线程数和最大线程数。如果执行时间长的任务较多，可能需要增加线程池的最大线程数，以防止任务排队过长。另外，你还可以使用合适的任务拒绝策略来处理执行时间过长的任务，例如callerrunspolicy，它可以将任务在调用线程上执行，而不是放入队列等待。\n 3. 任务的性质（cpu密集/io密集）： 任务的性质决定了线程池的类型。如果任务是cpu密集型，即它们主要消耗cpu资源而不涉及大量的io操作，可以考虑使用固定大小的线程池，以充分利用cpu核心。对于io密集型任务，你可以使用可缩放的线程池，允许根据需求自动调整线程数，以最大程度地利用io等待时间。\n 4. 任务的依赖关系： 如果任务之间存在依赖关系，需要确保线程池能够正确处理这些依赖关系。你可以使用executorcompletionservice来等待任务的完成，并按照它们的完成顺序处理结果。另外，如果任务之间存在依赖关系，要确保线程池的线程数足够大，以避免由于等待依赖任务而导致的性能下降。",charsets:{cjk:!0}},{title:"Future & CompletableFuture",frontmatter:{title:"Future & CompletableFuture",date:"2023-03-31T17:13:50.000Z",permalink:"/pages/9862ed/"},regularPath:"/01.Java/04.Java%E5%B9%B6%E5%8F%91/06.Future%20&%20CompletableFuture.html",relativePath:"01.Java/04.Java并发/06.Future & CompletableFuture.md",key:"v-567fbe26",path:"/pages/9862ed/",headers:[{level:2,title:"Future",slug:"future",normalizedTitle:"future",charIndex:2},{level:2,title:"Future 常见操作",slug:"future-常见操作",normalizedTitle:"future 常见操作",charIndex:449},{level:2,title:"Future 接口方法",slug:"future-接口方法",normalizedTitle:"future 接口方法",charIndex:895},{level:2,title:"CompletableFuture",slug:"completablefuture",normalizedTitle:"completablefuture",charIndex:1095},{level:2,title:"CompletableFuture 常见操作",slug:"completablefuture-常见操作",normalizedTitle:"completablefuture 常见操作",charIndex:1632},{level:3,title:"创建CompletableFuture",slug:"创建completablefuture",normalizedTitle:"创建completablefuture",charIndex:1659},{level:3,title:"处理异步结算的结果",slug:"处理异步结算的结果",normalizedTitle:"处理异步结算的结果",charIndex:2206},{level:3,title:"异常处理",slug:"异常处理",normalizedTitle:"异常处理",charIndex:1598},{level:3,title:"组合CompletableFuture",slug:"组合completablefuture",normalizedTitle:"组合completablefuture",charIndex:2396},{level:3,title:"并行运行多个CompletableFuture",slug:"并行运行多个completablefuture",normalizedTitle:"并行运行多个completablefuture",charIndex:2641},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:2800}],headersStr:"Future Future 常见操作 Future 接口方法 CompletableFuture CompletableFuture 常见操作 创建CompletableFuture 处理异步结算的结果 异常处理 组合CompletableFuture 并行运行多个CompletableFuture 参考",content:"# Future\n\nFuture 模式是多线程开发中非常常见的一种设计模式，它的核心思想是异步调用。\n\n当我们需要调用一个函数方法时，如果这个函数执行的很慢，那么我们就要进行等待。但有时候，我们可能并不急于获取结果。因此，我们可以让被调用者立即返回，让它在后台慢慢处理这个请求。对于调用者来说，则可以先处理一些其他任务，在真正需要数据的场合再去尝试获取需要的数据。\n\n对 Future 模式来说，虽然它无法立即给你需要的数据，但它会给你一个契约，将来你可以凭借这个契约去重新获取你需要的信息。\n\n这里我们主要谈论 JDK 中的 Future 模式，即 java.util.concurrent 包下的 Future 接口。\n\nRunnableFutre 接口：继承了 Future 和 Runnable 两个接口。其中run() 方法用于构造真实的数据。\n\nFutureTask 类：一个具体的实现类。WaitNode 是其内部类。\n\n\n\n图：Diagram for FutureTask\n\n\n# Future 常见操作\n\nExecutorService executor = Executors.newFixedThreadPool(4); \n// 定义任务:\nCallable<String> task = new Task();\n// 提交任务并获得Future:\nFuture<String> future = executor.submit(task);\n// 从Future获取异步执行返回的结果:\nString result = future.get(); // 可能阻塞\n\n\n流程：\n\n 1. 当我们提交一个Callable任务后（Runnable 任务没有返回值），我们会同时获得一个Future对象。\n\n 2. 然后，我们在主线程某个时刻调用Future对象的get()方法，就可以获得异步执行的结果。\n\n 3. 在调用get()时，如果异步任务已经完成，我们就直接获得结果。\n\n 4. 如果异步任务还没有完成，那么get()会阻塞，直到任务完成后才返回结果。\n\n\n# Future 接口方法\n\n一个Future<V>接口表示一个未来可能会返回的结果，它定义的方法有：\n\n * get()：获取结果（可能会等待）\n * get(long timeout, TimeUnit unit)：获取结果，但只等待指定的时间；\n * cancel(boolean mayInterruptIfRunning)：取消当前任务；\n * isDone()：判断任务是否已完成。\n\n\n# CompletableFuture\n\nCompletableFuture 是 Java8 新增的工具类，是增强的 Future。\n\nCompletableFuture 它实现了 Future 接口，还实现了 CompletionStage 接口。\n\nCompletableFuture 除了提供了更为好用和强大的 Future 特性之外，还提供了函数式编程的能力。\n\npublic class CompletableFuture<T> implements Future<T>, CompletionStage<T> {\n}\n\n\nCompletionStage 接口也是 Java8 新增的。而这个接口里有多达40种方法，是为了函数式编程中的流式调用准备的。\n\n通过这个接口，我们可以在一个执行结果上进行多次流式调用。\n\nstage.thenApply(x -> square(x)).thenAccept(x -> System.out.print(x)).thenRun(() -> System.out.println)\n\n\n其功能：\n\n * 完成了就通知\n * 异步执行任务\n * 流式调用\n * 异常处理\n * 组合多个CompletableFuture\n\n\n# CompletableFuture 常见操作\n\n\n# 创建CompletableFuture\n\n常见的创建 CompletableFuture 对象的方法如下：\n\n 1. 通过 new 关键字。\n 2. 基于 CompletableFuture 自带的静态工厂方法：runAsync() 、supplyAsync() 。\n\nCompletableFuture<RpcResponse<Object>> resultFuture = new CompletableFuture<>();\n\nstatic <U> CompletableFuture<U> supplyAsync(Supplier<U> supplier);\n// 使用自定义线程池(推荐)\nstatic <U> CompletableFuture<U> supplyAsync(Supplier<U> supplier, Executor executor);\nstatic CompletableFuture<Void> runAsync(Runnable runnable);\n// 使用自定义线程池(推荐)\nstatic CompletableFuture<Void> runAsync(Runnable runnable, Executor executor);\n\n\n\n\n# 处理异步结算的结果\n\n当我们获取到异步计算的结果之后，还可以对其进行进一步的处理，比较常用的方法有下面几个：\n\n * thenApply()\n * thenAccept()\n * thenRun()\n * whenComplete()\n\n\n# 异常处理\n\n * handle()\n * exceptionally()\n * completeExceptionally()\n\n\n# 组合CompletableFuture\n\n * thenCompose()\n * thenCombine()\n\nthenCompose() 和 thenCombine() 有什么区别呢？\n\n * thenCompose() 可以两个 CompletableFuture 对象，并将前一个任务的返回结果作为下一个任务的参数，它们之间存在着先后顺序。\n * thenCombine() 会在两个任务都执行完成后，把两个任务的结果合并。两个任务是并行执行的，它们之间并没有先后依赖顺序。\n\n\n# 并行运行多个CompletableFuture\n\n * allOf()\n * anyOf()\n\nallOf() 方法会等到所有的 CompletableFuture 都运行完成之后再返回\n\nanyOf() 方法不会等待所有的 CompletableFuture 都运行完成之后再返回，只要有一个执行完成即可！\n\n\n# 参考\n\n[1] 《实战Java高并发程序设计》\n\n[2] 廖雪峰-使用Future\n\n[3] JavaGuide-CompletableFuture入门",normalizedContent:"# future\n\nfuture 模式是多线程开发中非常常见的一种设计模式，它的核心思想是异步调用。\n\n当我们需要调用一个函数方法时，如果这个函数执行的很慢，那么我们就要进行等待。但有时候，我们可能并不急于获取结果。因此，我们可以让被调用者立即返回，让它在后台慢慢处理这个请求。对于调用者来说，则可以先处理一些其他任务，在真正需要数据的场合再去尝试获取需要的数据。\n\n对 future 模式来说，虽然它无法立即给你需要的数据，但它会给你一个契约，将来你可以凭借这个契约去重新获取你需要的信息。\n\n这里我们主要谈论 jdk 中的 future 模式，即 java.util.concurrent 包下的 future 接口。\n\nrunnablefutre 接口：继承了 future 和 runnable 两个接口。其中run() 方法用于构造真实的数据。\n\nfuturetask 类：一个具体的实现类。waitnode 是其内部类。\n\n\n\n图：diagram for futuretask\n\n\n# future 常见操作\n\nexecutorservice executor = executors.newfixedthreadpool(4); \n// 定义任务:\ncallable<string> task = new task();\n// 提交任务并获得future:\nfuture<string> future = executor.submit(task);\n// 从future获取异步执行返回的结果:\nstring result = future.get(); // 可能阻塞\n\n\n流程：\n\n 1. 当我们提交一个callable任务后（runnable 任务没有返回值），我们会同时获得一个future对象。\n\n 2. 然后，我们在主线程某个时刻调用future对象的get()方法，就可以获得异步执行的结果。\n\n 3. 在调用get()时，如果异步任务已经完成，我们就直接获得结果。\n\n 4. 如果异步任务还没有完成，那么get()会阻塞，直到任务完成后才返回结果。\n\n\n# future 接口方法\n\n一个future<v>接口表示一个未来可能会返回的结果，它定义的方法有：\n\n * get()：获取结果（可能会等待）\n * get(long timeout, timeunit unit)：获取结果，但只等待指定的时间；\n * cancel(boolean mayinterruptifrunning)：取消当前任务；\n * isdone()：判断任务是否已完成。\n\n\n# completablefuture\n\ncompletablefuture 是 java8 新增的工具类，是增强的 future。\n\ncompletablefuture 它实现了 future 接口，还实现了 completionstage 接口。\n\ncompletablefuture 除了提供了更为好用和强大的 future 特性之外，还提供了函数式编程的能力。\n\npublic class completablefuture<t> implements future<t>, completionstage<t> {\n}\n\n\ncompletionstage 接口也是 java8 新增的。而这个接口里有多达40种方法，是为了函数式编程中的流式调用准备的。\n\n通过这个接口，我们可以在一个执行结果上进行多次流式调用。\n\nstage.thenapply(x -> square(x)).thenaccept(x -> system.out.print(x)).thenrun(() -> system.out.println)\n\n\n其功能：\n\n * 完成了就通知\n * 异步执行任务\n * 流式调用\n * 异常处理\n * 组合多个completablefuture\n\n\n# completablefuture 常见操作\n\n\n# 创建completablefuture\n\n常见的创建 completablefuture 对象的方法如下：\n\n 1. 通过 new 关键字。\n 2. 基于 completablefuture 自带的静态工厂方法：runasync() 、supplyasync() 。\n\ncompletablefuture<rpcresponse<object>> resultfuture = new completablefuture<>();\n\nstatic <u> completablefuture<u> supplyasync(supplier<u> supplier);\n// 使用自定义线程池(推荐)\nstatic <u> completablefuture<u> supplyasync(supplier<u> supplier, executor executor);\nstatic completablefuture<void> runasync(runnable runnable);\n// 使用自定义线程池(推荐)\nstatic completablefuture<void> runasync(runnable runnable, executor executor);\n\n\n\n\n# 处理异步结算的结果\n\n当我们获取到异步计算的结果之后，还可以对其进行进一步的处理，比较常用的方法有下面几个：\n\n * thenapply()\n * thenaccept()\n * thenrun()\n * whencomplete()\n\n\n# 异常处理\n\n * handle()\n * exceptionally()\n * completeexceptionally()\n\n\n# 组合completablefuture\n\n * thencompose()\n * thencombine()\n\nthencompose() 和 thencombine() 有什么区别呢？\n\n * thencompose() 可以两个 completablefuture 对象，并将前一个任务的返回结果作为下一个任务的参数，它们之间存在着先后顺序。\n * thencombine() 会在两个任务都执行完成后，把两个任务的结果合并。两个任务是并行执行的，它们之间并没有先后依赖顺序。\n\n\n# 并行运行多个completablefuture\n\n * allof()\n * anyof()\n\nallof() 方法会等到所有的 completablefuture 都运行完成之后再返回\n\nanyof() 方法不会等待所有的 completablefuture 都运行完成之后再返回，只要有一个执行完成即可！\n\n\n# 参考\n\n[1] 《实战java高并发程序设计》\n\n[2] 廖雪峰-使用future\n\n[3] javaguide-completablefuture入门",charsets:{cjk:!0}},{title:"从线程到Java的锁机制",frontmatter:{title:"从线程到Java的锁机制",date:"2023-04-03T14:21:57.000Z",permalink:"/pages/646254/"},regularPath:"/01.Java/04.Java%E5%B9%B6%E5%8F%91/07.%E4%BB%8E%E7%BA%BF%E7%A8%8B%E5%88%B0Java%E7%9A%84%E9%94%81%E6%9C%BA%E5%88%B6.html",relativePath:"01.Java/04.Java并发/07.从线程到Java的锁机制.md",key:"v-0ba27c18",path:"/pages/646254/",headers:[{level:2,title:"什么是线程？什么是进程？",slug:"什么是线程-什么是进程",normalizedTitle:"什么是线程？什么是进程？",charIndex:2},{level:2,title:"线程的缺点有什么？",slug:"线程的缺点有什么",normalizedTitle:"线程的缺点有什么？",charIndex:386},{level:2,title:"有了进程为什么还要线程？",slug:"有了进程为什么还要线程",normalizedTitle:"有了进程为什么还要线程？",charIndex:658},{level:2,title:"有了线程为什么要有进程？",slug:"有了线程为什么要有进程",normalizedTitle:"有了线程为什么要有进程？",charIndex:1127},{level:2,title:"线程间的内存是共享的吗？",slug:"线程间的内存是共享的吗",normalizedTitle:"线程间的内存是共享的吗？",charIndex:1590},{level:2,title:"Java中的锁机制",slug:"java中的锁机制",normalizedTitle:"java中的锁机制",charIndex:1975},{level:2,title:"ReentranLock是悲观锁还是乐观锁？",slug:"reentranlock是悲观锁还是乐观锁",normalizedTitle:"reentranlock是悲观锁还是乐观锁？",charIndex:2959},{level:2,title:"悲观锁和乐观锁的区别",slug:"悲观锁和乐观锁的区别",normalizedTitle:"悲观锁和乐观锁的区别",charIndex:3349},{level:2,title:"Java中乐观锁的实现",slug:"java中乐观锁的实现",normalizedTitle:"java中乐观锁的实现",charIndex:3862},{level:3,title:"CAS（Compare And Swap）实现乐观锁",slug:"cas-compare-and-swap-实现乐观锁",normalizedTitle:"cas（compare and swap）实现乐观锁",charIndex:3911},{level:3,title:"版本号实现乐观锁",slug:"版本号实现乐观锁",normalizedTitle:"版本号实现乐观锁",charIndex:4165},{level:2,title:"Java中乐观锁的类",slug:"java中乐观锁的类",normalizedTitle:"java中乐观锁的类",charIndex:4416},{level:2,title:"Spring中的乐观锁",slug:"spring中的乐观锁",normalizedTitle:"spring中的乐观锁",charIndex:4827},{level:2,title:"MySQL支持版本号和时间戳字段",slug:"mysql支持版本号和时间戳字段",normalizedTitle:"mysql支持版本号和时间戳字段",charIndex:5263},{level:2,title:"Spring @Version 案例",slug:"spring-version-案例",normalizedTitle:"spring @version 案例",charIndex:6477},{level:2,title:"AQS",slug:"aqs",normalizedTitle:"aqs",charIndex:7630},{level:2,title:"AQS实现Reentrantlock",slug:"aqs实现reentrantlock",normalizedTitle:"aqs实现reentrantlock",charIndex:8491},{level:2,title:"理解AQS中的acquire方法",slug:"理解aqs中的acquire方法",normalizedTitle:"理解aqs中的acquire方法",charIndex:10548},{level:2,title:"什么是中断",slug:"什么是中断",normalizedTitle:"什么是中断",charIndex:11458},{level:2,title:"自我中断",slug:"自我中断",normalizedTitle:"自我中断",charIndex:11432}],headersStr:"什么是线程？什么是进程？ 线程的缺点有什么？ 有了进程为什么还要线程？ 有了线程为什么要有进程？ 线程间的内存是共享的吗？ Java中的锁机制 ReentranLock是悲观锁还是乐观锁？ 悲观锁和乐观锁的区别 Java中乐观锁的实现 CAS（Compare And Swap）实现乐观锁 版本号实现乐观锁 Java中乐观锁的类 Spring中的乐观锁 MySQL支持版本号和时间戳字段 Spring @Version 案例 AQS AQS实现Reentrantlock 理解AQS中的acquire方法 什么是中断 自我中断",content:'# 什么是线程？什么是进程？\n\n线程和进程是操作系统中的两个重要概念，它们都是并发执行的基本单位。\n\n进程是程序的一次执行过程，是操作系统资源分配的基本单位，每个进程都有独立的地址空间、文件描述符、信号处理和状态等信息。进程可以创建子进程，不同进程之间的通信需要使用进程间通信机制。\n\n线程是进程中的一个执行单元，是程序执行的最小单位，每个线程共享进程的地址空间、文件描述符和其他资源。线程在同一进程内执行，可以访问共享数据，因此需要使用同步机制来避免资源竞争。线程之间的切换比进程之间的切换更快，因为线程共享进程的地址空间和其他资源，不需要进行资源的复制和切换。\n\n总的来说，进程和线程都是操作系统中并发执行的基本单位，但进程之间的隔离性更强，资源消耗更大，线程之间的切换更快，共享资源更多。在编写程序时，需要根据具体的需求选择使用进程还是线程来实现并发执行。\n\n\n# 线程的缺点有什么？\n\n * 频繁的上下文切换：当一个线程需要访问共享资源时，其他线程可能会被挂起，这会导致大量的上下文切换，降低了系统的性能。\n * 资源竞争：多个线程访问同一共享资源时，可能会导致资源竞争和死锁问题，需要使用同步机制来解决。\n * 内存占用：每个线程都需要一定的栈空间和线程控制块等资源，当创建大量线程时，可能会导致内存占用过高。\n * 可靠性问题：线程之间的错误和异常可能会导致整个程序崩溃，因此需要小心地编写和管理线程代码。\n * 复杂性问题：线程编程需要考虑线程之间的交互和同步，增加了程序的复杂性和维护难度。\n\n\n# 有了进程为什么还要线程？\n\n虽然进程是操作系统资源分配的基本单位，但是线程比进程更轻量级，执行速度更快，因此线程在并发编程中有以下优势：\n\n * 更快的切换：线程之间的切换比进程之间的切换更快，因为线程共享进程的地址空间和其他资源，不需要进行资源的复制和切换。这意味着在需要大量并发执行的场景下，使用线程可以更有效地利用计算资源。\n * 更低的资源消耗：每个进程都需要独立的地址空间、文件描述符和其他资源，因此进程的资源消耗比线程更大。使用线程可以减少系统资源的占用，提高系统的性能。\n * 更好的通信和同步：线程共享进程的地址空间和其他资源，因此线程之间的通信和同步更容易实现。在多线程编程中，可以使用锁、信号量、条件变量等同步机制来协调线程之间的执行。\n * 更容易实现并发编程：使用线程可以更容易地实现并发编程，因为线程可以利用多核处理器并行执行任务，而不需要手动编写复杂的进程间通信代码。\n\n总之，尽管进程和线程都可以实现并发编程，但是线程更适合于需要高效利用计算资源的场景，更容易实现通信和同步，并且编写起来更加简单。\n\n\n# 有了线程为什么要有进程？\n\n虽然线程比进程更轻量级，但是进程在操作系统中仍然扮演着至关重要的角色，有以下几个方面的优势：\n\n * 更强的隔离性：每个进程都有独立的地址空间、文件描述符、信号处理和状态等信息，因此不同进程之间的代码和数据是相互隔离的。这样可以保证程序的安全性和稳定性，避免因为一个进程的崩溃导致整个系统崩溃。\n * 更好的可靠性：进程之间的错误和异常可以被隔离，避免一个进程的错误影响其他进程的正常运行。此外，进程可以使用操作系统提供的监控机制来检测和恢复错误，增强程序的可靠性和稳定性。\n * 更多的编程模型：进程可以使用多种编程模型来实现并发编程，包括多进程模型、多线程模型和协程模型等。这些模型可以根据不同的需求选择使用，从而实现更加灵活的编程。\n * 更多的资源：每个进程都可以拥有独立的资源，包括文件、端口、socket等。这些资源可以被不同的进程所共享，从而实现更加灵活的资源管理。\n\n虽然线程比进程更轻量级，但是进程仍然是操作系统中不可或缺的概念，可以提供更好的隔离性、可靠性和编程模型。\n\n\n# 线程间的内存是共享的吗？\n\n是的，线程之间的内存是共享的。在同一个进程中的所有线程共享同一份地址空间，这意味着它们可以直接访问同一份内存，包括全局变量、静态变量、动态分配的内存和堆栈等。\n\n因此，在多线程编程中，需要特别注意线程间的内存访问，以避免出现数据竞争等问题。如果多个线程同时读写同一块内存，可能会导致数据的不一致，这称为竞态条件。为了避免这种情况，需要使用同步机制来协调线程之间的访问，比如使用锁、信号量、条件变量等。\n\n此外，在多线程编程中，还需要注意线程之间的内存可见性。如果一个线程修改了一块内存，其他线程可能无法立即看到这个修改。为了解决这个问题，需要使用同步机制来确保内存可见性，比如使用volatile变量、memory barrier等。\n\n总之，线程之间的内存是共享的，需要特别注意线程之间的内存访问和同步，以确保程序的正确性和性能。\n\n\n# Java中的锁机制\n\nJava中的锁机制主要包括以下几种：\n\n * synchronized关键字：synchronized是Java中最基本的锁机制，它可以实现对代码块、方法或者对象的同步访问。synchronized关键字可以保证在同一时刻只有一个线程可以进入被锁定的代码块或方法，从而避免线程间的数据竞争。\n\n * ReentrantLock类：ReentrantLock是Java中的一个可重入锁，它提供了与synchronized相似的锁机制，但是更加灵活和可扩展。与synchronized不同的是，ReentrantLock可以实现公平锁和非公平锁，可以支持多个条件变量等高级特性。\n\n * ReadWriteLock接口：ReadWriteLock是Java中的一个读写锁接口，它可以实现对共享数据的读写分离。ReadWriteLock允许多个线程同时读取共享数据，但是只允许一个线程写入共享数据，从而避免了读写之间的竞态条件。\n\n * StampedLock类：StampedLock是Java中的一个乐观读写锁，它提供了对共享数据的读写访问，并支持无锁CAS操作。StampedLock的乐观读取机制可以避免读写冲突的情况下使用悲观锁带来的性能损失。\n\n * CountDownLatch类：CountDownLatch是Java中的一个倒计时锁，它可以让一个线程等待多个线程执行完毕之后再继续执行。CountDownLatch的计数器初始值可以设置为多少个线程，当每个线程执行完毕后就会递减计数器，当计数器为0时，等待的线程就会被唤醒。\n\n * Semaphore类：Semaphore是Java中的一个信号量，它可以限制多个线程对资源的访问。Semaphore的计数器可以指定多少个线程可以同时访问资源，当线程访问完毕之后，计数器会自动递增。\n\n * Exchanger类：Exchanger是Java中的一个线程间交换数据的工具类，它可以让两个线程交换彼此的数据。Exchanger可以用于解决线程之间的数据交换问题，例如数据传输、缓存池等场景。\n\n除了以上列举的锁机制，Java中还有一些其他的并发工具类，如Semaphore、CyclicBarrier、LockSupport等，它们可以帮助我们更加方便和高效地实现多线程编程。\n\n\n# ReentranLock是悲观锁还是乐观锁？\n\nReentrantLock 是属于悲观锁的范畴。\n\n悲观锁是一种保守的锁策略，它在使用锁之前总是假设有其他线程正在使用该共享资源，并且在加锁后直到解锁前都会占用锁，阻止其他线程访问该共享资源。这种策略的优点是可以有效避免并发访问的冲突，但同时也会带来一定的开销。\n\nReentrantLock 在进行加锁操作时，会尝试获取锁，如果当前没有其他线程持有该锁，则会成功获取并占用锁，如果有其他线程持有该锁，则当前线程会被阻塞，等待其他线程释放锁。由于 ReentrantLock 可以重入，即同一个线程可以多次获取同一个锁而不会造成死锁，所以它的命名中包含了 "Reentrant"（可重入）这一词汇。\n\n与乐观锁不同，悲观锁的主要特点是在访问共享资源之前，总是先获取锁，因此 ReentrantLock 不属于乐观锁的范畴。\n\n\n# 悲观锁和乐观锁的区别\n\n悲观锁和乐观锁是两种并发控制的策略，它们的区别如下：\n\n * 性能差异：悲观锁在使用锁之前总是假设有其他线程正在使用该共享资源，并且在加锁后直到解锁前都会占用锁，阻止其他线程访问该共享资源。这种策略的优点是可以有效避免并发访问的冲突，但同时也会带来一定的开销。乐观锁则假设并发冲突不会发生，直接进行并发操作，如果发现冲突则进行回滚或重试。因此，乐观锁的性能一般比悲观锁要好。\n * 实现方式：悲观锁的实现方式通常是使用 synchronized、ReentrantLock 等锁机制，而乐观锁的实现方式通常是使用 CAS（Compare And Swap）等乐观并发控制机制。\n * 冲突解决方式：悲观锁在加锁期间，阻止其他线程访问共享资源，从而避免并发冲突。乐观锁则假设并发冲突不会发生，在操作结束后才会检查并发冲突，如果发现冲突则进行回滚或重试。\n * 应用场景：悲观锁适用于并发冲突概率较高的场景，例如在高并发访问数据库时，由于每次访问需要获取独占锁，因此悲观锁的效果会比较好。而乐观锁适用于并发冲突概率较低的场景，例如在单机多线程环境下，由于并发冲突概率较低，使用乐观锁可以提高性能。\n\n\n# Java中乐观锁的实现\n\n在 Java 中，乐观锁主要有两种实现方式：CAS 和版本号。\n\n\n# CAS（Compare And Swap）实现乐观锁\n\nCAS 是一种乐观锁的实现方式，它使用原子性操作来实现并发控制。CAS 操作需要提供要更新的变量的值、预期值和新值，如果当前变量的值等于预期值，就使用新值更新变量并返回 true，否则不做任何操作并返回 false。\n\nJava 中的 AtomicInteger 和 AtomicLong 类就是使用 CAS 实现乐观锁的典型例子。使用 CAS 实现乐观锁时，需要注意 CAS 操作可能会出现 ABA 问题，需要额外的处理措施来解决这个问题。\n\n\n# 版本号实现乐观锁\n\n另一种实现乐观锁的方式是通过版本号实现。在实现版本号乐观锁时，每个共享数据都有一个版本号，每次更新时都需要比较当前版本号和要更新的数据的版本号，如果一致，则更新成功，并增加版本号，否则更新失败。\n\n在 Java 中，实现版本号乐观锁可以使用 AtomicStampedReference 类，它可以对一个对象的引用和版本号进行原子操作。使用 AtomicStampedReference 时需要注意，每次更新时需要同时更新对象引用和版本号，否则可能会出现数据不一致的问题。\n\n\n# Java中乐观锁的类\n\nJava中乐观锁的实现类包括：\n\n * Atomic 包下的原子类：例如 AtomicInteger、AtomicLong、AtomicReference 等，这些类提供了原子性的操作方法，可以实现乐观锁机制。\n\n * CAS（Compare and Swap）：CAS 是乐观锁的一种实现方式，Java 中提供了 sun.misc.Unsafe 类的 compareAndSwapXXX() 方法，可以用于实现 CAS 操作。\n\n * 乐观锁框架：Java 中有一些开源的乐观锁框架，例如 JPA 的乐观锁、Spring 中的乐观锁等，这些框架封装了乐观锁的实现细节，使得开发者可以更方便地使用乐观锁机制。\n\n需要注意的是，在使用乐观锁时需要特别关注并发冲突的处理，因为乐观锁不会阻塞其他线程，所以可能会出现多个线程同时进行修改导致冲突的情况，这时需要使用一些特殊的算法或者技术来解决。\n\n\n# Spring中的乐观锁\n\nSpring 中提供了两种乐观锁实现方式：\n\n * 基于版本号（Version）的乐观锁：该实现方式是通过为每条记录增加一个版本号字段，在更新记录时比较版本号是否一致来判断是否发生了并发冲突。在 Spring 中，可以通过 @Version 注解来指定版本号字段，同时在执行更新操作时，Spring 会自动检查版本号并进行并发冲突检测和处理。\n * 基于时间戳（Timestamp）的乐观锁：该实现方式是通过为每条记录增加一个时间戳字段，在更新记录时比较时间戳是否一致来判断是否发生了并发冲突。在 Spring 中，可以通过 @Timestamp 注解来指定时间戳字段，同时在执行更新操作时，Spring 会自动检查时间戳并进行并发冲突检测和处理。\n\n需要注意的是，在使用 Spring 的乐观锁机制时，需要确保数据库中支持乐观锁实现所需要的版本号或时间戳字段，同时需要特别关注并发冲突的处理，确保在并发访问时不会发生数据不一致的情况。\n\n\n# MySQL支持版本号和时间戳字段\n\n 1. 基于版本号的乐观锁：在 MySQL 中，可以使用 INT 或 BIGINT 类型的字段作为版本号字段，并在更新记录时，使用 WHERE 子句限制版本号相同的记录才能被更新，从而实现乐观锁控制。\n    \n    例如，创建一个包含版本号的表：\n\nCREATE TABLE `user` (\n  `id` bigint(20) NOT NULL AUTO_INCREMENT,\n  `name` varchar(255) DEFAULT NULL,\n  `age` int(11) DEFAULT NULL,\n  `version` int(11) DEFAULT 0,\n  PRIMARY KEY (`id`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n\n\n在更新记录时，使用类似以下的 SQL 语句进行版本号的比较和更新：\n\nUPDATE `user` SET `age` = #{age}, `version` = `version` + 1 WHERE `id` = #{id} AND `version` = #{version};\n\n\n其中，#{id} 和 #{version} 分别表示需要更新的记录的 ID 和版本号，#{age} 表示需要更新的年龄值。\n\n 2. 基于时间戳的乐观锁：在 MySQL 中，可以使用 TIMESTAMP 或 DATETIME 类型的字段作为时间戳字段，并在更新记录时，使用 WHERE 子句限制时间戳相同的记录才能被更新，从而实现乐观锁控制。\n\n例如，创建一个包含时间戳的表：\n\nCREATE TABLE `user` (\n  `id` bigint(20) NOT NULL AUTO_INCREMENT,\n  `name` varchar(255) DEFAULT NULL,\n  `age` int(11) DEFAULT NULL,\n  `update_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,\n  PRIMARY KEY (`id`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n\n\n在更新记录时，使用类似以下的 SQL 语句进行时间戳的比较和更新：\n\nUPDATE `user` SET `age` = #{age}, `update_time` = #{updateTime} WHERE `id` = #{id} AND `update_time` = #{updateTime};\n\n\n其中，#{id} 和 #{updateTime} 分别表示需要更新的记录的 ID 和时间戳，#{age} 表示需要更新的年龄值。\n\n\n# Spring @Version 案例\n\n@Version 注解可以用于指定实体类中的版本号字段，以便在更新操作时进行乐观锁控制。下面是一个简单的示例：\n\n假设我们有一个 User 实体类，其中包含了一个 version 字段表示版本号，可以使用 @Version 注解来标识：\n\n@Entity\n@Table(name = "user")\npublic class User {\n\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    private Long id;\n\n    @Column(name = "name")\n    private String name;\n\n    @Column(name = "age")\n    private Integer age;\n\n    @Version\n    @Column(name = "version")\n    private Integer version;\n    \n    // getter and setter methods\n}\n\n\n在进行更新操作时，可以通过调用 Spring Data JPA 提供的 save() 方法来实现乐观锁控制。例如：\n\n@Service\npublic class UserService {\n\n    @Autowired\n    private UserRepository userRepository;\n\n    public void update(User user) {\n        userRepository.save(user);\n    }\n}\n\n\n当调用 update() 方法更新 User 实体时，Spring Data JPA 会自动检查 version 字段的值是否与数据库中的一致，如果一致则执行更新操作，否则抛出 OptimisticLockException 异常。例如：\n\nUser user = userRepository.findById(1L).orElseThrow();\nuser.setAge(30);\nuserService.update(user);\n\n\n在上述代码中，首先通过 UserRepository 查询到 ID 为 1 的 User 实体，并将其年龄修改为 30。接着，调用 UserService 的 update() 方法进行更新操作，此时 Spring Data JPA 会检查 user 实体的 version 字段是否与数据库中的一致，如果一致则执行更新操作，否则抛出 OptimisticLockException 异常。\n\n\n# AQS\n\nAQS（AbstractQueuedSynchronizer）是 Java 并发包中锁和同步器的核心实现，它通过一个双向队列和一个整形状态值来管理同步状态，并提供了 acquire 和 release 两个主要的同步操作。\n\nAQS 内部维护了一个类似于双向链表的队列，队列中的节点表示正在等待获取锁的线程。当一个线程尝试获取锁时，如果锁已经被其他线程占用，则该线程会被加入到队列的末尾，并被阻塞。当锁的占用者释放锁时，AQS 会将队列头部的线程唤醒，并让其尝试获取锁。\n\nAQS 内部的状态值可以用来表示锁的占用状态，同时也可以被子类用来表示自定义的同步状态。在使用 AQS 实现同步器时，一般需要继承 AQS 类，并通过实现 tryAcquire、tryRelease 等方法来实现同步器的加锁和释放锁操作，同时需要根据具体需求覆盖 AQS 中的一些方法来实现自定义的同步策略。\n\nAQS 内部的核心方法有以下几个：\n\n * acquire(int arg): 尝试获取锁，如果获取失败则阻塞等待。\n\n * release(int arg): 释放锁，并唤醒等待队列中的一个线程。\n\n * tryAcquire(int arg): 尝试获取锁，返回 true 表示获取成功，返回 false 表示获取失败。\n\n * tryRelease(int arg): 尝试释放锁，返回 true 表示释放成功，返回 false 表示释放失败。\n\n * tryAcquireShared(int arg): 尝试获取共享锁，返回值的含义与 tryAcquire 相同。\n\n * tryReleaseShared(int arg): 尝试释放共享锁，返回值的含义与 tryRelease 相同。\n\nAQS 是 Java 并发包中锁和同步器的核心实现，使用 AQS 实现同步器时需要对 AQS 的原理和机制有一定的了解，才能保证实现的正确性和高效性。同时，使用 AQS 实现同步器需要谨慎，否则容易出现死锁等问题。\n\n\n# AQS实现Reentrantlock\n\nimport java.util.concurrent.locks.AbstractQueuedSynchronizer;\n\npublic class ReentrantLock extends AbstractQueuedSynchronizer {\n    private Thread ownerThread;\n    private int lockCount;\n\n    public ReentrantLock() {\n        ownerThread = null;\n        lockCount = 0;\n    }\n\n    @Override\n    protected boolean tryAcquire(int arg) {\n        Thread currentThread = Thread.currentThread();\n        int c = getState();\n        if (c == 0) {\n            if (compareAndSetState(0, arg)) {\n                ownerThread = currentThread;\n                lockCount++;\n                return true;\n            }\n        } else if (currentThread == ownerThread) {\n            setState(c + arg);\n            lockCount++;\n            return true;\n        }\n        return false;\n    }\n\n    @Override\n    protected boolean tryRelease(int arg) {\n        Thread currentThread = Thread.currentThread();\n        if (currentThread != ownerThread) {\n            throw new IllegalMonitorStateException("Not owner thread");\n        }\n\n        int c = getState() - arg;\n        boolean free = false;\n        if (c == 0) {\n            free = true;\n            ownerThread = null;\n        }\n        setState(c);\n        if (free) {\n            release();\n        }\n        return true;\n    }\n\n    public void lock() {\n        acquire(1);\n    }\n\n    public void unlock() {\n        release(1);\n    }\n}\n\n\n在上面的示例代码中，我们自定义了一个 ReentrantLock 类，继承了 AbstractQueuedSynchronizer 类。\n\n这个类是 AQS 提供的基类，我们可以通过继承这个类来实现自定义的同步器。\n\n在这个类中，我们定义了 ownerThread 和 lockCount 两个变量来记录当前线程和当前线程获取锁的次数。我们重写了 tryAcquire 和 tryRelease 方法来实现获取锁和释放锁的逻辑。\n\n在 tryAcquire 方法中，首先判断当前线程是否已经获取了锁，如果已经获取了锁则直接增加 lockCount。否则，我们尝试使用 compareAndSetState 方法来更新状态值。如果更新成功，则将当前线程记录为 ownerThread，同时将 lockCount 设置为 1。\n\n在 tryRelease 方法中，首先判断当前线程是否为 ownerThread，如果不是则抛出异常。然后根据传入的参数来计算新的状态值，如果状态值为 0，则将 ownerThread 设置为 null，表示当前线程已经释放了锁。最后，我们调用 release 方法来释放同步状态。\n\n我们还定义了 lock 和 unlock 方法，分别用于获取锁和释放锁。在这些方法中，我们直接调用 acquire 和 release 方法来实现获取锁和释放锁的逻辑。acquire 和 release 在 AQS 中就会去调用 tryAcquire 和 tryRelease，从而执行我们重写的逻辑。\n\n\n# 理解AQS中的acquire方法\n\nacquire() 是 AQS 中的方法之一，用于获取锁，其内部实现包括以下几个步骤：\n\n 1. 调用 tryAcquire() 方法尝试获取锁，如果成功，则直接返回。\n 2. 如果 tryAcquire() 方法返回失败，将当前线程包装成节点（Node）并加入到等待队列中（即 waiters 队列），并将该线程阻塞。\n 3. 当锁被释放时，会调用 release() 方法释放锁，该方法会唤醒等待队列中的第一个线程（即队头节点），并将其从队列中移除。\n\n通过上述步骤，acquire() 方法可以实现获取锁的操作，同时能够保证多线程下的安全性。\n\n这段代码是 AQS 中 acquire(int arg) 方法的实现：\n\npublic final void acquire(int arg) {\n        if (!tryAcquire(arg) &&\n            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))\n            selfInterrupt();\n}\n\n\n 1. 第一行代码中的 tryAcquire(arg) 是尝试获取锁，如果返回成功，则直接返回，这是一个快速路径，可以避免创建节点和加入等待队列等操作，提高了性能。\n 2. 如果快速路径失败，就需要进入到慢速路径。其中，addWaiter(Node.EXCLUSIVE) 将当前线程封装成节点并添加到等待队列的尾部，同时返回该节点。\n 3. acquireQueued(Node node, int arg) 是尝试获取锁的核心方法，它会让当前线程进入等待队列并等待锁的释放，直到它成功获取锁为止。当获取锁失败时，该方法会将线程挂起并等待锁的释放，同时处理多线程之间的竞争关系。该方法返回一个布尔值，表示当前线程是否需要被阻塞。\n 4. 当 acquireQueued() 方法返回 true 时，说明当前线程已经被阻塞，需要被唤醒，同时需要调用 selfInterrupt() 方法自我中断，保证在被唤醒后能够及时处理中断。\n\n\n# 什么是中断\n\n中断（interrupt）是指一个线程请求中止另一个正在运行的线程的执行。当一个线程请求中止另一个线程时，通常会将一个信号发送给目标线程，让其停止正在执行的任务并进行清理工作。\n\nJava中的中断机制是一种协作式机制，即线程需要配合才能实现中断。当一个线程调用另一个线程的 interrupt() 方法时，目标线程会收到一个中断请求，并设置一个中断状态，通知目标线程中断请求的发生。目标线程可以通过检查自身的中断状态来响应中断请求，通常的做法是在适当的时候抛出 InterruptedException 异常，并在异常处理中进行清理工作。\n\n需要注意的是，中断机制并不能强制终止一个线程的执行。线程可以在任何时刻检查自身的中断状态，并自行决定是否响应中断请求。另外，如果线程没有执行可中断的操作，例如忙等待或者死循环，那么中断请求是无法起作用的，线程仍然会一直执行下去。因此，在编写多线程程序时，需要注意避免使用忙等待和死循环等操作，以便能够及时响应中断请求。\n\n\n# 自我中断\n\n自我中断指的是线程在等待锁的过程中，被中断的情况。在 Java 中，可以使用 Thread.interrupt() 方法对一个线程进行中断操作，这时线程就会被设置为中断状态，然后由线程自己决定如何处理中断。\n\n在 AQS 中，如果一个线程在等待锁的过程中被中断，就会触发自我中断操作。这时，AQS 会在等待队列中找到该线程对应的节点，并将其标记为已中断，然后在下一次调用 acquire() 方法时，会抛出 InterruptedException 异常。这样，线程就可以在等待锁的过程中响应中断，避免因长时间等待锁而导致线程无法退出的问题。\n\n在 AQS 中，自我中断通常与阻塞式同步器（例如 ReentrantLock）配合使用，可以有效提高多线程程序的响应能力。',normalizedContent:'# 什么是线程？什么是进程？\n\n线程和进程是操作系统中的两个重要概念，它们都是并发执行的基本单位。\n\n进程是程序的一次执行过程，是操作系统资源分配的基本单位，每个进程都有独立的地址空间、文件描述符、信号处理和状态等信息。进程可以创建子进程，不同进程之间的通信需要使用进程间通信机制。\n\n线程是进程中的一个执行单元，是程序执行的最小单位，每个线程共享进程的地址空间、文件描述符和其他资源。线程在同一进程内执行，可以访问共享数据，因此需要使用同步机制来避免资源竞争。线程之间的切换比进程之间的切换更快，因为线程共享进程的地址空间和其他资源，不需要进行资源的复制和切换。\n\n总的来说，进程和线程都是操作系统中并发执行的基本单位，但进程之间的隔离性更强，资源消耗更大，线程之间的切换更快，共享资源更多。在编写程序时，需要根据具体的需求选择使用进程还是线程来实现并发执行。\n\n\n# 线程的缺点有什么？\n\n * 频繁的上下文切换：当一个线程需要访问共享资源时，其他线程可能会被挂起，这会导致大量的上下文切换，降低了系统的性能。\n * 资源竞争：多个线程访问同一共享资源时，可能会导致资源竞争和死锁问题，需要使用同步机制来解决。\n * 内存占用：每个线程都需要一定的栈空间和线程控制块等资源，当创建大量线程时，可能会导致内存占用过高。\n * 可靠性问题：线程之间的错误和异常可能会导致整个程序崩溃，因此需要小心地编写和管理线程代码。\n * 复杂性问题：线程编程需要考虑线程之间的交互和同步，增加了程序的复杂性和维护难度。\n\n\n# 有了进程为什么还要线程？\n\n虽然进程是操作系统资源分配的基本单位，但是线程比进程更轻量级，执行速度更快，因此线程在并发编程中有以下优势：\n\n * 更快的切换：线程之间的切换比进程之间的切换更快，因为线程共享进程的地址空间和其他资源，不需要进行资源的复制和切换。这意味着在需要大量并发执行的场景下，使用线程可以更有效地利用计算资源。\n * 更低的资源消耗：每个进程都需要独立的地址空间、文件描述符和其他资源，因此进程的资源消耗比线程更大。使用线程可以减少系统资源的占用，提高系统的性能。\n * 更好的通信和同步：线程共享进程的地址空间和其他资源，因此线程之间的通信和同步更容易实现。在多线程编程中，可以使用锁、信号量、条件变量等同步机制来协调线程之间的执行。\n * 更容易实现并发编程：使用线程可以更容易地实现并发编程，因为线程可以利用多核处理器并行执行任务，而不需要手动编写复杂的进程间通信代码。\n\n总之，尽管进程和线程都可以实现并发编程，但是线程更适合于需要高效利用计算资源的场景，更容易实现通信和同步，并且编写起来更加简单。\n\n\n# 有了线程为什么要有进程？\n\n虽然线程比进程更轻量级，但是进程在操作系统中仍然扮演着至关重要的角色，有以下几个方面的优势：\n\n * 更强的隔离性：每个进程都有独立的地址空间、文件描述符、信号处理和状态等信息，因此不同进程之间的代码和数据是相互隔离的。这样可以保证程序的安全性和稳定性，避免因为一个进程的崩溃导致整个系统崩溃。\n * 更好的可靠性：进程之间的错误和异常可以被隔离，避免一个进程的错误影响其他进程的正常运行。此外，进程可以使用操作系统提供的监控机制来检测和恢复错误，增强程序的可靠性和稳定性。\n * 更多的编程模型：进程可以使用多种编程模型来实现并发编程，包括多进程模型、多线程模型和协程模型等。这些模型可以根据不同的需求选择使用，从而实现更加灵活的编程。\n * 更多的资源：每个进程都可以拥有独立的资源，包括文件、端口、socket等。这些资源可以被不同的进程所共享，从而实现更加灵活的资源管理。\n\n虽然线程比进程更轻量级，但是进程仍然是操作系统中不可或缺的概念，可以提供更好的隔离性、可靠性和编程模型。\n\n\n# 线程间的内存是共享的吗？\n\n是的，线程之间的内存是共享的。在同一个进程中的所有线程共享同一份地址空间，这意味着它们可以直接访问同一份内存，包括全局变量、静态变量、动态分配的内存和堆栈等。\n\n因此，在多线程编程中，需要特别注意线程间的内存访问，以避免出现数据竞争等问题。如果多个线程同时读写同一块内存，可能会导致数据的不一致，这称为竞态条件。为了避免这种情况，需要使用同步机制来协调线程之间的访问，比如使用锁、信号量、条件变量等。\n\n此外，在多线程编程中，还需要注意线程之间的内存可见性。如果一个线程修改了一块内存，其他线程可能无法立即看到这个修改。为了解决这个问题，需要使用同步机制来确保内存可见性，比如使用volatile变量、memory barrier等。\n\n总之，线程之间的内存是共享的，需要特别注意线程之间的内存访问和同步，以确保程序的正确性和性能。\n\n\n# java中的锁机制\n\njava中的锁机制主要包括以下几种：\n\n * synchronized关键字：synchronized是java中最基本的锁机制，它可以实现对代码块、方法或者对象的同步访问。synchronized关键字可以保证在同一时刻只有一个线程可以进入被锁定的代码块或方法，从而避免线程间的数据竞争。\n\n * reentrantlock类：reentrantlock是java中的一个可重入锁，它提供了与synchronized相似的锁机制，但是更加灵活和可扩展。与synchronized不同的是，reentrantlock可以实现公平锁和非公平锁，可以支持多个条件变量等高级特性。\n\n * readwritelock接口：readwritelock是java中的一个读写锁接口，它可以实现对共享数据的读写分离。readwritelock允许多个线程同时读取共享数据，但是只允许一个线程写入共享数据，从而避免了读写之间的竞态条件。\n\n * stampedlock类：stampedlock是java中的一个乐观读写锁，它提供了对共享数据的读写访问，并支持无锁cas操作。stampedlock的乐观读取机制可以避免读写冲突的情况下使用悲观锁带来的性能损失。\n\n * countdownlatch类：countdownlatch是java中的一个倒计时锁，它可以让一个线程等待多个线程执行完毕之后再继续执行。countdownlatch的计数器初始值可以设置为多少个线程，当每个线程执行完毕后就会递减计数器，当计数器为0时，等待的线程就会被唤醒。\n\n * semaphore类：semaphore是java中的一个信号量，它可以限制多个线程对资源的访问。semaphore的计数器可以指定多少个线程可以同时访问资源，当线程访问完毕之后，计数器会自动递增。\n\n * exchanger类：exchanger是java中的一个线程间交换数据的工具类，它可以让两个线程交换彼此的数据。exchanger可以用于解决线程之间的数据交换问题，例如数据传输、缓存池等场景。\n\n除了以上列举的锁机制，java中还有一些其他的并发工具类，如semaphore、cyclicbarrier、locksupport等，它们可以帮助我们更加方便和高效地实现多线程编程。\n\n\n# reentranlock是悲观锁还是乐观锁？\n\nreentrantlock 是属于悲观锁的范畴。\n\n悲观锁是一种保守的锁策略，它在使用锁之前总是假设有其他线程正在使用该共享资源，并且在加锁后直到解锁前都会占用锁，阻止其他线程访问该共享资源。这种策略的优点是可以有效避免并发访问的冲突，但同时也会带来一定的开销。\n\nreentrantlock 在进行加锁操作时，会尝试获取锁，如果当前没有其他线程持有该锁，则会成功获取并占用锁，如果有其他线程持有该锁，则当前线程会被阻塞，等待其他线程释放锁。由于 reentrantlock 可以重入，即同一个线程可以多次获取同一个锁而不会造成死锁，所以它的命名中包含了 "reentrant"（可重入）这一词汇。\n\n与乐观锁不同，悲观锁的主要特点是在访问共享资源之前，总是先获取锁，因此 reentrantlock 不属于乐观锁的范畴。\n\n\n# 悲观锁和乐观锁的区别\n\n悲观锁和乐观锁是两种并发控制的策略，它们的区别如下：\n\n * 性能差异：悲观锁在使用锁之前总是假设有其他线程正在使用该共享资源，并且在加锁后直到解锁前都会占用锁，阻止其他线程访问该共享资源。这种策略的优点是可以有效避免并发访问的冲突，但同时也会带来一定的开销。乐观锁则假设并发冲突不会发生，直接进行并发操作，如果发现冲突则进行回滚或重试。因此，乐观锁的性能一般比悲观锁要好。\n * 实现方式：悲观锁的实现方式通常是使用 synchronized、reentrantlock 等锁机制，而乐观锁的实现方式通常是使用 cas（compare and swap）等乐观并发控制机制。\n * 冲突解决方式：悲观锁在加锁期间，阻止其他线程访问共享资源，从而避免并发冲突。乐观锁则假设并发冲突不会发生，在操作结束后才会检查并发冲突，如果发现冲突则进行回滚或重试。\n * 应用场景：悲观锁适用于并发冲突概率较高的场景，例如在高并发访问数据库时，由于每次访问需要获取独占锁，因此悲观锁的效果会比较好。而乐观锁适用于并发冲突概率较低的场景，例如在单机多线程环境下，由于并发冲突概率较低，使用乐观锁可以提高性能。\n\n\n# java中乐观锁的实现\n\n在 java 中，乐观锁主要有两种实现方式：cas 和版本号。\n\n\n# cas（compare and swap）实现乐观锁\n\ncas 是一种乐观锁的实现方式，它使用原子性操作来实现并发控制。cas 操作需要提供要更新的变量的值、预期值和新值，如果当前变量的值等于预期值，就使用新值更新变量并返回 true，否则不做任何操作并返回 false。\n\njava 中的 atomicinteger 和 atomiclong 类就是使用 cas 实现乐观锁的典型例子。使用 cas 实现乐观锁时，需要注意 cas 操作可能会出现 aba 问题，需要额外的处理措施来解决这个问题。\n\n\n# 版本号实现乐观锁\n\n另一种实现乐观锁的方式是通过版本号实现。在实现版本号乐观锁时，每个共享数据都有一个版本号，每次更新时都需要比较当前版本号和要更新的数据的版本号，如果一致，则更新成功，并增加版本号，否则更新失败。\n\n在 java 中，实现版本号乐观锁可以使用 atomicstampedreference 类，它可以对一个对象的引用和版本号进行原子操作。使用 atomicstampedreference 时需要注意，每次更新时需要同时更新对象引用和版本号，否则可能会出现数据不一致的问题。\n\n\n# java中乐观锁的类\n\njava中乐观锁的实现类包括：\n\n * atomic 包下的原子类：例如 atomicinteger、atomiclong、atomicreference 等，这些类提供了原子性的操作方法，可以实现乐观锁机制。\n\n * cas（compare and swap）：cas 是乐观锁的一种实现方式，java 中提供了 sun.misc.unsafe 类的 compareandswapxxx() 方法，可以用于实现 cas 操作。\n\n * 乐观锁框架：java 中有一些开源的乐观锁框架，例如 jpa 的乐观锁、spring 中的乐观锁等，这些框架封装了乐观锁的实现细节，使得开发者可以更方便地使用乐观锁机制。\n\n需要注意的是，在使用乐观锁时需要特别关注并发冲突的处理，因为乐观锁不会阻塞其他线程，所以可能会出现多个线程同时进行修改导致冲突的情况，这时需要使用一些特殊的算法或者技术来解决。\n\n\n# spring中的乐观锁\n\nspring 中提供了两种乐观锁实现方式：\n\n * 基于版本号（version）的乐观锁：该实现方式是通过为每条记录增加一个版本号字段，在更新记录时比较版本号是否一致来判断是否发生了并发冲突。在 spring 中，可以通过 @version 注解来指定版本号字段，同时在执行更新操作时，spring 会自动检查版本号并进行并发冲突检测和处理。\n * 基于时间戳（timestamp）的乐观锁：该实现方式是通过为每条记录增加一个时间戳字段，在更新记录时比较时间戳是否一致来判断是否发生了并发冲突。在 spring 中，可以通过 @timestamp 注解来指定时间戳字段，同时在执行更新操作时，spring 会自动检查时间戳并进行并发冲突检测和处理。\n\n需要注意的是，在使用 spring 的乐观锁机制时，需要确保数据库中支持乐观锁实现所需要的版本号或时间戳字段，同时需要特别关注并发冲突的处理，确保在并发访问时不会发生数据不一致的情况。\n\n\n# mysql支持版本号和时间戳字段\n\n 1. 基于版本号的乐观锁：在 mysql 中，可以使用 int 或 bigint 类型的字段作为版本号字段，并在更新记录时，使用 where 子句限制版本号相同的记录才能被更新，从而实现乐观锁控制。\n    \n    例如，创建一个包含版本号的表：\n\ncreate table `user` (\n  `id` bigint(20) not null auto_increment,\n  `name` varchar(255) default null,\n  `age` int(11) default null,\n  `version` int(11) default 0,\n  primary key (`id`)\n) engine=innodb default charset=utf8mb4;\n\n\n在更新记录时，使用类似以下的 sql 语句进行版本号的比较和更新：\n\nupdate `user` set `age` = #{age}, `version` = `version` + 1 where `id` = #{id} and `version` = #{version};\n\n\n其中，#{id} 和 #{version} 分别表示需要更新的记录的 id 和版本号，#{age} 表示需要更新的年龄值。\n\n 2. 基于时间戳的乐观锁：在 mysql 中，可以使用 timestamp 或 datetime 类型的字段作为时间戳字段，并在更新记录时，使用 where 子句限制时间戳相同的记录才能被更新，从而实现乐观锁控制。\n\n例如，创建一个包含时间戳的表：\n\ncreate table `user` (\n  `id` bigint(20) not null auto_increment,\n  `name` varchar(255) default null,\n  `age` int(11) default null,\n  `update_time` timestamp not null default current_timestamp on update current_timestamp,\n  primary key (`id`)\n) engine=innodb default charset=utf8mb4;\n\n\n在更新记录时，使用类似以下的 sql 语句进行时间戳的比较和更新：\n\nupdate `user` set `age` = #{age}, `update_time` = #{updatetime} where `id` = #{id} and `update_time` = #{updatetime};\n\n\n其中，#{id} 和 #{updatetime} 分别表示需要更新的记录的 id 和时间戳，#{age} 表示需要更新的年龄值。\n\n\n# spring @version 案例\n\n@version 注解可以用于指定实体类中的版本号字段，以便在更新操作时进行乐观锁控制。下面是一个简单的示例：\n\n假设我们有一个 user 实体类，其中包含了一个 version 字段表示版本号，可以使用 @version 注解来标识：\n\n@entity\n@table(name = "user")\npublic class user {\n\n    @id\n    @generatedvalue(strategy = generationtype.identity)\n    private long id;\n\n    @column(name = "name")\n    private string name;\n\n    @column(name = "age")\n    private integer age;\n\n    @version\n    @column(name = "version")\n    private integer version;\n    \n    // getter and setter methods\n}\n\n\n在进行更新操作时，可以通过调用 spring data jpa 提供的 save() 方法来实现乐观锁控制。例如：\n\n@service\npublic class userservice {\n\n    @autowired\n    private userrepository userrepository;\n\n    public void update(user user) {\n        userrepository.save(user);\n    }\n}\n\n\n当调用 update() 方法更新 user 实体时，spring data jpa 会自动检查 version 字段的值是否与数据库中的一致，如果一致则执行更新操作，否则抛出 optimisticlockexception 异常。例如：\n\nuser user = userrepository.findbyid(1l).orelsethrow();\nuser.setage(30);\nuserservice.update(user);\n\n\n在上述代码中，首先通过 userrepository 查询到 id 为 1 的 user 实体，并将其年龄修改为 30。接着，调用 userservice 的 update() 方法进行更新操作，此时 spring data jpa 会检查 user 实体的 version 字段是否与数据库中的一致，如果一致则执行更新操作，否则抛出 optimisticlockexception 异常。\n\n\n# aqs\n\naqs（abstractqueuedsynchronizer）是 java 并发包中锁和同步器的核心实现，它通过一个双向队列和一个整形状态值来管理同步状态，并提供了 acquire 和 release 两个主要的同步操作。\n\naqs 内部维护了一个类似于双向链表的队列，队列中的节点表示正在等待获取锁的线程。当一个线程尝试获取锁时，如果锁已经被其他线程占用，则该线程会被加入到队列的末尾，并被阻塞。当锁的占用者释放锁时，aqs 会将队列头部的线程唤醒，并让其尝试获取锁。\n\naqs 内部的状态值可以用来表示锁的占用状态，同时也可以被子类用来表示自定义的同步状态。在使用 aqs 实现同步器时，一般需要继承 aqs 类，并通过实现 tryacquire、tryrelease 等方法来实现同步器的加锁和释放锁操作，同时需要根据具体需求覆盖 aqs 中的一些方法来实现自定义的同步策略。\n\naqs 内部的核心方法有以下几个：\n\n * acquire(int arg): 尝试获取锁，如果获取失败则阻塞等待。\n\n * release(int arg): 释放锁，并唤醒等待队列中的一个线程。\n\n * tryacquire(int arg): 尝试获取锁，返回 true 表示获取成功，返回 false 表示获取失败。\n\n * tryrelease(int arg): 尝试释放锁，返回 true 表示释放成功，返回 false 表示释放失败。\n\n * tryacquireshared(int arg): 尝试获取共享锁，返回值的含义与 tryacquire 相同。\n\n * tryreleaseshared(int arg): 尝试释放共享锁，返回值的含义与 tryrelease 相同。\n\naqs 是 java 并发包中锁和同步器的核心实现，使用 aqs 实现同步器时需要对 aqs 的原理和机制有一定的了解，才能保证实现的正确性和高效性。同时，使用 aqs 实现同步器需要谨慎，否则容易出现死锁等问题。\n\n\n# aqs实现reentrantlock\n\nimport java.util.concurrent.locks.abstractqueuedsynchronizer;\n\npublic class reentrantlock extends abstractqueuedsynchronizer {\n    private thread ownerthread;\n    private int lockcount;\n\n    public reentrantlock() {\n        ownerthread = null;\n        lockcount = 0;\n    }\n\n    @override\n    protected boolean tryacquire(int arg) {\n        thread currentthread = thread.currentthread();\n        int c = getstate();\n        if (c == 0) {\n            if (compareandsetstate(0, arg)) {\n                ownerthread = currentthread;\n                lockcount++;\n                return true;\n            }\n        } else if (currentthread == ownerthread) {\n            setstate(c + arg);\n            lockcount++;\n            return true;\n        }\n        return false;\n    }\n\n    @override\n    protected boolean tryrelease(int arg) {\n        thread currentthread = thread.currentthread();\n        if (currentthread != ownerthread) {\n            throw new illegalmonitorstateexception("not owner thread");\n        }\n\n        int c = getstate() - arg;\n        boolean free = false;\n        if (c == 0) {\n            free = true;\n            ownerthread = null;\n        }\n        setstate(c);\n        if (free) {\n            release();\n        }\n        return true;\n    }\n\n    public void lock() {\n        acquire(1);\n    }\n\n    public void unlock() {\n        release(1);\n    }\n}\n\n\n在上面的示例代码中，我们自定义了一个 reentrantlock 类，继承了 abstractqueuedsynchronizer 类。\n\n这个类是 aqs 提供的基类，我们可以通过继承这个类来实现自定义的同步器。\n\n在这个类中，我们定义了 ownerthread 和 lockcount 两个变量来记录当前线程和当前线程获取锁的次数。我们重写了 tryacquire 和 tryrelease 方法来实现获取锁和释放锁的逻辑。\n\n在 tryacquire 方法中，首先判断当前线程是否已经获取了锁，如果已经获取了锁则直接增加 lockcount。否则，我们尝试使用 compareandsetstate 方法来更新状态值。如果更新成功，则将当前线程记录为 ownerthread，同时将 lockcount 设置为 1。\n\n在 tryrelease 方法中，首先判断当前线程是否为 ownerthread，如果不是则抛出异常。然后根据传入的参数来计算新的状态值，如果状态值为 0，则将 ownerthread 设置为 null，表示当前线程已经释放了锁。最后，我们调用 release 方法来释放同步状态。\n\n我们还定义了 lock 和 unlock 方法，分别用于获取锁和释放锁。在这些方法中，我们直接调用 acquire 和 release 方法来实现获取锁和释放锁的逻辑。acquire 和 release 在 aqs 中就会去调用 tryacquire 和 tryrelease，从而执行我们重写的逻辑。\n\n\n# 理解aqs中的acquire方法\n\nacquire() 是 aqs 中的方法之一，用于获取锁，其内部实现包括以下几个步骤：\n\n 1. 调用 tryacquire() 方法尝试获取锁，如果成功，则直接返回。\n 2. 如果 tryacquire() 方法返回失败，将当前线程包装成节点（node）并加入到等待队列中（即 waiters 队列），并将该线程阻塞。\n 3. 当锁被释放时，会调用 release() 方法释放锁，该方法会唤醒等待队列中的第一个线程（即队头节点），并将其从队列中移除。\n\n通过上述步骤，acquire() 方法可以实现获取锁的操作，同时能够保证多线程下的安全性。\n\n这段代码是 aqs 中 acquire(int arg) 方法的实现：\n\npublic final void acquire(int arg) {\n        if (!tryacquire(arg) &&\n            acquirequeued(addwaiter(node.exclusive), arg))\n            selfinterrupt();\n}\n\n\n 1. 第一行代码中的 tryacquire(arg) 是尝试获取锁，如果返回成功，则直接返回，这是一个快速路径，可以避免创建节点和加入等待队列等操作，提高了性能。\n 2. 如果快速路径失败，就需要进入到慢速路径。其中，addwaiter(node.exclusive) 将当前线程封装成节点并添加到等待队列的尾部，同时返回该节点。\n 3. acquirequeued(node node, int arg) 是尝试获取锁的核心方法，它会让当前线程进入等待队列并等待锁的释放，直到它成功获取锁为止。当获取锁失败时，该方法会将线程挂起并等待锁的释放，同时处理多线程之间的竞争关系。该方法返回一个布尔值，表示当前线程是否需要被阻塞。\n 4. 当 acquirequeued() 方法返回 true 时，说明当前线程已经被阻塞，需要被唤醒，同时需要调用 selfinterrupt() 方法自我中断，保证在被唤醒后能够及时处理中断。\n\n\n# 什么是中断\n\n中断（interrupt）是指一个线程请求中止另一个正在运行的线程的执行。当一个线程请求中止另一个线程时，通常会将一个信号发送给目标线程，让其停止正在执行的任务并进行清理工作。\n\njava中的中断机制是一种协作式机制，即线程需要配合才能实现中断。当一个线程调用另一个线程的 interrupt() 方法时，目标线程会收到一个中断请求，并设置一个中断状态，通知目标线程中断请求的发生。目标线程可以通过检查自身的中断状态来响应中断请求，通常的做法是在适当的时候抛出 interruptedexception 异常，并在异常处理中进行清理工作。\n\n需要注意的是，中断机制并不能强制终止一个线程的执行。线程可以在任何时刻检查自身的中断状态，并自行决定是否响应中断请求。另外，如果线程没有执行可中断的操作，例如忙等待或者死循环，那么中断请求是无法起作用的，线程仍然会一直执行下去。因此，在编写多线程程序时，需要注意避免使用忙等待和死循环等操作，以便能够及时响应中断请求。\n\n\n# 自我中断\n\n自我中断指的是线程在等待锁的过程中，被中断的情况。在 java 中，可以使用 thread.interrupt() 方法对一个线程进行中断操作，这时线程就会被设置为中断状态，然后由线程自己决定如何处理中断。\n\n在 aqs 中，如果一个线程在等待锁的过程中被中断，就会触发自我中断操作。这时，aqs 会在等待队列中找到该线程对应的节点，并将其标记为已中断，然后在下一次调用 acquire() 方法时，会抛出 interruptedexception 异常。这样，线程就可以在等待锁的过程中响应中断，避免因长时间等待锁而导致线程无法退出的问题。\n\n在 aqs 中，自我中断通常与阻塞式同步器（例如 reentrantlock）配合使用，可以有效提高多线程程序的响应能力。',charsets:{cjk:!0}},{title:"CopyOnWriteArrayList",frontmatter:{title:"CopyOnWriteArrayList",date:"2023-04-12T22:12:32.000Z",permalink:"/pages/9c98d8/"},regularPath:"/01.Java/04.Java%E5%B9%B6%E5%8F%91/08.CopyOnWriteArrayList.html",relativePath:"01.Java/04.Java并发/08.CopyOnWriteArrayList.md",key:"v-3f862f67",path:"/pages/9c98d8/",headers:[{level:2,title:"CopyOnWriteArrayList.add()",slug:"copyonwritearraylist-add",normalizedTitle:"copyonwritearraylist.add()",charIndex:2}],headersStr:"CopyOnWriteArrayList.add()",content:"# CopyOnWriteArrayList.add()\n\nCopyOnWrite 即写时复制，将一个元素添加到容器中时，不直接往当前容器添加，而是先将当前容器进行copy，往新容器中添加，添加完后，再将原容器的引用指向新容器，这样可以对容器进行并发的读，而不需加锁，因为当前容器不会提那家任何元素。所以 CopyOnWrite 是一种读写分离的思想，读和写是不同的容器。\n\npublic boolean add(E e) {\n        synchronized (lock) {\n            Object[] es = getArray();\n            int len = es.length;\n            es = Arrays.copyOf(es, len + 1);\n            es[len] = e;\n            setArray(es);\n            return true;\n        }\n    }\n",normalizedContent:"# copyonwritearraylist.add()\n\ncopyonwrite 即写时复制，将一个元素添加到容器中时，不直接往当前容器添加，而是先将当前容器进行copy，往新容器中添加，添加完后，再将原容器的引用指向新容器，这样可以对容器进行并发的读，而不需加锁，因为当前容器不会提那家任何元素。所以 copyonwrite 是一种读写分离的思想，读和写是不同的容器。\n\npublic boolean add(e e) {\n        synchronized (lock) {\n            object[] es = getarray();\n            int len = es.length;\n            es = arrays.copyof(es, len + 1);\n            es[len] = e;\n            setarray(es);\n            return true;\n        }\n    }\n",charsets:{cjk:!0}},{title:"CountDownLatch",frontmatter:{title:"CountDownLatch",date:"2023-05-15T23:02:42.000Z",permalink:"/pages/7c31b2/"},regularPath:"/01.Java/04.Java%E5%B9%B6%E5%8F%91/10.CountDownLatch.html",relativePath:"01.Java/04.Java并发/10.CountDownLatch.md",key:"v-e30b8032",path:"/pages/7c31b2/",headers:[{level:2,title:"核心方法",slug:"核心方法",normalizedTitle:"核心方法",charIndex:675},{level:2,title:"应用场景：",slug:"应用场景",normalizedTitle:"应用场景：",charIndex:766}],headersStr:"核心方法 应用场景：",content:"CountDownLatch是Java并发编程中的一个同步工具类，它可以让一个或多个线程等待一组操作完成后再继续执行。\n\nCountDownLatch is a synchronization tool that allows one or more threads to wait until a set of operations has completed. It is initialized with a count, and each time the countDown() method is called, the count is decremented. When the count reaches zero, all threads that are waiting on the CountDownLatch are released.\n\nCountDownLatch can be used to solve a variety of synchronization problems. For example, it can be used to ensure that all threads in a group have finished executing before a certain task is started, or to ensure that a certain number of resources are available before a task is started.\n\n\n# 核心方法\n\nCountDownLatch latch = new CountDownLatch(5);\nlatch.countDown();\nlatch.await();\n\n\n\n# 应用场景：\n\n 1. 并发任务的协同：当一个任务需要等待其他多个任务完成后才能继续执行时，可以使用 CountDownLatch 来实现线程之间的协同。任务中的线程可以调用 CountDownLatch 的 await() 方法进入等待状态，而其他任务中的线程执行完自己的操作后可以调用 CountDownLatch 的 countDown() 方法来减少计数器，当计数器减至零时，等待中的线程就会被唤醒。\n 2. 等待资源初始化：当一个程序需要等待一些资源初始化完成后才能正常运行时，可以使用 CountDownLatch 来实现等待。主线程可以调用 await() 方法等待初始化任务完成，而初始化任务中的线程在完成初始化后调用 countDown() 方法来减少计数器，当计数器减至零时，主线程就会被唤醒，可以开始执行后续的逻辑。\n 3. 测试多线程性能：在性能测试中，可以使用 CountDownLatch 来模拟并发场景。主线程可以启动多个工作线程，这些工作线程会执行相同的任务，并在任务完成时调用 countDown() 方法。主线程可以调用 await() 方法等待所有工作线程完成，以便统计执行时间和性能指标。",normalizedContent:"countdownlatch是java并发编程中的一个同步工具类，它可以让一个或多个线程等待一组操作完成后再继续执行。\n\ncountdownlatch is a synchronization tool that allows one or more threads to wait until a set of operations has completed. it is initialized with a count, and each time the countdown() method is called, the count is decremented. when the count reaches zero, all threads that are waiting on the countdownlatch are released.\n\ncountdownlatch can be used to solve a variety of synchronization problems. for example, it can be used to ensure that all threads in a group have finished executing before a certain task is started, or to ensure that a certain number of resources are available before a task is started.\n\n\n# 核心方法\n\ncountdownlatch latch = new countdownlatch(5);\nlatch.countdown();\nlatch.await();\n\n\n\n# 应用场景：\n\n 1. 并发任务的协同：当一个任务需要等待其他多个任务完成后才能继续执行时，可以使用 countdownlatch 来实现线程之间的协同。任务中的线程可以调用 countdownlatch 的 await() 方法进入等待状态，而其他任务中的线程执行完自己的操作后可以调用 countdownlatch 的 countdown() 方法来减少计数器，当计数器减至零时，等待中的线程就会被唤醒。\n 2. 等待资源初始化：当一个程序需要等待一些资源初始化完成后才能正常运行时，可以使用 countdownlatch 来实现等待。主线程可以调用 await() 方法等待初始化任务完成，而初始化任务中的线程在完成初始化后调用 countdown() 方法来减少计数器，当计数器减至零时，主线程就会被唤醒，可以开始执行后续的逻辑。\n 3. 测试多线程性能：在性能测试中，可以使用 countdownlatch 来模拟并发场景。主线程可以启动多个工作线程，这些工作线程会执行相同的任务，并在任务完成时调用 countdown() 方法。主线程可以调用 await() 方法等待所有工作线程完成，以便统计执行时间和性能指标。",charsets:{cjk:!0}},{title:"并发编程",frontmatter:{title:"并发编程",date:"2023-03-30T15:08:27.000Z",permalink:"/pages/d5fcba/"},regularPath:"/01.Java/04.Java%E5%B9%B6%E5%8F%91/100.%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B.html",relativePath:"01.Java/04.Java并发/100.并发编程.md",key:"v-03e85d0e",path:"/pages/d5fcba/",headers:[{level:2,title:"创建线程的方式",slug:"创建线程的方式",normalizedTitle:"创建线程的方式",charIndex:2},{level:2,title:"Runnable 和 Callable 有什么区别？",slug:"runnable-和-callable-有什么区别",normalizedTitle:"runnable 和 callable 有什么区别？",charIndex:125},{level:2,title:"Future 和 FutureTask",slug:"future-和-futuretask",normalizedTitle:"future 和 futuretask",charIndex:300},{level:2,title:"Callable、Future、FutureTask 的使用",slug:"callable、future、futuretask-的使用",normalizedTitle:"callable、future、futuretask 的使用",charIndex:1048},{level:2,title:"线程的状态",slug:"线程的状态",normalizedTitle:"线程的状态",charIndex:2947},{level:2,title:"sleep方法和wait方法区别",slug:"sleep方法和wait方法区别",normalizedTitle:"sleep方法和wait方法区别",charIndex:3063},{level:2,title:"sleep()、wait()、join()的区别",slug:"sleep-、wait-、join-的区别",normalizedTitle:"sleep()、wait()、join()的区别",charIndex:3765},{level:2,title:"Java程序如何保证多线程运行安全",slug:"java程序如何保证多线程运行安全",normalizedTitle:"java程序如何保证多线程运行安全",charIndex:6199},{level:2,title:"Java线程同步的几种方法",slug:"java线程同步的几种方法",normalizedTitle:"java线程同步的几种方法",charIndex:8155}],headersStr:"创建线程的方式 Runnable 和 Callable 有什么区别？ Future 和 FutureTask Callable、Future、FutureTask 的使用 线程的状态 sleep方法和wait方法区别 sleep()、wait()、join()的区别 Java程序如何保证多线程运行安全 Java线程同步的几种方法",content:'# 创建线程的方式\n\n * 继承 Thread 类创建线程\n * 实现 Runnable 接口创建线程\n * 实现 Callable 接口和 Future创建线程，并获取结果。\n * 通过线程池 ThreadPoolExecutor 创建。\n\n\n# Runnable 和 Callable 有什么区别？\n\n * Runnable 接口中的 run() 方法的返回值是 void，它做的事情只是纯粹地去执行 run() 方法中的代码而已；\n\n * Callable 接口中的 call() 方法是有返回值的，是一个泛型，和 Future、FutureTask 配合可以用来获取异步执行的结果。\n\n\n# Future 和 FutureTask\n\nFuture和FutureTask都是Java中用于处理异步任务的接口，它们之间的主要区别如下：\n\n 1. Future是一个接口，它定义了一些方法，如isDone()、get()等，用于操作异步任务的结果。FutureTask是一个实现了Future接口的类，它还实现了Runnable接口，可以被当做一个线程来执行。\n 2. Future接口只是一个标准的接口，它并没有提供实现。在使用Future时，需要使用它的实现类，如FutureTask、CompletableFuture等。\n 3. Future接口的主要作用是获取异步任务的执行结果，可以通过get()方法来获取，如果任务还没有完成，get()方法会阻塞当前线程，直到任务完成并返回结果。FutureTask除了可以获取任务的执行结果外，还可以通过它的cancel()方法来取消任务的执行。\n 4. FutureTask是一个比较强大的类，它可以包含一个Callable或Runnable对象，并且支持将任务提交到Executor执行器中。在调用get()方法时，如果任务还没有执行完成，它会阻塞当前线程，直到任务执行完成并返回结果。另外，如果任务被取消，get()方法会抛出CancellationException异常。\n\n综上所述，Future是一个接口，用于定义异步任务的返回值和操作方法；而FutureTask是一个实现了Future接口的类，除了实现Future接口的方法外，还实现了Runnable接口，可以被当做一个线程来执行。FutureTask是一个比较强大的类，它不仅支持获取异步任务的执行结果，还支持任务的提交和取消，可以方便地处理异步任务的执行和管理。\n\n\n# Callable、Future、FutureTask 的使用\n\nimport java.util.concurrent.Callable;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.FutureTask;\n\npublic class MyCallable implements Callable<Integer> {\n    public Integer call() throws Exception {\n        int sum = 0;\n        for (int i = 1; i <= 100; i++) {\n            sum += i;\n        }\n        return sum;\n    }\n\n    public static void main(String[] args) {\n        // 创建Callable对象\n        Callable<Integer> callable = new MyCallable();\n\n        // 创建FutureTask对象\n        FutureTask<Integer> futureTask = new FutureTask<Integer>(callable);\n\n        // 创建线程对象\n        Thread thread = new Thread(futureTask);\n\n        // 启动线程\n        thread.start();\n\n        try {\n            // 获取线程返回结果\n            int sum = futureTask.get();\n            System.out.println("1 + 2 + ... + 100 = " + sum);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        } catch (ExecutionException e) {\n            e.printStackTrace();\n        }\n    }\n}\n\n\nimport java.util.concurrent.*;\n\npublic class MyCallable implements Callable<Integer> {\n    public Integer call() throws Exception {\n        int sum = 0;\n        for (int i = 1; i <= 100; i++) {\n            sum += i;\n        }\n        return sum;\n    }\n\n    public static void main(String[] args) throws InterruptedException, ExecutionException {\n        // 创建线程池\n        ExecutorService executorService = Executors.newSingleThreadExecutor();\n\n        // 提交Callable任务\n        Future<Integer> future = executorService.submit(new MyCallable());\n\n        // 阻塞等待任务执行完成\n        while (!future.isDone()) {\n            System.out.println("任务还没有执行完成，继续等待...");\n            Thread.sleep(1000);\n        }\n\n        // 获取任务执行结果\n        int sum = future.get();\n        System.out.println("1 + 2 + ... + 100 = " + sum);\n\n        // 关闭线程池\n        executorService.shutdown();\n    }\n}\n\n\n\n# 线程的状态\n\nThread 的源码中定义了6种状态：new（新建）、runnnable（可运行）、blocked（阻塞）、waiting（等待）、time waiting （定时等待）和 terminated（终止）。\n\n\n\n\n# sleep方法和wait方法区别\n\nsleep()和wait()方法都可以暂停线程的执行，但它们的作用和用法是不同的：\n\n 1. sleep() 方法是 Thread 类中的一个静态方法，它会暂停当前线程的执行，让出CPU的时间片，但是不会释放当前线程持有的锁。sleep() 方法的调用必须捕获 InterruptedException 异常。\n 2. wait() 方法是 Object 类中的一个实例方法，它会让当前线程等待，直到另一个线程调用 notify() 或 notifyAll() 方法唤醒它。调用 wait() 方法的线程必须拥有该对象的锁，否则会抛出 IllegalMonitorStateException 异常。wait() 方法也必须捕获 InterruptedException 异常。\n\n因此，sleep() 和 wait() 的区别在于：\n\n 1. sleep() 不会释放锁，wait() 会释放锁。\n 2. sleep() 只能在 Thread 类中使用，而 wait() 可以在任意对象上调用，因为 wait() 是 Object 类的实例方法。\n 3. wait() 必须在 synchronized 块或方法中使用，否则会抛出 IllegalMonitorStateException 异常。\n 4. sleep() 的作用是暂停当前线程的执行，让出CPU的时间片，而 wait() 的作用是让线程等待某个条件的满足。\n\n因此，如果需要暂停当前线程的执行，可以使用 sleep() 方法；如果需要让线程等待某个条件的满足，可以使用 wait() 方法。\n\n\n# sleep()、wait()、join()的区别\n\nwait() 方法是 Object 类中的方法，用于使当前线程等待，直到其他线程调用该对象的 notify() 或 notifyAll() 方法唤醒它；sleep() 和 join() 方法是 Thread 类中的方法，sleep是静态方法， Thread.sleep()。而join()需要线程对象来调用。\n\nwait() 方法必须在同步代码块或同步方法中使用，否则会抛出 IllegalMonitorStateException 异常；sleep() 和 join() 方法可以在任何地方调用，不需要在同步代码块或同步方法中。\n\nwait() 方法会释放锁，使得其他线程可以获取锁并修改共享变量；sleep() 方法不会释放锁，当前线程仍然持有锁。\n\nObject中的wait、notift、notifyAll都是用于协调多个线程对共享数据的存取，所以必须在Synchronized语句块内使用这三个方法。Synchronized 关键字用于保护共享数据，阻止其他线程对共享数据的存取。但是这样程序的流程就很不灵活了，如何才能在当前线程还没退出Synchronized数据块时让其他线程也有机会访问共享数据呢？此时就用这三个方法来灵活控制。\n\n * wait()方法使当前线程暂停执行并释放对象锁标志，让其他线程可以进入Synchronized数据块，当前线程被放入对象等待池中。\n * 当调用 notify()方法后，将从对象的等待池中移走一个任意的线程并放到锁标志等待池中，只有锁标志等待池中的线程能够获取锁标志；如果锁标志等待池中没有线程，则notify()不起作用。\n * notifyAll()则从对象等待池中移走所有等待那个对象的线程并放到锁标志等待池中。\n\npublic class WaitNotifyExample {\n    public static void main(String[] args) {\n        final Object lock = new Object(); // 定义一个锁对象\n\n        // 线程A，等待锁对象\n        Thread threadA = new Thread(new Runnable() {\n            public void run() {\n                synchronized (lock) {\n                    try {\n                        System.out.println("ThreadA is waiting...");\n                        lock.wait(); // 等待锁对象\n                        System.out.println("ThreadA is woken up!");\n                    } catch (InterruptedException e) {\n                        e.printStackTrace();\n                    }\n                }\n            }\n        });\n\n        // 线程B，唤醒等待的线程\n        Thread threadB = new Thread(new Runnable() {\n            public void run() {\n                synchronized (lock) {\n                    System.out.println("ThreadB is notifying...");\n                    lock.notify(); // 唤醒等待的线程\n                }\n            }\n        });\n\n        // 启动线程A和线程B\n        threadA.start();\n        threadB.start();\n    }\n}\n\n\nsleep：Thread类的方法，必须带一个时间参数。会让当前线程休眠进入阻塞状态并释放CPU资源，提供其他线程运行的机会且不考虑优先级，但如果有同步锁则sleep不会释放锁即其他线程无法获得同步锁，可通过调用interrupt()方法来唤醒休眠线程。\n\nyield：让出CPU调度，Thread类的方法，类似sleep只是不能由用户指定暂停多长时间 ，并且yield()方法只能让同优先级的线程有执行的机会。 yield()只是使当前线程重新回到可执行状态，所以执行yield()的线程有可能在进入到可执行状态后马上又被执行。调用yield方法只是一个建议，告诉线程调度器我的工作已经做的差不多了，可以让别的相同优先级的线程使用CPU了，没有任何机制保证采纳。\n\nwait：Object类的方法(notify()、notifyAll() 也是Object对象)，必须放在循环体和同步代码块中，执行该方法的线程会释放锁，进入线程等待池中等待被再次唤醒(notify随机唤醒，notifyAll全部唤醒，线程结束自动唤醒)即放入锁池中竞争同步锁\n\njoin：一种特殊的wait，当前运行线程调用另一个线程的join方法，当前线程进入阻塞状态直到另一个线程运行结束等待该线程终止。 注意该方法也需要捕捉异常。\n\n等待调用join方法的线程结束，再继续执行。如：t.join();//主要用于等待t线程运行结束，若无此句，main则会执行完毕，导致结果不可预测。\n\n\n# Java程序如何保证多线程运行安全\n\n线程安全在三个方面体现：\n\n原子性：提供互斥访问，同一时刻只能有一个线程对数据进行操作，（atomic，synchronized）；\n\n可见性：一个线程对主内存的修改可以及时地被其他线程看到，（synchronized、volatile）；\n\n有序性：一个线程观察其他线程中的指令执行顺序，由于指令重排序，该观察结果一般杂乱无序，（happens-before 原则）。\n\n可见性和有序性：\n\n保证可见性意味着当一个线程修改了某个共享变量的值时，其他线程能够立即看到这个变量的最新值，从而避免了数据不一致的问题。Java中提供的volatile关键字就是一种保证可见性的机制。\n\n而保证有序性则是要确保在多线程环境下，对共享变量的读写操作能够按照程序的原有顺序进行，避免了指令重排和其他因素引起的执行顺序问题。Java中的happens-before规则可以保证程序的有序性，happens-before规则描述了在多线程环境下的各种操作之间的顺序关系。\n\n因此，保证可见性只是保证了数据一致性，而保证有序性可以避免程序出现各种难以预料的问题。在实际开发中，我们需要同时考虑保证可见性和有序性，才能保证多线程程序的正确性和性能。\n\nhappens-before原则：（是Java内存模型的一部分，用于定义多线程程序中共享变量的读写操作的顺序关系，保证了程序的可见性和有序性。）\n\n 1. 程序顺序规则：一个线程内按照程序代码顺序执行的结果，happens-before于该线程内的任意后续操作。\n 2. 锁定规则：一个unlock操作happens-before于后续的任意lock操作（同一个锁），反之也成立。\n 3. volatile变量规则：对一个volatile变量的写操作happens-before于后续的任意读操作（同一个volatile变量），反之也成立。\n 4. 传递性规则：如果操作A happens-before于操作B，且操作B happens-before于操作C，那么操作A happens-before于操作C。\n 5. 线程启动规则：一个线程的启动操作happens-before于该线程中的任意操作。\n 6. 线程终止规则：线程中的任意操作happens-before于该线程的终止操作。\n 7. 线程中断规则：对线程 interrupt() 方法的调用 happens-before 于被中断线程中的任意操作。\n 8. 对象终结规则：一个对象的初始化操作 happens-before 于finalize() 方法的开始。\n\n在多线程程序中，遵守happens-before规则可以保证程序的有序性和正确性。通过合理地使用同步机制和volatile关键字，可以实现线程之间的顺序执行，避免数据竞争和指令重排等问题。\n\nJava中有多种机制可以保证多线程运行的安全，下面列举几种主要的方式：\n\n 1. synchronized关键字：使用synchronized关键字可以将一段代码块或方法标记为同步代码，同一时刻只能有一个线程进入该代码块或方法。这种方式需要注意锁对象的选择，需要保证不同线程使用的是同一个锁对象。\n 2. ReentrantLock类：与synchronized类似，ReentrantLock也是一种同步机制。使用ReentrantLock需要手动获取和释放锁，因此更灵活。另外，ReentrantLock还提供了一些高级特性，如公平锁和可重入锁等。\n 3. volatile关键字：使用volatile关键字可以保证多个线程对变量的可见性。即一个线程修改了一个volatile变量的值，其他线程可以立即看到这个值的变化。但是volatile不能保证原子性。\n 4. Atomic类：Java中提供了AtomicInteger、AtomicBoolean、AtomicLong等原子类，使用这些类可以保证操作的原子性。\n 5. ThreadLocal类：ThreadLocal是一个线程内部的数据结构，可以用来保存线程的局部变量。ThreadLocal为每个线程都提供了一个独立的变量副本，从而避免了线程安全问题。\n 6. 线程池：使用线程池可以避免创建过多的线程，从而提高程序性能和稳定性。Java中提供了ThreadPoolExecutor类，可以根据需要自定义线程池的大小和其他参数。\n 7. 线程安全的容器：ConcurrentHashMap、CopyOnWriteArrayList、BlockingQueue、ConcurrentSkipListMap、ConcurrentSkipListSet\n\n\n# Java线程同步的几种方法\n\n * 使用 synchronized 关键字\n * 使用wait 和 notify，需结合synchronized使用\n * 使用可重入锁 ReentrantLock\n * 使用阻塞队列 BlockQueue\n * 使用信号量 Semaphone',normalizedContent:'# 创建线程的方式\n\n * 继承 thread 类创建线程\n * 实现 runnable 接口创建线程\n * 实现 callable 接口和 future创建线程，并获取结果。\n * 通过线程池 threadpoolexecutor 创建。\n\n\n# runnable 和 callable 有什么区别？\n\n * runnable 接口中的 run() 方法的返回值是 void，它做的事情只是纯粹地去执行 run() 方法中的代码而已；\n\n * callable 接口中的 call() 方法是有返回值的，是一个泛型，和 future、futuretask 配合可以用来获取异步执行的结果。\n\n\n# future 和 futuretask\n\nfuture和futuretask都是java中用于处理异步任务的接口，它们之间的主要区别如下：\n\n 1. future是一个接口，它定义了一些方法，如isdone()、get()等，用于操作异步任务的结果。futuretask是一个实现了future接口的类，它还实现了runnable接口，可以被当做一个线程来执行。\n 2. future接口只是一个标准的接口，它并没有提供实现。在使用future时，需要使用它的实现类，如futuretask、completablefuture等。\n 3. future接口的主要作用是获取异步任务的执行结果，可以通过get()方法来获取，如果任务还没有完成，get()方法会阻塞当前线程，直到任务完成并返回结果。futuretask除了可以获取任务的执行结果外，还可以通过它的cancel()方法来取消任务的执行。\n 4. futuretask是一个比较强大的类，它可以包含一个callable或runnable对象，并且支持将任务提交到executor执行器中。在调用get()方法时，如果任务还没有执行完成，它会阻塞当前线程，直到任务执行完成并返回结果。另外，如果任务被取消，get()方法会抛出cancellationexception异常。\n\n综上所述，future是一个接口，用于定义异步任务的返回值和操作方法；而futuretask是一个实现了future接口的类，除了实现future接口的方法外，还实现了runnable接口，可以被当做一个线程来执行。futuretask是一个比较强大的类，它不仅支持获取异步任务的执行结果，还支持任务的提交和取消，可以方便地处理异步任务的执行和管理。\n\n\n# callable、future、futuretask 的使用\n\nimport java.util.concurrent.callable;\nimport java.util.concurrent.executionexception;\nimport java.util.concurrent.futuretask;\n\npublic class mycallable implements callable<integer> {\n    public integer call() throws exception {\n        int sum = 0;\n        for (int i = 1; i <= 100; i++) {\n            sum += i;\n        }\n        return sum;\n    }\n\n    public static void main(string[] args) {\n        // 创建callable对象\n        callable<integer> callable = new mycallable();\n\n        // 创建futuretask对象\n        futuretask<integer> futuretask = new futuretask<integer>(callable);\n\n        // 创建线程对象\n        thread thread = new thread(futuretask);\n\n        // 启动线程\n        thread.start();\n\n        try {\n            // 获取线程返回结果\n            int sum = futuretask.get();\n            system.out.println("1 + 2 + ... + 100 = " + sum);\n        } catch (interruptedexception e) {\n            e.printstacktrace();\n        } catch (executionexception e) {\n            e.printstacktrace();\n        }\n    }\n}\n\n\nimport java.util.concurrent.*;\n\npublic class mycallable implements callable<integer> {\n    public integer call() throws exception {\n        int sum = 0;\n        for (int i = 1; i <= 100; i++) {\n            sum += i;\n        }\n        return sum;\n    }\n\n    public static void main(string[] args) throws interruptedexception, executionexception {\n        // 创建线程池\n        executorservice executorservice = executors.newsinglethreadexecutor();\n\n        // 提交callable任务\n        future<integer> future = executorservice.submit(new mycallable());\n\n        // 阻塞等待任务执行完成\n        while (!future.isdone()) {\n            system.out.println("任务还没有执行完成，继续等待...");\n            thread.sleep(1000);\n        }\n\n        // 获取任务执行结果\n        int sum = future.get();\n        system.out.println("1 + 2 + ... + 100 = " + sum);\n\n        // 关闭线程池\n        executorservice.shutdown();\n    }\n}\n\n\n\n# 线程的状态\n\nthread 的源码中定义了6种状态：new（新建）、runnnable（可运行）、blocked（阻塞）、waiting（等待）、time waiting （定时等待）和 terminated（终止）。\n\n\n\n\n# sleep方法和wait方法区别\n\nsleep()和wait()方法都可以暂停线程的执行，但它们的作用和用法是不同的：\n\n 1. sleep() 方法是 thread 类中的一个静态方法，它会暂停当前线程的执行，让出cpu的时间片，但是不会释放当前线程持有的锁。sleep() 方法的调用必须捕获 interruptedexception 异常。\n 2. wait() 方法是 object 类中的一个实例方法，它会让当前线程等待，直到另一个线程调用 notify() 或 notifyall() 方法唤醒它。调用 wait() 方法的线程必须拥有该对象的锁，否则会抛出 illegalmonitorstateexception 异常。wait() 方法也必须捕获 interruptedexception 异常。\n\n因此，sleep() 和 wait() 的区别在于：\n\n 1. sleep() 不会释放锁，wait() 会释放锁。\n 2. sleep() 只能在 thread 类中使用，而 wait() 可以在任意对象上调用，因为 wait() 是 object 类的实例方法。\n 3. wait() 必须在 synchronized 块或方法中使用，否则会抛出 illegalmonitorstateexception 异常。\n 4. sleep() 的作用是暂停当前线程的执行，让出cpu的时间片，而 wait() 的作用是让线程等待某个条件的满足。\n\n因此，如果需要暂停当前线程的执行，可以使用 sleep() 方法；如果需要让线程等待某个条件的满足，可以使用 wait() 方法。\n\n\n# sleep()、wait()、join()的区别\n\nwait() 方法是 object 类中的方法，用于使当前线程等待，直到其他线程调用该对象的 notify() 或 notifyall() 方法唤醒它；sleep() 和 join() 方法是 thread 类中的方法，sleep是静态方法， thread.sleep()。而join()需要线程对象来调用。\n\nwait() 方法必须在同步代码块或同步方法中使用，否则会抛出 illegalmonitorstateexception 异常；sleep() 和 join() 方法可以在任何地方调用，不需要在同步代码块或同步方法中。\n\nwait() 方法会释放锁，使得其他线程可以获取锁并修改共享变量；sleep() 方法不会释放锁，当前线程仍然持有锁。\n\nobject中的wait、notift、notifyall都是用于协调多个线程对共享数据的存取，所以必须在synchronized语句块内使用这三个方法。synchronized 关键字用于保护共享数据，阻止其他线程对共享数据的存取。但是这样程序的流程就很不灵活了，如何才能在当前线程还没退出synchronized数据块时让其他线程也有机会访问共享数据呢？此时就用这三个方法来灵活控制。\n\n * wait()方法使当前线程暂停执行并释放对象锁标志，让其他线程可以进入synchronized数据块，当前线程被放入对象等待池中。\n * 当调用 notify()方法后，将从对象的等待池中移走一个任意的线程并放到锁标志等待池中，只有锁标志等待池中的线程能够获取锁标志；如果锁标志等待池中没有线程，则notify()不起作用。\n * notifyall()则从对象等待池中移走所有等待那个对象的线程并放到锁标志等待池中。\n\npublic class waitnotifyexample {\n    public static void main(string[] args) {\n        final object lock = new object(); // 定义一个锁对象\n\n        // 线程a，等待锁对象\n        thread threada = new thread(new runnable() {\n            public void run() {\n                synchronized (lock) {\n                    try {\n                        system.out.println("threada is waiting...");\n                        lock.wait(); // 等待锁对象\n                        system.out.println("threada is woken up!");\n                    } catch (interruptedexception e) {\n                        e.printstacktrace();\n                    }\n                }\n            }\n        });\n\n        // 线程b，唤醒等待的线程\n        thread threadb = new thread(new runnable() {\n            public void run() {\n                synchronized (lock) {\n                    system.out.println("threadb is notifying...");\n                    lock.notify(); // 唤醒等待的线程\n                }\n            }\n        });\n\n        // 启动线程a和线程b\n        threada.start();\n        threadb.start();\n    }\n}\n\n\nsleep：thread类的方法，必须带一个时间参数。会让当前线程休眠进入阻塞状态并释放cpu资源，提供其他线程运行的机会且不考虑优先级，但如果有同步锁则sleep不会释放锁即其他线程无法获得同步锁，可通过调用interrupt()方法来唤醒休眠线程。\n\nyield：让出cpu调度，thread类的方法，类似sleep只是不能由用户指定暂停多长时间 ，并且yield()方法只能让同优先级的线程有执行的机会。 yield()只是使当前线程重新回到可执行状态，所以执行yield()的线程有可能在进入到可执行状态后马上又被执行。调用yield方法只是一个建议，告诉线程调度器我的工作已经做的差不多了，可以让别的相同优先级的线程使用cpu了，没有任何机制保证采纳。\n\nwait：object类的方法(notify()、notifyall() 也是object对象)，必须放在循环体和同步代码块中，执行该方法的线程会释放锁，进入线程等待池中等待被再次唤醒(notify随机唤醒，notifyall全部唤醒，线程结束自动唤醒)即放入锁池中竞争同步锁\n\njoin：一种特殊的wait，当前运行线程调用另一个线程的join方法，当前线程进入阻塞状态直到另一个线程运行结束等待该线程终止。 注意该方法也需要捕捉异常。\n\n等待调用join方法的线程结束，再继续执行。如：t.join();//主要用于等待t线程运行结束，若无此句，main则会执行完毕，导致结果不可预测。\n\n\n# java程序如何保证多线程运行安全\n\n线程安全在三个方面体现：\n\n原子性：提供互斥访问，同一时刻只能有一个线程对数据进行操作，（atomic，synchronized）；\n\n可见性：一个线程对主内存的修改可以及时地被其他线程看到，（synchronized、volatile）；\n\n有序性：一个线程观察其他线程中的指令执行顺序，由于指令重排序，该观察结果一般杂乱无序，（happens-before 原则）。\n\n可见性和有序性：\n\n保证可见性意味着当一个线程修改了某个共享变量的值时，其他线程能够立即看到这个变量的最新值，从而避免了数据不一致的问题。java中提供的volatile关键字就是一种保证可见性的机制。\n\n而保证有序性则是要确保在多线程环境下，对共享变量的读写操作能够按照程序的原有顺序进行，避免了指令重排和其他因素引起的执行顺序问题。java中的happens-before规则可以保证程序的有序性，happens-before规则描述了在多线程环境下的各种操作之间的顺序关系。\n\n因此，保证可见性只是保证了数据一致性，而保证有序性可以避免程序出现各种难以预料的问题。在实际开发中，我们需要同时考虑保证可见性和有序性，才能保证多线程程序的正确性和性能。\n\nhappens-before原则：（是java内存模型的一部分，用于定义多线程程序中共享变量的读写操作的顺序关系，保证了程序的可见性和有序性。）\n\n 1. 程序顺序规则：一个线程内按照程序代码顺序执行的结果，happens-before于该线程内的任意后续操作。\n 2. 锁定规则：一个unlock操作happens-before于后续的任意lock操作（同一个锁），反之也成立。\n 3. volatile变量规则：对一个volatile变量的写操作happens-before于后续的任意读操作（同一个volatile变量），反之也成立。\n 4. 传递性规则：如果操作a happens-before于操作b，且操作b happens-before于操作c，那么操作a happens-before于操作c。\n 5. 线程启动规则：一个线程的启动操作happens-before于该线程中的任意操作。\n 6. 线程终止规则：线程中的任意操作happens-before于该线程的终止操作。\n 7. 线程中断规则：对线程 interrupt() 方法的调用 happens-before 于被中断线程中的任意操作。\n 8. 对象终结规则：一个对象的初始化操作 happens-before 于finalize() 方法的开始。\n\n在多线程程序中，遵守happens-before规则可以保证程序的有序性和正确性。通过合理地使用同步机制和volatile关键字，可以实现线程之间的顺序执行，避免数据竞争和指令重排等问题。\n\njava中有多种机制可以保证多线程运行的安全，下面列举几种主要的方式：\n\n 1. synchronized关键字：使用synchronized关键字可以将一段代码块或方法标记为同步代码，同一时刻只能有一个线程进入该代码块或方法。这种方式需要注意锁对象的选择，需要保证不同线程使用的是同一个锁对象。\n 2. reentrantlock类：与synchronized类似，reentrantlock也是一种同步机制。使用reentrantlock需要手动获取和释放锁，因此更灵活。另外，reentrantlock还提供了一些高级特性，如公平锁和可重入锁等。\n 3. volatile关键字：使用volatile关键字可以保证多个线程对变量的可见性。即一个线程修改了一个volatile变量的值，其他线程可以立即看到这个值的变化。但是volatile不能保证原子性。\n 4. atomic类：java中提供了atomicinteger、atomicboolean、atomiclong等原子类，使用这些类可以保证操作的原子性。\n 5. threadlocal类：threadlocal是一个线程内部的数据结构，可以用来保存线程的局部变量。threadlocal为每个线程都提供了一个独立的变量副本，从而避免了线程安全问题。\n 6. 线程池：使用线程池可以避免创建过多的线程，从而提高程序性能和稳定性。java中提供了threadpoolexecutor类，可以根据需要自定义线程池的大小和其他参数。\n 7. 线程安全的容器：concurrenthashmap、copyonwritearraylist、blockingqueue、concurrentskiplistmap、concurrentskiplistset\n\n\n# java线程同步的几种方法\n\n * 使用 synchronized 关键字\n * 使用wait 和 notify，需结合synchronized使用\n * 使用可重入锁 reentrantlock\n * 使用阻塞队列 blockqueue\n * 使用信号量 semaphone',charsets:{cjk:!0}},{title:"AQS",frontmatter:{title:"AQS",date:"2023-09-08T14:26:54.000Z",permalink:"/pages/109178/"},regularPath:"/01.Java/04.Java%E5%B9%B6%E5%8F%91/12.AQS.html",relativePath:"01.Java/04.Java并发/12.AQS.md",key:"v-6b463bfb",path:"/pages/109178/",headersStr:null,content:"AbstractQueuedSynchronizer 抽象同步队列，简称 AQS ，它是Java并发包的根基，并发包中的锁就是基于AQS实现的。\n\n * AQS是基于一个FIFO的双向队列，其内部定义了一个节点类Node，Node 节点内部的 SHARED 用来标记该线程是获取共享资源时被阻挂起后放入AQS 队列的， EXCLUSIVE 用来标记线程是 取独占资源时被挂起后放入AQS 队列\n * AQS 使用一个 volatile 修饰的 int 类型的成员变量 state 来表示同步状态，修改同步状态成功即为获得锁，volatile 保证了变量在多线程之间的可见性，修改 State 值时通过 CAS 机制来保证修改的原子性\n * 获取state的方式分为两种，独占方式和共享方式，一个线程使用独占方式获取了资源，其它线程就会在获取失败后被阻塞。一个线程使用共享方式获取了资源，另外一个线程还可以通过CAS的方式进行获取。\n * 如果共享资源被占用，需要一定的阻塞等待唤醒机制来保证锁的分配，AQS 中会将竞争共享资源失败的线程添加到一个变体的 CLH 队列中。\n\n\n\nAQS 中的 CLH 变体等待队列拥有以下特性：\n\n * AQS 中队列是个双向链表，也是 FIFO 先进先出的特性\n * 通过 Head、Tail 头尾两个节点来组成队列结构，通过 volatile 修饰保证可见性\n * Head 指向节点为已获得锁的节点，是一个虚拟节点，节点本身不持有具体线程\n * 获取不到同步状态，会将节点进行自旋获取锁，自旋一定次数失败后会将线程阻塞，相对于 CLH 队列性能较好",normalizedContent:"abstractqueuedsynchronizer 抽象同步队列，简称 aqs ，它是java并发包的根基，并发包中的锁就是基于aqs实现的。\n\n * aqs是基于一个fifo的双向队列，其内部定义了一个节点类node，node 节点内部的 shared 用来标记该线程是获取共享资源时被阻挂起后放入aqs 队列的， exclusive 用来标记线程是 取独占资源时被挂起后放入aqs 队列\n * aqs 使用一个 volatile 修饰的 int 类型的成员变量 state 来表示同步状态，修改同步状态成功即为获得锁，volatile 保证了变量在多线程之间的可见性，修改 state 值时通过 cas 机制来保证修改的原子性\n * 获取state的方式分为两种，独占方式和共享方式，一个线程使用独占方式获取了资源，其它线程就会在获取失败后被阻塞。一个线程使用共享方式获取了资源，另外一个线程还可以通过cas的方式进行获取。\n * 如果共享资源被占用，需要一定的阻塞等待唤醒机制来保证锁的分配，aqs 中会将竞争共享资源失败的线程添加到一个变体的 clh 队列中。\n\n\n\naqs 中的 clh 变体等待队列拥有以下特性：\n\n * aqs 中队列是个双向链表，也是 fifo 先进先出的特性\n * 通过 head、tail 头尾两个节点来组成队列结构，通过 volatile 修饰保证可见性\n * head 指向节点为已获得锁的节点，是一个虚拟节点，节点本身不持有具体线程\n * 获取不到同步状态，会将节点进行自旋获取锁，自旋一定次数失败后会将线程阻塞，相对于 clh 队列性能较好",charsets:{cjk:!0}},{title:"如何实现 ReentrantLock？",frontmatter:{title:"如何实现 ReentrantLock？",date:"2023-03-31T17:17:06.000Z",permalink:"/pages/3c96b3/"},regularPath:"/01.Java/04.Java%E5%B9%B6%E5%8F%91/99.%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%20ReentrantLock%EF%BC%9F.html",relativePath:"01.Java/04.Java并发/99.如何实现 ReentrantLock？.md",key:"v-74777bb3",path:"/pages/3c96b3/",headers:[{level:2,title:"ReentrantLock 是什么？提供什么功能？",slug:"reentrantlock-是什么-提供什么功能",normalizedTitle:"reentrantlock 是什么？提供什么功能？",charIndex:2},{level:2,title:"ReentrantLock 跟 Synchronized 的对比",slug:"reentrantlock-跟-synchronized-的对比",normalizedTitle:"reentrantlock 跟 synchronized 的对比",charIndex:409},{level:2,title:"ReentrantLock 的使用",slug:"reentrantlock-的使用",normalizedTitle:"reentrantlock 的使用",charIndex:779},{level:2,title:"ReentrantLock 是如何实现的？",slug:"reentrantlock-是如何实现的",normalizedTitle:"reentrantlock 是如何实现的？",charIndex:948},{level:3,title:"整体实现流程",slug:"整体实现流程",normalizedTitle:"整体实现流程",charIndex:974},{level:3,title:"重入锁和其他非重入锁的实现",slug:"重入锁和其他非重入锁的实现",normalizedTitle:"重入锁和其他非重入锁的实现",charIndex:1244},{level:3,title:"公平锁和非公平锁的实现",slug:"公平锁和非公平锁的实现",normalizedTitle:"公平锁和非公平锁的实现",charIndex:1508},{level:2,title:"ReentranLock 与 AQS",slug:"reentranlock-与-aqs",normalizedTitle:"reentranlock 与 aqs",charIndex:1998},{level:2,title:"AQS",slug:"aqs",normalizedTitle:"aqs",charIndex:493},{level:3,title:"底层数据结构",slug:"底层数据结构",normalizedTitle:"底层数据结构",charIndex:2255},{level:3,title:"通过修改 state 同步状态实现多线程的独占模式和共享模式",slug:"通过修改-state-同步状态实现多线程的独占模式和共享模式",normalizedTitle:"通过修改 state 同步状态实现多线程的独占模式和共享模式",charIndex:2439},{level:3,title:"自定义同步器",slug:"自定义同步器",normalizedTitle:"自定义同步器",charIndex:2476},{level:3,title:"AQS 应用",slug:"aqs-应用",normalizedTitle:"aqs 应用",charIndex:4147},{level:2,title:"Q & A（ReentrantLock）",slug:"q-a-reentrantlock",normalizedTitle:"q &amp; a（reentrantlock）",charIndex:null},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:5272}],headersStr:"ReentrantLock 是什么？提供什么功能？ ReentrantLock 跟 Synchronized 的对比 ReentrantLock 的使用 ReentrantLock 是如何实现的？ 整体实现流程 重入锁和其他非重入锁的实现 公平锁和非公平锁的实现 ReentranLock 与 AQS AQS 底层数据结构 通过修改 state 同步状态实现多线程的独占模式和共享模式 自定义同步器 AQS 应用 Q & A（ReentrantLock） 参考资料",content:"# ReentrantLock 是什么？提供什么功能？\n\nReentrantLock 为可重入锁，指一个线程可以对临界资源重复加锁。\n\n * 支持公平锁和非公平锁。\n\n * 支持设置多个条件。\n\n * 支持响应中断。\n\n公平锁和非公平锁：\n\n公平锁是指多个线程按照申请锁的顺序来获取锁，线程直接进入队列中排队，队列中的第一个线程才能获得锁。公平锁的优点是等待锁的线程不会饿死。缺点是整体吞吐效率相对非公平锁要低，等待队列中除第一个线程以外的所有线程都会阻塞，CPU唤醒阻塞线程的开销比非公平锁大。\n\n非公平锁是多个线程加锁时直接尝试获取锁，获取不到才会到等待队列的队尾等待。但如果此时锁刚好可用，那么这个线程可以无需阻塞直接获取到锁。非公平锁的优点是可以减少唤起线程的开销，整体的吞吐效率高，因为线程有几率不阻塞直接获得锁，CPU不必唤醒所有线程。缺点是处于等待队列中的线程可能会饿死，或者等很久才会获得锁。\n\n\n# ReentrantLock 跟 Synchronized 的对比\n\n        REENTRANTLOCK     SYNCHRONIZED\n锁实现机制   依赖 AQS            依赖 JDK\n灵活性     支持响应中断、超时、尝试获取锁   不灵活\n锁释放形式   必须显示调用 unlock()   自动释放监视器\n锁类型     公平锁 & 非公平锁        非公平锁\n条件队列    可关联多个条件           只能关联一个条件\n可重入性    可重入               可重入\n\n都是可重入锁。可重入的意思是同一个线程在外层方法获取锁的时候，该线程的内层方法会自动获取该锁（前提是锁的对象是同一个对象或class），不会因为之前获取过还没释放而阻塞。在一定程度上可以避免死锁。\n\n\n# ReentrantLock 的使用\n\nReentrantLock lock = new ReentrantLock();\nlock.lock();\ntry {\n    if(lock.tryLock(100, TimeUnit.MILLISECONDS)){ }\n} finally {\n    lock.unlock()\n}\n\n\n\n# ReentrantLock 是如何实现的？\n\n\n# 整体实现流程\n\n继承 AQS，具体获取锁的方法由内部类公平锁（FairSync）和非公平锁（NonfairSync）重写 tryAcquire() 方法实现，该方法通过 CAS 去设置 state，如果该方法返回了 true，表示当前线程获取锁成功，执行结束；如果该方法返回 false，表示获取失败，则需要加入等待队列中，通过执行 addWaiter(Node.EXCLUSIVE)。\n\n在 ReentrantLock 里面的公平锁和非公平锁的父类 Sync 定义了可重入锁的释放锁机制，重写了 tryRelease() 方法。\n\n\n# 重入锁和其他非重入锁的实现\n\n通过父类 AQS 中维护的同步状态 state 来计算重入次数，state 初始化为0。\n\n当线程尝试获取锁时，可重入锁先尝试获取并更新 state 值，如果 state == 0 表示没有其他线程占用，将 state 置位1，当前线程开始执行；如果 state != 0，则判断当前线程是否是获取到这个锁的线程，如果是的话，state + 1，且当前线程可以再次获取锁。\n\n非重入锁则是直接去获取并尝试更新当前 state 的值，如果 state != 0，则获取锁失败，当前线程阻塞。\n\n\n# 公平锁和非公平锁的实现\n\nReentrantLock 的公平锁和非公平锁都是独享锁。当一个线程调用 lock 方法获取锁时，如果同步资源没有被其他线程锁住，那么当前线程使用 CAS 更新 state 值成功后会抢占该资源。如果同步资源被占用且不是当前线程占用时，则加锁失败。\n\nReentrantLock 中有一个内部类 Sync，Sync 继承了 AQS（AbstractQueuedSynchronizer），公平锁（FairSync）和非公平锁（NonfairSync）继承了Sync。ReentrantLock默认使用非公平锁，可通过构造器指定使用公平锁。\n\n公平锁与非公平锁的 lock() 方法唯一的区别就在于公平锁在获取同步状态时多了一个限制条件：hasQueuedPredecessors()。主要是用于判断当前线程是否位于同步队列中的第一个。如果是则返回true，否则返回false。\n\n公平锁就是通过同步队列来实现多个线程按照申请锁的顺序来获取锁，从而实现公平的特性。非公平锁加锁时不考虑排队等待问题，直接尝试获取锁，所以存在后申请却先获得锁的情况。\n\n\n# ReentranLock 与 AQS\n\n加锁逻辑：通过 CAS 设置 state，设置成功表示获取锁成功。获取锁失败则进入等待队列处理。\n\nReentrantLock 加锁解锁时 API 层核心方法的映射关系：\n\n\n\n\n# AQS\n\nAQS 的核心思想是，如果共享资源空闲，将当前请求资源的线程设置为有效的工作线程，同时通过 CAS 将共享资源的状态（state）设置为锁定状态。如果共享资源被占用，则通过阻塞等待唤醒机制来保证锁的分配，这里通过 CLH 队列的变体实现，将暂时没获取到锁的线程加入队列。\n\n\n# 底层数据结构\n\n * Node节点的 CLH队列。原始的 CLH 是单向链表，AQS 的队列是 CLH 的变体，是虚拟双向队列，AQS 通过将每条请求共享资源的线程封装成一个节点（Node）来实现锁的分配。\n * state。用 volatile int state 表示同步状态，通过 CAS 完成对 state 值的修改，通过队列完成资源获取的排队。\n\n\n\n\n# 通过修改 state 同步状态实现多线程的独占模式和共享模式\n\n\n\n\n# 自定义同步器\n\n * 独占模式，实现 tryAcquire-tryRelease。如 ReentrantLock\n * 共享模式，实现 ryAcquireShared-tryReleaseShared\n * 同时实现独占和共享两种模式。如 ReentrantReadWriteLock\n\npublic class LeeLock  {\n\n    private static class Sync extends AbstractQueuedSynchronizer {\n        @Override\n        protected boolean tryAcquire (int arg) {\n            return compareAndSetState(0, 1);\n        }\n\n        @Override\n        protected boolean tryRelease (int arg) {\n            setState(0);\n            return true;\n        }\n\n        @Override\n        protected boolean isHeldExclusively () {\n            return getState() == 1;\n        }\n    }\n\n    private Sync sync = new Sync();\n\n    public void lock () {\n        sync.acquire(1);\n    }\n\n    public void unlock () {\n        sync.release(1);\n    }\n}\n\n\npublic class LeeMain {\n\n    static int count = 0;\n    static LeeLock leeLock = new LeeLock();\n\n    public static void main (String[] args) throws InterruptedException {\n\n        Runnable runnable = new Runnable() {\n            @Override\n            public void run () {\n                try {\n                    leeLock.lock();\n                    for (int i = 0; i < 10000; i++) {\n                        count++;\n                    }\n                } catch (Exception e) {\n                    e.printStackTrace();\n                } finally {\n                    leeLock.unlock();\n                }\n\n            }\n        };\n        Thread thread1 = new Thread(runnable);\n        Thread thread2 = new Thread(runnable);\n        thread1.start();\n        thread2.start();\n        thread1.join();\n        thread2.join();\n        System.out.println(count);\n    }\n}\n\n\n上述代码每次运行结果都会是 20000。通过简单的几行代码实现同步功能。\n\n\n# AQS 应用\n\n实现 ReentrantLock 可重入性\n\n 1. State 初始化的时候为 0，表示没有任何线程持有锁。\n 2. 当有线程持有该锁时，值就会在原来的基础上+1，同一个线程多次获得锁是，就会多次+1，这里就是可重入的概念。\n 3. 解锁也是对这个字段-1，一直到 0，此线程对锁释放。\n\n同步工具\n\n同步工具                     同步工具与 AQS 的关联\nReentrantLock            使用 AQS 保存锁重复持有的次数。当一个线程获取锁时，ReentrantLock\n                         记录当前获得锁的线程标识，用于检测是否重复获取，以及错误线程试图解锁操作时异常情况的处理。\nSemaphore                使用 AQS 同步状态来保存信号量的当前计数。tryRelease 会增加计数，acquireShared 会减少计数。\nCountDownLatch           使用 AQS 同步状态来表示计数。计数为 0 时，所有的 Acquire 操作（CountDownLatch 的\n                         await 方法）才可以通过。\nReentrantReadWriteLock   使用 AQS 同步状态中的 16 位保存写锁持有的次数，剩下的 16 位用于保存读锁的持有次数。\nThreadPoolExecutor       Worker 利用 AQS 同步状态实现对独占线程变量的设置（tryAcquire 和 tryRelease）。\n\n\n# Q & A（ReentrantLock）\n\nQ：某个线程获取锁失败的后续流程是什么呢？\n\nA：存在某种排队等候机制，线程继续等待，仍然保留获取锁的可能，获取锁流程仍在继续。\n\nQ：既然说到了排队等候机制，那么就一定会有某种队列形成，这样的队列是什么数据结构呢？\n\nA：是 CLH 变体的 FIFO 双端队列。\n\nQ：处于排队等候机制中的线程，什么时候可以有机会获取锁呢？\n\nA：前置节点是头结点，且当前线程获取锁成功\n\nQ：如果处于排队等候机制中的线程一直无法获取锁，需要一直等待么？还是有别的策略来解决这一问题？\n\nA：线程所在节点的状态会变成取消状态，取消状态的节点会从队列中释放。\n\nQ：Lock 函数通过 Acquire 方法进行加锁，但是具体是如何加锁的呢？\n\nA：AQS 的 Acquire 会调用 tryAcquire 方法，tryAcquire 由各个自定义同步器实现，通过 tryAcquire 完成加锁过程。\n\n\n# 参考资料\n\n * 【基本功】不可不说的Java“锁”事\n * 从ReentrantLock的实现看AQS的原理及应用\n * synchronized 实现原理 | 小米信息部技术团队\n * AQS 详解",normalizedContent:"# reentrantlock 是什么？提供什么功能？\n\nreentrantlock 为可重入锁，指一个线程可以对临界资源重复加锁。\n\n * 支持公平锁和非公平锁。\n\n * 支持设置多个条件。\n\n * 支持响应中断。\n\n公平锁和非公平锁：\n\n公平锁是指多个线程按照申请锁的顺序来获取锁，线程直接进入队列中排队，队列中的第一个线程才能获得锁。公平锁的优点是等待锁的线程不会饿死。缺点是整体吞吐效率相对非公平锁要低，等待队列中除第一个线程以外的所有线程都会阻塞，cpu唤醒阻塞线程的开销比非公平锁大。\n\n非公平锁是多个线程加锁时直接尝试获取锁，获取不到才会到等待队列的队尾等待。但如果此时锁刚好可用，那么这个线程可以无需阻塞直接获取到锁。非公平锁的优点是可以减少唤起线程的开销，整体的吞吐效率高，因为线程有几率不阻塞直接获得锁，cpu不必唤醒所有线程。缺点是处于等待队列中的线程可能会饿死，或者等很久才会获得锁。\n\n\n# reentrantlock 跟 synchronized 的对比\n\n        reentrantlock     synchronized\n锁实现机制   依赖 aqs            依赖 jdk\n灵活性     支持响应中断、超时、尝试获取锁   不灵活\n锁释放形式   必须显示调用 unlock()   自动释放监视器\n锁类型     公平锁 & 非公平锁        非公平锁\n条件队列    可关联多个条件           只能关联一个条件\n可重入性    可重入               可重入\n\n都是可重入锁。可重入的意思是同一个线程在外层方法获取锁的时候，该线程的内层方法会自动获取该锁（前提是锁的对象是同一个对象或class），不会因为之前获取过还没释放而阻塞。在一定程度上可以避免死锁。\n\n\n# reentrantlock 的使用\n\nreentrantlock lock = new reentrantlock();\nlock.lock();\ntry {\n    if(lock.trylock(100, timeunit.milliseconds)){ }\n} finally {\n    lock.unlock()\n}\n\n\n\n# reentrantlock 是如何实现的？\n\n\n# 整体实现流程\n\n继承 aqs，具体获取锁的方法由内部类公平锁（fairsync）和非公平锁（nonfairsync）重写 tryacquire() 方法实现，该方法通过 cas 去设置 state，如果该方法返回了 true，表示当前线程获取锁成功，执行结束；如果该方法返回 false，表示获取失败，则需要加入等待队列中，通过执行 addwaiter(node.exclusive)。\n\n在 reentrantlock 里面的公平锁和非公平锁的父类 sync 定义了可重入锁的释放锁机制，重写了 tryrelease() 方法。\n\n\n# 重入锁和其他非重入锁的实现\n\n通过父类 aqs 中维护的同步状态 state 来计算重入次数，state 初始化为0。\n\n当线程尝试获取锁时，可重入锁先尝试获取并更新 state 值，如果 state == 0 表示没有其他线程占用，将 state 置位1，当前线程开始执行；如果 state != 0，则判断当前线程是否是获取到这个锁的线程，如果是的话，state + 1，且当前线程可以再次获取锁。\n\n非重入锁则是直接去获取并尝试更新当前 state 的值，如果 state != 0，则获取锁失败，当前线程阻塞。\n\n\n# 公平锁和非公平锁的实现\n\nreentrantlock 的公平锁和非公平锁都是独享锁。当一个线程调用 lock 方法获取锁时，如果同步资源没有被其他线程锁住，那么当前线程使用 cas 更新 state 值成功后会抢占该资源。如果同步资源被占用且不是当前线程占用时，则加锁失败。\n\nreentrantlock 中有一个内部类 sync，sync 继承了 aqs（abstractqueuedsynchronizer），公平锁（fairsync）和非公平锁（nonfairsync）继承了sync。reentrantlock默认使用非公平锁，可通过构造器指定使用公平锁。\n\n公平锁与非公平锁的 lock() 方法唯一的区别就在于公平锁在获取同步状态时多了一个限制条件：hasqueuedpredecessors()。主要是用于判断当前线程是否位于同步队列中的第一个。如果是则返回true，否则返回false。\n\n公平锁就是通过同步队列来实现多个线程按照申请锁的顺序来获取锁，从而实现公平的特性。非公平锁加锁时不考虑排队等待问题，直接尝试获取锁，所以存在后申请却先获得锁的情况。\n\n\n# reentranlock 与 aqs\n\n加锁逻辑：通过 cas 设置 state，设置成功表示获取锁成功。获取锁失败则进入等待队列处理。\n\nreentrantlock 加锁解锁时 api 层核心方法的映射关系：\n\n\n\n\n# aqs\n\naqs 的核心思想是，如果共享资源空闲，将当前请求资源的线程设置为有效的工作线程，同时通过 cas 将共享资源的状态（state）设置为锁定状态。如果共享资源被占用，则通过阻塞等待唤醒机制来保证锁的分配，这里通过 clh 队列的变体实现，将暂时没获取到锁的线程加入队列。\n\n\n# 底层数据结构\n\n * node节点的 clh队列。原始的 clh 是单向链表，aqs 的队列是 clh 的变体，是虚拟双向队列，aqs 通过将每条请求共享资源的线程封装成一个节点（node）来实现锁的分配。\n * state。用 volatile int state 表示同步状态，通过 cas 完成对 state 值的修改，通过队列完成资源获取的排队。\n\n\n\n\n# 通过修改 state 同步状态实现多线程的独占模式和共享模式\n\n\n\n\n# 自定义同步器\n\n * 独占模式，实现 tryacquire-tryrelease。如 reentrantlock\n * 共享模式，实现 ryacquireshared-tryreleaseshared\n * 同时实现独占和共享两种模式。如 reentrantreadwritelock\n\npublic class leelock  {\n\n    private static class sync extends abstractqueuedsynchronizer {\n        @override\n        protected boolean tryacquire (int arg) {\n            return compareandsetstate(0, 1);\n        }\n\n        @override\n        protected boolean tryrelease (int arg) {\n            setstate(0);\n            return true;\n        }\n\n        @override\n        protected boolean isheldexclusively () {\n            return getstate() == 1;\n        }\n    }\n\n    private sync sync = new sync();\n\n    public void lock () {\n        sync.acquire(1);\n    }\n\n    public void unlock () {\n        sync.release(1);\n    }\n}\n\n\npublic class leemain {\n\n    static int count = 0;\n    static leelock leelock = new leelock();\n\n    public static void main (string[] args) throws interruptedexception {\n\n        runnable runnable = new runnable() {\n            @override\n            public void run () {\n                try {\n                    leelock.lock();\n                    for (int i = 0; i < 10000; i++) {\n                        count++;\n                    }\n                } catch (exception e) {\n                    e.printstacktrace();\n                } finally {\n                    leelock.unlock();\n                }\n\n            }\n        };\n        thread thread1 = new thread(runnable);\n        thread thread2 = new thread(runnable);\n        thread1.start();\n        thread2.start();\n        thread1.join();\n        thread2.join();\n        system.out.println(count);\n    }\n}\n\n\n上述代码每次运行结果都会是 20000。通过简单的几行代码实现同步功能。\n\n\n# aqs 应用\n\n实现 reentrantlock 可重入性\n\n 1. state 初始化的时候为 0，表示没有任何线程持有锁。\n 2. 当有线程持有该锁时，值就会在原来的基础上+1，同一个线程多次获得锁是，就会多次+1，这里就是可重入的概念。\n 3. 解锁也是对这个字段-1，一直到 0，此线程对锁释放。\n\n同步工具\n\n同步工具                     同步工具与 aqs 的关联\nreentrantlock            使用 aqs 保存锁重复持有的次数。当一个线程获取锁时，reentrantlock\n                         记录当前获得锁的线程标识，用于检测是否重复获取，以及错误线程试图解锁操作时异常情况的处理。\nsemaphore                使用 aqs 同步状态来保存信号量的当前计数。tryrelease 会增加计数，acquireshared 会减少计数。\ncountdownlatch           使用 aqs 同步状态来表示计数。计数为 0 时，所有的 acquire 操作（countdownlatch 的\n                         await 方法）才可以通过。\nreentrantreadwritelock   使用 aqs 同步状态中的 16 位保存写锁持有的次数，剩下的 16 位用于保存读锁的持有次数。\nthreadpoolexecutor       worker 利用 aqs 同步状态实现对独占线程变量的设置（tryacquire 和 tryrelease）。\n\n\n# q & a（reentrantlock）\n\nq：某个线程获取锁失败的后续流程是什么呢？\n\na：存在某种排队等候机制，线程继续等待，仍然保留获取锁的可能，获取锁流程仍在继续。\n\nq：既然说到了排队等候机制，那么就一定会有某种队列形成，这样的队列是什么数据结构呢？\n\na：是 clh 变体的 fifo 双端队列。\n\nq：处于排队等候机制中的线程，什么时候可以有机会获取锁呢？\n\na：前置节点是头结点，且当前线程获取锁成功\n\nq：如果处于排队等候机制中的线程一直无法获取锁，需要一直等待么？还是有别的策略来解决这一问题？\n\na：线程所在节点的状态会变成取消状态，取消状态的节点会从队列中释放。\n\nq：lock 函数通过 acquire 方法进行加锁，但是具体是如何加锁的呢？\n\na：aqs 的 acquire 会调用 tryacquire 方法，tryacquire 由各个自定义同步器实现，通过 tryacquire 完成加锁过程。\n\n\n# 参考资料\n\n * 【基本功】不可不说的java“锁”事\n * 从reentrantlock的实现看aqs的原理及应用\n * synchronized 实现原理 | 小米信息部技术团队\n * aqs 详解",charsets:{cjk:!0}},{title:"MySQL",frontmatter:{title:"MySQL",date:"2023-03-23T15:44:50.000Z",permalink:"/pages/mysql/"},regularPath:"/02.MySQL/00.MySQL.html",relativePath:"02.MySQL/00.MySQL.md",key:"v-6a709319",path:"/pages/mysql/",headers:[{level:2,title:"锁",slug:"锁",normalizedTitle:"锁",charIndex:2}],headersStr:"锁",content:"# 锁",normalizedContent:"# 锁",charsets:{cjk:!0},lastUpdated:"2023/03/29, 21:03:43",lastUpdatedTimestamp:1680095023e3},{title:"MySQL存储引擎",frontmatter:{title:"MySQL存储引擎",date:"2023-03-23T21:42:51.000Z",permalink:"/pages/26cff4/"},regularPath:"/02.MySQL/01.MySQL%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E.html",relativePath:"02.MySQL/01.MySQL存储引擎.md",key:"v-135d0248",path:"/pages/26cff4/",headers:[{level:2,title:"InnoDB",slug:"innodb",normalizedTitle:"innodb",charIndex:2},{level:2,title:"MyISAM",slug:"myisam",normalizedTitle:"myisam",charIndex:1136},{level:2,title:"其他存储引擎",slug:"其他存储引擎",normalizedTitle:"其他存储引擎",charIndex:1816}],headersStr:"InnoDB MyISAM 其他存储引擎",content:"# InnoDB\n\n是 MySQL 默认的事务型存储引擎，只有在需要它不支持的特性时，才考虑使用其它存储引擎。\n\n实现了四个标准的隔离级别，默认级别是可重复读(REPEATABLE READ)。在可重复读隔离级别下，通过多版本并发控制(MVCC)+ 间隙锁(Next-Key Locking)防止幻读问题。\n\n主索引是聚簇索引，在索引中保存了数据，从而避免直接读取磁盘，因此对查询性能有很大的提升。对表中的数据，InnoDB 采用聚集（clustered）的方式，因此每张表的存储都是按主键顺序进行存放的。如果没有显式的在表定义时指定主键，InnoDB 会为每一行生成一个6字节的 ROWID，作为主键。这种存储方式的表称为索引组织表（index organized table）。\n\n内部做了很多优化，包括从磁盘读取数据时采用的可预测性读、能够加快读操作并且自动创建的自适应哈希索引、能够加速插入操作的插入缓冲区等。\n\n支持真正的在线热备份。其它存储引擎不支持在线热备份，要获取一致性视图需要停止对所有表的写入，而在读写混合场景中，停止写入可能也意味着停止读取。\n\n提供了插入缓冲（insert buffer）、二次写（double write）、自适应哈希索引（adaptive hash index）、预读（read ahead）等功能。\n\nInnoDB特点：\n\n 1. 支持ACID事务：InnoDB存储引擎支持原子性、一致性、隔离性和持久性，可以通过事务来保证数据的一致性和完整性。\n 2. 支持行级锁：InnoDB支持行级锁，可以提高多用户并发访问时的性能。\n 3. 支持外键约束：InnoDB支持外键约束，可以保证数据的完整性。\n 4. 支持MVCC：InnoDB存储引擎支持多版本并发控制（MVCC），可以提高并发访问时的性能。MVCC通过在每行记录中添加多个版本来实现事务的隔离性。\n 5. 支持热备份：InnoDB支持热备份，可以在线备份数据，避免了数据停机时间。\n 6. 支持自适应哈希索引：InnoDB支持自适应哈希索引，在特定的条件下可以提高查询的性能。\n 7. 支持大容量存储：InnoDB存储引擎支持大容量存储，可以存储TB级别的数据。\n\nInnoDB 支持以下几种常见的索引：\n\n * B+ 树索引：是一种基于树形结构的索引类型，它按照顺序存储数据并且支持快速的查找和范围查找操作。\n * 全文索引：：全文索引可以用于在文本数据中进行全文搜索。InnoDB支持全文索引，但是需要使用特定的语法来创建和查询全文索引。\n * 哈希索引：哈希索引可以用于快速查找数据，但是只支持等值查找。\n\nInnoDB支持在一个表上同时创建多个索引。\n\n\n# MyISAM\n\n设计简单，数据以紧密格式存储。对于只读数据，或者表比较小、可以容忍修复操作，则依然可以使用它。\n\n特性，包括压缩表、空间数据索引（R-Tree）等。\n\n优点：\n\n 1. 高速读取：MyISAM表在读取大量数据时速度非常快，尤其是当表中有很多静态数据的时候。\n 2. 索引搜索效率高：MyISAM表的索引搜索效率非常高，尤其是在处理大数据量的情况下。\n 3. 独立的表结构：MyISAM表的表结构和数据文件是分开的，这样就使得备份和恢复数据变得更加容易。\n 4. 支持全文本搜索：MyISAM表支持全文本搜索，这使得对文本数据进行高效的搜索和分析变得更加容易。\n 5. 易于维护：MyISAM表的维护非常简单，对于频繁进行读取操作的表来说，可以使用OPTIMIZE TABLE语句对表进行优化，以提高表的性能。\n\n不支持事务。\n\n不支持行级锁，只能对整张表加锁，读取时会对需要读到的所有表加共享锁，写入时则对表加排它锁。但在表有读取操作的同时，也可以往表中插入新的记录，这被称为并发插入(CONCURRENT INSERT)。\n\n可以手工或者自动执行检查和修复操作，但是和事务恢复以及崩溃恢复不同，可能导致一些数据丢失，而且修复操作是非常慢的。\n\n如果指定了 DELAY_KEY_WRITE 选项，在每次修改执行完成时，不会立即将修改的索引数据写入磁盘，而是会写到内存中的键缓冲区，只有在清理键缓冲区或者关闭表的时候才会将对应的索引块写入磁盘。这种方式可以极大的提升写入性能，但是在数据库或者主机崩溃时会造成索引损坏，需要执行修复操作。\n\n\n# 其他存储引擎\n\n 1. MyISAM：MyISAM是MySQL的另一种常用存储引擎，它比InnoDB更简单、更快速，适用于读密集的应用场景。但是，它不支持事务、行级锁、外键约束等功能，也不支持热备份和崩溃恢复。\n 2. Memory：Memory存储引擎是MySQL中最快的存储引擎之一，适用于对速度要求很高的场景，比如缓存数据和临时表等。Memory存储引擎将数据存储在内存中，因此不支持大容量数据存储。此外，它不支持持久性和崩溃恢复等功能，也不支持TEXT和BLOB类型。\n 3. Archive：Archive存储引擎适用于数据归档和备份场景，可以在需要时快速存储和检索大量历史数据。它采用压缩算法存储数据，因此占用空间较小。但是，Archive存储引擎不支持索引、事务、行级锁等功能，也不支持数据修改操作。\n 4. CSV：CSV存储引擎将数据以逗号分隔的格式存储在文本文件中，适用于数据导入、导出和交换等场景。它不支持索引、事务、行级锁等功能，也不支持BLOB和TEXT类型。",normalizedContent:"# innodb\n\n是 mysql 默认的事务型存储引擎，只有在需要它不支持的特性时，才考虑使用其它存储引擎。\n\n实现了四个标准的隔离级别，默认级别是可重复读(repeatable read)。在可重复读隔离级别下，通过多版本并发控制(mvcc)+ 间隙锁(next-key locking)防止幻读问题。\n\n主索引是聚簇索引，在索引中保存了数据，从而避免直接读取磁盘，因此对查询性能有很大的提升。对表中的数据，innodb 采用聚集（clustered）的方式，因此每张表的存储都是按主键顺序进行存放的。如果没有显式的在表定义时指定主键，innodb 会为每一行生成一个6字节的 rowid，作为主键。这种存储方式的表称为索引组织表（index organized table）。\n\n内部做了很多优化，包括从磁盘读取数据时采用的可预测性读、能够加快读操作并且自动创建的自适应哈希索引、能够加速插入操作的插入缓冲区等。\n\n支持真正的在线热备份。其它存储引擎不支持在线热备份，要获取一致性视图需要停止对所有表的写入，而在读写混合场景中，停止写入可能也意味着停止读取。\n\n提供了插入缓冲（insert buffer）、二次写（double write）、自适应哈希索引（adaptive hash index）、预读（read ahead）等功能。\n\ninnodb特点：\n\n 1. 支持acid事务：innodb存储引擎支持原子性、一致性、隔离性和持久性，可以通过事务来保证数据的一致性和完整性。\n 2. 支持行级锁：innodb支持行级锁，可以提高多用户并发访问时的性能。\n 3. 支持外键约束：innodb支持外键约束，可以保证数据的完整性。\n 4. 支持mvcc：innodb存储引擎支持多版本并发控制（mvcc），可以提高并发访问时的性能。mvcc通过在每行记录中添加多个版本来实现事务的隔离性。\n 5. 支持热备份：innodb支持热备份，可以在线备份数据，避免了数据停机时间。\n 6. 支持自适应哈希索引：innodb支持自适应哈希索引，在特定的条件下可以提高查询的性能。\n 7. 支持大容量存储：innodb存储引擎支持大容量存储，可以存储tb级别的数据。\n\ninnodb 支持以下几种常见的索引：\n\n * b+ 树索引：是一种基于树形结构的索引类型，它按照顺序存储数据并且支持快速的查找和范围查找操作。\n * 全文索引：：全文索引可以用于在文本数据中进行全文搜索。innodb支持全文索引，但是需要使用特定的语法来创建和查询全文索引。\n * 哈希索引：哈希索引可以用于快速查找数据，但是只支持等值查找。\n\ninnodb支持在一个表上同时创建多个索引。\n\n\n# myisam\n\n设计简单，数据以紧密格式存储。对于只读数据，或者表比较小、可以容忍修复操作，则依然可以使用它。\n\n特性，包括压缩表、空间数据索引（r-tree）等。\n\n优点：\n\n 1. 高速读取：myisam表在读取大量数据时速度非常快，尤其是当表中有很多静态数据的时候。\n 2. 索引搜索效率高：myisam表的索引搜索效率非常高，尤其是在处理大数据量的情况下。\n 3. 独立的表结构：myisam表的表结构和数据文件是分开的，这样就使得备份和恢复数据变得更加容易。\n 4. 支持全文本搜索：myisam表支持全文本搜索，这使得对文本数据进行高效的搜索和分析变得更加容易。\n 5. 易于维护：myisam表的维护非常简单，对于频繁进行读取操作的表来说，可以使用optimize table语句对表进行优化，以提高表的性能。\n\n不支持事务。\n\n不支持行级锁，只能对整张表加锁，读取时会对需要读到的所有表加共享锁，写入时则对表加排它锁。但在表有读取操作的同时，也可以往表中插入新的记录，这被称为并发插入(concurrent insert)。\n\n可以手工或者自动执行检查和修复操作，但是和事务恢复以及崩溃恢复不同，可能导致一些数据丢失，而且修复操作是非常慢的。\n\n如果指定了 delay_key_write 选项，在每次修改执行完成时，不会立即将修改的索引数据写入磁盘，而是会写到内存中的键缓冲区，只有在清理键缓冲区或者关闭表的时候才会将对应的索引块写入磁盘。这种方式可以极大的提升写入性能，但是在数据库或者主机崩溃时会造成索引损坏，需要执行修复操作。\n\n\n# 其他存储引擎\n\n 1. myisam：myisam是mysql的另一种常用存储引擎，它比innodb更简单、更快速，适用于读密集的应用场景。但是，它不支持事务、行级锁、外键约束等功能，也不支持热备份和崩溃恢复。\n 2. memory：memory存储引擎是mysql中最快的存储引擎之一，适用于对速度要求很高的场景，比如缓存数据和临时表等。memory存储引擎将数据存储在内存中，因此不支持大容量数据存储。此外，它不支持持久性和崩溃恢复等功能，也不支持text和blob类型。\n 3. archive：archive存储引擎适用于数据归档和备份场景，可以在需要时快速存储和检索大量历史数据。它采用压缩算法存储数据，因此占用空间较小。但是，archive存储引擎不支持索引、事务、行级锁等功能，也不支持数据修改操作。\n 4. csv：csv存储引擎将数据以逗号分隔的格式存储在文本文件中，适用于数据导入、导出和交换等场景。它不支持索引、事务、行级锁等功能，也不支持blob和text类型。",charsets:{cjk:!0},lastUpdated:"2023/03/29, 21:03:43",lastUpdatedTimestamp:1680095023e3},{title:"CyclicBarrier",frontmatter:{title:"CyclicBarrier",date:"2023-05-15T23:04:48.000Z",permalink:"/pages/fa1dea/"},regularPath:"/01.Java/04.Java%E5%B9%B6%E5%8F%91/11.%20CyclicBarrier.html",relativePath:"01.Java/04.Java并发/11. CyclicBarrier.md",key:"v-c3e7532c",path:"/pages/fa1dea/",headers:[{level:2,title:"CyclicBarrier 的特点如下：",slug:"cyclicbarrier-的特点如下",normalizedTitle:"cyclicbarrier 的特点如下：",charIndex:75},{level:2,title:"核心方法",slug:"核心方法",normalizedTitle:"核心方法",charIndex:335},{level:2,title:"CyclicBarrier 和 CountDonwLatch 的对比",slug:"cyclicbarrier-和-countdonwlatch-的对比",normalizedTitle:"cyclicbarrier 和 countdonwlatch 的对比",charIndex:615},{level:2,title:"CyclicBarrier 的应用场景包括以下几个方面：",slug:"cyclicbarrier-的应用场景包括以下几个方面",normalizedTitle:"cyclicbarrier 的应用场景包括以下几个方面：",charIndex:1203}],headersStr:"CyclicBarrier 的特点如下： 核心方法 CyclicBarrier 和 CountDonwLatch 的对比 CyclicBarrier 的应用场景包括以下几个方面：",content:"CyclicBarrier（循环屏障）是Java并发编程中的一个同步工具类，它可以让一组线程在达到某个共同点之前互相等待，然后同时继续执行。\n\n\n# CyclicBarrier 的特点如下：\n\n 1. 共同点：CyclicBarrier 可以设置一个共同点，当等待的线程数达到指定数量时，所有线程将同时被释放，继续执行后续操作。\n 2. 循环使用：CyclicBarrier 可以被多次使用。当所有线程都被释放后，CyclicBarrier 会被重置，并可以再次使用。\n 3. 等待与释放：线程通过调用 CyclicBarrier 的 await() 方法进入等待状态，当指定数量的线程都调用了 await() 方法后，所有线程会同时被释放，继续执行后续操作。\n\n\n# 核心方法\n\n// 构造方法\nCyclicBarrier(int, Runnable); // 指定关联该CyclicBarrier的线程数量，并且可以指定在所有线程都进入屏障后的执行动作，该执行动作由最后一个进行屏障的线程执行。\nCyclicBarrier(int);\n\ncb.await();\n\n\n在所有线程进入屏障后会调用 nextGeneration()，即生成下一个版本，所有线程又可以重新进入到屏障中。要注意barrier.await()方法的调用次数应该与创建CyclicBarrier时指定的线程数量相匹配，以确保正确的同步和等待行为。\n\n\n# CyclicBarrier 和 CountDonwLatch 的对比\n\n * CountDownLatch减计数，CyclicBarrier加计数。\n\n * CountDownLatch是一次性的，CyclicBarrier可以重用。\n\n * CountDownLatch和CyclicBarrier都有让多个线程等待同步然后再开始下一步动作的意思，但是CountDownLatch的下一步的动作实施者是主线程，具有不可重复性；而CyclicBarrier的下一步动作实施者还是“其他线程”本身，具有往复多次实施动作的特点。\n\n * 对于CountDownLatch，其他线程为游戏玩家，比如英雄联盟，主线程为控制游戏开始的线程。在所有的玩家都准备好之前，主线程是处于等待状态的，也就是游戏不能开始。当所有的玩家准备好之后，下一步的动作实施者为主线程，即开始游戏。\n\n * 对于CyclicBarrier，假设有一家公司要全体员工进行团建活动，活动内容为翻越三个障碍物，每一个人翻越障碍物所用的时间是不一样的。但是公司要求所有人在翻越当前障碍物之后再开始翻越下一个障碍物，也就是所有人翻越第一个障碍物之后，才开始翻越第二个，以此类推。类比地，每一个员工都是一个“其他线程”。当所有人都翻越的所有的障碍物之后，程序才结束。而主线程可能早就结束了，这里我们不用管主线程。\n\n\n# CyclicBarrier 的应用场景包括以下几个方面：\n\n 1. 并行计算任务的拆分与合并：当一个大型计算任务可以被拆分为多个子任务并行执行时，可以使用 CyclicBarrier 来等待所有子任务完成后再进行合并计算。\n 2. 多线程任务的阶段同步：当一个任务需要按照阶段进行多次并发操作，每个阶段需要等待所有线程都完成后才能继续下一阶段，可以使用 CyclicBarrier 来实现阶段间的同步。\n 3. 并发流水线的流程控制：当多个线程需要按照特定的流水线方式执行任务，每个线程在完成一定操作后需要等待其他线程才能继续，可以使用 CyclicBarrier 来实现线程之间的同步。",normalizedContent:"cyclicbarrier（循环屏障）是java并发编程中的一个同步工具类，它可以让一组线程在达到某个共同点之前互相等待，然后同时继续执行。\n\n\n# cyclicbarrier 的特点如下：\n\n 1. 共同点：cyclicbarrier 可以设置一个共同点，当等待的线程数达到指定数量时，所有线程将同时被释放，继续执行后续操作。\n 2. 循环使用：cyclicbarrier 可以被多次使用。当所有线程都被释放后，cyclicbarrier 会被重置，并可以再次使用。\n 3. 等待与释放：线程通过调用 cyclicbarrier 的 await() 方法进入等待状态，当指定数量的线程都调用了 await() 方法后，所有线程会同时被释放，继续执行后续操作。\n\n\n# 核心方法\n\n// 构造方法\ncyclicbarrier(int, runnable); // 指定关联该cyclicbarrier的线程数量，并且可以指定在所有线程都进入屏障后的执行动作，该执行动作由最后一个进行屏障的线程执行。\ncyclicbarrier(int);\n\ncb.await();\n\n\n在所有线程进入屏障后会调用 nextgeneration()，即生成下一个版本，所有线程又可以重新进入到屏障中。要注意barrier.await()方法的调用次数应该与创建cyclicbarrier时指定的线程数量相匹配，以确保正确的同步和等待行为。\n\n\n# cyclicbarrier 和 countdonwlatch 的对比\n\n * countdownlatch减计数，cyclicbarrier加计数。\n\n * countdownlatch是一次性的，cyclicbarrier可以重用。\n\n * countdownlatch和cyclicbarrier都有让多个线程等待同步然后再开始下一步动作的意思，但是countdownlatch的下一步的动作实施者是主线程，具有不可重复性；而cyclicbarrier的下一步动作实施者还是“其他线程”本身，具有往复多次实施动作的特点。\n\n * 对于countdownlatch，其他线程为游戏玩家，比如英雄联盟，主线程为控制游戏开始的线程。在所有的玩家都准备好之前，主线程是处于等待状态的，也就是游戏不能开始。当所有的玩家准备好之后，下一步的动作实施者为主线程，即开始游戏。\n\n * 对于cyclicbarrier，假设有一家公司要全体员工进行团建活动，活动内容为翻越三个障碍物，每一个人翻越障碍物所用的时间是不一样的。但是公司要求所有人在翻越当前障碍物之后再开始翻越下一个障碍物，也就是所有人翻越第一个障碍物之后，才开始翻越第二个，以此类推。类比地，每一个员工都是一个“其他线程”。当所有人都翻越的所有的障碍物之后，程序才结束。而主线程可能早就结束了，这里我们不用管主线程。\n\n\n# cyclicbarrier 的应用场景包括以下几个方面：\n\n 1. 并行计算任务的拆分与合并：当一个大型计算任务可以被拆分为多个子任务并行执行时，可以使用 cyclicbarrier 来等待所有子任务完成后再进行合并计算。\n 2. 多线程任务的阶段同步：当一个任务需要按照阶段进行多次并发操作，每个阶段需要等待所有线程都完成后才能继续下一阶段，可以使用 cyclicbarrier 来实现阶段间的同步。\n 3. 并发流水线的流程控制：当多个线程需要按照特定的流水线方式执行任务，每个线程在完成一定操作后需要等待其他线程才能继续，可以使用 cyclicbarrier 来实现线程之间的同步。",charsets:{cjk:!0}},{title:"索引",frontmatter:{title:"索引",date:"2023-03-23T21:35:58.000Z",permalink:"/pages/7ece7e/"},regularPath:"/02.MySQL/02.%E7%B4%A2%E5%BC%95.html",relativePath:"02.MySQL/02.索引.md",key:"v-571aeb12",path:"/pages/7ece7e/",headers:[{level:2,title:"索引是什么",slug:"索引是什么",normalizedTitle:"索引是什么",charIndex:2},{level:2,title:"索引的优点",slug:"索引的优点",normalizedTitle:"索引的优点",charIndex:319},{level:2,title:"索引的使用场景",slug:"索引的使用场景",normalizedTitle:"索引的使用场景",charIndex:516},{level:2,title:"MySQL 索引分类",slug:"mysql-索引分类",normalizedTitle:"mysql 索引分类",charIndex:665},{level:2,title:"聚集索引和非聚集索引",slug:"聚集索引和非聚集索引",normalizedTitle:"聚集索引和非聚集索引",charIndex:815},{level:2,title:"MySQL 各种索引区别",slug:"mysql-各种索引区别",normalizedTitle:"mysql 各种索引区别",charIndex:1062},{level:3,title:"唯一索引",slug:"唯一索引",normalizedTitle:"唯一索引",charIndex:979},{level:3,title:"哈希索引",slug:"哈希索引",normalizedTitle:"哈希索引",charIndex:250},{level:2,title:"索引的选择",slug:"索引的选择",normalizedTitle:"索引的选择",charIndex:1498},{level:2,title:"什么是change buffer",slug:"什么是change-buffer",normalizedTitle:"什么是change buffer",charIndex:1574},{level:2,title:"索引相关SQL",slug:"索引相关sql",normalizedTitle:"索引相关sql",charIndex:2440},{level:2,title:"B+ 树索引",slug:"b-树索引",normalizedTitle:"b+ 树索引",charIndex:2935},{level:2,title:"B树和B+树的对比",slug:"b树和b-树的对比",normalizedTitle:"b树和b+树的对比",charIndex:3644},{level:2,title:"B+树和红黑树的对比",slug:"b-树和红黑树的对比",normalizedTitle:"b+树和红黑树的对比",charIndex:3858},{level:2,title:"覆盖索引（covering index）",slug:"覆盖索引-covering-index",normalizedTitle:"覆盖索引（covering index）",charIndex:4292},{level:2,title:"索引下推（index condition pushdown，ICP）",slug:"索引下推-index-condition-pushdown-icp",normalizedTitle:"索引下推（index condition pushdown，icp）",charIndex:4365},{level:2,title:"索引失效常见场景",slug:"索引失效常见场景",normalizedTitle:"索引失效常见场景",charIndex:4543},{level:2,title:"建索引的几大原则",slug:"建索引的几大原则",normalizedTitle:"建索引的几大原则",charIndex:4848},{level:2,title:"参考资料：",slug:"参考资料",normalizedTitle:"参考资料：",charIndex:5264}],headersStr:"索引是什么 索引的优点 索引的使用场景 MySQL 索引分类 聚集索引和非聚集索引 MySQL 各种索引区别 唯一索引 哈希索引 索引的选择 什么是change buffer 索引相关SQL B+ 树索引 B树和B+树的对比 B+树和红黑树的对比 覆盖索引（covering index） 索引下推（index condition pushdown，ICP） 索引失效常见场景 建索引的几大原则 参考资料：",content:"# 索引是什么\n\n索引是一种数据结构，它可以帮助我们快速查找和访问数据库中的数据。通过使用索引，数据库系统可以避免全表扫描，从而加快数据访问速度。\n\n在数据库中，索引可以类比于书籍的目录，它可以告诉我们在哪里能够找到某个特定的条目。如果我们需要查找一个特定的记录，而没有索引，那么数据库系统就需要扫描整个表来查找这个记录，这会浪费大量的时间和资源。但是如果我们有了索引，数据库系统就可以快速地定位到存储记录的位置，从而更快地获取需要的数据。\n\n索引可以根据其数据结构的不同分为多种类型，如B+树索引、哈希索引、全文索引等。其中，B-树索引是最常见的一种，它可以处理范围查询和排序操作，并且可以很好地支持高并发和多用户访问的环境。\n\n\n# 索引的优点\n\n * 大大减少了服务器需要扫描的数据行数。\n * 帮助服务器避免进行排序和分组，也就不需要创建临时表(B+Tree 索引是有序的，可以用于 ORDER BY 和 GROUP BY 操作。临时表主要是在排序和分组过程中创建，因为不需要排序和分组，也就不需要创建临时表)。\n * 将随机 I/O 变为顺序 I/O(B+Tree 索引是有序的，也就将相邻的数据都存储在一起)。\n\n\n# 索引的使用场景\n\n对于非常小的表、大部分情况下简单的全表扫描比建立索引更高效。\n\n对于中到大型的表，索引就非常有效。\n\n但是对于特大型的表，建立和维护索引的代价将会随之增长。这种情况下，需要用到一种技术可以直接区分出需要查询的一组数据，而不是一条记录一条记录地匹配，例如可以使用分区技术。\n\n\n# MySQL 索引分类\n\n按数据结构分类可分为：B+tree索引、Hash索引、Full-text索引。 按物理存储分类可分为：聚簇索引、二级索引（辅助索引、非聚集索引）。 按字段特性分类可分为：主键索引、普通索引、前缀索引。 按字段个数分类可分为：单列索引、联合索引（复合索引、组合索引）。\n\n\n# 聚集索引和非聚集索引\n\n每张表只能有一个聚集索引。\n\n聚集索引是叶子结点存储完整数据，非聚集索引叶子结点存储聚集索引的地址。\n\n聚集索引，在索引页里直接存放数据，而非聚集索引在索引页里存放的是索引，这些索引指向专门的数据页的数据。\n\n聚集索引一般是表中的主键索引，如果表中没有显示指定主键，则会选择表中的第一个不允许为NULL的唯一索引，如果还是没有的话，就采用Innodb存储引擎为每行数据内置的6字节ROWID作为聚集索引。\n\n聚集索引一定是唯一索引，但唯一索引不一定是聚集索引。\n\n\n# MySQL 各种索引区别\n\n普通索引 INDEX：最基本的索引，没有任何限制\n\n唯一索引 UNIQUE：与\"普通索引\"类似，不同的就是：索引列的值必须唯一，但允许有空值。\n\n主键索引 PRIMARY KEY：是一种特殊的唯一索引，不允许有空值。\n\n全文索引 FULLTEXT：InnoDB 5.6开始也支持了，针对较大的数据，生成全文索引很耗时好空间。\n\n组合索引：为了更多的提高mysql效率可建立组合索引，遵循”最左前缀“原则。\n\n\n# 唯一索引\n\n * 唯一索引不允许两行具有相同的索引值\n * 聚集索引一定是唯一索引，但唯一索引不一定是聚集索引。\n * 一个表中可以有多个唯一性索引（Uniq Index），但只能有一个主键。\n * 主键列不允许空值，而唯一性索引列（Uniq Index）允许空值。\n\n\n# 哈希索引\n\nInnoDB 支持的哈希索引是自适应的，InnoDB 会根据表的使用状况自动为其生成哈希索引，不能人为干预是否在一张表生成哈希索引。\n\n\n# 索引的选择\n\n业务写多读少的场景：由于唯一索引用不上change buffer的优化机制，从性能角度出发建议优先考虑非唯一索引（即普通索引）。\n\n\n# 什么是change buffer\n\nChange buffer是MySQL数据库引擎InnoDB用于优化写入性能的一种机制。在InnoDB存储引擎中，每次进行写入操作时，需要将数据写入到磁盘中的数据文件中，这个过程是比较耗时的。为了优化这个过程，InnoDB使用了Change buffer机制。通过使用Change buffer，InnoDB可以将多个修改操作合并成一个较大的操作，从而减少磁盘I/O的次数，提高写入性能。此外，Change buffer还可以减少磁盘上的随机写入操作，从而降低了磁盘的读写负载。\n\n当需要更新一个数据页时，如果数据页在内存中就直接更新，而如果这个数据页还没有在内存中的话，InooDB会将这些更新操作缓存在change buffer中，这样就不需要从磁盘中读入这个数据页了，在后续的查询中再将这些操作应用到磁盘上的数据页中。在下次查询需要访问这个数据页的时候，将数据页读入内存，然后执行change buffer中与这个页有关的操作，保证数据逻辑的正确性。\n\n将change buffer中的操作应用到原数据页，得到最新结果的过程称为merge。除了访问这个数据页会触发merge外，系统有后台线程会定期merge。在数据库正常关闭（shutdown）的过程中， 也会执行merge操作。\n\nchange buffer对更新过程有加速作用，change buffer只限于用在普通索引的场景下，而不适用于唯一索引。\n\nchange buffer 适合写多读少的业务，因为页面在写完以后马上被访问到的概率比较小。这种业务模型常见的就是账单类、日志类的系统。\n\n反过来，假设一个业务的更新模式是写入之后马上会做查询，那么即使满足了条件，将更新先记录在change buffer，但之后由于马上要访问这个数据页，会立即触发merge过程。这样随机访问 IO的次数不会减少，反而增加了change buffer的维护代价。所以，对于这种业务模式来说，change buffer反而起到了副作用。\n\n\n# 索引相关SQL\n\n# 查看索引\nSHOW INDEX FROM <tableName> [FROM <databaseName>]\n\n# 创建索引\n1.该语句不能创建主键\nCREATE <索引名> ON <表名> (<列名> [<长度>] [ASC | DESC])\n\n2.在创建表时创建，在CREATE TABLE语句中添加\nCONSTRAINT PRIMARY KEY [索引类型] (<列名>...)\nKEY | INDEX [<索引名>] (<列名>...)\n\n3.在ALTER TABLE中添加\nADD PRIMARY KEY [索引类型] (<列名>...)\nADD INDEX [<索引名>] (<列名>...)\nADD UNIQUE [ INDEX | KEY] [<索引名>] [<索引类型>] (<列名>,…)\n\n完整SQL：\nCREATE INDEX <indexName> ON <tableName> (<columnName>)\nALTER TABLE <tableName> ADD INDEX <indexName> (<columnName>)\n\n\n\n# B+ 树索引\n\n索引是在存储引擎层实现的，而不是在服务器层实现的，所以不同存储引擎具有不同的索引类型和实现。\n\nB+ 树索引是大多数 MySQL 存储引擎的默认索引类型。\n\nB 代表 balance，B+ 树是平衡多路查找树。B+ 树中，所有记录节点都是按键值大小顺序存放在同一层的叶子节点上，各叶子节点通过指针进行相连。\n\nB+树是高度平衡的，叶子节点存放着所有的数据。并且所有叶子节点位于同一层。\n\nB+ Tree 是基于 B Tree 和叶子节点顺序访问指针进行实现，它具有 B Tree 的平衡性，并且通过顺序访问指针来提高区间查询的性能。\n\n在数据库中，B+ 树高度一般在 2~4 层，即查询某一键值的行记录最多只需 2~4 次 IO。一般机械磁盘每秒可以做100次IO，2~4 次IO只需0.02~0.04秒。\n\nB+ 树索引可以分为聚集索引（clustered index）和辅助索引（secondary index，也叫非聚集索引）。但不管是聚集还是辅助索引，底层都是B+树。区别在于，叶子节点存放的是否是一整行的数据。\n\n聚集索引的优点在于，对主键的排序查找和范围查找速度非常快。\n\n辅助索引的叶子节点不包含行记录的所有信息，只包含键值和对应行数据的聚集索引键。\n\n\n操作：\n\n进行查找操作时，首先在根节点进行二分查找，找到一个 key 所在的指针，然后递归地在指针所指向的节点进行查找。直到查找到叶子节点，然后在叶子节点上进行二分查找，找出 key 所对应的 data。\n\n插入删除操作记录会破坏平衡树的平衡性，因此在插入删除操作之后，需要对树进行一个分裂、合并、旋转等操作来维护平衡性。\n\n\n# B树和B+树的对比\n\nB+ 树在B树的基础上，为叶子节点增加了链表指针，所有数据都存储在叶子节点。非叶子节点作为叶子节点的索引。\n\nB+ 树相对于 B树的优势在于：\n\n * 只有叶子节点存储数据，单一节点可以存储的元素就更多了，使得查询的IO次数更少，因此更适合做为数据库底层数据结构。\n * 所有的叶子节点形成了一个有序链表，更加便于查找。\n * B+树支持range-query(区间查询)非常方便，而B树不支持。\n\n\n# B+树和红黑树的对比\n\n红黑树等平衡树也可以用来实现索引，但是文件系统及数据库系统普遍采用 B+ Tree 作为索引结构，主要有以下两个原因:\n\n 1. 更少的查找次数\n\n平衡树查找操作的时间复杂度等于树高 h，而树高大致为 O(h)=O(logdN)，其中 d 为每个节点的出度。\n\n红黑树的出度为 2，而 B+ Tree 的出度一般都非常大，所以红黑树的树高 h 很明显比 B+ Tree 大非常多，检索的次数也就更多。\n\n 2. 利用计算机预读特性\n\n为了减少磁盘 I/O，磁盘往往不是严格按需读取，而是每次都会预读。预读过程中，磁盘进行顺序读取，顺序读取不需要进行磁盘寻道，并且只需要很短的旋转时间，因此速度会非常快。\n\n操作系统一般将内存和磁盘分割成固态大小的块，每一块称为一页，内存与磁盘以页为单位交换数据。数据库系统将索引的一个节点的大小设置为页的大小，使得一次 I/O 就能完全载入一个节点，并且可以利用预读特性，相邻的节点也能够被预先载入。\n\n\n# 覆盖索引（covering index）\n\n即从辅助索引中就可以查询到需要的信息，不需要再去查询聚集索引的信息，减少了回表，减少了IO。\n\n\n# 索引下推（index condition pushdown，ICP）\n\n不支持 ICP 时，当进行索引查询时，首先根据索引查找到记录，再根据 where 条件过滤记录。而支持 ICP的话，在取出索引的同时，进行 where 条件的过滤，即将 where 操作放在了存储引擎层。在某些查询下，可以大大减少上层SQL层对记录的索取，也减少了回表次数。\n\n\n# 索引失效常见场景\n\n * 违反最左前缀匹配原则。例如有索引index(a,b)，但查询条件只有b字段。\n * 在索引列上做任何操作，包括计算、函数、类型转换等。\n * 范围查询使联合索引停止匹配。\n * 减少select*的使用。避免不必要的回表操作开销，尽量使用覆盖索引。\n * 使用不等于（!=、<>），使用or操作。\n * 字符串不加单引号索引失效。\n * like以通配符开头'%abc'。注意like ‘abc%’ 是可以走索引的。\n * order by 违反最左匹配原则，含非索引字段排序，会产生文件排序。\n * group by 违反最左匹配原则，含非索引字段分组，会导致产生临时表。\n\n\n# 建索引的几大原则\n\n * 最左前缀匹配原则，非常重要的原则\n   * mysql会一直向右匹配直到遇到范围查询(>、<、between、like)就停止匹配，\n   * 比如a = 1 and b = 2 and c > 3 and d = 4\n     * 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，\n     * 如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整（建立索引时他们三个的顺序）\n * =和in可以乱序，\n   * 比如a = 1 and b = 2 and c = 3 建立(a,b,c)索引可以任意顺序，\n   * mysql的查询优化器会帮你优化成索引可以识别的形式。\n * 尽量选择区分度高的列作为索引，\n   * 区分度的公式是count(distinct col)/count(*)，表示字段不重复的比例，比例越大我们扫描的记录数越少，唯一键的区分度是1\n\n\n# 参考资料：\n\n * 主键与唯一索引的区别\n * MySQL聚集索引和非聚集索引\n * MySQL索引都有哪些分类？",normalizedContent:"# 索引是什么\n\n索引是一种数据结构，它可以帮助我们快速查找和访问数据库中的数据。通过使用索引，数据库系统可以避免全表扫描，从而加快数据访问速度。\n\n在数据库中，索引可以类比于书籍的目录，它可以告诉我们在哪里能够找到某个特定的条目。如果我们需要查找一个特定的记录，而没有索引，那么数据库系统就需要扫描整个表来查找这个记录，这会浪费大量的时间和资源。但是如果我们有了索引，数据库系统就可以快速地定位到存储记录的位置，从而更快地获取需要的数据。\n\n索引可以根据其数据结构的不同分为多种类型，如b+树索引、哈希索引、全文索引等。其中，b-树索引是最常见的一种，它可以处理范围查询和排序操作，并且可以很好地支持高并发和多用户访问的环境。\n\n\n# 索引的优点\n\n * 大大减少了服务器需要扫描的数据行数。\n * 帮助服务器避免进行排序和分组，也就不需要创建临时表(b+tree 索引是有序的，可以用于 order by 和 group by 操作。临时表主要是在排序和分组过程中创建，因为不需要排序和分组，也就不需要创建临时表)。\n * 将随机 i/o 变为顺序 i/o(b+tree 索引是有序的，也就将相邻的数据都存储在一起)。\n\n\n# 索引的使用场景\n\n对于非常小的表、大部分情况下简单的全表扫描比建立索引更高效。\n\n对于中到大型的表，索引就非常有效。\n\n但是对于特大型的表，建立和维护索引的代价将会随之增长。这种情况下，需要用到一种技术可以直接区分出需要查询的一组数据，而不是一条记录一条记录地匹配，例如可以使用分区技术。\n\n\n# mysql 索引分类\n\n按数据结构分类可分为：b+tree索引、hash索引、full-text索引。 按物理存储分类可分为：聚簇索引、二级索引（辅助索引、非聚集索引）。 按字段特性分类可分为：主键索引、普通索引、前缀索引。 按字段个数分类可分为：单列索引、联合索引（复合索引、组合索引）。\n\n\n# 聚集索引和非聚集索引\n\n每张表只能有一个聚集索引。\n\n聚集索引是叶子结点存储完整数据，非聚集索引叶子结点存储聚集索引的地址。\n\n聚集索引，在索引页里直接存放数据，而非聚集索引在索引页里存放的是索引，这些索引指向专门的数据页的数据。\n\n聚集索引一般是表中的主键索引，如果表中没有显示指定主键，则会选择表中的第一个不允许为null的唯一索引，如果还是没有的话，就采用innodb存储引擎为每行数据内置的6字节rowid作为聚集索引。\n\n聚集索引一定是唯一索引，但唯一索引不一定是聚集索引。\n\n\n# mysql 各种索引区别\n\n普通索引 index：最基本的索引，没有任何限制\n\n唯一索引 unique：与\"普通索引\"类似，不同的就是：索引列的值必须唯一，但允许有空值。\n\n主键索引 primary key：是一种特殊的唯一索引，不允许有空值。\n\n全文索引 fulltext：innodb 5.6开始也支持了，针对较大的数据，生成全文索引很耗时好空间。\n\n组合索引：为了更多的提高mysql效率可建立组合索引，遵循”最左前缀“原则。\n\n\n# 唯一索引\n\n * 唯一索引不允许两行具有相同的索引值\n * 聚集索引一定是唯一索引，但唯一索引不一定是聚集索引。\n * 一个表中可以有多个唯一性索引（uniq index），但只能有一个主键。\n * 主键列不允许空值，而唯一性索引列（uniq index）允许空值。\n\n\n# 哈希索引\n\ninnodb 支持的哈希索引是自适应的，innodb 会根据表的使用状况自动为其生成哈希索引，不能人为干预是否在一张表生成哈希索引。\n\n\n# 索引的选择\n\n业务写多读少的场景：由于唯一索引用不上change buffer的优化机制，从性能角度出发建议优先考虑非唯一索引（即普通索引）。\n\n\n# 什么是change buffer\n\nchange buffer是mysql数据库引擎innodb用于优化写入性能的一种机制。在innodb存储引擎中，每次进行写入操作时，需要将数据写入到磁盘中的数据文件中，这个过程是比较耗时的。为了优化这个过程，innodb使用了change buffer机制。通过使用change buffer，innodb可以将多个修改操作合并成一个较大的操作，从而减少磁盘i/o的次数，提高写入性能。此外，change buffer还可以减少磁盘上的随机写入操作，从而降低了磁盘的读写负载。\n\n当需要更新一个数据页时，如果数据页在内存中就直接更新，而如果这个数据页还没有在内存中的话，inoodb会将这些更新操作缓存在change buffer中，这样就不需要从磁盘中读入这个数据页了，在后续的查询中再将这些操作应用到磁盘上的数据页中。在下次查询需要访问这个数据页的时候，将数据页读入内存，然后执行change buffer中与这个页有关的操作，保证数据逻辑的正确性。\n\n将change buffer中的操作应用到原数据页，得到最新结果的过程称为merge。除了访问这个数据页会触发merge外，系统有后台线程会定期merge。在数据库正常关闭（shutdown）的过程中， 也会执行merge操作。\n\nchange buffer对更新过程有加速作用，change buffer只限于用在普通索引的场景下，而不适用于唯一索引。\n\nchange buffer 适合写多读少的业务，因为页面在写完以后马上被访问到的概率比较小。这种业务模型常见的就是账单类、日志类的系统。\n\n反过来，假设一个业务的更新模式是写入之后马上会做查询，那么即使满足了条件，将更新先记录在change buffer，但之后由于马上要访问这个数据页，会立即触发merge过程。这样随机访问 io的次数不会减少，反而增加了change buffer的维护代价。所以，对于这种业务模式来说，change buffer反而起到了副作用。\n\n\n# 索引相关sql\n\n# 查看索引\nshow index from <tablename> [from <databasename>]\n\n# 创建索引\n1.该语句不能创建主键\ncreate <索引名> on <表名> (<列名> [<长度>] [asc | desc])\n\n2.在创建表时创建，在create table语句中添加\nconstraint primary key [索引类型] (<列名>...)\nkey | index [<索引名>] (<列名>...)\n\n3.在alter table中添加\nadd primary key [索引类型] (<列名>...)\nadd index [<索引名>] (<列名>...)\nadd unique [ index | key] [<索引名>] [<索引类型>] (<列名>,…)\n\n完整sql：\ncreate index <indexname> on <tablename> (<columnname>)\nalter table <tablename> add index <indexname> (<columnname>)\n\n\n\n# b+ 树索引\n\n索引是在存储引擎层实现的，而不是在服务器层实现的，所以不同存储引擎具有不同的索引类型和实现。\n\nb+ 树索引是大多数 mysql 存储引擎的默认索引类型。\n\nb 代表 balance，b+ 树是平衡多路查找树。b+ 树中，所有记录节点都是按键值大小顺序存放在同一层的叶子节点上，各叶子节点通过指针进行相连。\n\nb+树是高度平衡的，叶子节点存放着所有的数据。并且所有叶子节点位于同一层。\n\nb+ tree 是基于 b tree 和叶子节点顺序访问指针进行实现，它具有 b tree 的平衡性，并且通过顺序访问指针来提高区间查询的性能。\n\n在数据库中，b+ 树高度一般在 2~4 层，即查询某一键值的行记录最多只需 2~4 次 io。一般机械磁盘每秒可以做100次io，2~4 次io只需0.02~0.04秒。\n\nb+ 树索引可以分为聚集索引（clustered index）和辅助索引（secondary index，也叫非聚集索引）。但不管是聚集还是辅助索引，底层都是b+树。区别在于，叶子节点存放的是否是一整行的数据。\n\n聚集索引的优点在于，对主键的排序查找和范围查找速度非常快。\n\n辅助索引的叶子节点不包含行记录的所有信息，只包含键值和对应行数据的聚集索引键。\n\n\n操作：\n\n进行查找操作时，首先在根节点进行二分查找，找到一个 key 所在的指针，然后递归地在指针所指向的节点进行查找。直到查找到叶子节点，然后在叶子节点上进行二分查找，找出 key 所对应的 data。\n\n插入删除操作记录会破坏平衡树的平衡性，因此在插入删除操作之后，需要对树进行一个分裂、合并、旋转等操作来维护平衡性。\n\n\n# b树和b+树的对比\n\nb+ 树在b树的基础上，为叶子节点增加了链表指针，所有数据都存储在叶子节点。非叶子节点作为叶子节点的索引。\n\nb+ 树相对于 b树的优势在于：\n\n * 只有叶子节点存储数据，单一节点可以存储的元素就更多了，使得查询的io次数更少，因此更适合做为数据库底层数据结构。\n * 所有的叶子节点形成了一个有序链表，更加便于查找。\n * b+树支持range-query(区间查询)非常方便，而b树不支持。\n\n\n# b+树和红黑树的对比\n\n红黑树等平衡树也可以用来实现索引，但是文件系统及数据库系统普遍采用 b+ tree 作为索引结构，主要有以下两个原因:\n\n 1. 更少的查找次数\n\n平衡树查找操作的时间复杂度等于树高 h，而树高大致为 o(h)=o(logdn)，其中 d 为每个节点的出度。\n\n红黑树的出度为 2，而 b+ tree 的出度一般都非常大，所以红黑树的树高 h 很明显比 b+ tree 大非常多，检索的次数也就更多。\n\n 2. 利用计算机预读特性\n\n为了减少磁盘 i/o，磁盘往往不是严格按需读取，而是每次都会预读。预读过程中，磁盘进行顺序读取，顺序读取不需要进行磁盘寻道，并且只需要很短的旋转时间，因此速度会非常快。\n\n操作系统一般将内存和磁盘分割成固态大小的块，每一块称为一页，内存与磁盘以页为单位交换数据。数据库系统将索引的一个节点的大小设置为页的大小，使得一次 i/o 就能完全载入一个节点，并且可以利用预读特性，相邻的节点也能够被预先载入。\n\n\n# 覆盖索引（covering index）\n\n即从辅助索引中就可以查询到需要的信息，不需要再去查询聚集索引的信息，减少了回表，减少了io。\n\n\n# 索引下推（index condition pushdown，icp）\n\n不支持 icp 时，当进行索引查询时，首先根据索引查找到记录，再根据 where 条件过滤记录。而支持 icp的话，在取出索引的同时，进行 where 条件的过滤，即将 where 操作放在了存储引擎层。在某些查询下，可以大大减少上层sql层对记录的索取，也减少了回表次数。\n\n\n# 索引失效常见场景\n\n * 违反最左前缀匹配原则。例如有索引index(a,b)，但查询条件只有b字段。\n * 在索引列上做任何操作，包括计算、函数、类型转换等。\n * 范围查询使联合索引停止匹配。\n * 减少select*的使用。避免不必要的回表操作开销，尽量使用覆盖索引。\n * 使用不等于（!=、<>），使用or操作。\n * 字符串不加单引号索引失效。\n * like以通配符开头'%abc'。注意like ‘abc%’ 是可以走索引的。\n * order by 违反最左匹配原则，含非索引字段排序，会产生文件排序。\n * group by 违反最左匹配原则，含非索引字段分组，会导致产生临时表。\n\n\n# 建索引的几大原则\n\n * 最左前缀匹配原则，非常重要的原则\n   * mysql会一直向右匹配直到遇到范围查询(>、<、between、like)就停止匹配，\n   * 比如a = 1 and b = 2 and c > 3 and d = 4\n     * 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，\n     * 如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整（建立索引时他们三个的顺序）\n * =和in可以乱序，\n   * 比如a = 1 and b = 2 and c = 3 建立(a,b,c)索引可以任意顺序，\n   * mysql的查询优化器会帮你优化成索引可以识别的形式。\n * 尽量选择区分度高的列作为索引，\n   * 区分度的公式是count(distinct col)/count(*)，表示字段不重复的比例，比例越大我们扫描的记录数越少，唯一键的区分度是1\n\n\n# 参考资料：\n\n * 主键与唯一索引的区别\n * mysql聚集索引和非聚集索引\n * mysql索引都有哪些分类？",charsets:{cjk:!0},lastUpdated:"2023/03/29, 21:03:43",lastUpdatedTimestamp:1680095023e3},{title:"事务",frontmatter:{title:"事务",date:"2023-03-23T22:19:19.000Z",permalink:"/pages/e88566/"},regularPath:"/02.MySQL/03.%E4%BA%8B%E5%8A%A1.html",relativePath:"02.MySQL/03.事务.md",key:"v-d0afba64",path:"/pages/e88566/",headers:[{level:2,title:"事务",slug:"事务",normalizedTitle:"事务",charIndex:2},{level:2,title:"事务的四大特性（ACID）",slug:"事务的四大特性-acid",normalizedTitle:"事务的四大特性（acid）",charIndex:52},{level:2,title:"事务的隔离级别",slug:"事务的隔离级别",normalizedTitle:"事务的隔离级别",charIndex:134},{level:3,title:"设置隔离级别",slug:"设置隔离级别",normalizedTitle:"设置隔离级别",charIndex:603},{level:3,title:"脏读、不可重复读、幻读",slug:"脏读、不可重复读、幻读",normalizedTitle:"脏读、不可重复读、幻读",charIndex:256},{level:3,title:"注意",slug:"注意",normalizedTitle:"注意",charIndex:1246},{level:2,title:"数据库如何通过 ACID 来实现事务",slug:"数据库如何通过-acid-来实现事务",normalizedTitle:"数据库如何通过 acid 来实现事务",charIndex:1569},{level:2,title:"如何实现4种隔离级别",slug:"如何实现4种隔离级别",normalizedTitle:"如何实现4种隔离级别",charIndex:1773}],headersStr:"事务 事务的四大特性（ACID） 事务的隔离级别 设置隔离级别 脏读、不可重复读、幻读 注意 数据库如何通过 ACID 来实现事务 如何实现4种隔离级别",content:"# 事务\n\n事务的通俗解释：事务是一组逻辑操作，要么都执行，要么都不执行。\n\n经典例子：转账。\n\n\n# 事务的四大特性（ACID）\n\n * 原子性\n * 一致性：执行事务前后，数据保持一致，多个事务对同一个数据读取的结果是相同的；\n * 隔离性\n * 持久性\n\n\n# 事务的隔离级别\n\n为了达到事务的四大特性，数据库定义了4种不同的事务隔离级别，由低到高依次为\n\nRead uncommitted、Read committed、Repeatable read、Serializable，\n\n这四个级别可以逐个解决脏读、不可重复读、幻读这几类问题。\n\n * READ-UNCOMMITTED(读取未提交)： 最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、不可重复读、幻读问题。\n\n * READ-COMMITTED(读取已提交)： 允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生。\n\n * REPEATABLE-READ(可重复读)： 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。\n\n * SERIALIZABLE(可串行化)： 最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。\n\n\n# 设置隔离级别\n\n设置innodb的事务级别方法是：set 作用域 transaction isolation level 事务隔离级别，例如：\n\nSET [SESSION | GLOBAL] TRANSACTION ISOLATION LEVEL {READ UNCOMMITTED | READ COMMITTED | REPEATABLE READ | SERIALIZABLE}\n\nmysql> set global transaction isolation level read committed; //全局的\n\nmysql> set session transaction isolation level read committed; //当前会话（一个cmd窗口）\n\n\n\n# 脏读、不可重复读、幻读\n\n * 脏读(Drity Read)：某个事务已更新一份数据，另一个事务在此时读取了同一份数据，由于某些原因，前一个RollBack了操作，则后一个事务所读取的数据就会是不正确的。\n * 不可重复读(Non-repeatable read):在一个事务的两次查询之中数据不一致，这可能是两次查询过程中间插入了一个事务更新的原有的数据。\n * 幻读(Phantom Read):在一个事务的两次查询中数据笔数不一致，例如有一个事务查询了几列(Row)数据，而另一个事务却在此时插入了新的几列数据，先前的事务在接下来的查询中，就会发现有几列数据是它先前所没有的。\n\n\n# 注意\n\nMysql 默认采用的 REPEATABLE_READ隔离级别 Oracle 默认采用的 READ_COMMITTED隔离级别\n\n事务隔离机制的实现基于锁机制和并发调度。其中并发调度使用的是MVVC（多版本并发控制），通过保存修改的旧版本信息来支持并发一致性读和回滚等特性。\n\n因为隔离级别越低，事务请求的锁越少，所以大部分数据库系统的隔离级别都是READ-COMMITTED(读取提交内容):，但是你要知道的是InnoDB 存储引擎默认使用 **REPEATABLE-READ（可重读）**并不会有任何性能损失。\n\nInnoDB 存储引擎在 分布式事务 的情况下一般会用到**SERIALIZABLE(可串行化)**隔离级别。\n\n\n# 数据库如何通过 ACID 来实现事务\n\nACID：\n\nAID是手段，C是目的。为了保证数据状态的一致性，需要通过原子性、隔离性、持久性来保障。\n\n实现原子性：undo log\n\n实现持久性：redo log\n\n实现隔离性：加锁同步 + MVCC。\n\n阿里面试官：MySQL是如何实现ACID的？-mysql怎么实现acid\n\n深入学习MySQL事务：ACID特性的实现原理 - 编程迷思 - 博客园\n\n\n# 如何实现4种隔离级别\n\n提供了3种锁：写锁、读锁、范围锁。\n\n根据加锁的不同，提供了不同的隔离级别。\n\n串行化：对事务所有读、写的数据全加上读锁、写锁和范围锁。\n\n可重复读：对事务所涉及的数据加读锁和写锁，且直到事务结束，但不加范围锁。可能导致幻读问题（事务执行过程中，两个完全相同的范围查询得到不同的结果）。\n\n读已提交：对事务涉及的数据加的写锁一直持续到事务结束，加的读锁在查询操作结束后便马上释放。可能导致不可重复读问题（事务执行过程中，对同一行数据的两次查询得到不同结果）。\n\n读未提交：对事务涉及的数据只加写锁，且持续到事务结束。可能导致脏读问题（在事务执行过程中，一个事务读取到另一个事务未提交的数据）。\n\nMVCC（multi-version concurrency control）多版本并发控制\n\n针对一个事务读+一个事务写的场景，可以进行MVCC的无锁优化方案。只针对“读+写”场景优化。\n\n基本思路：对数据库的任何修改都不会覆盖之前的数据，而是产生一个新版副本与旧版本共存，以此达到读取时可以完全不用加锁的目的。版本可理解为数据库中每一行数据记录都存在2个看不见的字段：CREATE_VERSION和DELETE_VERSION，两个字段记录的都是事务ID。\n\n * 插入数据时：CREATE_VERSION 记录插入数据的事务 ID，DELETE_VERSION 为空。\n * 删除数据时：DELETE_VERSION 记录删除数据的事务 ID，CREATE_VERSION 为空。\n * 修改数据时：将修改数据视为“删除旧数据，插入新数据”的组合，即先将原有数据复制一份，原有数据的 DELETE_VERSION 记录修改数据的事务 ID，CREATE_VERSION 为空。复制出来的新数据的 CREATE_VERSION 记录修改数据的事务 ID，DELETE_VERSION 为空。\n\n此时，如有另外一个事务要读取这些发生了变化的数据，将根据隔离级别来决定到底应该读取哪个版本的数据。\n\n * 隔离级别是可重复读：总是读取 CREATE_VERSION 小于或等于当前事务 ID 的记录，在这个前提下，如果数据仍有多个版本，则取最新（事务 ID 最大）的。\n * 隔离级别是读已提交：总是取最新的版本即可，即最近被 Commit 的那个版本的数据记录。\n\n另外两个隔离级别都没有必要用到 MVCC，因为读未提交直接修改原始数据即可，其他事务查看数据的时候立刻可以看到，根本无须版本字段。可串行化本来的语义就是要阻塞其他事务的读取操作，而 MVCC 是做读取时无锁优化的，自然就不会放到一起用。",normalizedContent:"# 事务\n\n事务的通俗解释：事务是一组逻辑操作，要么都执行，要么都不执行。\n\n经典例子：转账。\n\n\n# 事务的四大特性（acid）\n\n * 原子性\n * 一致性：执行事务前后，数据保持一致，多个事务对同一个数据读取的结果是相同的；\n * 隔离性\n * 持久性\n\n\n# 事务的隔离级别\n\n为了达到事务的四大特性，数据库定义了4种不同的事务隔离级别，由低到高依次为\n\nread uncommitted、read committed、repeatable read、serializable，\n\n这四个级别可以逐个解决脏读、不可重复读、幻读这几类问题。\n\n * read-uncommitted(读取未提交)： 最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、不可重复读、幻读问题。\n\n * read-committed(读取已提交)： 允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生。\n\n * repeatable-read(可重复读)： 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。\n\n * serializable(可串行化)： 最高的隔离级别，完全服从acid的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。\n\n\n# 设置隔离级别\n\n设置innodb的事务级别方法是：set 作用域 transaction isolation level 事务隔离级别，例如：\n\nset [session | global] transaction isolation level {read uncommitted | read committed | repeatable read | serializable}\n\nmysql> set global transaction isolation level read committed; //全局的\n\nmysql> set session transaction isolation level read committed; //当前会话（一个cmd窗口）\n\n\n\n# 脏读、不可重复读、幻读\n\n * 脏读(drity read)：某个事务已更新一份数据，另一个事务在此时读取了同一份数据，由于某些原因，前一个rollback了操作，则后一个事务所读取的数据就会是不正确的。\n * 不可重复读(non-repeatable read):在一个事务的两次查询之中数据不一致，这可能是两次查询过程中间插入了一个事务更新的原有的数据。\n * 幻读(phantom read):在一个事务的两次查询中数据笔数不一致，例如有一个事务查询了几列(row)数据，而另一个事务却在此时插入了新的几列数据，先前的事务在接下来的查询中，就会发现有几列数据是它先前所没有的。\n\n\n# 注意\n\nmysql 默认采用的 repeatable_read隔离级别 oracle 默认采用的 read_committed隔离级别\n\n事务隔离机制的实现基于锁机制和并发调度。其中并发调度使用的是mvvc（多版本并发控制），通过保存修改的旧版本信息来支持并发一致性读和回滚等特性。\n\n因为隔离级别越低，事务请求的锁越少，所以大部分数据库系统的隔离级别都是read-committed(读取提交内容):，但是你要知道的是innodb 存储引擎默认使用 **repeatable-read（可重读）**并不会有任何性能损失。\n\ninnodb 存储引擎在 分布式事务 的情况下一般会用到**serializable(可串行化)**隔离级别。\n\n\n# 数据库如何通过 acid 来实现事务\n\nacid：\n\naid是手段，c是目的。为了保证数据状态的一致性，需要通过原子性、隔离性、持久性来保障。\n\n实现原子性：undo log\n\n实现持久性：redo log\n\n实现隔离性：加锁同步 + mvcc。\n\n阿里面试官：mysql是如何实现acid的？-mysql怎么实现acid\n\n深入学习mysql事务：acid特性的实现原理 - 编程迷思 - 博客园\n\n\n# 如何实现4种隔离级别\n\n提供了3种锁：写锁、读锁、范围锁。\n\n根据加锁的不同，提供了不同的隔离级别。\n\n串行化：对事务所有读、写的数据全加上读锁、写锁和范围锁。\n\n可重复读：对事务所涉及的数据加读锁和写锁，且直到事务结束，但不加范围锁。可能导致幻读问题（事务执行过程中，两个完全相同的范围查询得到不同的结果）。\n\n读已提交：对事务涉及的数据加的写锁一直持续到事务结束，加的读锁在查询操作结束后便马上释放。可能导致不可重复读问题（事务执行过程中，对同一行数据的两次查询得到不同结果）。\n\n读未提交：对事务涉及的数据只加写锁，且持续到事务结束。可能导致脏读问题（在事务执行过程中，一个事务读取到另一个事务未提交的数据）。\n\nmvcc（multi-version concurrency control）多版本并发控制\n\n针对一个事务读+一个事务写的场景，可以进行mvcc的无锁优化方案。只针对“读+写”场景优化。\n\n基本思路：对数据库的任何修改都不会覆盖之前的数据，而是产生一个新版副本与旧版本共存，以此达到读取时可以完全不用加锁的目的。版本可理解为数据库中每一行数据记录都存在2个看不见的字段：create_version和delete_version，两个字段记录的都是事务id。\n\n * 插入数据时：create_version 记录插入数据的事务 id，delete_version 为空。\n * 删除数据时：delete_version 记录删除数据的事务 id，create_version 为空。\n * 修改数据时：将修改数据视为“删除旧数据，插入新数据”的组合，即先将原有数据复制一份，原有数据的 delete_version 记录修改数据的事务 id，create_version 为空。复制出来的新数据的 create_version 记录修改数据的事务 id，delete_version 为空。\n\n此时，如有另外一个事务要读取这些发生了变化的数据，将根据隔离级别来决定到底应该读取哪个版本的数据。\n\n * 隔离级别是可重复读：总是读取 create_version 小于或等于当前事务 id 的记录，在这个前提下，如果数据仍有多个版本，则取最新（事务 id 最大）的。\n * 隔离级别是读已提交：总是取最新的版本即可，即最近被 commit 的那个版本的数据记录。\n\n另外两个隔离级别都没有必要用到 mvcc，因为读未提交直接修改原始数据即可，其他事务查看数据的时候立刻可以看到，根本无须版本字段。可串行化本来的语义就是要阻塞其他事务的读取操作，而 mvcc 是做读取时无锁优化的，自然就不会放到一起用。",charsets:{cjk:!0},lastUpdated:"2023/03/29, 21:03:43",lastUpdatedTimestamp:1680095023e3},{title:"MySQL中的log",frontmatter:{title:"MySQL中的log",date:"2023-03-23T22:23:15.000Z",permalink:"/pages/1d1ed2/"},regularPath:"/02.MySQL/04.MySQL%E4%B8%AD%E7%9A%84log.html",relativePath:"02.MySQL/04.MySQL中的log.md",key:"v-5ddc1b80",path:"/pages/1d1ed2/",headers:[{level:2,title:"MySQL 中的日志分类",slug:"mysql-中的日志分类",normalizedTitle:"mysql 中的日志分类",charIndex:2},{level:3,title:"MySQL Server 的日志包括：",slug:"mysql-server-的日志包括",normalizedTitle:"mysql server 的日志包括：",charIndex:497},{level:3,title:"存储引擎的日志包括：",slug:"存储引擎的日志包括",normalizedTitle:"存储引擎的日志包括：",charIndex:854},{level:2,title:"为什么只使用bin log无法实现崩溃恢复",slug:"为什么只使用bin-log无法实现崩溃恢复",normalizedTitle:"为什么只使用bin log无法实现崩溃恢复",charIndex:1207},{level:2,title:"redo log和bin log的对比",slug:"redo-log和bin-log的对比",normalizedTitle:"redo log和bin log的对比",charIndex:1537},{level:2,title:"redo log流程",slug:"redo-log流程",normalizedTitle:"redo log流程",charIndex:1832},{level:2,title:"Q & A",slug:"q-a",normalizedTitle:"q &amp; a",charIndex:null}],headersStr:"MySQL 中的日志分类 MySQL Server 的日志包括： 存储引擎的日志包括： 为什么只使用bin log无法实现崩溃恢复 redo log和bin log的对比 redo log流程 Q & A",content:'# MySQL 中的日志分类\n\nMySQL 中的日志分为两类：MySQL Server 的日志和存储引擎的日志。\n\nMySQL里经常说到的WAL技术，WAL的全称是WriteAhead Logging，它的关键点就是先写日志，再写磁盘。\n\nMySQL整体来看，其实有两块：一块是Server层，它主要做的是MySQL功能层面的事情；还有一块是引擎层，负责存储相关的具体事宜。redo log是 InnoDB引擎特有的日志，而Server层也有自己的日志，称为binlog（归档日志）。\n\n最开始MySQL里并没有InnoDB引擎。MySQL自带的引擎是MyISAM，但是MyISAM没有 crash-safe的能力，binlog日志只能用于归档。而InnoDB是另一个公司以插件形式引入MySQL的，既然只依靠binlog是没有crash-safe能力的，所以InnoDB使用另外一套日志系统，也就是 redo log来实现crash-safe能力。\n\n有了redo log，InnoDB就可以保证即使数据库发生异常重启，之前提交的记录都不会丢失，这个 能力称为crash-safe。\n\n\n# MySQL Server 的日志包括：\n\n 1. 慢查询日志（slow query log）：记录执行时间超过阈值的 SQL 语句。\n 2. 错误日志（error log）：记录 MySQL Server 在运行过程中出现的错误信息。\n 3. 通用查询日志（general query log）：记录所有连接到 MySQL Server 上的 SQL 语句。\n 4. 二进制日志（binary log/bin log）：记录对数据库的所有更新操作，包括 INSERT、UPDATE 和 DELETE 等语句，记录的是SQL语句或者语句的结果。binlog 用于数据备份、恢复和复制。\n 5. 中继日志（relay log）：在 MySQL 主从复制架构中，记录从库接收到的二进制日志，以便同步主库的数据。\n\n\n# 存储引擎的日志包括：\n\n 1. 事务日志（transaction log）：InnoDB 存储引擎的事务日志，用于实现事务的原子性和持久性。\n 2. 回滚日志（rollback log/undo log）：用于实现事务的回滚操作，同时也是 InnoDB 存储引擎的恢复机制的一部分。用于记录事务执行前的数据，以便在事务回滚时恢复数据的原始状态。在事务提交后，undo log 中的数据可以被删除或重用。\n 3. 重做日志（redo log）：用于保证数据库在崩溃后的数据一致性和完整性，同时也是 InnoDB 存储引擎的恢复机制的一部分。用于记录事务执行的所有修改操作，包括 INSERT、UPDATE、DELETE 等。在事务提交前，redo log 记录了修改的物理信息，保证事务能够被恢复。\n\n\n# 为什么只使用bin log无法实现崩溃恢复\n\nBinlog 只记录了数据库的修改操作，而没有记录对应的数据快照，因此在恢复数据时需要先恢复最近的一次数据快照，再依次执行 Binlog 中的修改操作。\n\nBinlog 只记录了已经提交的事务，而没有记录未提交的事务，如果 MySQL 实例在执行未提交的事务时崩溃，那么这些事务中所做的修改就无法通过 Binlog 进行恢复。\n\n因此，在 MySQL 中，实现崩溃恢复功能需要同时使用 Binlog 和 InnoDB 的 redo log，其中 InnoDB 的 redo log 记录了数据库引擎所做的修改操作，包括已经提交的和未提交的事务，可以用于在 MySQL 异常崩溃后快速恢复到上一个稳定状态。\n\n\n# redo log和bin log的对比\n\n两种日志有以下三点不同：\n\n 1. redo log是InnoDB引擎特有的；binlog是MySQL的Server层实现的，所有引擎都可以使用。\n 2. redo log是物理日志，记录的是“在某个数据页上做了什么修改”；binlog是逻辑日志，记录的是这个语句的原始逻辑，比如“给ID=2这一行的c字段加1 ”。 （所以bin log 才无法实现crash-safe）\n 3. redo log是循环写的，空间固定会用完；binlog是可以追加写入的。“追加写”是指binlog文件写到一定大小后会切换到下一个，并不会覆盖以前的日志。\n\n\n# redo log流程\n\nredo log的写入拆成了两个步骤：prepare和commit，是"两阶段提交"。\n\n第一阶段：预提交（Prepare）\n\n当一个事务提交时，InnoDB 存储引擎首先会将事务所做的修改操作记录到 redo log 中，这个过程称为预提交（Prepare）。在预提交阶段，InnoDB 将修改操作写入 redo log 缓冲区，但不会将修改操作写入磁盘，因此预提交是一个快速的操作。\n\n第二阶段：正式提交（Commit）\n\n当预提交完成后，InnoDB 存储引擎会等待 MySQL 主线程发出提交指令。在接收到提交指令后，InnoDB 会将 redo log 缓冲区中的修改操作写入磁盘，这个过程称为正式提交（Commit）。正式提交阶段是一个相对慢速的操作，因为需要将修改操作写入磁盘，确保数据的持久性。\n\n在两阶段提交的过程中，如果预提交成功但在正式提交前发生了故障，比如 MySQL 服务器崩溃或者断电等，那么 InnoDB 存储引擎在启动时会检查 redo log 中未提交的事务，并将这些未提交的事务进行回滚，以保证数据的一致性。因此，在 InnoDB 存储引擎中，redo log 的两阶段提交保证了事务的原子性和持久性。\n\n\n当一个事务提交时，InnoDB 首先将修改操作写入 redo log 中，然后再将这个事务的提交操作记录到 Binlog 中。\n\n\n# Q & A\n\nQ：定期全量备份的周期“取决于系统重要性，有的是一天一备，有的是一周一备”。那么在什么场景下，一天一备会比一周一备更有优势呢？或者说，它影响了这个数据库系统的哪个指标？\n\nA：一天一备，那么如果需要恢复数据的话，只要保证当天的binlog完整即可；一周一备的话就要保证一周的binlog完整；同时频繁全量备份需要更多存储空间，如何选择取决于业务的重要性，对应的指标是RTO(目标恢复时间)。',normalizedContent:'# mysql 中的日志分类\n\nmysql 中的日志分为两类：mysql server 的日志和存储引擎的日志。\n\nmysql里经常说到的wal技术，wal的全称是writeahead logging，它的关键点就是先写日志，再写磁盘。\n\nmysql整体来看，其实有两块：一块是server层，它主要做的是mysql功能层面的事情；还有一块是引擎层，负责存储相关的具体事宜。redo log是 innodb引擎特有的日志，而server层也有自己的日志，称为binlog（归档日志）。\n\n最开始mysql里并没有innodb引擎。mysql自带的引擎是myisam，但是myisam没有 crash-safe的能力，binlog日志只能用于归档。而innodb是另一个公司以插件形式引入mysql的，既然只依靠binlog是没有crash-safe能力的，所以innodb使用另外一套日志系统，也就是 redo log来实现crash-safe能力。\n\n有了redo log，innodb就可以保证即使数据库发生异常重启，之前提交的记录都不会丢失，这个 能力称为crash-safe。\n\n\n# mysql server 的日志包括：\n\n 1. 慢查询日志（slow query log）：记录执行时间超过阈值的 sql 语句。\n 2. 错误日志（error log）：记录 mysql server 在运行过程中出现的错误信息。\n 3. 通用查询日志（general query log）：记录所有连接到 mysql server 上的 sql 语句。\n 4. 二进制日志（binary log/bin log）：记录对数据库的所有更新操作，包括 insert、update 和 delete 等语句，记录的是sql语句或者语句的结果。binlog 用于数据备份、恢复和复制。\n 5. 中继日志（relay log）：在 mysql 主从复制架构中，记录从库接收到的二进制日志，以便同步主库的数据。\n\n\n# 存储引擎的日志包括：\n\n 1. 事务日志（transaction log）：innodb 存储引擎的事务日志，用于实现事务的原子性和持久性。\n 2. 回滚日志（rollback log/undo log）：用于实现事务的回滚操作，同时也是 innodb 存储引擎的恢复机制的一部分。用于记录事务执行前的数据，以便在事务回滚时恢复数据的原始状态。在事务提交后，undo log 中的数据可以被删除或重用。\n 3. 重做日志（redo log）：用于保证数据库在崩溃后的数据一致性和完整性，同时也是 innodb 存储引擎的恢复机制的一部分。用于记录事务执行的所有修改操作，包括 insert、update、delete 等。在事务提交前，redo log 记录了修改的物理信息，保证事务能够被恢复。\n\n\n# 为什么只使用bin log无法实现崩溃恢复\n\nbinlog 只记录了数据库的修改操作，而没有记录对应的数据快照，因此在恢复数据时需要先恢复最近的一次数据快照，再依次执行 binlog 中的修改操作。\n\nbinlog 只记录了已经提交的事务，而没有记录未提交的事务，如果 mysql 实例在执行未提交的事务时崩溃，那么这些事务中所做的修改就无法通过 binlog 进行恢复。\n\n因此，在 mysql 中，实现崩溃恢复功能需要同时使用 binlog 和 innodb 的 redo log，其中 innodb 的 redo log 记录了数据库引擎所做的修改操作，包括已经提交的和未提交的事务，可以用于在 mysql 异常崩溃后快速恢复到上一个稳定状态。\n\n\n# redo log和bin log的对比\n\n两种日志有以下三点不同：\n\n 1. redo log是innodb引擎特有的；binlog是mysql的server层实现的，所有引擎都可以使用。\n 2. redo log是物理日志，记录的是“在某个数据页上做了什么修改”；binlog是逻辑日志，记录的是这个语句的原始逻辑，比如“给id=2这一行的c字段加1 ”。 （所以bin log 才无法实现crash-safe）\n 3. redo log是循环写的，空间固定会用完；binlog是可以追加写入的。“追加写”是指binlog文件写到一定大小后会切换到下一个，并不会覆盖以前的日志。\n\n\n# redo log流程\n\nredo log的写入拆成了两个步骤：prepare和commit，是"两阶段提交"。\n\n第一阶段：预提交（prepare）\n\n当一个事务提交时，innodb 存储引擎首先会将事务所做的修改操作记录到 redo log 中，这个过程称为预提交（prepare）。在预提交阶段，innodb 将修改操作写入 redo log 缓冲区，但不会将修改操作写入磁盘，因此预提交是一个快速的操作。\n\n第二阶段：正式提交（commit）\n\n当预提交完成后，innodb 存储引擎会等待 mysql 主线程发出提交指令。在接收到提交指令后，innodb 会将 redo log 缓冲区中的修改操作写入磁盘，这个过程称为正式提交（commit）。正式提交阶段是一个相对慢速的操作，因为需要将修改操作写入磁盘，确保数据的持久性。\n\n在两阶段提交的过程中，如果预提交成功但在正式提交前发生了故障，比如 mysql 服务器崩溃或者断电等，那么 innodb 存储引擎在启动时会检查 redo log 中未提交的事务，并将这些未提交的事务进行回滚，以保证数据的一致性。因此，在 innodb 存储引擎中，redo log 的两阶段提交保证了事务的原子性和持久性。\n\n\n当一个事务提交时，innodb 首先将修改操作写入 redo log 中，然后再将这个事务的提交操作记录到 binlog 中。\n\n\n# q & a\n\nq：定期全量备份的周期“取决于系统重要性，有的是一天一备，有的是一周一备”。那么在什么场景下，一天一备会比一周一备更有优势呢？或者说，它影响了这个数据库系统的哪个指标？\n\na：一天一备，那么如果需要恢复数据的话，只要保证当天的binlog完整即可；一周一备的话就要保证一周的binlog完整；同时频繁全量备份需要更多存储空间，如何选择取决于业务的重要性，对应的指标是rto(目标恢复时间)。',charsets:{cjk:!0},lastUpdated:"2023/03/29, 21:03:43",lastUpdatedTimestamp:1680095023e3},{title:"MVCC解决幻读问题",frontmatter:{title:"MVCC解决幻读问题",date:"2023-03-31T23:17:34.000Z",permalink:"/pages/43cd7b/"},regularPath:"/02.MySQL/05.MVCC%E8%A7%A3%E5%86%B3%E5%B9%BB%E8%AF%BB%E9%97%AE%E9%A2%98.html",relativePath:"02.MySQL/05.MVCC解决幻读问题.md",key:"v-47a18848",path:"/pages/43cd7b/",headers:[{level:2,title:"快照读和当前读",slug:"快照读和当前读",normalizedTitle:"快照读和当前读",charIndex:583}],headersStr:"快照读和当前读",content:"InnoDB 是 MySQL 数据库中一种常见的存储引擎，它使用 MVCC 技术来实现并发控制。\n\nMVCC 的流程可以一定程度上解决幻读问题。幻读是指在同一事务中，第二次读取同样的查询条件，却得到了不同的结果，通常发生在并发事务中插入或删除数据时。MVCC 使用快照读（Snapshot Read）和当前读（Current Read）来避免幻读问题。\n\n对于 InnoDB 引擎，MVCC 的实现方式是通过使用多版本数据行来避免锁竞争问题。具体地，每行数据在表中存储多个版本，每个版本都有一个时间戳，用于表示该版本的创建时间。事务在执行读操作时，会根据其启动时间来选择一个一致性视图（Consistent Read View），只能看到该视图中已经存在的数据，因此可以避免幻读的问题。\n\n如果在>80的范围内插入一条90的数据，在 InnoDB 引擎中，如果该事务使用的是快照读，那么它将看不到这条记录，因此也不会出现幻读问题。如果该事务使用的是当前读，那么它将会锁定记录，避免其他并发事务对该记录进行修改或删除操作，从而避免幻读的问题。\n\n需要注意的是，InnoDB 引擎中仍然存在一些特殊情况下可能会出现幻读问题，例如在读取一些特殊的索引时。为了避免这些问题，可以使用一些技术来提高 MVCC 的可靠性，例如使用间隙锁（Gap Lock）来避免幻读。\n\n\n# 快照读和当前读\n\n在数据库中，快照读和当前读是两种不同的读取数据的方式。\n\n快照读是指在读取数据时，读取的是数据库在事务开始时的一个快照，不会受到其他并发事务的影响。在 MySQL 数据库中，可以使用 SELECT 语句来进行快照读取，例如：\n\nSELECT * FROM table_name;\n\n\n当前读则会锁定记录，保证在当前事务内读取的数据是最新的。在 MySQL 数据库中，如果需要进行当前读操作，可以使用 FOR UPDATE 或者 FOR SHARE 语句来进行锁定，例如：\n\nSELECT * FROM table_name WHERE column_name = value FOR UPDATE;\n\n\n在以上语句中，FOR UPDATE 表示对查询到的记录进行排它锁定，其他事务不能修改或者锁定该记录，而 FOR SHARE 则表示对查询到的记录进行共享锁定，其他事务不能修改该记录，但可以读取该记录。\n\n需要注意的是，不同的数据库管理系统中可能具有不同的语法来进行快照读或当前读操作，具体的实现方式可能会有所不同。",normalizedContent:"innodb 是 mysql 数据库中一种常见的存储引擎，它使用 mvcc 技术来实现并发控制。\n\nmvcc 的流程可以一定程度上解决幻读问题。幻读是指在同一事务中，第二次读取同样的查询条件，却得到了不同的结果，通常发生在并发事务中插入或删除数据时。mvcc 使用快照读（snapshot read）和当前读（current read）来避免幻读问题。\n\n对于 innodb 引擎，mvcc 的实现方式是通过使用多版本数据行来避免锁竞争问题。具体地，每行数据在表中存储多个版本，每个版本都有一个时间戳，用于表示该版本的创建时间。事务在执行读操作时，会根据其启动时间来选择一个一致性视图（consistent read view），只能看到该视图中已经存在的数据，因此可以避免幻读的问题。\n\n如果在>80的范围内插入一条90的数据，在 innodb 引擎中，如果该事务使用的是快照读，那么它将看不到这条记录，因此也不会出现幻读问题。如果该事务使用的是当前读，那么它将会锁定记录，避免其他并发事务对该记录进行修改或删除操作，从而避免幻读的问题。\n\n需要注意的是，innodb 引擎中仍然存在一些特殊情况下可能会出现幻读问题，例如在读取一些特殊的索引时。为了避免这些问题，可以使用一些技术来提高 mvcc 的可靠性，例如使用间隙锁（gap lock）来避免幻读。\n\n\n# 快照读和当前读\n\n在数据库中，快照读和当前读是两种不同的读取数据的方式。\n\n快照读是指在读取数据时，读取的是数据库在事务开始时的一个快照，不会受到其他并发事务的影响。在 mysql 数据库中，可以使用 select 语句来进行快照读取，例如：\n\nselect * from table_name;\n\n\n当前读则会锁定记录，保证在当前事务内读取的数据是最新的。在 mysql 数据库中，如果需要进行当前读操作，可以使用 for update 或者 for share 语句来进行锁定，例如：\n\nselect * from table_name where column_name = value for update;\n\n\n在以上语句中，for update 表示对查询到的记录进行排它锁定，其他事务不能修改或者锁定该记录，而 for share 则表示对查询到的记录进行共享锁定，其他事务不能修改该记录，但可以读取该记录。\n\n需要注意的是，不同的数据库管理系统中可能具有不同的语法来进行快照读或当前读操作，具体的实现方式可能会有所不同。",charsets:{cjk:!0}},{title:"数据库三范式",frontmatter:{title:"数据库三范式",date:"2023-03-31T23:22:19.000Z",permalink:"/pages/9ed061/"},regularPath:"/02.MySQL/06.%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%89%E8%8C%83%E5%BC%8F.html",relativePath:"02.MySQL/06.数据库三范式.md",key:"v-e231d910",path:"/pages/9ed061/",headers:[{level:2,title:"例子说明第二范式和第三范式的区别",slug:"例子说明第二范式和第三范式的区别",normalizedTitle:"例子说明第二范式和第三范式的区别",charIndex:958},{level:3,title:"第二范式",slug:"第二范式",normalizedTitle:"第二范式",charIndex:145},{level:3,title:"第三范式",slug:"第三范式",normalizedTitle:"第三范式",charIndex:520}],headersStr:"例子说明第二范式和第三范式的区别 第二范式 第三范式",content:"数据库三范式是关系型数据库设计中的基本原则，用于规范数据库中的数据结构，避免数据冗余和数据不一致性。\n\n * 第一范式（1NF）：要求关系中的每个属性具有原子性，即不可再分解。例如，一个顾客信息表中的电话号码字段应该是原子的，而不能把电话号码分成区号、电话号码、分机号等多个字段。\n\n * 第二范式（2NF）：要求关系中的每个非主键属性都完全依赖于主键。也就是说，如果一个关系中有多个主键，则每个非主键属性都应该和这些主键相关，而不能只和其中一部分主键相关。\n   \n   * 例如：假设有一个学生课程表（StudentCourses）关系，其中包括学生ID、课程ID、课程名称、教师ID和教师姓名等字段。其中，学生ID和课程ID组成联合主键，教师ID和教师姓名与课程ID相关。\n     \n     此时，课程名称和教师姓名两个字段都不完全依赖于主键，因为它们只和课程ID相关，而不和学生ID相关。为了满足第二范式，应该将教师姓名从StudentCourses关系中拆分出来，建立一个新的教师表（Teachers），将教师ID、教师姓名等字段放入其中。这样，每个非主键属性都完全依赖于主键，不会出现数据冗余和数据不一致性的问题。\n\n * 第三范式（3NF）：要求关系中的每个非主键属性都不传递依赖于主键。也就是说，如果一个非主键属性依赖于另一个非主键属性，那么它应该被拆分成单独的关系，以避免数据冗余和不一致性。\n   \n   * 例如：假设有一个订单关系（Orders），其中包括订单号、客户ID、客户姓名、客户地址等字段。此时，客户姓名和客户地址两个字段之间存在传递依赖，因为它们都和客户ID相关。为了满足第三范式，应该将客户姓名和客户地址两个字段从订单关系中拆分出来，建立一个新的客户表（Customers），将客户ID、客户姓名、客户地址等字段放入其中。这样，每个非主键属性都不传递依赖于主键，可以避免数据冗余和不一致性的问题。\n\n三范式的实际应用可以提高数据库的数据存储效率、减少冗余数据，从而避免数据不一致的情况出现。但是，在实际的数据库设计过程中，有时候严格遵循三范式并不一定是最优的选择，需要根据具体情况进行权衡和取舍。例如，在某些查询频繁的场景下，可能需要采用反范式设计来提高查询性能。\n\n\n# 例子说明第二范式和第三范式的区别\n\n假设有一个订单表（Order）包括以下字段：订单号、客户号、客户名称、客户地址、商品号、商品名称、商品单价、商品数量、订单总价。其中，订单号为主键。\n\n\n# 第二范式\n\n如果我们将商品名称和商品单价两个字段放在订单表中，那么会出现以下问题：\n\n数据冗余：如果一种商品被多个订单使用，那么它的名称和单价就会在订单表中重复出现。 数据不一致：如果修改了一种商品的名称或单价，那么所有使用该商品的订单中的相应字段都需要修改。 为了避免这些问题，我们可以将商品名称和商品单价从订单表中拆分出来，建立一个新的商品表（Product），包括商品号、商品名称、商品单价等字段。这样，每个非主键属性都完全依赖于主键，可以避免数据冗余和数据不一致性的问题。\n\n\n# 第三范式\n\n如果我们将客户名称和客户地址两个字段放在订单表中，那么会出现以下问题：\n\n数据冗余：如果一个客户在多个订单中使用，那么它的名称和地址就会在订单表中重复出现。 数据不一致：如果修改了一个客户的名称或地址，那么所有使用该客户的订单中的相应字段都需要修改。 为了避免这些问题，我们可以将客户名称和客户地址从订单表中拆分出来，建立一个新的客户表（Customer），包括客户号、客户名称、客户地址等字段。这样，每个非主键属性都不传递依赖于主键，可以避免数据冗余和数据不一致性的问题。",normalizedContent:"数据库三范式是关系型数据库设计中的基本原则，用于规范数据库中的数据结构，避免数据冗余和数据不一致性。\n\n * 第一范式（1nf）：要求关系中的每个属性具有原子性，即不可再分解。例如，一个顾客信息表中的电话号码字段应该是原子的，而不能把电话号码分成区号、电话号码、分机号等多个字段。\n\n * 第二范式（2nf）：要求关系中的每个非主键属性都完全依赖于主键。也就是说，如果一个关系中有多个主键，则每个非主键属性都应该和这些主键相关，而不能只和其中一部分主键相关。\n   \n   * 例如：假设有一个学生课程表（studentcourses）关系，其中包括学生id、课程id、课程名称、教师id和教师姓名等字段。其中，学生id和课程id组成联合主键，教师id和教师姓名与课程id相关。\n     \n     此时，课程名称和教师姓名两个字段都不完全依赖于主键，因为它们只和课程id相关，而不和学生id相关。为了满足第二范式，应该将教师姓名从studentcourses关系中拆分出来，建立一个新的教师表（teachers），将教师id、教师姓名等字段放入其中。这样，每个非主键属性都完全依赖于主键，不会出现数据冗余和数据不一致性的问题。\n\n * 第三范式（3nf）：要求关系中的每个非主键属性都不传递依赖于主键。也就是说，如果一个非主键属性依赖于另一个非主键属性，那么它应该被拆分成单独的关系，以避免数据冗余和不一致性。\n   \n   * 例如：假设有一个订单关系（orders），其中包括订单号、客户id、客户姓名、客户地址等字段。此时，客户姓名和客户地址两个字段之间存在传递依赖，因为它们都和客户id相关。为了满足第三范式，应该将客户姓名和客户地址两个字段从订单关系中拆分出来，建立一个新的客户表（customers），将客户id、客户姓名、客户地址等字段放入其中。这样，每个非主键属性都不传递依赖于主键，可以避免数据冗余和不一致性的问题。\n\n三范式的实际应用可以提高数据库的数据存储效率、减少冗余数据，从而避免数据不一致的情况出现。但是，在实际的数据库设计过程中，有时候严格遵循三范式并不一定是最优的选择，需要根据具体情况进行权衡和取舍。例如，在某些查询频繁的场景下，可能需要采用反范式设计来提高查询性能。\n\n\n# 例子说明第二范式和第三范式的区别\n\n假设有一个订单表（order）包括以下字段：订单号、客户号、客户名称、客户地址、商品号、商品名称、商品单价、商品数量、订单总价。其中，订单号为主键。\n\n\n# 第二范式\n\n如果我们将商品名称和商品单价两个字段放在订单表中，那么会出现以下问题：\n\n数据冗余：如果一种商品被多个订单使用，那么它的名称和单价就会在订单表中重复出现。 数据不一致：如果修改了一种商品的名称或单价，那么所有使用该商品的订单中的相应字段都需要修改。 为了避免这些问题，我们可以将商品名称和商品单价从订单表中拆分出来，建立一个新的商品表（product），包括商品号、商品名称、商品单价等字段。这样，每个非主键属性都完全依赖于主键，可以避免数据冗余和数据不一致性的问题。\n\n\n# 第三范式\n\n如果我们将客户名称和客户地址两个字段放在订单表中，那么会出现以下问题：\n\n数据冗余：如果一个客户在多个订单中使用，那么它的名称和地址就会在订单表中重复出现。 数据不一致：如果修改了一个客户的名称或地址，那么所有使用该客户的订单中的相应字段都需要修改。 为了避免这些问题，我们可以将客户名称和客户地址从订单表中拆分出来，建立一个新的客户表（customer），包括客户号、客户名称、客户地址等字段。这样，每个非主键属性都不传递依赖于主键，可以避免数据冗余和数据不一致性的问题。",charsets:{cjk:!0}},{title:"Untitled",frontmatter:{title:"Untitled",date:"2023-08-14T17:12:08.000Z",permalink:"/pages/a4281a/"},regularPath:"/02.MySQL/07.MySQL%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.html",relativePath:"02.MySQL/07.MySQL数据类型.md",key:"v-5d98fa16",path:"/pages/a4281a/",headersStr:null,content:" * 整数类型\n   * TINYINT\n   * SMALLINT\n   * INT 4个字节\n   * BIGINT 8个字节\n * 浮点类型和定点类型\n   * FLOAT\n   * DOUBLE\n   * DECIMAL\n   * 浮点数型在数据库中存放的是近似值，而定点数类型在数据库中存放的是精确值。\n * char类型和varchar类型\n   * char\n   * varchar\n   * CHAR类型指定了n之后，如果存入的字符数小于n，后面将会以空格补齐，查询的时候再将末尾的空格去掉，所以CHAR类型存储的字符串末尾不能有空格，VARCHAR不受此限制。\n   * CHAR类型的字符串检索速度要比VARCHAR类型的快。\n * text类型和blob类型\n   * BLOB和TEXT是对应的，不过存储方式不同，TEXT是以文本方式存储的，而BLOB是以二进制方式存储的。如果存储英文的话，TEXT区分大小写，而BLOB不区分大小写。TEXT可以指定字符集，BLOB不用指定字符集。\n   * tinytest, tinyblob\n   * text, blob\n   * mediumtext, mediumblob\n   * longtext, longblob\n * binary类型和varbinary\n   * BINARY和VARBINARY数据类型类似于CHAR和VARCHAR。不同之处在于BINARY与VARBINARY使用字节为存储单位，而CHAR与VARCHAR使用字符为存储单位。\n * 时间和日期类型\n   * year\n   * time\n   * date\n   * datetime\n   * timestamp\n * enum和set类型\n\nhttps://www.modb.pro/db/50149",normalizedContent:" * 整数类型\n   * tinyint\n   * smallint\n   * int 4个字节\n   * bigint 8个字节\n * 浮点类型和定点类型\n   * float\n   * double\n   * decimal\n   * 浮点数型在数据库中存放的是近似值，而定点数类型在数据库中存放的是精确值。\n * char类型和varchar类型\n   * char\n   * varchar\n   * char类型指定了n之后，如果存入的字符数小于n，后面将会以空格补齐，查询的时候再将末尾的空格去掉，所以char类型存储的字符串末尾不能有空格，varchar不受此限制。\n   * char类型的字符串检索速度要比varchar类型的快。\n * text类型和blob类型\n   * blob和text是对应的，不过存储方式不同，text是以文本方式存储的，而blob是以二进制方式存储的。如果存储英文的话，text区分大小写，而blob不区分大小写。text可以指定字符集，blob不用指定字符集。\n   * tinytest, tinyblob\n   * text, blob\n   * mediumtext, mediumblob\n   * longtext, longblob\n * binary类型和varbinary\n   * binary和varbinary数据类型类似于char和varchar。不同之处在于binary与varbinary使用字节为存储单位，而char与varchar使用字符为存储单位。\n * 时间和日期类型\n   * year\n   * time\n   * date\n   * datetime\n   * timestamp\n * enum和set类型\n\nhttps://www.modb.pro/db/50149",charsets:{cjk:!0}},{title:"范围查询导致索引失效问题",frontmatter:{title:"范围查询导致索引失效问题",date:"2023-08-24T22:59:28.000Z",permalink:"/pages/c10308/"},regularPath:"/02.MySQL/08.%E8%8C%83%E5%9B%B4%E6%9F%A5%E8%AF%A2%E5%AF%BC%E8%87%B4%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88%E9%97%AE%E9%A2%98.html",relativePath:"02.MySQL/08.范围查询导致索引失效问题.md",key:"v-2552a92f",path:"/pages/c10308/",headers:[{level:2,title:"范围查询导致联合索引停止匹配",slug:"范围查询导致联合索引停止匹配",normalizedTitle:"范围查询导致联合索引停止匹配",charIndex:2}],headersStr:"范围查询导致联合索引停止匹配",content:"# 范围查询导致联合索引停止匹配\n\n为什么范围查询会使联合索引停止匹配？\n\n涉及到最左前缀匹配原理。假设建立一个联合索引 index(a, b)，会先对a进行排序，在a相等的情况下对b进行排序，如下图所示。在该索引树上，a是全局有序的，而b则处于全局无序、局部有序状态。从全局来看，b的值为1、2、1、4、1、2，只有 b=2 查询条件无法直接使用该索引；从局部来看，当a的值确定时，b则是有序状态，a=2 && b=4可以使用该索引。所以范围查询使联合索引停止匹配的根本原因是，索引树上非首字段的有序状态依赖前一个字段相等情况，而范围查询破坏了下一个索引字段局部有序状态，导致索引停止匹配。\n\n\n\n联合索引的最左匹配原则，在遇到范围查询（如 >、<）的时候，就会停止匹配，也就是范围查询的字段可以用到联合索引，但是在范围查询字段后面的字段无法用到联合索引。\n\n注意，对于 >=、<=、BETWEEN、like 前缀匹配的范围查询，并不会停止匹配（是因为对于部分a等于的数据，b可以走索引去过滤）。\n\neg：select * from t_table where a >= 1 and b = 2\n\n虽然在符合 a>= 1 条件的二级索引记录的范围里，b 字段的值是「无序」的，但是对于符合 a = 1 的二级索引记录的范围里，b 字段的值是「有序」的。\n\n于是，在确定需要扫描的二级索引的范围时，当二级索引记录的 a 字段值为 1 时，可以通过 b = 2 条件减少需要扫描的二级索引记录范围（b 字段可以利用联合索引进行索引查询的意思）。\n\n所以，这条查询语句 a 和 b 字段都用到了联合索引进行索引查询。\n\nhttps://www.51cto.com/article/720535.html",normalizedContent:"# 范围查询导致联合索引停止匹配\n\n为什么范围查询会使联合索引停止匹配？\n\n涉及到最左前缀匹配原理。假设建立一个联合索引 index(a, b)，会先对a进行排序，在a相等的情况下对b进行排序，如下图所示。在该索引树上，a是全局有序的，而b则处于全局无序、局部有序状态。从全局来看，b的值为1、2、1、4、1、2，只有 b=2 查询条件无法直接使用该索引；从局部来看，当a的值确定时，b则是有序状态，a=2 && b=4可以使用该索引。所以范围查询使联合索引停止匹配的根本原因是，索引树上非首字段的有序状态依赖前一个字段相等情况，而范围查询破坏了下一个索引字段局部有序状态，导致索引停止匹配。\n\n\n\n联合索引的最左匹配原则，在遇到范围查询（如 >、<）的时候，就会停止匹配，也就是范围查询的字段可以用到联合索引，但是在范围查询字段后面的字段无法用到联合索引。\n\n注意，对于 >=、<=、between、like 前缀匹配的范围查询，并不会停止匹配（是因为对于部分a等于的数据，b可以走索引去过滤）。\n\neg：select * from t_table where a >= 1 and b = 2\n\n虽然在符合 a>= 1 条件的二级索引记录的范围里，b 字段的值是「无序」的，但是对于符合 a = 1 的二级索引记录的范围里，b 字段的值是「有序」的。\n\n于是，在确定需要扫描的二级索引的范围时，当二级索引记录的 a 字段值为 1 时，可以通过 b = 2 条件减少需要扫描的二级索引记录范围（b 字段可以利用联合索引进行索引查询的意思）。\n\n所以，这条查询语句 a 和 b 字段都用到了联合索引进行索引查询。\n\nhttps://www.51cto.com/article/720535.html",charsets:{cjk:!0}},{title:"Explain分析",frontmatter:{title:"Explain分析",date:"2023-08-24T23:02:42.000Z",permalink:"/pages/b85e9d/"},regularPath:"/02.MySQL/09.Explain%E5%88%86%E6%9E%90.html",relativePath:"02.MySQL/09.Explain分析.md",key:"v-273d7455",path:"/pages/b85e9d/",headersStr:null,content:"慢查询的分析离不开mysql的explain语句，explain主要关注两个字段Type和Extra。\n\nType表示访问数据的方式，Extra表示过滤和整理数据的方式。\n\nTYPE                                   EXTRA                      \nALL      全表扫描                          Using index                使用覆盖索引，不需要回表，不需要Mysql服务层过滤\nindex    索引树全扫描                        Using where                从存储引擎层获取数据，在Mysql服务层用where查询条件过滤数据。\nrange    索引树范围扫描                       Using where; Using index   索引范围扫描。索引扫描和全表扫描类似，只是发生的层面不一样。\nref      非唯一性索引扫描，比如非唯一索引和唯一索引的非唯一前缀   Using index condition      使用索引下推，在存储引擎层充分利用查询索引字段过滤数据\neq_ref   唯一性索引扫描，比如唯一索引、主键索引           Using temporary            临时表存储结果，用于排序和分组查询\nconst    将查询转化成常量                      Using filesort             文件排序，用于排序\nNULL     不用访问表或索引                      NULL                       回表\n\n",normalizedContent:"慢查询的分析离不开mysql的explain语句，explain主要关注两个字段type和extra。\n\ntype表示访问数据的方式，extra表示过滤和整理数据的方式。\n\ntype                                   extra                      \nall      全表扫描                          using index                使用覆盖索引，不需要回表，不需要mysql服务层过滤\nindex    索引树全扫描                        using where                从存储引擎层获取数据，在mysql服务层用where查询条件过滤数据。\nrange    索引树范围扫描                       using where; using index   索引范围扫描。索引扫描和全表扫描类似，只是发生的层面不一样。\nref      非唯一性索引扫描，比如非唯一索引和唯一索引的非唯一前缀   using index condition      使用索引下推，在存储引擎层充分利用查询索引字段过滤数据\neq_ref   唯一性索引扫描，比如唯一索引、主键索引           using temporary            临时表存储结果，用于排序和分组查询\nconst    将查询转化成常量                      using filesort             文件排序，用于排序\nnull     不用访问表或索引                      null                       回表\n\n",charsets:{cjk:!0}},{title:"MySQL中的锁",frontmatter:{title:"MySQL中的锁",date:"2023-09-06T12:17:13.000Z",permalink:"/pages/92d4ca/"},regularPath:"/02.MySQL/10.MySQL%E4%B8%AD%E7%9A%84%E9%94%81.html",relativePath:"02.MySQL/10.MySQL中的锁.md",key:"v-d5dc6db4",path:"/pages/92d4ca/",headers:[{level:2,title:"next-key lock",slug:"next-key-lock",normalizedTitle:"next-key lock",charIndex:1139},{level:3,title:"间隙锁和next-key lock的加锁规则",slug:"间隙锁和next-key-lock的加锁规则",normalizedTitle:"间隙锁和next-key lock的加锁规则",charIndex:1214}],headersStr:"next-key lock 间隙锁和next-key lock的加锁规则",content:"从加锁的范围来区别，可以分为：\n\n * 全局锁\n   * 应用场景：全库逻辑备份。但还是建议开启事务，借助可重复读的Read View 来备份。\n * 表级锁\n   * 表锁\n   * 元数据锁（metadata lock，MDL）：我们不需要显示的使用 MDL，因为当我们对数据库表进行操作时，会自动给这个表加上 MDL。\n   * 意向锁：意向共享锁和意向独占锁是表级锁，不会和行级的共享锁和独占锁发生冲突，而且意向锁之间也不会发生冲突，只会和共享表锁（lock tables ... read）和独占表锁（lock tables ... write）发生冲突。\n   * AUTO-INC 锁：AUTO-INC 锁是特殊的表锁机制，锁不是再一个事务提交后才释放，而是再执行完插入语句后就会立即释放。\n * 行级锁\n   * 记录锁 Record Lock：仅把一条记录上锁\n   * 间隙锁 Gap Lock：锁定一个范围，但不包含记录本身\n     * 间隙锁虽然存在 X 型间隙锁和 S 型间隙锁，但是并没有什么区别，间隙锁之间是兼容的，即两个事务可以同时持有包含共同间隙范围的间隙锁，并不存在互斥关系，因为间隙锁的目的是防止插入幻影记录而提出的。\n   * 临键锁 Next-key Lock：=Record Lock + Gap Lock，锁定一个范围以及记录本身。\n\n表锁和行锁是满足读读共享、读写互斥、写写互斥的。\n\n普通的 select 是不会加行级锁的，普通的 select 语句是利用 MVCC 实现一致性读，是无锁的。\n\n在 InnoDB 事务中，对记录加锁带基本单位是 next-key 锁，但是会因为一些条件会退化成间隙锁，或者记录锁。加锁的位置准确的说，锁是加在索引上的而非行上。\n\n# 开启全局锁\nflush tables with read lock\n# 释放全局锁\nunlock tables\n\n# 表级别的共享锁，也就是读锁\nlock tables t read;\n# 表级别的排他锁，也就是写锁\nlock tables t write;\n# 释放当前会话的所有表锁\nunlock tables\n\n# 这两条语句必须在一个事务中，因为当事务提交了，锁就会被释放。\n# 所以在使用这两条语句的时候，要加上 begin、start transaction 或者 set autocommit = 0。\n# 先在表上加上意向共享锁，然后对读取的记录加共享锁（S锁）\nselect ... lock in share mode;\n# 先表上加上意向独占锁，然后对读取的记录加独占锁（X锁）\nselect ... for update;\n\n\n\n# next-key lock\n\n行锁 + 该行之前的间隙锁合称 next-key lock，每个 next-key lock 是前开后闭区间。\n\n\n# 间隙锁和next-key lock的加锁规则\n\n加锁规则里面，包含了两个“原则”、两个“优化”和一个“bug”。\n\n 1. 原则 1：加锁的基本单位是 next-key lock。next-key lock 是前开后闭区间。\n 2. 原则 2：查找过程中访问到的对象才会加锁。\n 3. 优化 1：索引上的等值查询，给唯一索引加锁的时候，next-key lock 退化为行锁。\n 4. 优化 2：索引上的等值查询，向右遍历时且最后一个值不满足等值条件的时候，next-key lock 退化为间隙锁。\n 5. 一个 bug：唯一索引上的范围查询会访问到不满足条件的第一个值为止。（8.0.26 没有这个bug）\n\nhttps://www.jianshu.com/p/d1aba64b5c03",normalizedContent:"从加锁的范围来区别，可以分为：\n\n * 全局锁\n   * 应用场景：全库逻辑备份。但还是建议开启事务，借助可重复读的read view 来备份。\n * 表级锁\n   * 表锁\n   * 元数据锁（metadata lock，mdl）：我们不需要显示的使用 mdl，因为当我们对数据库表进行操作时，会自动给这个表加上 mdl。\n   * 意向锁：意向共享锁和意向独占锁是表级锁，不会和行级的共享锁和独占锁发生冲突，而且意向锁之间也不会发生冲突，只会和共享表锁（lock tables ... read）和独占表锁（lock tables ... write）发生冲突。\n   * auto-inc 锁：auto-inc 锁是特殊的表锁机制，锁不是再一个事务提交后才释放，而是再执行完插入语句后就会立即释放。\n * 行级锁\n   * 记录锁 record lock：仅把一条记录上锁\n   * 间隙锁 gap lock：锁定一个范围，但不包含记录本身\n     * 间隙锁虽然存在 x 型间隙锁和 s 型间隙锁，但是并没有什么区别，间隙锁之间是兼容的，即两个事务可以同时持有包含共同间隙范围的间隙锁，并不存在互斥关系，因为间隙锁的目的是防止插入幻影记录而提出的。\n   * 临键锁 next-key lock：=record lock + gap lock，锁定一个范围以及记录本身。\n\n表锁和行锁是满足读读共享、读写互斥、写写互斥的。\n\n普通的 select 是不会加行级锁的，普通的 select 语句是利用 mvcc 实现一致性读，是无锁的。\n\n在 innodb 事务中，对记录加锁带基本单位是 next-key 锁，但是会因为一些条件会退化成间隙锁，或者记录锁。加锁的位置准确的说，锁是加在索引上的而非行上。\n\n# 开启全局锁\nflush tables with read lock\n# 释放全局锁\nunlock tables\n\n# 表级别的共享锁，也就是读锁\nlock tables t read;\n# 表级别的排他锁，也就是写锁\nlock tables t write;\n# 释放当前会话的所有表锁\nunlock tables\n\n# 这两条语句必须在一个事务中，因为当事务提交了，锁就会被释放。\n# 所以在使用这两条语句的时候，要加上 begin、start transaction 或者 set autocommit = 0。\n# 先在表上加上意向共享锁，然后对读取的记录加共享锁（s锁）\nselect ... lock in share mode;\n# 先表上加上意向独占锁，然后对读取的记录加独占锁（x锁）\nselect ... for update;\n\n\n\n# next-key lock\n\n行锁 + 该行之前的间隙锁合称 next-key lock，每个 next-key lock 是前开后闭区间。\n\n\n# 间隙锁和next-key lock的加锁规则\n\n加锁规则里面，包含了两个“原则”、两个“优化”和一个“bug”。\n\n 1. 原则 1：加锁的基本单位是 next-key lock。next-key lock 是前开后闭区间。\n 2. 原则 2：查找过程中访问到的对象才会加锁。\n 3. 优化 1：索引上的等值查询，给唯一索引加锁的时候，next-key lock 退化为行锁。\n 4. 优化 2：索引上的等值查询，向右遍历时且最后一个值不满足等值条件的时候，next-key lock 退化为间隙锁。\n 5. 一个 bug：唯一索引上的范围查询会访问到不满足条件的第一个值为止。（8.0.26 没有这个bug）\n\nhttps://www.jianshu.com/p/d1aba64b5c03",charsets:{cjk:!0}},{title:"SQL记录",frontmatter:{title:"SQL记录",date:"2023-03-23T22:20:17.000Z",permalink:"/pages/1b8a9e/"},regularPath:"/02.MySQL/100.SQL%E8%AE%B0%E5%BD%95.html",relativePath:"02.MySQL/100.SQL记录.md",key:"v-4a6be083",path:"/pages/1b8a9e/",headers:[{level:2,title:"CASE  WHEN THEN",slug:"case-when-then",normalizedTitle:"case  when then",charIndex:null},{level:2,title:"IFNULL 函数",slug:"ifnull-函数",normalizedTitle:"ifnull 函数",charIndex:384},{level:2,title:"LIMIT num OFFSET index",slug:"limit-num-offset-index",normalizedTitle:"limit num offset index",charIndex:636}],headersStr:"CASE  WHEN THEN IFNULL 函数 LIMIT num OFFSET index",content:"# CASE WHEN THEN\n\nSELECT *,\nCASE WHEN NOW() > start_time AND NOW() < end_time THEN '进行中'\n\t\t WHEN NOW() < start_time THEN '未开始'\nELSE '已结束'\nEND state\nfrom activity\n\n\n--简单case函数\ncase sex\n  when '1' then '男'\n  when '2' then '女’\n  else '其他' end\n  \n--case搜索函数\ncase when sex = '1' then '男'\n     when sex = '2' then '女'\n     else '其他' end\n\n\n\n * https://www.w3schools.com/sql/sql_case.asp\n\n\n# IFNULL 函数\n\nIFNULL(expression, alt_value);\n\n如果第一个参数的表达式 expression 为 NULL，则返回第二个参数的备用值。\n\nSELECT\n    IFNULL(\n      (SELECT DISTINCT Salary\n       FROM Employee\n       ORDER BY Salary DESC\n        LIMIT 1 OFFSET 1),\n    NULL) AS SecondHighestSalary;\n\n\n\n# LIMIT num OFFSET index",normalizedContent:"# case when then\n\nselect *,\ncase when now() > start_time and now() < end_time then '进行中'\n\t\t when now() < start_time then '未开始'\nelse '已结束'\nend state\nfrom activity\n\n\n--简单case函数\ncase sex\n  when '1' then '男'\n  when '2' then '女’\n  else '其他' end\n  \n--case搜索函数\ncase when sex = '1' then '男'\n     when sex = '2' then '女'\n     else '其他' end\n\n\n\n * https://www.w3schools.com/sql/sql_case.asp\n\n\n# ifnull 函数\n\nifnull(expression, alt_value);\n\n如果第一个参数的表达式 expression 为 null，则返回第二个参数的备用值。\n\nselect\n    ifnull(\n      (select distinct salary\n       from employee\n       order by salary desc\n        limit 1 offset 1),\n    null) as secondhighestsalary;\n\n\n\n# limit num offset index",charsets:{cjk:!0},lastUpdated:"2023/03/29, 21:03:43",lastUpdatedTimestamp:1680095023e3},{title:"MySQL实战45讲",frontmatter:{title:"MySQL实战45讲",date:"2023-03-23T22:24:39.000Z",permalink:"/pages/4f8fa0/"},regularPath:"/02.MySQL/99.MySQL%E5%AE%9E%E6%88%9845%E8%AE%B2.html",relativePath:"02.MySQL/99.MySQL实战45讲.md",key:"v-783fbd46",path:"/pages/4f8fa0/",headers:[{level:2,title:"连接器",slug:"连接器",normalizedTitle:"连接器",charIndex:468},{level:2,title:"查询缓存",slug:"查询缓存",normalizedTitle:"查询缓存",charIndex:1238},{level:2,title:"分析器",slug:"分析器",normalizedTitle:"分析器",charIndex:1667},{level:3,title:"词法分析",slug:"词法分析",normalizedTitle:"词法分析",charIndex:1675},{level:3,title:"语法分析",slug:"语法分析",normalizedTitle:"语法分析",charIndex:1722},{level:2,title:"优化器",slug:"优化器",normalizedTitle:"优化器",charIndex:1760},{level:2,title:"执行器",slug:"执行器",normalizedTitle:"执行器",charIndex:1830},{level:2,title:"InnoDB的索引模型",slug:"innodb的索引模型",normalizedTitle:"innodb的索引模型",charIndex:4895},{level:2,title:"覆盖索引",slug:"覆盖索引",normalizedTitle:"覆盖索引",charIndex:5424},{level:2,title:"最左前缀原则",slug:"最左前缀原则",normalizedTitle:"最左前缀原则",charIndex:5709},{level:2,title:"索引下推",slug:"索引下推",normalizedTitle:"索引下推",charIndex:5890},{level:2,title:"全局锁",slug:"全局锁",normalizedTitle:"全局锁",charIndex:6045},{level:2,title:"表级锁",slug:"表级锁",normalizedTitle:"表级锁",charIndex:6089},{level:2,title:"小结",slug:"小结",normalizedTitle:"小结",charIndex:7449},{level:2,title:"可重复读隔离级别下",slug:"可重复读隔离级别下",normalizedTitle:"可重复读隔离级别下",charIndex:3659},{level:2,title:"读提交隔离级别下",slug:"读提交隔离级别下",normalizedTitle:"读提交隔离级别下",charIndex:15629},{level:2,title:"主备延迟",slug:"主备延迟",normalizedTitle:"主备延迟",charIndex:16572},{level:3,title:"可靠性优先策略：",slug:"可靠性优先策略",normalizedTitle:"可靠性优先策略：",charIndex:16949},{level:3,title:"可用性有先策略：",slug:"可用性有先策略",normalizedTitle:"可用性有先策略：",charIndex:17221},{level:2,title:"GTID",slug:"gtid",normalizedTitle:"gtid",charIndex:18286},{level:2,title:"判断主备无延迟方案",slug:"判断主备无延迟方案",normalizedTitle:"判断主备无延迟方案",charIndex:18956},{level:2,title:"semi-sync replication 半同步控制",slug:"semi-sync-replication-半同步控制",normalizedTitle:"semi-sync replication 半同步控制",charIndex:19098},{level:2,title:"等主库位点方案",slug:"等主库位点方案",normalizedTitle:"等主库位点方案",charIndex:19061},{level:2,title:"GTID方案",slug:"gtid方案",normalizedTitle:"gtid方案",charIndex:19073},{level:2,title:"hash索引和b-tree索引",slug:"hash索引和b-tree索引",normalizedTitle:"hash索引和b-tree索引",charIndex:21477},{level:2,title:"分区表的应用场景",slug:"分区表的应用场景",normalizedTitle:"分区表的应用场景",charIndex:23072}],headersStr:"连接器 查询缓存 分析器 词法分析 语法分析 优化器 执行器 InnoDB的索引模型 覆盖索引 最左前缀原则 索引下推 全局锁 表级锁 小结 可重复读隔离级别下 读提交隔离级别下 主备延迟 可靠性优先策略： 可用性有先策略： GTID 判断主备无延迟方案 semi-sync replication 半同步控制 等主库位点方案 GTID方案 hash索引和b-tree索引 分区表的应用场景",content:"学习路径：先要会用，然后可以发现问题。\n\nmysql参考资料：\n\n * mysql的官方手册，有定位再去查漏补缺\n * 《高性能的mysql》\n\nMDL metadata lock：元数据锁\n\n一些建议：\n\n * 道路千万条，实践第一条。手动搭建一套主备复制结构。平时遇到问题，动手复现。在阅读其他技术文章、图书时，如果觉得自己理解了一个知识点，也一定要尝试设计一个例子来验证它。也建议设置对照的反例，达到融会贯通。\n * 怎么证明自己是不是真的把原理弄清楚了？说出来，写出来！如果有人请教你某个知识点，一定要跟他将清楚，不要觉得这是浪费时间。因为这样，依一来可以验证自己确实搞懂了这个知识点，二来可以提升自己的技术表达能力。毕竟你终究要面临和3类人讲清楚原理的时候：老板、晋升答辩的评委、新工作的面试官。\n * 知识要成体系，才不容易忘记。\n * 手册补全面，案例扫盲点。一开始不要看手册，手册应该是在你知识网络构建的差不多时再看。\n\n\n# 一、基础架构\n\n大体来说，MySQL可以分为Server层和存储引擎层两部分。\n\n\n\n\n# 连接器\n\n一般的连接命令：\n\nmysql -h$ip -P$port -u\n\n\n完成经典的TCP握手后，连接器就要开始认证你的身份，这个时候用的就是你输入的用户名和密码。\n\n * 如果用户名或密码不对，你就会收到一个\"Access denied for user\"的错误，然后客户端程序 结束执行。\n\n * 如果用户名密码认证通过，连接器会到权限表里面查出你拥有的权限。之后，这个连接里面 的权限判断逻辑，都将依赖于此时读到的权限。\n\n一个用户成功建立连接后，即使你用管理员账号对这个用户的权限做了修改，也不 会影响已经存在连接的权限。修改完成后，只有再新建的连接才会使用新的权限设置。\n\n连接完成后，如果你没有后续的动作，这个连接就处于空闲状态，你可以在show processlist命令中看到它。\n\n客户端如果太长时间没动静，连接器就会自动将它断开。这个时间是由参数wait_timeout控制 的，默认值是8小时。\n\n尽量使用长连接。\n\n但是全部使用长连接后，你可能会发现，有些时候MySQL占用内存涨得特别快，这是因为 MySQL在执行过程中临时使用的内存是管理在连接对象里面的。这些资源会在连接断开的时候才释放。所以如果长连接累积下来，可能导致内存占用太大，被系统强行杀掉（OOM），从现象看就是MySQL异常重启了。\n\n怎么解决这个问题呢？你可以考虑以下两种方案。\n\n 1. 定期断开长连接。使用一段时间，或者程序里面判断执行过一个占用内存的大查询后，断开连接，之后要查询再重连。\n\n 2. 如果你用的是MySQL 5.7或更新版本，可以在每次执行一个比较大的操作后，通过执行mysql_reset_connection来重新初始化连接资源。这个过程不需要重连和重新做权限验证，但是会将连接恢复到刚刚创建完时的状态。\n\n\n# 查询缓存\n\n但是大多数情况下我会建议你不要使用查询缓存， 因为查询缓存往往弊大于利。\n\n查询缓存的失效非常频繁，只要有对一个表的更新，这个表上所有的查询缓存都会被清空。因此 很可能你费劲地把结果存起来，还没使用呢，就被一个更新全清空了。对于更新压力大的数据库 来说，查询缓存的命中率会非常低。除非你的业务就是有一张静态表，很长时间才会更新一次。 比如，一个系统配置表，那这张表上的查询才适合使用查询缓存。\n\n好在MySQL也提供了这种“按需使用”的方式。你可以将参数query_cache_type设置成DEMAND，这样对于默认的SQL语句都不使用查询缓存。而对于你确定要使用查询缓存的语 句，可以用SQL_CACHE显式指定，像下面这个语句一样：\n\nselect SQL_CACHE * from T where ID = 10;\n\n\n需要注意的是，MySQL 8.0版本直接将查询缓存的整块功能删掉了，也就是说8.0开始彻底没有 这个功能了。\n\n\n# 分析器\n\n\n# 词法分析\n\n根据输入的字符串和空格进行识别，识别出里面的字符串分别是什么，代表什么。\n\n\n# 语法分析\n\n根据语法规则，判断输入的sql是否满足mysql语法。\n\n\n# 优化器\n\n优化器是在表里面有多个索引的时候，决定使用哪个索引；或者在一个语句有多表关联（join） 的时候，决定各个表的连接顺序。\n\n\n# 执行器\n\n首先判断有没对表T的执行权限。有的话就打开表继续执行。\n\n分为有索引的情况和没索引的情况。\n\n你会在数据库的慢查询日志中看到一个rows_examined的字段，表示这个语句执行过程中扫描了 多少行。这个值就是在执行器每次调用引擎获取数据行的时候累加的。\n\n在有些场景下，执行器调用一次，在引擎内部则扫描了多行，因此引擎扫描行数跟引擎扫描行数跟 rows_examined并不是完全相同的。\n\n\n# 二、日志系统\n\n与查询流程不同，更新流程还涉及两个重要的日志模块。\n\n * redo log（重做日志）\n\n * binlog（归档日志）\n\n而粉板和账本配合的整个过程，其实就是MySQL里经常说到的WAL技术，WAL的全称是WriteAhead Logging，它的关键点就是先写日志，再写磁盘，也就是先写粉板，等不忙的时候再写账本。\n\nMySQL整体来看，其实就有两块：一块是Server层，它主要做的是MySQL功能层面的事情；还有一块是引擎层，负责存储相关的具体事宜。上面我们聊到的粉板redo log是 InnoDB引擎特有的日志，而Server层也有自己的日志，称为binlog（归档日志）。\n\n最开始MySQL里并没有InnoDB引擎。MySQL自带的引擎是MyISAM，但是MyISAM没有 crash-safe的能力，binlog日志只能用于归档。而InnoDB是另一个公司以插件形式引入MySQL的，既然只依靠binlog是没有crash-safe能力的，所以InnoDB使用另外一套日志系统— — 也就是 redo log来实现crash-safe能力。\n\n有了redo log，InnoDB就可以保证即使数据库发生异常重启，之前提交的记录都不会丢失，这个 能力称为crash-safe。\n\n这两种日志有以下三点不同。\n\n 1. redo log是InnoDB引擎特有的；binlog是MySQL的Server层实现的，所有引擎都可以使用。\n 2. redo log是物理日志，记录的是“在某个数据页上做了什么修改”；binlog是逻辑日志，记录的是这个语句的原始逻辑，比如“给ID=2这一行的c字段加1 ”。\n 3. redo log是循环写的，空间固定会用完；binlog是可以追加写入的。“追加写”是指binlog文件写到一定大小后会切换到下一个，并不会覆盖以前的日志。\n\nredo log的写入拆成了两个步骤：prepare和commit，是\"两阶段提交\"。\n\n当你需要扩容的时候，也就是需要再 多搭建一些备库来增加系统的读能力的时候，现在常见的做法也是用全量备份加上应用binlog来实现的，这个“不一致”就会导致你的线上出现主从数据库不一致的情况。\n\n简单说，redo log和binlog都可以用于表示事务的提交状态，而两阶段提交就是让这两个状态保 持逻辑上的一致。\n\n**思考一个问题：**定期全量备份的周期“取决于系统重要性，有的是一天一备，有的是一周一备”。那么在什么场景下，一天一备会比一周一备更有优势呢？或者说，它影响了这个数据库系统的哪个指标？\n\n一天一备，那么如果需要恢复数据的话，只要保证当天的binlog完整即可；一周一备的话就要保证一周的binlog完整；同时频繁全量备份需要更多存储空间，如何选择取决于业务的重要性，对应的指标是RTO(目标恢复时间)。\n\n\n# 三、事务隔离\n\n提到事务，我们会想到ACID\n\n * Atomicity 原子性\n * Consistency 一致性\n * Isolation 隔离性\n * Durability 持久性\n\n这里主要谈隔离性。\n\n当数据库上有多个事务同时执行的时候，就可能出现脏读（dirty read）、不可重复读（non- repeatable read）、幻读（phantom read）的问题，为了解决这些问题，就有了“隔离级别”的概念。\n\n隔离得越严实，效率就会越低。\n\nSQL标准的事务隔离级别包括：\n\n * 读未提交（read uncommitted）：一个事务还没提交时，它做的变更就能被别的事务看到。\n * 读提交（read committed）：一个事务提交之后，它做的变更才会被其他事务看到。\n * 可重复读（repeatable read）：一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。当然在可重复读隔离级别下，未提交变更对其他事务也是不可见的。\n * 串行化（serializable ）：对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。\n\n在实现上，数据库里面会创建一个视图，访问的时候以视图的逻辑结果为准。在“可重复读”隔离级别下，这个视图是在事务启动时创建的，整个事务存在期间都用这个视图。**在“读提交”隔离级 别下，这个视图是在每个SQL语句开始执行的时候创建的。**这里需要注意的是，“读未提交”隔离 级别下直接返回记录上的最新值，没有视图概念；而“串行化”隔离级别下直接用加锁的方式来避 免并行访问。\n\nOracle数据库的默认隔离级别其 实就是“读提交”，因此对于一些从Oracle迁移到MySQL的应用，为保证数据库隔离级别的一致， 你一定要记得将MySQL的隔离级别设置为“读提交”。mysql默认隔离级别是可重复读。\n\n配置的方式是，将启动参数transaction-isolation的值设置成READ-COMMITTED。你可以用 show variables来查看当前的值。\n\n尽量避免长事务。\n\n长事务意味着系统里面会存在很老的事务视图。由于这些事务随时可能访问数据库里面的任何数据，所以这个事务提交之前，数据库里面它可能用到的回滚记录都必须保留，这就会导致大量占用存储空间。\n\n在MySQL 5.5及以前的版本，回滚日志是跟数据字典一起放在ibdata文件里的，即使长事务最终提交，回滚段被清理，文件也不会变小。我见过数据只有20GB，而回滚段有200GB的库。最终只好为了清理回滚段，重建整个库。\n\n除了对回滚段的影响，长事务还占用锁资源，也可能拖垮整个库。\n\nMySQL的事务启动方式有以下几种：\n\n 1. 显式启动事务语句， begin 或 start transaction。配套的提交语句是commit，回滚语句是rollback。\n 2. set autocommit=0，这个命令会将这个线程的自动提交关掉。意味着如果你只执行一个select语句，这个事务就启动了，而且并不会自动提交。这个事务持续存在直到你主动执行 commit 或 rollback 语句，或者断开连接。\n\n建议你总是使用set autocommit=1, 通过显式语句的方式来启动事务。\n\n\n# 四&五、索引\n\n索引场景模型：\n\n * 哈希表：适用于只有等值查询的场景。\n * 有序数组：在等值查询和范围查询场景中性能优秀。只适用于静态存储引擎，更新数据代价太高。\n * 搜索树：N叉树，读写性能佳，适合磁盘的访问模式，广泛应用在数据库引擎中。\n * 跳表、LSM树。。。\n\n在MySQL中，索引是在存储引擎层实现的，所以并没有统一的索引标准，即不同存储引擎的索 引的工作方式并不一样。而即使多个存储引擎支持同一种类型的索引，其底层的实现也可能不同。\n\n\n# InnoDB的索引模型\n\nInnoDB使用B+树索引模型。\n\n每一个索引在InnoDB里对应一棵B+树。\n\n根据叶子节点的内容，索引类型分为主键索引和非主键索引。\n\n主键索引的叶子节点存储的是整行数据。在InnoDB中，主键索引也被称为聚簇索引（clustered index）。\n\n非主键索引的叶子节点存储的是主键的值。在InnoDB中，非主键索引也被称为二级索引（secondary index）。\n\n因此，基于主键索引和普通索引的查询的区别是，主键查询只需要搜索ID这棵B+树，普通索引查询，要先搜索普通索引树，得到ID后，再搜索ID索引树。这个过程称为回表。\n\n也就是说，基于非主键索引的查询需要多扫描一棵索引树。因此，我们在应用中应该尽量使用主键查询。\n\n主键长度越小， 普通索引的叶子节点就越小， 普通索引占用的空间也就越小。\n\n从性能和存储空间方面考量，自增主键往往是更合理的选择。自增主键也不会造成分裂和合并操作。\n\nQ：通过两个alter 语句重建索引k，以及通过两个alter语句重建主键索引是否合理？\n\n重建索引k的做法是合理的，可以达到省空间的目的。但是，重建主键的过程不合理。不论是删除主键还是创建主键，都会将整个表重建。\n\n\n# 覆盖索引\n\n由于覆盖索引可以减少树的搜索次数， 显著提升查询性能， 所以使用覆盖索引是一个常用的性能优化手段。\n\n我们知道，身份证号是市民的唯一标识。也就是说，如果有根据身份证号查询市民信息的需求， 我们只要在身份证号字段上建立索引就够了。而再建立一个（身份证号、姓名）的联合索引，是不是浪费空间？\n\n如果现在有一个高频请求，要根据市民的身份证号查询他的姓名，这个联合索引就有意义了。它 可以在这个高频请求上用到覆盖索引，不再需要回表查整行记录，减少语句的执行时间。\n\n当然，索引字段的维护总是有代价的。因此，在建立冗余索引来支持覆盖索引时就需要权衡考虑 了。\n\n\n# 最左前缀原则\n\n在建立联合索引的时候， 如何安排索引内的字段顺序？\n\n这里我们的评估标准是，索引的复用能力。因为可以支持最左前缀，所以当已经有了(a,b)这个联合索引后，一般就不需要单独在a上建立索引了。因此，第一原则是， 如果通过调整顺序， 可以少维护一个索引， 那么这个顺序往往就是需要优先考虑采用的。\n\n如果不得不维护另一个索引，那么要考虑空间。\n\n\n# 索引下推\n\n在MySQL 5.6之前，只能从ID3开始一个个回表。到主键索引上找出数据行，再对比字段值。\n\n而MySQL 5.6 引入的索引下推优化（index condition pushdown)， 可以在索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数。\n\n\n# 六、全局锁和表锁\n\n\n# 全局锁\n\n根据加锁的范围， MySQL里面的锁大致可以分成全局锁、表级锁和行锁三类 。\n\n顾名思义，全局锁就是对整个数据库实例加锁。MySQL提供了一个加全局读锁的方法，命令是 Flush tables with read lock (FTWRL)。当你需要让整个库处于只读状态的时候，可以使用这个命令，之后其他线程的以下语句会被阻塞：数据更新语句（数据的增删改）、数据定义语句（包括 建表、修改表结构等）和更新类事务的提交语句。\n\n全局锁的典型使用场景是， 做全库逻辑备份。 也就是把整库每个表都select出来存成文本。\n\n不加锁的话，备份系统备份的得到的库不是一个逻辑时间点，这个视图是逻辑不一致的。\n\n说到视图你肯定想起来了，我们在前面讲事务隔离的时候，其实是有一个方法能够拿到一致性视 图的，对吧？\n\n是的，就是在可重复读隔离级别下开启一个事务。\n\n官方自带的逻辑备份工具是mysqldump。当mysqldump使用参数–single-transaction的时候，导 数据之前就会启动一个事务，来确保拿到一致性视图。而由于MVCC的支持，这个过程中数据是可以正常更新的。\n\n你一定在疑惑，有了这个功能，为什么还需要FTWRL呢？一致性读是好，一致性读是好， 但前提是引擎要支 持这个隔离级别。 比如，对于MyISAM这种不支持事务的引擎，如果备份过程中有更新，总是 只能取到最新的数据，那么就破坏了备份的一致性。这时，我们就需要使用FTWRL命令了。\n\n所以，single-transaction方法只适用于所有的表使用事务引擎的库。 如果有的表使用了不支持事务的引擎，那么备份就只能通过FTWRL方法。这往往是DBA要求业务开发人员使用InnoDB替代MyISAM的原因之一。\n\n\n# 表级锁\n\nMySQL里面表级别的锁有两种：一种是表锁，一种是元数据锁（meta data lock，MDL)。\n\n表锁的语法是 lock tables … read/write。 与FTWRL类似，可以用unlock tables主动释放锁， 也可以在客户端断开的时候自动释放。需要注意，lock tables语法除了会限制别的线程的读写外，也限定了本线程接下来的操作对象。\n\n另一类表级的锁是 MDL（ metadata lock)。 MDL不需要显式使用，在访问一个表的时候会被 自动加上。MDL的作用是，保证读写的正确性。你可以想象一下，如果一个查询正在遍历一个表中的数据，而执行期间另一个线程对这个表结构做变更，删了一列，那么查询线程拿到的结果跟表结构对不上，肯定是不行的。\n\n因此，在MySQL 5.5版本中引入了MDL，当对一个表做增删改查操作的时候，加MDL读锁；当 要对表做结构变更操作的时候，加MDL写锁。\n\nQ：如果你要变更的表是一个热点表，虽然数据量不大，但是上面的请求很频 繁，而你不得不加个字段，你该怎么做呢？\n\n比较理想的机制是，在alter table语句里面 设定等待时间，如果在这个指定的等待时间里面能够拿到MDL写锁最好，拿不到也不要阻塞后 面的业务语句，先放弃。之后开发人员或者DBA再通过重试命令重复这个过程。\n\nMariaDB已经合并了AliSQL的这个功能，所以这两个开源分支目前都支持DDL NOWAIT/WAIT n这个语法。\n\n\n# 小结\n\n * 全局锁主要用在逻辑备份过程中。对于全部是InnoDB引擎的库，我建议你选择使用–singletransaction参数，对应用会更友好。\n * 表锁一般是在数据库引擎不支持行锁的时候才会被用到的。如果你发现你的应用程序里有lock tables这样的语句，你需要追查一下，比较可能的情况是：\n   * 要么是你的系统现在还在用MyISAM这类不支持事务的引擎，那要安排升级换引擎；\n   * 要么是你的引擎升级了，但是代码还没升级。我见过这样的情况，最后业务开发就是把lock tables 和 unlock tables 改成 begin 和 commit，问题就解决了。\n   * MDL会直到事务提交才释放，在做表结构变更的时候，你一定要小心不要导致锁住线上查询和更新。\n\n\n# 九、普通索引和唯一索引的选择\n\n由于唯一索引用不上change buffer的优化机制，因此如果业务可以接受，从性能角度出发我建议你优先考虑非唯一索引。\n\n\n# 十、MySQL为什么有时候会选错索引？\n\n由于索引统计的更新机制，统计的行数有时会有偏差。\n\n而且优化器存在选错索引的可能性。优化器选择索引的目的，是找到一个最优的执行方案，并用最小的代价去执行语句。在数据库里面，扫描行数是影响执行代价的因素之一。扫描的行数越少，意味着访问磁盘数据的次数越少，消耗的CPU资源越少。\n\n扫描行数并不是唯一的判断标准，优化器还会结合是否使用临时表、是否排序等因素进行综合判断。\n\n对于由于索引统计信息不准确导致的问题，你可以用analyze table t 语句来解决。（重新统计索引信息）\n\n而对于其他优化器误判的情况，你可以在应用端用force index来强行指定索引，也可以通过修改语句来引导优化器，还可以通过增加或者删除索引来绕过这个问题。\n\n估计记录数\n\nmysql通过统计信息来估算记录数，这个统计信息就是索引的“区分度”。一个索引上不同的值越多，这个索引的区分度就越好。而一个索引上不同值的个数，称为“基数”（cardinality）。\n\n可使用show index from t，查看索引的基数。\n\nmysql通过采样统计来得到索引的基数。InnoDB默认选择N个数据页，统计这些页面上的不通值，得到一个平均值，然后乘以这索引的页面数，得到这个索引的基数。当数据行数超过1/M的时候，会自动触发重新做一次统计所有。\n\n在MySQL中，有两种存储索引统计的方式，可以通过设置参数innodb_stats_persistent的值来选择：\n\n * 设置为on的时候，表示统计信息会持久化存储。这时，默认的N是20，M是10。\n\n * 设置为off的时候，表示统计信息只存储在内存中。这时，默认的N是8，M是16。\n\n * 由于是采样统计，所以不管N是20还是8，这个基数都是很容易不准的。\n\n\n# 十一、怎么给字符串字段加索引？\n\nmysql支持前缀索引，可以定义字符串的一部分作为索引。默认索引包含整个字符串。\n\nalter table user add index index1(email);\n\nalter table user add index index2(email(6));\n\n\n使用前缀索引可以减少空间占用，这是优势。但可能导致查询语句读数据的次数变多。\n\n因此使用前缀索引，需要定义好长度，达到即省空间，又不用额外增加太多的查询成本。\n\n可以使用一下方法判断前缀的合适长度：(设定一个可以接受的损失比例)\n\nselect count(distinct email) as L from user;\n\nselect\n\tcount(distinct left(emial, 4)) as L4,\n\tcount(distinct left(emial, 5)) as L5,\n\tcount(distinct left(emial, 6)) as L6,\n\tcount(distinct left(emial, 7)) as L7,\nfrom user;\n\n\n此外，使用前缀索引就用不上覆盖索引对查询性能的优化。\n\n前缀多数相同时的索引思路：\n\n * 倒序存储\n * 增加hash字段，如用crc()得到校验码。\n\n总结：\n\n 1. 直接创建完整索引，这样可能比较占用空间；\n 2. 创建前缀索引，节省空间，但会增加查询扫描次数，并且不能使用覆盖索引；\n 3. 倒序存储，再创建前缀索引，用于绕过字符串本身前缀的区分度不够的问题；\n 4. 创建hash字段索引，查询性能稳定，有额外的存储和计算消耗，跟第三种方式一样，都不支持范围扫描。\n\n\n# 十二、为什么我的SQL会“抖”一下\n\n当内存数据页跟磁盘数据页内容不一致的时候， 我们称这个内存页为 “ 脏页 ” 。\n\n平时执行很快的更新操作，其实就是在写内存和日志，而 MySQL偶尔“抖”一下的那个瞬间，可能就是在刷脏页（flush）。\n\n什么情况会引发数据库flush？\n\n * InnoDB的redo log写满了。这时候系统会停止所有更新操作，把 checkpoint往前推进，redo log留出空间可以继续写。\n * 系统内存不足。需要淘汰一些数据页，如果淘汰的是脏页就要先把脏页写到磁盘。\n * mysql认为系统空闲时。\n * mysql正常关闭时。\n\n所以，刷脏页虽然是常态，但是出现以下这两种情况，都是会明显影响性能的：\n\n 1. 一个查询要淘汰的脏页个数太多，会导致查询的响应时间明显变长；\n\n 2. 日志写满，更新全部堵住，写性能跌为0，这种情况对敏感业务来说，是不能接受的。\n\n所以，InnoDB需要有控制脏页比例的机制，来尽量避免上面的这两种情况。\n\n通过innodb_io_capacity告诉InnoDB你的磁盘能力，全力刷脏页时可以多快。建议设为磁盘的IOPS。\n\n参数innodb_max_dirty_pages_pct是脏页比例上限，默认值是75%。\n\n平时要多关注脏页比例， 不要让它经常接近 75%。\n\ninnodb_flush_neighbors 参数值为1的时候会有“连坐”机制，值为0时表示不找邻居，自己刷自己的。在MySQL 8.0中，innodb_flush_neighbors参数的默认值已经是0了。\n\n\n# 十三、为什么表数据删掉一半，表文件大小不变？\n\n如果要收缩一个表，只是delete掉表里面不用的数据的话，表文件的大小是不会变的，你还要通过alter table命令重建表，才能达到表文件变小的目的。我跟你介绍了重建 表的两种实现方式，Online DDL的方式是可以考虑在业务低峰期使用的，而MySQL 5.5及之前的 版本，这个命令是会阻塞DML的，这个你需要特别小心。\n\noptimize table、analyze table和alter table这三种方式重建表的区别。\n\n * 从MySQL 5.6版本开始，alter table t engine = InnoDB（也就是recreate）默认的就是上面图4的流程了；\n * analyze table t 其实不是重建表，只是对表的索引信息做重新统计，没有修改数据，这个过程中加了MDL读锁；\n * optimize table t 等于recreate+analyze。\n\n\n# 十四、count(*)这么慢，怎么办？\n\n * MyISAM表虽然count(*)很快，但是不支持事务；\n * show table status命令虽然返回很快，但是不准确；\n * InnoDB表直接count(*)会遍历全表，虽然结果准确，但会导致性能问题。\n\n用redis或者是用另一张表记录总数，都会出现数据不一致的情况。\n\n把计数放在Redis里面，不能够保证计数和MySQL表里的数据精确一致的原因，是这两个这两个不同的存储构成的系统， 不支持分布式事务， 无法拿到精确一致的视图。\n\n而把计数值也放在 MySQL中，就解决了一致性视图的问题。 InnoDB引擎支持事务，我们利用好事务的原子性和隔离性，就可以简化在业务开发时的逻辑。 这也是InnoDB引擎备受青睐的原因之一。\n\n问题都是由于InnoDB要支持事务，从而导致InnoDB表不能把count(*) 直接存起来，然后查询的时候直接返回形成的。 所谓以子之矛攻子之盾，现在我们就利用“事务”这个特性，把问题解决掉。\n\n\n\ncount()的语义。count()是一个聚合函数，对于返回的结果集，一行行地判断，如果count函数的参数不是NULL，累计值就加1，否则不加。最后返回累计值。\n\n所以，count(*)、count(主键id)和count(1) 都表示返回满足条件的结果集的总行数；而count(字段），则表示返回满足条件的数据行里面，参数“字段”不为NULL的总个数。\n\n分析性能差别：\n\n * server层要什么就给什么；\n * InnoDB只给必要的值；\n * 现在的优化器只优化了count(*)的语义为“取行数”，其他“显而易见”的优化并没有做。\n\n结论是：按照效率排序的话，count(字段)<count(主键id)<count(1)≈count(*)，所以我建议你，尽量使用count(*)。\n\n\n# 十五、答疑，日志和索引相关\n\n崩溃恢复时的判断规则：\n\n 1. 如果redo log里面的事务是完整的，也就是已经有了commit标识，则直接提交。\n 2. 如果redo log里面的事务只有完整的prepare，则判断对应的事务binlog是否存在并完整：\n    1. 如果是，则提交事务。\n    2. 否则，回滚事务。\n\nmysql怎么知道binlog是否完整？\n\n一个事务的binlog是由完整格式的：\n\n * statement格式的binlog，最后会有COMMIT；\n * row格式的binlog，最后会有一个XID event；\n\n另外，在MySQL 5.6.2后，还引入了binlog-checksum参数，用来验证binlog内容的正确性。\n\nredo log 和 binlog是怎么关联起来的？\n\n他们有一个共同的数据字段，叫XID，崩溃恢复时，会按顺序扫描redo log：\n\n * 如果碰到既有prepare，又有commit的redo log，直接提交。\n * 如果碰到只有prepare，没有commit的redo log，就拿着XID去binlog找对应的事务。\n\n\n# 十六、order by是怎么工作的？\n\n通常情况下，全字段排序：\n\n 1. 初始化sort_buffer，确定放入name、city、age这三个字段；\n\n 2. 从索引city找到第一个满足city='杭州’条件的主键id，也就是图中的ID_X；\n\n 3. 到主键id索引取出整行，取name、city、age三个字段的值，存入sort_buffer中；\n\n 4. 从索引city取下一个记录的主键id；\n\n 5. 重复步骤3、4直到city的值不满足查询条件为止，对应的主键id也就是图中的ID_Y；\n\n 6. 对sort_buffer中的数据按照字段name做快速排序；\n\n 7. 按照排序结果取前1000行返回给客户端。\n\n如果mysql认为排序的单行长度太大会采用rowid排序：\n\n（即新的算法放入sort_buffer的字段，只有要排序的列（即name字段）和主键id，然后再从原表取）\n\n 1. 初始化sort_buffer，确定放入两个字段，即name和id；\n\n 2. 从索引city找到第一个满足city='杭州’条件的主键id，也就是图中的ID_X；\n\n 3. 到主键id索引取出整行，取name、id这两个字段，存入sort_buffer中；\n\n 4. 从索引city取下一个记录的主键id；\n\n 5. 重复步骤3、4直到不满足city='杭州’条件为止，也就是图中的ID_Y；\n\n 6. 对sort_buffer中的数据按照字段name进行排序；\n\n 7. 遍历排序结果，取前1000行，并按照id的值回到原表中取出city、name和age三个字段返回\n\n给客户端。\n\n如果MySQL实在是担心排序内存太小，会影响排序效率，才会采用rowid排序算法，这样排序过 程中一次可以排序更多行，但是需要再回到原表去取数据。\n\n如果MySQL认为内存足够大，会优先选择全字段排序，把需要的字段都放到sort_buffer中，这样排序后就会直接从内存里面返回查询结果了，不用再回到原表去取数据。\n\n这也就体现了MySQL的一个设计思想：如果内存够，如果内存够， 就要多利用内存， 尽量减少磁盘访问。\n\n优化：（索引的维护有代价，需要权衡）\n\n * 如果从索引上取出来的行，天然就排序好了的话，就可以不用再排序了。可以使用联合索引。\n * 还可以覆盖索引，使其直接返回需要的值。（也是用上联合索引）\n\n\n# 十七、如何正确地显示随机消息\n\n# 随机选择3个单词\nselect word from words order by rand() limit 3;\n\n\n这条语句的执行流程是这样的：\n\n 1. 创建一个临时表。这个临时表使用的是memory引擎，表里有两个字段，第一个字段是 double类型，为了后面描述方便，记为字段R，第二个字段是varchar(64)类型，记为字段\n\nW。并且，这个表没有建索引。\n\n 2. 从words表中，按主键顺序取出所有的word值。对于每一个word值，调用rand()函数生成一\n\n个大于0小于1的随机小数，并把这个随机小数和word分别存入临时表的R和W字段中，到 此，扫描行数是10000。 3. 现在临时表有10000行数据了，接下来你要在这个没有索引的内存临时表上，按照字段R排\n\n序。 4. 初始化 sort_buffer。sort_buffer中有两个字段，一个是double类型，另一个是整型。\n\n 5. 从内存临时表中一行一行地取出R值和位置信息（我后面会和你解释这里为什么是“位置信 息”），分别存入sort_buffer中的两个字段里。这个过程要对内存临时表做全表扫描，此时 扫描行数增加10000，变成了20000。\n\n 6. 在sort_buffer中根据R的值进行排序。注意，这个过程没有涉及到表操作，所以不会增加扫\n\n描行数。\n\n 7. 排序完成后，取出前三个结果的位置信息，依次到内存临时表中取出word值，返回给客户\n\n端。这个过程中，访问了表的三行数据，总扫描行数变成了20003。\n\n小结：order by rand()使用了内存临时表， 内存临时表排序的时候使用了 rowid排序方法。\n\n * 对于对于 InnoDB表来说 ，执行全字段排序会减少磁盘访问，因此会被优先选择。\n\n * 而对于内存表， 回表过程只是简单地根据数据行的位 置， 直接访问内存得到数据， 根本不会导致多访问磁盘 。优化器没有了这一层顾虑，那么它 会优先考虑的，就是用于排序的行长度越少越好了，所以，MySQL这时就会选择rowid排序。\n\ntmp_table_size配置内存临时表的大小，默认是16M，超过时会转成磁盘临时表。\n\nMySQL 5.6版本引入的一个新的排序算法， 即：优先队列排序算法。（维护了一个堆）\n\n临时文件的算法也就是归并算法。\n\n如果你直接使用order by rand()，这个语句需要Using temporary 和 Using filesort，查询的执行代价往往是比较大的。所以，在设计的时候你要量避开这种写法。\n\n为了达到严格的随机结果：\n\n 1. 取到整个表的行数，记作C。\n 2. 取到Y = floor(C * rand())。floor在这里的作用，就是取整数部分。\n 3. 再用limit Y, 1取得一行。\n\n\n# 十八、为什么逻辑相同的SQL语句，性能差异巨大（先pass）\n\n小结：对索引字段做函数操作，可能会破坏索引值的有序性，因此优化器就决定放弃走树搜索功能。\n\n\n# 十九、为什么只查一行的语句，也执行慢？\n\n分析原因时候，一般先执行show processlist，看看当前语句处于什么状态。\n\n第一类：查询长时间不返回\n\n * 等MDL锁\n   \n   出现Waiting for table metadata lock，表示现在有一个线程正在表t上请求或者持有MDL写锁，把select语句堵住了。\n   \n   解决：通过查询select blocking_pid from sys.schema_table_lock_waits;查出造成阻塞的process id，把他kill了。\n\n * 等flush\n\n * 等行锁\n\n第二类：查询慢\n\n\n# 二十、幻读是什么？有什么问题？（还是有点蒙呀）\n\nfor update 排他锁\n\nfor update仅适用于InnoDB，且必须在事务块(BEGIN/COMMIT)中才能生效。在进行事务操作时，通过“for update”语句，MySQL会对查询结果集中每行数据都添加排他锁，其他线程对该记录的更新与删除操作都会阻塞。排他锁包含行锁、表锁。\n\nlock in share mode 共享锁\n\n幻读指的是一个事务在前后两次查询同一个范围的时候，后一次查询看到了前一次查询没有看到的行。\n\n“幻读”做一个说明：\n\n 1. 在可重复读隔离级别下，普通的查询是快照读，是不会看到别的事务插入的数据的。因此， 幻读在“当前读”下才会出现。\n\n 2. 上面session B的修改结果，被session A之后的select语句用“当前读”看到，不能称为幻读。 幻读仅专指“新插入的行”。\n\n锁的设计是为了保证数据的一致性。而这个一致性，不止是数据库内部数据状态在此 刻的一致性，还包含了数据和日志在逻辑上的一致性。\n\nInnoDB如何解决幻读？\n\n幻读产生的原因是，行锁只能锁住行，但是新插入记录这个动作，要更新的是记录之间的“间隙”。因此，为了解决幻读问题，InnoDB只好引入新的锁，也即是间隙锁（Gap Lock）。\n\n间隙锁和行锁合称next-key lock。但其实他们是分开加的。\n\n间隙锁是在可重复读隔离级别下才会生效的。所以，你如果把隔离级别设置为读提交的话， 就没有间隙锁了。但同时，你要解决可能出现的数据和日志不一致问题，需要把binlog格式设置 为row。这也是现在不少公司使用的配置组合。\n\n很多公司使用：读提交隔离级别加binlog_format=row的组合。到底合不合理？\n\n如果读提交隔离级别够用，即业务不需要可重复读的保证，这样考虑到读提交下操作数据的锁范围更小（没有间隙锁），这个选择是合理的。\n\n比如大家都用读提交，可逻辑备份时，mysqldump为什么要把备份线程设置成可重复读？然后，在备份期间，备份线程用的是可重复读，而业务线程使用的是读提交，同时存在两种事务隔离级别会不会有问题？\n\n\n# 二十一、加锁规则\n\n\n# 可重复读隔离级别下\n\n锁是加在索引上的。\n\nnext-key lock=间隙锁+行锁，(]，前开后闭区间。\n\n间隙锁，()，前开后开区间。\n\n行锁就一个。\n\n加锁规则：2个原则，2个优化，1个bug\n\n 1. 原则1：加锁的基本单位是next-key lock。\n\n 2. 原则2：查找过程中访问到的对象才会加锁。\n\n 3. 优化1：索引上的等值查询，给唯一索引加锁的时候，next-key lock退化为行锁。\n\n 4. 优化2：索引上的等值查询，向右遍历时且遇到不满足等值条件的值时，next-key lock退化为间隙锁。\n\n 5. 一个bug：唯一索引上的范围查询会访问到不满足条件的第一个值为止。\n\n\n# 读提交隔离级别下\n\n读提交隔离级别的话，去掉间隙锁的部分，剩下行锁的部分。\n\n其实读提交隔离级别在外键场景下还是有间隙锁，相对比较复杂，我们今天先不展开。\n\n另外，在读提交隔离级别下还有一个优化，即：语句执行过程中加上的行锁，在语句执行完成后，就要把“不满足条件的行”上的行锁直接释放了，不需要等到事务提交。\n\n也就是说，读提交隔离级别下，锁的范围更小，锁的时间更短，这也是不少业务都默认使用读提交隔离级别的原因。\n\n\n# 24、mysql怎么保持主备一致？\n\nbinlog功不可没。\n\nmysql有容易学习和方便使用高可用架构。几乎所有的高可用架构，都直接依赖于binlog。虽然越来与复杂，但都是从最基本的一主一备演化而来。\n\n在一个主备关系中，每个备库接受主库的binlog执行。只要主库执行更新生成的所有binlog都可以传到备库被正确执行，备库就能达到跟主库一致的状态，这就是最终一致性。\n\n建议把备库设置成readonly模式。好处如下：\n\n * 有些运营类的查询语句会再备库查，设置为只读可防止误操作。\n * 防止切换逻辑bug，如切换过程中出现双写，造成主备不一致。\n * 可用readonly状态，判断节点的角色。\n\n因为readonly设置对super权限角色无效，而用于同步更新的线程就拥有超级权限。\n\n主库和备库之间维持了一个长连接。主库内部有一个线程，专门用于服务备库的这个长连接。\n\nbinlog的三种格式：（通过binlog_format属性设置）\n\n * statement。记录的是语句原文。可能导致主备不一致。\n * row。记录了真实删除行的主键id（如果是删除）。占空间，如删除10w条数据。\n * mixed。前两种的混合。\n\n现在越来越多的场景要求把mysql的binlog格式设置为row，其中之一好处在于：恢复数据。\n\n实际生产使用比较多的是双M结构，互为主备。相较于MS结构，切换时不用修改主备关系。\n\nmysql通过判断server id的方式，解决循环复制问题。\n\n通过mysqlbinlog工具解析和查看binlog中的内容。\n\n\n# 25、mysql如何保证高可用？\n\n只有最终一致性还不够，mysql还要提供高可用。\n\n\n# 主备延迟\n\n可通过在备库执行 show slave status显示seconds_behind_master表示当前备库延迟了多少秒。\n\n主备延迟的来源：\n\n * 备库所在的机器性能比主库的差。（现在一般做对称部署，主备切换）。\n * 备库的压力大。\n * 主库大事务。\n   * 因为主库必须等事务执行完成才会写入binlog，再传给备库。\n   * 如不要一次性用delete删除太多数据，典型的大事务场景。\n   * 如大表DDL也是典型的大事务场景。处理方案：计划内的DDL，建议使用go-ost方案。\n * 备库的并行复制能力。\n\n一般处理：\n\n * 一主多从。（这里把HA过程中被选成新主库的称为备库，其他的称为从库。备库和从库概念上差不多）\n * 通过binlog输出到外部系统，如hadoop，让外部系统提供统计类查询的能力。\n\n\n# 可靠性优先策略：\n\n双M结构下，主备切换：\n\n 1. 判断备库B现在的seconds_behind_master，如果小于某个值（比如5秒）继续下一步，否则\n\n持续重试这一步；\n\n 2. 把主库A改成只读状态，即把readonly设置为true；\n\n 3. 判断备库B的seconds_behind_master的值，直到这个值变成0为止；\n\n 4. 把备库B改成可读写状态，也就是把readonly 设置为false；\n\n 5. 把业务请求切到备库B。\n\n这个切换流程，一般是由专门的HA系统来完成的，我们暂时称之为可靠性优先流程。\n\n\n# 可用性有先策略：\n\n如果我强行把步骤4、5调整到最开始执行，也就是说不等主备数据同步，直接把连接切到备库 B，并且让备库B可以读写，那么系统几乎就没有不可用时间了。\n\n这个切换流程的代价，就是可能出现数据不一 致的情况。\n\n结论：\n\n 1. 使用row格式的binlog时，数据不一致的问题更容易被发现。而使用mixed或者statement格式的binlog时，数据很可能悄悄地就不一致了。如果你过了很久才发现数据不一致的问题， 很可能这时的数据不一致已经不可查，或者连带造成了更多的数据逻辑不一致。\n\n 2. 主备切换的可用性优先策略会导致数据不一致。因此，大多数情况下，我都建议你使用可靠性优先策略。毕竟对数据服务来说的话，数据的可靠性一般还是要优于可用性的。\n\n在满足数据可靠性的前提下，MySQL高可用系统的可用性，是依赖于主备延迟的。延迟的时间越小，在主库故障的时候，服务恢复需要的时间就越短，可用性就越高。\n\n\n# 26、备库为什么会延迟好几个小时？（略看）\n\n简单总结：\n\n介绍了MySQL的各种多线程复制策略。\n\n为什么要有多线程复制呢？这是因为单线程复制的能力全面低于多线程复制，对于更新压力较大 的主库，备库是可能一直追不上主库的。从现象上看就是，备库上seconds_behind_master的值 越来越大。\n\n大事务不仅会影响到主库，也是造成备库复制延迟的主要原因之一。 因此，在平时的开发工作中，我建议你尽量减少大事务操作，把大事务拆成小事务。\n\nbinlog-transaction-dependency-tracking参数：\n\n * COMMIT_ORDER\n * WRITESET\n * WRITE_SESSIOn\n\n\n# 27、主库出问题了从库怎么办？\n\n\n\n一主多从基本结构。\n\n将节点B设置成节点A的从库A`，需要执行change master命令。\n\n这条命令有6个参数，其中MASTER_LOG_FILE和MASTER_LOG_POS表示从主库的【文件名】、【日志偏移量】的日志继续同步。\n\n这个pos往往不精确。\n\n通常我们在切换任务时，要先主动跳过这些错误，有两种常用的方法：\n\n * 主动跳过一个事务set global sql_slave_skip_count = 1;start save;\n * 通过设置slave_skip_error参数，直接设置跳过指定的错误。\n   * 1062错误是插入数据时唯一键冲突；\n   * 1032错误是删除数据时找不到行。\n\n\n# GTID\n\n通过sql_slave_skip_counter跳过事务和通过slave_skip_errors忽略错误的方法，虽然都最终可以 建立从库B和新主库A’的主备关系，但这两种操作都很复杂，而且容易出错。所以，MySQL 5.6版本引入了GTID，彻底解决了这个困难。\n\nGTID的全称是Global Transaction Identifier，也就是全局事务ID，是一个事务在提交的时候生成的，是这个事务的唯一标识。\n\nGTID=server_uuid:gno\n\n * server_uuid是一个实例第一次启动时自动生成的，是一个全局唯一的值；\n\n * gno是一个整数，初始值是1，每次提交事务的时候分配给这个事务，并加1。\n\nGTID主备复制的用法：\n\n执行change maste，只需使用master_auto_position = 1代替前面的MASTER_LOG_FILE和MASTER_LOG_POS。\n\n在基于GTID的主备关系里，系统认为只要建立主备关系，就必须保证主库发给备库的日志是完整的。因此，如果实例B需要的日志已经不存在，A’就拒绝把日志发给B。\n\n这跟基于位点的主备协议不同。基于位点的协议，是由备库决定的，备库指定哪个位点，主库就发哪个位点，不做日志的完整性判断。\n\n\n# 28、读写分离\n\n一主多从架构的应用场景：读写分离。\n\n读写分离的主要目标就是分摊主库的压力。\n\n\n\n客户端主动做读写分离。\n\n\n\n中间代理层proxy分发。\n\n方案：\n\n * 强制走主库方案\n * sleep方案\n * 判断主备无延迟方案\n   * 判断seconds_behind_master 是否等于0\n   * 对比位点qu确保主备无延迟\n   * 对比GTID集合确保主备无延迟\n * 配合semi-sync方案\n * 等主库位点方案\n * 等GTID方案\n\n\n# 判断主备无延迟方案\n\n\n# semi-sync replication 半同步控制\n\n 1. 事务提交的时候，主库把binlog发给从库；\n\n 2. 从库收到binlog以后，发回给主库一个ack，表示收到了；\n\n 3. 主库收到这个ack以后，才能给客户端返回“事务完成”的确认。\n\nsemi-sync配合前面关于位点的判断，就能够确定在从库上执行的查询请求，可以避免过期读。\n\n但是，semi-sync+位点判断的方案，只对一主一备的场景是成立的。在一主多从场景中，主库只 要等到一个从库的ack，就开始给客户端返回确认。\n\n小结一下，semi-sync配合判断主备无延迟的方案，存在两个问题：\n\n 1. 一主多从的时候，在某些从库执行查询请求会存在过期读的现象；\n\n 2. 在持续延迟的情况下，可能出现过度等待的问题。\n\n等主库位点方案，就可以解决这两个问题\n\n\n# 等主库位点方案\n\nselect master_pos_wait(file, pos[, timeout]);\n\n 1. 它是在从库执行的；\n\n 2. 参数file和pos指的是主库上的文件名和位置；\n\n 3. timeout可选，设置为正整数N表示这个函数最多等待N秒。\n\n这个命令正常返回的结果是一个正整数M，表示从命令开始执行，到应用完file和pos表示的 binlog位置，执行了多少事务。\n\n当然，除了正常返回一个正整数M外，这条命令还会返回一些其他结果，包括：\n\n 1. 如果执行期间，备库同步线程发生异常，则返回NULL；\n\n 2. 如果等待超过N秒，就返回-1；\n\n 3. 如果刚开始执行的时候，就发现已经执行过这个位置了，则返回0。\n\n 4. trx1事务更新完成后，马上执行show master status得到当前主库执行到的File和Position；\n\n 5. 选定一个从库执行查询语句；\n\n 6. 在从库上执行select master_pos_wait(File, Position, 1)；\n\n 7. 如果返回值是>=0的正整数，则在这个从库执行查询语句；\n\n 8. 否则，到主库执行查询语句。\n\n如果按照我们设定不允许过期读的要求，就只有两种选择，一种是超时放弃，一种是转到主库查询。具体怎么选择，就需要业务开发同学做好限流策略了。\n\n\n# GTID方案\n\n如果你的数据库开启了GTID模式，对应的也有等待GTID的方案。\n\nselect wait_for_executed_gtid_set(gtid_set, 1);\n\n这条命令的逻辑是：\n\n 1. 等待，直到这个库执行的事务中包含传入的gtid_set，返回0；\n\n 2. 超时返回1。\n\n在前面等位点的方案中，我们执行完事务后，还要主动去主库执行show master status。而 MySQL 5.7.6版本开始，允许在执行完更新类事务后，把这个事务的GTID返回给客户端，这样等GTID的方案就可以减少一次查询。 这时，等GTID的执行流程就变成了：\n\n 1. trx1事务更新完成后，从返回包直接获取这个事务的GTID，记为gtid1；\n\n 2. 选定一个从库执行查询语句；\n\n 3. 在从库上执行 select wait_for_executed_gtid_set(gtid1, 1)；\n\n 4. 如果返回值是0，则在这个从库执行查询语句；\n\n 5. 否则，到主库执行查询语句。\n\n跟等主库位点的方案一样，等待超时后是否直接到主库查询，需要业务开发同学来做限流考虑。\n\n在实际应用中，这几个方案是可以混合使用的。\n\n比如，先在客户端对请求做分类，区分哪些请求可以接受过期读，而哪些请求完全不能接受过期读；然后，对于不能接受过期读的语句，再使用等GTID或等位点的方案。\n\n但话说回来，过期读在本质上是由一写多读导致的。在实际应用中，可能会有别的不需要等待就可以水平扩展的数据库方案，但这往往是用牺牲写性能换来的，也就是需要在读性能和写性能中取权衡。\n\n开源proxy：MariaDB MaxScale\n\n\n# 40、InnoDB和Memory引擎\n\nInnoDB表的数据就放在主键索引树上，主键索引是B+树。\n\nMemory引擎的数据和索引是分开的。\n\n内存表的数据部分以数组的形式单独存放，而主键id索引里，存放的是每个数据的位置。主键id是hash索引，索引上的key不是有序的。\n\n可见，InnoDB和Memory引擎的数据组织方式是不同的：\n\n * InnoDB引擎把数据放在主键索引上，其他索引上保存的是主键id。这种方式，我们称之为索引组织表 （Index Organizied Table）。\n\n * 而Memory引擎采用的是把数据单独存放，索引上保存数据位置的数据组织形式，我们称之 为堆组织表 （Heap Organizied Table）。\n\n这两个引擎的一些典型不同：\n\n 1. InnoDB表的数据总是有序存放的，而内存表的数据就是按照写入顺序存放的；\n 2. 当数据文件有空洞的时候，InnoDB表在插入新数据的时候，为了保证数据有序性，只能在固定的位置写入新值，而内存表找到空位就可以插入新值；\n 3. 数据位置发生变化的时候，InnoDB表只需要修改主键索引，而内存表需要修改所有索引；\n 4. InnoDB表用主键索引查询时需要走一次索引查找，用普通索引查询的时候，需要走两次索引查找。而内存表没有这个区别，所有索引的“地位”都是相同的。\n 5. InnoDB支持变长数据类型，不同记录的长度可能不同；内存表不支持Blob 和 Text字段，并且即使定义了varchar(N)，实际也当作char(N)，也就是固定长度字符串来存储，因此内存表的每行数据长度相同。\n\n\n# hash索引和b-tree索引\n\n实际上，内存表也是自持B-Tree索引的。\n\n在我们的一般印象中，内存表的优势是速度快，其中一个原因就是Memory引擎支持hash索引。更重要的原因是，内存表的所有数据都保存在内存上，而内存的读写速度总是比磁盘快。\n\n但不建议在生产环境上使用内存表，主要有2个原因：\n\n 1. 锁粒度问题。\n    1. 内存表不支持行锁，只支持表锁。\n 2. 数据持久化问题\n\n建议把普通内存表都用InnoDB表代替。\n\n例外的场景：内存临时表。内存表支持hash索引，这个特性利用起来，对复杂查询的加速效果还是很不错的。\n\n\n# 40、insert语句的锁为什么这么多？（初略总结）\n\nMySQL对自增主键锁做了优化，尽量在申请到自增id以后，就释放自增锁。\n\n普通情况下，insert语句是一个很轻量的操作。\n\n特殊情况下，如：\n\ninsert …select 是很常见的在两个表之间拷贝数据的方法。你需要注意，在可重复读隔离级别下，这个语句会给select的表里扫描到的记录和间隙加读锁。 而如果insert和select的对象是同一个表，则有可能会造成循环写入。这种情况下，我们需要引入\n\n用户临时表来做优化。\n\ninsert 语句如果出现唯一键冲突，会在冲突的唯一值上加共享的next-key lock(S锁)。因此，碰到\n\n由于唯一键约束导致报错后，要尽快提交或回滚事务，避免加锁时间过长。\n\n\n# 43、要不要使用分区表？\n\n分区表有什么问题，为什么很多公司规范不让使用分区表呢？\n\n分区表的组织形式：\n\nCREATE TABLE `t` (\n\t`ftime` datetime NOTNULL,\n  `c` int(11) DEFAULT NULL,\n  KEY (`ftime`)\n) ENGINE=InnoDB DEFAULT CHARSET = latin1\nPARTITION BY RANGE(YEAR(ftime))\n(PARTITION p_2017 VALUES LESS THAN (2017) ENGINE = InnoDB,\n PARTITION p_2018 VALUES LESS THAN (2018) ENGINE = InnoDB,\n PARTITION p_2019 VALUES LESS THAN (2019) ENGINE = InnoDB,\n PARTITION p_others VALUES LESS THAN MAXVALUE ENGINE = InnoDB);\n \n insert into t value('2017-4-1',1),('2018-4-1',1); \n\n\n在表t中初始化插入了两行记录，按照定义的分区规则，这两行记录分别落在p_2018和p_2019 这两个分区上。\n\n这个表包含了一个.frm文件和4个.ibd文件，每个分区对应一个.ibd文件。也就是说：\n\n * 对于引擎层来说，这是4个表；\n * 对于Server层来说，这是1个表。\n\n我们使用分区表的一个重要原因就是单表过大。那么，如果不使用分区表的话，我们就是要使用手动分表的方式。\n\n分区表和手工分表，一个是由server层来决定使用哪个分区，一个是由应用层代码来决定使用哪 个分表。因此，从引擎层看，这两种方式也是没有差别的。\n\n其实这两个方案的区别，主要是在server层上。从server层看，我们就不得不提到分区表一个被广为诟病的问题：打开表的行为。\n\n 1. MySQL在第一次打开分区表的时候，需要访问所有的分区；\n\n 2. 在server层，认为这是同一张表，因此所有分区共用同一个MDL锁；\n\n 3. 在引擎层，认为这是不同的表，因此MDL锁之后的执行过程，会根据分区表规则，只访问必要的分区。\n\n\n# 分区表的应用场景\n\n分区表的一个显而易见的优势是对业务透明，相对于用户分表来说，使用分区表的业务代码更简洁。还有，分区表可以很方便的清理历史数据。\n\n如果一项业务跑的时间足够长，往往就会有根据时间删除历史数据的需求。这时候，按照时间分区的分区表，就可以直接通过alter table t drop partition这个语法删掉分区，从而删掉过期的历史数据。\n\n这个alter table t drop partition …操作是直接删除分区文件，效果跟drop普通表类似。与使用delete语句删除数据相比，优势是速度快、对系统影响小。\n\n我们以范围分区（range）为例和你介绍的。实际上，MySQL还支持hash分区、 list分区等分区方法。你可以在需要用到的时候，再翻翻手册。\n\n实际使用时，分区表跟用户分表比起来，有两个绕不开的问题：一个是第一次访问的时候需要访问所有分区，另一个是共用MDL锁。\n\n因此，如果要使用分区表，就不要创建太多的分区。我见过一个用户做了按天分区策略，然后预先创建了10年的分区。这种情况下，访问分区表的性能自然是不好的。这里有两个问题需要注意：\n\n 1. 分区并不是越细越好。实际上，单表或者单分区的数据一千万行，只要没有特别大的索引， 对于现在的硬件能力来说都已经是小表了。\n\n 2. 分区也不要提前预留太多，在使用之前预先创建即可。比如，如果是按月分区，每年年底时再把下一年度的12个新分区创建上即可。对于没有数据的历史分区，要及时的drop掉。\n\n至于分区表的其他问题，比如查询需要跨多个分区取数据，查询性能就会比较慢，基本上就不是分区表本身的问题，而是数据量的问题或者说是使用方式的问题了。\n\n当然，如果你的团队已经维护了成熟的分库分表中间件，用业务分表，对业务开发同学没有额外的复杂性，对DBA也更直观，自然是更好的。",normalizedContent:"学习路径：先要会用，然后可以发现问题。\n\nmysql参考资料：\n\n * mysql的官方手册，有定位再去查漏补缺\n * 《高性能的mysql》\n\nmdl metadata lock：元数据锁\n\n一些建议：\n\n * 道路千万条，实践第一条。手动搭建一套主备复制结构。平时遇到问题，动手复现。在阅读其他技术文章、图书时，如果觉得自己理解了一个知识点，也一定要尝试设计一个例子来验证它。也建议设置对照的反例，达到融会贯通。\n * 怎么证明自己是不是真的把原理弄清楚了？说出来，写出来！如果有人请教你某个知识点，一定要跟他将清楚，不要觉得这是浪费时间。因为这样，依一来可以验证自己确实搞懂了这个知识点，二来可以提升自己的技术表达能力。毕竟你终究要面临和3类人讲清楚原理的时候：老板、晋升答辩的评委、新工作的面试官。\n * 知识要成体系，才不容易忘记。\n * 手册补全面，案例扫盲点。一开始不要看手册，手册应该是在你知识网络构建的差不多时再看。\n\n\n# 一、基础架构\n\n大体来说，mysql可以分为server层和存储引擎层两部分。\n\n\n\n\n# 连接器\n\n一般的连接命令：\n\nmysql -h$ip -p$port -u\n\n\n完成经典的tcp握手后，连接器就要开始认证你的身份，这个时候用的就是你输入的用户名和密码。\n\n * 如果用户名或密码不对，你就会收到一个\"access denied for user\"的错误，然后客户端程序 结束执行。\n\n * 如果用户名密码认证通过，连接器会到权限表里面查出你拥有的权限。之后，这个连接里面 的权限判断逻辑，都将依赖于此时读到的权限。\n\n一个用户成功建立连接后，即使你用管理员账号对这个用户的权限做了修改，也不 会影响已经存在连接的权限。修改完成后，只有再新建的连接才会使用新的权限设置。\n\n连接完成后，如果你没有后续的动作，这个连接就处于空闲状态，你可以在show processlist命令中看到它。\n\n客户端如果太长时间没动静，连接器就会自动将它断开。这个时间是由参数wait_timeout控制 的，默认值是8小时。\n\n尽量使用长连接。\n\n但是全部使用长连接后，你可能会发现，有些时候mysql占用内存涨得特别快，这是因为 mysql在执行过程中临时使用的内存是管理在连接对象里面的。这些资源会在连接断开的时候才释放。所以如果长连接累积下来，可能导致内存占用太大，被系统强行杀掉（oom），从现象看就是mysql异常重启了。\n\n怎么解决这个问题呢？你可以考虑以下两种方案。\n\n 1. 定期断开长连接。使用一段时间，或者程序里面判断执行过一个占用内存的大查询后，断开连接，之后要查询再重连。\n\n 2. 如果你用的是mysql 5.7或更新版本，可以在每次执行一个比较大的操作后，通过执行mysql_reset_connection来重新初始化连接资源。这个过程不需要重连和重新做权限验证，但是会将连接恢复到刚刚创建完时的状态。\n\n\n# 查询缓存\n\n但是大多数情况下我会建议你不要使用查询缓存， 因为查询缓存往往弊大于利。\n\n查询缓存的失效非常频繁，只要有对一个表的更新，这个表上所有的查询缓存都会被清空。因此 很可能你费劲地把结果存起来，还没使用呢，就被一个更新全清空了。对于更新压力大的数据库 来说，查询缓存的命中率会非常低。除非你的业务就是有一张静态表，很长时间才会更新一次。 比如，一个系统配置表，那这张表上的查询才适合使用查询缓存。\n\n好在mysql也提供了这种“按需使用”的方式。你可以将参数query_cache_type设置成demand，这样对于默认的sql语句都不使用查询缓存。而对于你确定要使用查询缓存的语 句，可以用sql_cache显式指定，像下面这个语句一样：\n\nselect sql_cache * from t where id = 10;\n\n\n需要注意的是，mysql 8.0版本直接将查询缓存的整块功能删掉了，也就是说8.0开始彻底没有 这个功能了。\n\n\n# 分析器\n\n\n# 词法分析\n\n根据输入的字符串和空格进行识别，识别出里面的字符串分别是什么，代表什么。\n\n\n# 语法分析\n\n根据语法规则，判断输入的sql是否满足mysql语法。\n\n\n# 优化器\n\n优化器是在表里面有多个索引的时候，决定使用哪个索引；或者在一个语句有多表关联（join） 的时候，决定各个表的连接顺序。\n\n\n# 执行器\n\n首先判断有没对表t的执行权限。有的话就打开表继续执行。\n\n分为有索引的情况和没索引的情况。\n\n你会在数据库的慢查询日志中看到一个rows_examined的字段，表示这个语句执行过程中扫描了 多少行。这个值就是在执行器每次调用引擎获取数据行的时候累加的。\n\n在有些场景下，执行器调用一次，在引擎内部则扫描了多行，因此引擎扫描行数跟引擎扫描行数跟 rows_examined并不是完全相同的。\n\n\n# 二、日志系统\n\n与查询流程不同，更新流程还涉及两个重要的日志模块。\n\n * redo log（重做日志）\n\n * binlog（归档日志）\n\n而粉板和账本配合的整个过程，其实就是mysql里经常说到的wal技术，wal的全称是writeahead logging，它的关键点就是先写日志，再写磁盘，也就是先写粉板，等不忙的时候再写账本。\n\nmysql整体来看，其实就有两块：一块是server层，它主要做的是mysql功能层面的事情；还有一块是引擎层，负责存储相关的具体事宜。上面我们聊到的粉板redo log是 innodb引擎特有的日志，而server层也有自己的日志，称为binlog（归档日志）。\n\n最开始mysql里并没有innodb引擎。mysql自带的引擎是myisam，但是myisam没有 crash-safe的能力，binlog日志只能用于归档。而innodb是另一个公司以插件形式引入mysql的，既然只依靠binlog是没有crash-safe能力的，所以innodb使用另外一套日志系统— — 也就是 redo log来实现crash-safe能力。\n\n有了redo log，innodb就可以保证即使数据库发生异常重启，之前提交的记录都不会丢失，这个 能力称为crash-safe。\n\n这两种日志有以下三点不同。\n\n 1. redo log是innodb引擎特有的；binlog是mysql的server层实现的，所有引擎都可以使用。\n 2. redo log是物理日志，记录的是“在某个数据页上做了什么修改”；binlog是逻辑日志，记录的是这个语句的原始逻辑，比如“给id=2这一行的c字段加1 ”。\n 3. redo log是循环写的，空间固定会用完；binlog是可以追加写入的。“追加写”是指binlog文件写到一定大小后会切换到下一个，并不会覆盖以前的日志。\n\nredo log的写入拆成了两个步骤：prepare和commit，是\"两阶段提交\"。\n\n当你需要扩容的时候，也就是需要再 多搭建一些备库来增加系统的读能力的时候，现在常见的做法也是用全量备份加上应用binlog来实现的，这个“不一致”就会导致你的线上出现主从数据库不一致的情况。\n\n简单说，redo log和binlog都可以用于表示事务的提交状态，而两阶段提交就是让这两个状态保 持逻辑上的一致。\n\n**思考一个问题：**定期全量备份的周期“取决于系统重要性，有的是一天一备，有的是一周一备”。那么在什么场景下，一天一备会比一周一备更有优势呢？或者说，它影响了这个数据库系统的哪个指标？\n\n一天一备，那么如果需要恢复数据的话，只要保证当天的binlog完整即可；一周一备的话就要保证一周的binlog完整；同时频繁全量备份需要更多存储空间，如何选择取决于业务的重要性，对应的指标是rto(目标恢复时间)。\n\n\n# 三、事务隔离\n\n提到事务，我们会想到acid\n\n * atomicity 原子性\n * consistency 一致性\n * isolation 隔离性\n * durability 持久性\n\n这里主要谈隔离性。\n\n当数据库上有多个事务同时执行的时候，就可能出现脏读（dirty read）、不可重复读（non- repeatable read）、幻读（phantom read）的问题，为了解决这些问题，就有了“隔离级别”的概念。\n\n隔离得越严实，效率就会越低。\n\nsql标准的事务隔离级别包括：\n\n * 读未提交（read uncommitted）：一个事务还没提交时，它做的变更就能被别的事务看到。\n * 读提交（read committed）：一个事务提交之后，它做的变更才会被其他事务看到。\n * 可重复读（repeatable read）：一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。当然在可重复读隔离级别下，未提交变更对其他事务也是不可见的。\n * 串行化（serializable ）：对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。\n\n在实现上，数据库里面会创建一个视图，访问的时候以视图的逻辑结果为准。在“可重复读”隔离级别下，这个视图是在事务启动时创建的，整个事务存在期间都用这个视图。**在“读提交”隔离级 别下，这个视图是在每个sql语句开始执行的时候创建的。**这里需要注意的是，“读未提交”隔离 级别下直接返回记录上的最新值，没有视图概念；而“串行化”隔离级别下直接用加锁的方式来避 免并行访问。\n\noracle数据库的默认隔离级别其 实就是“读提交”，因此对于一些从oracle迁移到mysql的应用，为保证数据库隔离级别的一致， 你一定要记得将mysql的隔离级别设置为“读提交”。mysql默认隔离级别是可重复读。\n\n配置的方式是，将启动参数transaction-isolation的值设置成read-committed。你可以用 show variables来查看当前的值。\n\n尽量避免长事务。\n\n长事务意味着系统里面会存在很老的事务视图。由于这些事务随时可能访问数据库里面的任何数据，所以这个事务提交之前，数据库里面它可能用到的回滚记录都必须保留，这就会导致大量占用存储空间。\n\n在mysql 5.5及以前的版本，回滚日志是跟数据字典一起放在ibdata文件里的，即使长事务最终提交，回滚段被清理，文件也不会变小。我见过数据只有20gb，而回滚段有200gb的库。最终只好为了清理回滚段，重建整个库。\n\n除了对回滚段的影响，长事务还占用锁资源，也可能拖垮整个库。\n\nmysql的事务启动方式有以下几种：\n\n 1. 显式启动事务语句， begin 或 start transaction。配套的提交语句是commit，回滚语句是rollback。\n 2. set autocommit=0，这个命令会将这个线程的自动提交关掉。意味着如果你只执行一个select语句，这个事务就启动了，而且并不会自动提交。这个事务持续存在直到你主动执行 commit 或 rollback 语句，或者断开连接。\n\n建议你总是使用set autocommit=1, 通过显式语句的方式来启动事务。\n\n\n# 四&五、索引\n\n索引场景模型：\n\n * 哈希表：适用于只有等值查询的场景。\n * 有序数组：在等值查询和范围查询场景中性能优秀。只适用于静态存储引擎，更新数据代价太高。\n * 搜索树：n叉树，读写性能佳，适合磁盘的访问模式，广泛应用在数据库引擎中。\n * 跳表、lsm树。。。\n\n在mysql中，索引是在存储引擎层实现的，所以并没有统一的索引标准，即不同存储引擎的索 引的工作方式并不一样。而即使多个存储引擎支持同一种类型的索引，其底层的实现也可能不同。\n\n\n# innodb的索引模型\n\ninnodb使用b+树索引模型。\n\n每一个索引在innodb里对应一棵b+树。\n\n根据叶子节点的内容，索引类型分为主键索引和非主键索引。\n\n主键索引的叶子节点存储的是整行数据。在innodb中，主键索引也被称为聚簇索引（clustered index）。\n\n非主键索引的叶子节点存储的是主键的值。在innodb中，非主键索引也被称为二级索引（secondary index）。\n\n因此，基于主键索引和普通索引的查询的区别是，主键查询只需要搜索id这棵b+树，普通索引查询，要先搜索普通索引树，得到id后，再搜索id索引树。这个过程称为回表。\n\n也就是说，基于非主键索引的查询需要多扫描一棵索引树。因此，我们在应用中应该尽量使用主键查询。\n\n主键长度越小， 普通索引的叶子节点就越小， 普通索引占用的空间也就越小。\n\n从性能和存储空间方面考量，自增主键往往是更合理的选择。自增主键也不会造成分裂和合并操作。\n\nq：通过两个alter 语句重建索引k，以及通过两个alter语句重建主键索引是否合理？\n\n重建索引k的做法是合理的，可以达到省空间的目的。但是，重建主键的过程不合理。不论是删除主键还是创建主键，都会将整个表重建。\n\n\n# 覆盖索引\n\n由于覆盖索引可以减少树的搜索次数， 显著提升查询性能， 所以使用覆盖索引是一个常用的性能优化手段。\n\n我们知道，身份证号是市民的唯一标识。也就是说，如果有根据身份证号查询市民信息的需求， 我们只要在身份证号字段上建立索引就够了。而再建立一个（身份证号、姓名）的联合索引，是不是浪费空间？\n\n如果现在有一个高频请求，要根据市民的身份证号查询他的姓名，这个联合索引就有意义了。它 可以在这个高频请求上用到覆盖索引，不再需要回表查整行记录，减少语句的执行时间。\n\n当然，索引字段的维护总是有代价的。因此，在建立冗余索引来支持覆盖索引时就需要权衡考虑 了。\n\n\n# 最左前缀原则\n\n在建立联合索引的时候， 如何安排索引内的字段顺序？\n\n这里我们的评估标准是，索引的复用能力。因为可以支持最左前缀，所以当已经有了(a,b)这个联合索引后，一般就不需要单独在a上建立索引了。因此，第一原则是， 如果通过调整顺序， 可以少维护一个索引， 那么这个顺序往往就是需要优先考虑采用的。\n\n如果不得不维护另一个索引，那么要考虑空间。\n\n\n# 索引下推\n\n在mysql 5.6之前，只能从id3开始一个个回表。到主键索引上找出数据行，再对比字段值。\n\n而mysql 5.6 引入的索引下推优化（index condition pushdown)， 可以在索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数。\n\n\n# 六、全局锁和表锁\n\n\n# 全局锁\n\n根据加锁的范围， mysql里面的锁大致可以分成全局锁、表级锁和行锁三类 。\n\n顾名思义，全局锁就是对整个数据库实例加锁。mysql提供了一个加全局读锁的方法，命令是 flush tables with read lock (ftwrl)。当你需要让整个库处于只读状态的时候，可以使用这个命令，之后其他线程的以下语句会被阻塞：数据更新语句（数据的增删改）、数据定义语句（包括 建表、修改表结构等）和更新类事务的提交语句。\n\n全局锁的典型使用场景是， 做全库逻辑备份。 也就是把整库每个表都select出来存成文本。\n\n不加锁的话，备份系统备份的得到的库不是一个逻辑时间点，这个视图是逻辑不一致的。\n\n说到视图你肯定想起来了，我们在前面讲事务隔离的时候，其实是有一个方法能够拿到一致性视 图的，对吧？\n\n是的，就是在可重复读隔离级别下开启一个事务。\n\n官方自带的逻辑备份工具是mysqldump。当mysqldump使用参数–single-transaction的时候，导 数据之前就会启动一个事务，来确保拿到一致性视图。而由于mvcc的支持，这个过程中数据是可以正常更新的。\n\n你一定在疑惑，有了这个功能，为什么还需要ftwrl呢？一致性读是好，一致性读是好， 但前提是引擎要支 持这个隔离级别。 比如，对于myisam这种不支持事务的引擎，如果备份过程中有更新，总是 只能取到最新的数据，那么就破坏了备份的一致性。这时，我们就需要使用ftwrl命令了。\n\n所以，single-transaction方法只适用于所有的表使用事务引擎的库。 如果有的表使用了不支持事务的引擎，那么备份就只能通过ftwrl方法。这往往是dba要求业务开发人员使用innodb替代myisam的原因之一。\n\n\n# 表级锁\n\nmysql里面表级别的锁有两种：一种是表锁，一种是元数据锁（meta data lock，mdl)。\n\n表锁的语法是 lock tables … read/write。 与ftwrl类似，可以用unlock tables主动释放锁， 也可以在客户端断开的时候自动释放。需要注意，lock tables语法除了会限制别的线程的读写外，也限定了本线程接下来的操作对象。\n\n另一类表级的锁是 mdl（ metadata lock)。 mdl不需要显式使用，在访问一个表的时候会被 自动加上。mdl的作用是，保证读写的正确性。你可以想象一下，如果一个查询正在遍历一个表中的数据，而执行期间另一个线程对这个表结构做变更，删了一列，那么查询线程拿到的结果跟表结构对不上，肯定是不行的。\n\n因此，在mysql 5.5版本中引入了mdl，当对一个表做增删改查操作的时候，加mdl读锁；当 要对表做结构变更操作的时候，加mdl写锁。\n\nq：如果你要变更的表是一个热点表，虽然数据量不大，但是上面的请求很频 繁，而你不得不加个字段，你该怎么做呢？\n\n比较理想的机制是，在alter table语句里面 设定等待时间，如果在这个指定的等待时间里面能够拿到mdl写锁最好，拿不到也不要阻塞后 面的业务语句，先放弃。之后开发人员或者dba再通过重试命令重复这个过程。\n\nmariadb已经合并了alisql的这个功能，所以这两个开源分支目前都支持ddl nowait/wait n这个语法。\n\n\n# 小结\n\n * 全局锁主要用在逻辑备份过程中。对于全部是innodb引擎的库，我建议你选择使用–singletransaction参数，对应用会更友好。\n * 表锁一般是在数据库引擎不支持行锁的时候才会被用到的。如果你发现你的应用程序里有lock tables这样的语句，你需要追查一下，比较可能的情况是：\n   * 要么是你的系统现在还在用myisam这类不支持事务的引擎，那要安排升级换引擎；\n   * 要么是你的引擎升级了，但是代码还没升级。我见过这样的情况，最后业务开发就是把lock tables 和 unlock tables 改成 begin 和 commit，问题就解决了。\n   * mdl会直到事务提交才释放，在做表结构变更的时候，你一定要小心不要导致锁住线上查询和更新。\n\n\n# 九、普通索引和唯一索引的选择\n\n由于唯一索引用不上change buffer的优化机制，因此如果业务可以接受，从性能角度出发我建议你优先考虑非唯一索引。\n\n\n# 十、mysql为什么有时候会选错索引？\n\n由于索引统计的更新机制，统计的行数有时会有偏差。\n\n而且优化器存在选错索引的可能性。优化器选择索引的目的，是找到一个最优的执行方案，并用最小的代价去执行语句。在数据库里面，扫描行数是影响执行代价的因素之一。扫描的行数越少，意味着访问磁盘数据的次数越少，消耗的cpu资源越少。\n\n扫描行数并不是唯一的判断标准，优化器还会结合是否使用临时表、是否排序等因素进行综合判断。\n\n对于由于索引统计信息不准确导致的问题，你可以用analyze table t 语句来解决。（重新统计索引信息）\n\n而对于其他优化器误判的情况，你可以在应用端用force index来强行指定索引，也可以通过修改语句来引导优化器，还可以通过增加或者删除索引来绕过这个问题。\n\n估计记录数\n\nmysql通过统计信息来估算记录数，这个统计信息就是索引的“区分度”。一个索引上不同的值越多，这个索引的区分度就越好。而一个索引上不同值的个数，称为“基数”（cardinality）。\n\n可使用show index from t，查看索引的基数。\n\nmysql通过采样统计来得到索引的基数。innodb默认选择n个数据页，统计这些页面上的不通值，得到一个平均值，然后乘以这索引的页面数，得到这个索引的基数。当数据行数超过1/m的时候，会自动触发重新做一次统计所有。\n\n在mysql中，有两种存储索引统计的方式，可以通过设置参数innodb_stats_persistent的值来选择：\n\n * 设置为on的时候，表示统计信息会持久化存储。这时，默认的n是20，m是10。\n\n * 设置为off的时候，表示统计信息只存储在内存中。这时，默认的n是8，m是16。\n\n * 由于是采样统计，所以不管n是20还是8，这个基数都是很容易不准的。\n\n\n# 十一、怎么给字符串字段加索引？\n\nmysql支持前缀索引，可以定义字符串的一部分作为索引。默认索引包含整个字符串。\n\nalter table user add index index1(email);\n\nalter table user add index index2(email(6));\n\n\n使用前缀索引可以减少空间占用，这是优势。但可能导致查询语句读数据的次数变多。\n\n因此使用前缀索引，需要定义好长度，达到即省空间，又不用额外增加太多的查询成本。\n\n可以使用一下方法判断前缀的合适长度：(设定一个可以接受的损失比例)\n\nselect count(distinct email) as l from user;\n\nselect\n\tcount(distinct left(emial, 4)) as l4,\n\tcount(distinct left(emial, 5)) as l5,\n\tcount(distinct left(emial, 6)) as l6,\n\tcount(distinct left(emial, 7)) as l7,\nfrom user;\n\n\n此外，使用前缀索引就用不上覆盖索引对查询性能的优化。\n\n前缀多数相同时的索引思路：\n\n * 倒序存储\n * 增加hash字段，如用crc()得到校验码。\n\n总结：\n\n 1. 直接创建完整索引，这样可能比较占用空间；\n 2. 创建前缀索引，节省空间，但会增加查询扫描次数，并且不能使用覆盖索引；\n 3. 倒序存储，再创建前缀索引，用于绕过字符串本身前缀的区分度不够的问题；\n 4. 创建hash字段索引，查询性能稳定，有额外的存储和计算消耗，跟第三种方式一样，都不支持范围扫描。\n\n\n# 十二、为什么我的sql会“抖”一下\n\n当内存数据页跟磁盘数据页内容不一致的时候， 我们称这个内存页为 “ 脏页 ” 。\n\n平时执行很快的更新操作，其实就是在写内存和日志，而 mysql偶尔“抖”一下的那个瞬间，可能就是在刷脏页（flush）。\n\n什么情况会引发数据库flush？\n\n * innodb的redo log写满了。这时候系统会停止所有更新操作，把 checkpoint往前推进，redo log留出空间可以继续写。\n * 系统内存不足。需要淘汰一些数据页，如果淘汰的是脏页就要先把脏页写到磁盘。\n * mysql认为系统空闲时。\n * mysql正常关闭时。\n\n所以，刷脏页虽然是常态，但是出现以下这两种情况，都是会明显影响性能的：\n\n 1. 一个查询要淘汰的脏页个数太多，会导致查询的响应时间明显变长；\n\n 2. 日志写满，更新全部堵住，写性能跌为0，这种情况对敏感业务来说，是不能接受的。\n\n所以，innodb需要有控制脏页比例的机制，来尽量避免上面的这两种情况。\n\n通过innodb_io_capacity告诉innodb你的磁盘能力，全力刷脏页时可以多快。建议设为磁盘的iops。\n\n参数innodb_max_dirty_pages_pct是脏页比例上限，默认值是75%。\n\n平时要多关注脏页比例， 不要让它经常接近 75%。\n\ninnodb_flush_neighbors 参数值为1的时候会有“连坐”机制，值为0时表示不找邻居，自己刷自己的。在mysql 8.0中，innodb_flush_neighbors参数的默认值已经是0了。\n\n\n# 十三、为什么表数据删掉一半，表文件大小不变？\n\n如果要收缩一个表，只是delete掉表里面不用的数据的话，表文件的大小是不会变的，你还要通过alter table命令重建表，才能达到表文件变小的目的。我跟你介绍了重建 表的两种实现方式，online ddl的方式是可以考虑在业务低峰期使用的，而mysql 5.5及之前的 版本，这个命令是会阻塞dml的，这个你需要特别小心。\n\noptimize table、analyze table和alter table这三种方式重建表的区别。\n\n * 从mysql 5.6版本开始，alter table t engine = innodb（也就是recreate）默认的就是上面图4的流程了；\n * analyze table t 其实不是重建表，只是对表的索引信息做重新统计，没有修改数据，这个过程中加了mdl读锁；\n * optimize table t 等于recreate+analyze。\n\n\n# 十四、count(*)这么慢，怎么办？\n\n * myisam表虽然count(*)很快，但是不支持事务；\n * show table status命令虽然返回很快，但是不准确；\n * innodb表直接count(*)会遍历全表，虽然结果准确，但会导致性能问题。\n\n用redis或者是用另一张表记录总数，都会出现数据不一致的情况。\n\n把计数放在redis里面，不能够保证计数和mysql表里的数据精确一致的原因，是这两个这两个不同的存储构成的系统， 不支持分布式事务， 无法拿到精确一致的视图。\n\n而把计数值也放在 mysql中，就解决了一致性视图的问题。 innodb引擎支持事务，我们利用好事务的原子性和隔离性，就可以简化在业务开发时的逻辑。 这也是innodb引擎备受青睐的原因之一。\n\n问题都是由于innodb要支持事务，从而导致innodb表不能把count(*) 直接存起来，然后查询的时候直接返回形成的。 所谓以子之矛攻子之盾，现在我们就利用“事务”这个特性，把问题解决掉。\n\n\n\ncount()的语义。count()是一个聚合函数，对于返回的结果集，一行行地判断，如果count函数的参数不是null，累计值就加1，否则不加。最后返回累计值。\n\n所以，count(*)、count(主键id)和count(1) 都表示返回满足条件的结果集的总行数；而count(字段），则表示返回满足条件的数据行里面，参数“字段”不为null的总个数。\n\n分析性能差别：\n\n * server层要什么就给什么；\n * innodb只给必要的值；\n * 现在的优化器只优化了count(*)的语义为“取行数”，其他“显而易见”的优化并没有做。\n\n结论是：按照效率排序的话，count(字段)<count(主键id)<count(1)≈count(*)，所以我建议你，尽量使用count(*)。\n\n\n# 十五、答疑，日志和索引相关\n\n崩溃恢复时的判断规则：\n\n 1. 如果redo log里面的事务是完整的，也就是已经有了commit标识，则直接提交。\n 2. 如果redo log里面的事务只有完整的prepare，则判断对应的事务binlog是否存在并完整：\n    1. 如果是，则提交事务。\n    2. 否则，回滚事务。\n\nmysql怎么知道binlog是否完整？\n\n一个事务的binlog是由完整格式的：\n\n * statement格式的binlog，最后会有commit；\n * row格式的binlog，最后会有一个xid event；\n\n另外，在mysql 5.6.2后，还引入了binlog-checksum参数，用来验证binlog内容的正确性。\n\nredo log 和 binlog是怎么关联起来的？\n\n他们有一个共同的数据字段，叫xid，崩溃恢复时，会按顺序扫描redo log：\n\n * 如果碰到既有prepare，又有commit的redo log，直接提交。\n * 如果碰到只有prepare，没有commit的redo log，就拿着xid去binlog找对应的事务。\n\n\n# 十六、order by是怎么工作的？\n\n通常情况下，全字段排序：\n\n 1. 初始化sort_buffer，确定放入name、city、age这三个字段；\n\n 2. 从索引city找到第一个满足city='杭州’条件的主键id，也就是图中的id_x；\n\n 3. 到主键id索引取出整行，取name、city、age三个字段的值，存入sort_buffer中；\n\n 4. 从索引city取下一个记录的主键id；\n\n 5. 重复步骤3、4直到city的值不满足查询条件为止，对应的主键id也就是图中的id_y；\n\n 6. 对sort_buffer中的数据按照字段name做快速排序；\n\n 7. 按照排序结果取前1000行返回给客户端。\n\n如果mysql认为排序的单行长度太大会采用rowid排序：\n\n（即新的算法放入sort_buffer的字段，只有要排序的列（即name字段）和主键id，然后再从原表取）\n\n 1. 初始化sort_buffer，确定放入两个字段，即name和id；\n\n 2. 从索引city找到第一个满足city='杭州’条件的主键id，也就是图中的id_x；\n\n 3. 到主键id索引取出整行，取name、id这两个字段，存入sort_buffer中；\n\n 4. 从索引city取下一个记录的主键id；\n\n 5. 重复步骤3、4直到不满足city='杭州’条件为止，也就是图中的id_y；\n\n 6. 对sort_buffer中的数据按照字段name进行排序；\n\n 7. 遍历排序结果，取前1000行，并按照id的值回到原表中取出city、name和age三个字段返回\n\n给客户端。\n\n如果mysql实在是担心排序内存太小，会影响排序效率，才会采用rowid排序算法，这样排序过 程中一次可以排序更多行，但是需要再回到原表去取数据。\n\n如果mysql认为内存足够大，会优先选择全字段排序，把需要的字段都放到sort_buffer中，这样排序后就会直接从内存里面返回查询结果了，不用再回到原表去取数据。\n\n这也就体现了mysql的一个设计思想：如果内存够，如果内存够， 就要多利用内存， 尽量减少磁盘访问。\n\n优化：（索引的维护有代价，需要权衡）\n\n * 如果从索引上取出来的行，天然就排序好了的话，就可以不用再排序了。可以使用联合索引。\n * 还可以覆盖索引，使其直接返回需要的值。（也是用上联合索引）\n\n\n# 十七、如何正确地显示随机消息\n\n# 随机选择3个单词\nselect word from words order by rand() limit 3;\n\n\n这条语句的执行流程是这样的：\n\n 1. 创建一个临时表。这个临时表使用的是memory引擎，表里有两个字段，第一个字段是 double类型，为了后面描述方便，记为字段r，第二个字段是varchar(64)类型，记为字段\n\nw。并且，这个表没有建索引。\n\n 2. 从words表中，按主键顺序取出所有的word值。对于每一个word值，调用rand()函数生成一\n\n个大于0小于1的随机小数，并把这个随机小数和word分别存入临时表的r和w字段中，到 此，扫描行数是10000。 3. 现在临时表有10000行数据了，接下来你要在这个没有索引的内存临时表上，按照字段r排\n\n序。 4. 初始化 sort_buffer。sort_buffer中有两个字段，一个是double类型，另一个是整型。\n\n 5. 从内存临时表中一行一行地取出r值和位置信息（我后面会和你解释这里为什么是“位置信 息”），分别存入sort_buffer中的两个字段里。这个过程要对内存临时表做全表扫描，此时 扫描行数增加10000，变成了20000。\n\n 6. 在sort_buffer中根据r的值进行排序。注意，这个过程没有涉及到表操作，所以不会增加扫\n\n描行数。\n\n 7. 排序完成后，取出前三个结果的位置信息，依次到内存临时表中取出word值，返回给客户\n\n端。这个过程中，访问了表的三行数据，总扫描行数变成了20003。\n\n小结：order by rand()使用了内存临时表， 内存临时表排序的时候使用了 rowid排序方法。\n\n * 对于对于 innodb表来说 ，执行全字段排序会减少磁盘访问，因此会被优先选择。\n\n * 而对于内存表， 回表过程只是简单地根据数据行的位 置， 直接访问内存得到数据， 根本不会导致多访问磁盘 。优化器没有了这一层顾虑，那么它 会优先考虑的，就是用于排序的行长度越少越好了，所以，mysql这时就会选择rowid排序。\n\ntmp_table_size配置内存临时表的大小，默认是16m，超过时会转成磁盘临时表。\n\nmysql 5.6版本引入的一个新的排序算法， 即：优先队列排序算法。（维护了一个堆）\n\n临时文件的算法也就是归并算法。\n\n如果你直接使用order by rand()，这个语句需要using temporary 和 using filesort，查询的执行代价往往是比较大的。所以，在设计的时候你要量避开这种写法。\n\n为了达到严格的随机结果：\n\n 1. 取到整个表的行数，记作c。\n 2. 取到y = floor(c * rand())。floor在这里的作用，就是取整数部分。\n 3. 再用limit y, 1取得一行。\n\n\n# 十八、为什么逻辑相同的sql语句，性能差异巨大（先pass）\n\n小结：对索引字段做函数操作，可能会破坏索引值的有序性，因此优化器就决定放弃走树搜索功能。\n\n\n# 十九、为什么只查一行的语句，也执行慢？\n\n分析原因时候，一般先执行show processlist，看看当前语句处于什么状态。\n\n第一类：查询长时间不返回\n\n * 等mdl锁\n   \n   出现waiting for table metadata lock，表示现在有一个线程正在表t上请求或者持有mdl写锁，把select语句堵住了。\n   \n   解决：通过查询select blocking_pid from sys.schema_table_lock_waits;查出造成阻塞的process id，把他kill了。\n\n * 等flush\n\n * 等行锁\n\n第二类：查询慢\n\n\n# 二十、幻读是什么？有什么问题？（还是有点蒙呀）\n\nfor update 排他锁\n\nfor update仅适用于innodb，且必须在事务块(begin/commit)中才能生效。在进行事务操作时，通过“for update”语句，mysql会对查询结果集中每行数据都添加排他锁，其他线程对该记录的更新与删除操作都会阻塞。排他锁包含行锁、表锁。\n\nlock in share mode 共享锁\n\n幻读指的是一个事务在前后两次查询同一个范围的时候，后一次查询看到了前一次查询没有看到的行。\n\n“幻读”做一个说明：\n\n 1. 在可重复读隔离级别下，普通的查询是快照读，是不会看到别的事务插入的数据的。因此， 幻读在“当前读”下才会出现。\n\n 2. 上面session b的修改结果，被session a之后的select语句用“当前读”看到，不能称为幻读。 幻读仅专指“新插入的行”。\n\n锁的设计是为了保证数据的一致性。而这个一致性，不止是数据库内部数据状态在此 刻的一致性，还包含了数据和日志在逻辑上的一致性。\n\ninnodb如何解决幻读？\n\n幻读产生的原因是，行锁只能锁住行，但是新插入记录这个动作，要更新的是记录之间的“间隙”。因此，为了解决幻读问题，innodb只好引入新的锁，也即是间隙锁（gap lock）。\n\n间隙锁和行锁合称next-key lock。但其实他们是分开加的。\n\n间隙锁是在可重复读隔离级别下才会生效的。所以，你如果把隔离级别设置为读提交的话， 就没有间隙锁了。但同时，你要解决可能出现的数据和日志不一致问题，需要把binlog格式设置 为row。这也是现在不少公司使用的配置组合。\n\n很多公司使用：读提交隔离级别加binlog_format=row的组合。到底合不合理？\n\n如果读提交隔离级别够用，即业务不需要可重复读的保证，这样考虑到读提交下操作数据的锁范围更小（没有间隙锁），这个选择是合理的。\n\n比如大家都用读提交，可逻辑备份时，mysqldump为什么要把备份线程设置成可重复读？然后，在备份期间，备份线程用的是可重复读，而业务线程使用的是读提交，同时存在两种事务隔离级别会不会有问题？\n\n\n# 二十一、加锁规则\n\n\n# 可重复读隔离级别下\n\n锁是加在索引上的。\n\nnext-key lock=间隙锁+行锁，(]，前开后闭区间。\n\n间隙锁，()，前开后开区间。\n\n行锁就一个。\n\n加锁规则：2个原则，2个优化，1个bug\n\n 1. 原则1：加锁的基本单位是next-key lock。\n\n 2. 原则2：查找过程中访问到的对象才会加锁。\n\n 3. 优化1：索引上的等值查询，给唯一索引加锁的时候，next-key lock退化为行锁。\n\n 4. 优化2：索引上的等值查询，向右遍历时且遇到不满足等值条件的值时，next-key lock退化为间隙锁。\n\n 5. 一个bug：唯一索引上的范围查询会访问到不满足条件的第一个值为止。\n\n\n# 读提交隔离级别下\n\n读提交隔离级别的话，去掉间隙锁的部分，剩下行锁的部分。\n\n其实读提交隔离级别在外键场景下还是有间隙锁，相对比较复杂，我们今天先不展开。\n\n另外，在读提交隔离级别下还有一个优化，即：语句执行过程中加上的行锁，在语句执行完成后，就要把“不满足条件的行”上的行锁直接释放了，不需要等到事务提交。\n\n也就是说，读提交隔离级别下，锁的范围更小，锁的时间更短，这也是不少业务都默认使用读提交隔离级别的原因。\n\n\n# 24、mysql怎么保持主备一致？\n\nbinlog功不可没。\n\nmysql有容易学习和方便使用高可用架构。几乎所有的高可用架构，都直接依赖于binlog。虽然越来与复杂，但都是从最基本的一主一备演化而来。\n\n在一个主备关系中，每个备库接受主库的binlog执行。只要主库执行更新生成的所有binlog都可以传到备库被正确执行，备库就能达到跟主库一致的状态，这就是最终一致性。\n\n建议把备库设置成readonly模式。好处如下：\n\n * 有些运营类的查询语句会再备库查，设置为只读可防止误操作。\n * 防止切换逻辑bug，如切换过程中出现双写，造成主备不一致。\n * 可用readonly状态，判断节点的角色。\n\n因为readonly设置对super权限角色无效，而用于同步更新的线程就拥有超级权限。\n\n主库和备库之间维持了一个长连接。主库内部有一个线程，专门用于服务备库的这个长连接。\n\nbinlog的三种格式：（通过binlog_format属性设置）\n\n * statement。记录的是语句原文。可能导致主备不一致。\n * row。记录了真实删除行的主键id（如果是删除）。占空间，如删除10w条数据。\n * mixed。前两种的混合。\n\n现在越来越多的场景要求把mysql的binlog格式设置为row，其中之一好处在于：恢复数据。\n\n实际生产使用比较多的是双m结构，互为主备。相较于ms结构，切换时不用修改主备关系。\n\nmysql通过判断server id的方式，解决循环复制问题。\n\n通过mysqlbinlog工具解析和查看binlog中的内容。\n\n\n# 25、mysql如何保证高可用？\n\n只有最终一致性还不够，mysql还要提供高可用。\n\n\n# 主备延迟\n\n可通过在备库执行 show slave status显示seconds_behind_master表示当前备库延迟了多少秒。\n\n主备延迟的来源：\n\n * 备库所在的机器性能比主库的差。（现在一般做对称部署，主备切换）。\n * 备库的压力大。\n * 主库大事务。\n   * 因为主库必须等事务执行完成才会写入binlog，再传给备库。\n   * 如不要一次性用delete删除太多数据，典型的大事务场景。\n   * 如大表ddl也是典型的大事务场景。处理方案：计划内的ddl，建议使用go-ost方案。\n * 备库的并行复制能力。\n\n一般处理：\n\n * 一主多从。（这里把ha过程中被选成新主库的称为备库，其他的称为从库。备库和从库概念上差不多）\n * 通过binlog输出到外部系统，如hadoop，让外部系统提供统计类查询的能力。\n\n\n# 可靠性优先策略：\n\n双m结构下，主备切换：\n\n 1. 判断备库b现在的seconds_behind_master，如果小于某个值（比如5秒）继续下一步，否则\n\n持续重试这一步；\n\n 2. 把主库a改成只读状态，即把readonly设置为true；\n\n 3. 判断备库b的seconds_behind_master的值，直到这个值变成0为止；\n\n 4. 把备库b改成可读写状态，也就是把readonly 设置为false；\n\n 5. 把业务请求切到备库b。\n\n这个切换流程，一般是由专门的ha系统来完成的，我们暂时称之为可靠性优先流程。\n\n\n# 可用性有先策略：\n\n如果我强行把步骤4、5调整到最开始执行，也就是说不等主备数据同步，直接把连接切到备库 b，并且让备库b可以读写，那么系统几乎就没有不可用时间了。\n\n这个切换流程的代价，就是可能出现数据不一 致的情况。\n\n结论：\n\n 1. 使用row格式的binlog时，数据不一致的问题更容易被发现。而使用mixed或者statement格式的binlog时，数据很可能悄悄地就不一致了。如果你过了很久才发现数据不一致的问题， 很可能这时的数据不一致已经不可查，或者连带造成了更多的数据逻辑不一致。\n\n 2. 主备切换的可用性优先策略会导致数据不一致。因此，大多数情况下，我都建议你使用可靠性优先策略。毕竟对数据服务来说的话，数据的可靠性一般还是要优于可用性的。\n\n在满足数据可靠性的前提下，mysql高可用系统的可用性，是依赖于主备延迟的。延迟的时间越小，在主库故障的时候，服务恢复需要的时间就越短，可用性就越高。\n\n\n# 26、备库为什么会延迟好几个小时？（略看）\n\n简单总结：\n\n介绍了mysql的各种多线程复制策略。\n\n为什么要有多线程复制呢？这是因为单线程复制的能力全面低于多线程复制，对于更新压力较大 的主库，备库是可能一直追不上主库的。从现象上看就是，备库上seconds_behind_master的值 越来越大。\n\n大事务不仅会影响到主库，也是造成备库复制延迟的主要原因之一。 因此，在平时的开发工作中，我建议你尽量减少大事务操作，把大事务拆成小事务。\n\nbinlog-transaction-dependency-tracking参数：\n\n * commit_order\n * writeset\n * write_session\n\n\n# 27、主库出问题了从库怎么办？\n\n\n\n一主多从基本结构。\n\n将节点b设置成节点a的从库a`，需要执行change master命令。\n\n这条命令有6个参数，其中master_log_file和master_log_pos表示从主库的【文件名】、【日志偏移量】的日志继续同步。\n\n这个pos往往不精确。\n\n通常我们在切换任务时，要先主动跳过这些错误，有两种常用的方法：\n\n * 主动跳过一个事务set global sql_slave_skip_count = 1;start save;\n * 通过设置slave_skip_error参数，直接设置跳过指定的错误。\n   * 1062错误是插入数据时唯一键冲突；\n   * 1032错误是删除数据时找不到行。\n\n\n# gtid\n\n通过sql_slave_skip_counter跳过事务和通过slave_skip_errors忽略错误的方法，虽然都最终可以 建立从库b和新主库a’的主备关系，但这两种操作都很复杂，而且容易出错。所以，mysql 5.6版本引入了gtid，彻底解决了这个困难。\n\ngtid的全称是global transaction identifier，也就是全局事务id，是一个事务在提交的时候生成的，是这个事务的唯一标识。\n\ngtid=server_uuid:gno\n\n * server_uuid是一个实例第一次启动时自动生成的，是一个全局唯一的值；\n\n * gno是一个整数，初始值是1，每次提交事务的时候分配给这个事务，并加1。\n\ngtid主备复制的用法：\n\n执行change maste，只需使用master_auto_position = 1代替前面的master_log_file和master_log_pos。\n\n在基于gtid的主备关系里，系统认为只要建立主备关系，就必须保证主库发给备库的日志是完整的。因此，如果实例b需要的日志已经不存在，a’就拒绝把日志发给b。\n\n这跟基于位点的主备协议不同。基于位点的协议，是由备库决定的，备库指定哪个位点，主库就发哪个位点，不做日志的完整性判断。\n\n\n# 28、读写分离\n\n一主多从架构的应用场景：读写分离。\n\n读写分离的主要目标就是分摊主库的压力。\n\n\n\n客户端主动做读写分离。\n\n\n\n中间代理层proxy分发。\n\n方案：\n\n * 强制走主库方案\n * sleep方案\n * 判断主备无延迟方案\n   * 判断seconds_behind_master 是否等于0\n   * 对比位点qu确保主备无延迟\n   * 对比gtid集合确保主备无延迟\n * 配合semi-sync方案\n * 等主库位点方案\n * 等gtid方案\n\n\n# 判断主备无延迟方案\n\n\n# semi-sync replication 半同步控制\n\n 1. 事务提交的时候，主库把binlog发给从库；\n\n 2. 从库收到binlog以后，发回给主库一个ack，表示收到了；\n\n 3. 主库收到这个ack以后，才能给客户端返回“事务完成”的确认。\n\nsemi-sync配合前面关于位点的判断，就能够确定在从库上执行的查询请求，可以避免过期读。\n\n但是，semi-sync+位点判断的方案，只对一主一备的场景是成立的。在一主多从场景中，主库只 要等到一个从库的ack，就开始给客户端返回确认。\n\n小结一下，semi-sync配合判断主备无延迟的方案，存在两个问题：\n\n 1. 一主多从的时候，在某些从库执行查询请求会存在过期读的现象；\n\n 2. 在持续延迟的情况下，可能出现过度等待的问题。\n\n等主库位点方案，就可以解决这两个问题\n\n\n# 等主库位点方案\n\nselect master_pos_wait(file, pos[, timeout]);\n\n 1. 它是在从库执行的；\n\n 2. 参数file和pos指的是主库上的文件名和位置；\n\n 3. timeout可选，设置为正整数n表示这个函数最多等待n秒。\n\n这个命令正常返回的结果是一个正整数m，表示从命令开始执行，到应用完file和pos表示的 binlog位置，执行了多少事务。\n\n当然，除了正常返回一个正整数m外，这条命令还会返回一些其他结果，包括：\n\n 1. 如果执行期间，备库同步线程发生异常，则返回null；\n\n 2. 如果等待超过n秒，就返回-1；\n\n 3. 如果刚开始执行的时候，就发现已经执行过这个位置了，则返回0。\n\n 4. trx1事务更新完成后，马上执行show master status得到当前主库执行到的file和position；\n\n 5. 选定一个从库执行查询语句；\n\n 6. 在从库上执行select master_pos_wait(file, position, 1)；\n\n 7. 如果返回值是>=0的正整数，则在这个从库执行查询语句；\n\n 8. 否则，到主库执行查询语句。\n\n如果按照我们设定不允许过期读的要求，就只有两种选择，一种是超时放弃，一种是转到主库查询。具体怎么选择，就需要业务开发同学做好限流策略了。\n\n\n# gtid方案\n\n如果你的数据库开启了gtid模式，对应的也有等待gtid的方案。\n\nselect wait_for_executed_gtid_set(gtid_set, 1);\n\n这条命令的逻辑是：\n\n 1. 等待，直到这个库执行的事务中包含传入的gtid_set，返回0；\n\n 2. 超时返回1。\n\n在前面等位点的方案中，我们执行完事务后，还要主动去主库执行show master status。而 mysql 5.7.6版本开始，允许在执行完更新类事务后，把这个事务的gtid返回给客户端，这样等gtid的方案就可以减少一次查询。 这时，等gtid的执行流程就变成了：\n\n 1. trx1事务更新完成后，从返回包直接获取这个事务的gtid，记为gtid1；\n\n 2. 选定一个从库执行查询语句；\n\n 3. 在从库上执行 select wait_for_executed_gtid_set(gtid1, 1)；\n\n 4. 如果返回值是0，则在这个从库执行查询语句；\n\n 5. 否则，到主库执行查询语句。\n\n跟等主库位点的方案一样，等待超时后是否直接到主库查询，需要业务开发同学来做限流考虑。\n\n在实际应用中，这几个方案是可以混合使用的。\n\n比如，先在客户端对请求做分类，区分哪些请求可以接受过期读，而哪些请求完全不能接受过期读；然后，对于不能接受过期读的语句，再使用等gtid或等位点的方案。\n\n但话说回来，过期读在本质上是由一写多读导致的。在实际应用中，可能会有别的不需要等待就可以水平扩展的数据库方案，但这往往是用牺牲写性能换来的，也就是需要在读性能和写性能中取权衡。\n\n开源proxy：mariadb maxscale\n\n\n# 40、innodb和memory引擎\n\ninnodb表的数据就放在主键索引树上，主键索引是b+树。\n\nmemory引擎的数据和索引是分开的。\n\n内存表的数据部分以数组的形式单独存放，而主键id索引里，存放的是每个数据的位置。主键id是hash索引，索引上的key不是有序的。\n\n可见，innodb和memory引擎的数据组织方式是不同的：\n\n * innodb引擎把数据放在主键索引上，其他索引上保存的是主键id。这种方式，我们称之为索引组织表 （index organizied table）。\n\n * 而memory引擎采用的是把数据单独存放，索引上保存数据位置的数据组织形式，我们称之 为堆组织表 （heap organizied table）。\n\n这两个引擎的一些典型不同：\n\n 1. innodb表的数据总是有序存放的，而内存表的数据就是按照写入顺序存放的；\n 2. 当数据文件有空洞的时候，innodb表在插入新数据的时候，为了保证数据有序性，只能在固定的位置写入新值，而内存表找到空位就可以插入新值；\n 3. 数据位置发生变化的时候，innodb表只需要修改主键索引，而内存表需要修改所有索引；\n 4. innodb表用主键索引查询时需要走一次索引查找，用普通索引查询的时候，需要走两次索引查找。而内存表没有这个区别，所有索引的“地位”都是相同的。\n 5. innodb支持变长数据类型，不同记录的长度可能不同；内存表不支持blob 和 text字段，并且即使定义了varchar(n)，实际也当作char(n)，也就是固定长度字符串来存储，因此内存表的每行数据长度相同。\n\n\n# hash索引和b-tree索引\n\n实际上，内存表也是自持b-tree索引的。\n\n在我们的一般印象中，内存表的优势是速度快，其中一个原因就是memory引擎支持hash索引。更重要的原因是，内存表的所有数据都保存在内存上，而内存的读写速度总是比磁盘快。\n\n但不建议在生产环境上使用内存表，主要有2个原因：\n\n 1. 锁粒度问题。\n    1. 内存表不支持行锁，只支持表锁。\n 2. 数据持久化问题\n\n建议把普通内存表都用innodb表代替。\n\n例外的场景：内存临时表。内存表支持hash索引，这个特性利用起来，对复杂查询的加速效果还是很不错的。\n\n\n# 40、insert语句的锁为什么这么多？（初略总结）\n\nmysql对自增主键锁做了优化，尽量在申请到自增id以后，就释放自增锁。\n\n普通情况下，insert语句是一个很轻量的操作。\n\n特殊情况下，如：\n\ninsert …select 是很常见的在两个表之间拷贝数据的方法。你需要注意，在可重复读隔离级别下，这个语句会给select的表里扫描到的记录和间隙加读锁。 而如果insert和select的对象是同一个表，则有可能会造成循环写入。这种情况下，我们需要引入\n\n用户临时表来做优化。\n\ninsert 语句如果出现唯一键冲突，会在冲突的唯一值上加共享的next-key lock(s锁)。因此，碰到\n\n由于唯一键约束导致报错后，要尽快提交或回滚事务，避免加锁时间过长。\n\n\n# 43、要不要使用分区表？\n\n分区表有什么问题，为什么很多公司规范不让使用分区表呢？\n\n分区表的组织形式：\n\ncreate table `t` (\n\t`ftime` datetime notnull,\n  `c` int(11) default null,\n  key (`ftime`)\n) engine=innodb default charset = latin1\npartition by range(year(ftime))\n(partition p_2017 values less than (2017) engine = innodb,\n partition p_2018 values less than (2018) engine = innodb,\n partition p_2019 values less than (2019) engine = innodb,\n partition p_others values less than maxvalue engine = innodb);\n \n insert into t value('2017-4-1',1),('2018-4-1',1); \n\n\n在表t中初始化插入了两行记录，按照定义的分区规则，这两行记录分别落在p_2018和p_2019 这两个分区上。\n\n这个表包含了一个.frm文件和4个.ibd文件，每个分区对应一个.ibd文件。也就是说：\n\n * 对于引擎层来说，这是4个表；\n * 对于server层来说，这是1个表。\n\n我们使用分区表的一个重要原因就是单表过大。那么，如果不使用分区表的话，我们就是要使用手动分表的方式。\n\n分区表和手工分表，一个是由server层来决定使用哪个分区，一个是由应用层代码来决定使用哪 个分表。因此，从引擎层看，这两种方式也是没有差别的。\n\n其实这两个方案的区别，主要是在server层上。从server层看，我们就不得不提到分区表一个被广为诟病的问题：打开表的行为。\n\n 1. mysql在第一次打开分区表的时候，需要访问所有的分区；\n\n 2. 在server层，认为这是同一张表，因此所有分区共用同一个mdl锁；\n\n 3. 在引擎层，认为这是不同的表，因此mdl锁之后的执行过程，会根据分区表规则，只访问必要的分区。\n\n\n# 分区表的应用场景\n\n分区表的一个显而易见的优势是对业务透明，相对于用户分表来说，使用分区表的业务代码更简洁。还有，分区表可以很方便的清理历史数据。\n\n如果一项业务跑的时间足够长，往往就会有根据时间删除历史数据的需求。这时候，按照时间分区的分区表，就可以直接通过alter table t drop partition这个语法删掉分区，从而删掉过期的历史数据。\n\n这个alter table t drop partition …操作是直接删除分区文件，效果跟drop普通表类似。与使用delete语句删除数据相比，优势是速度快、对系统影响小。\n\n我们以范围分区（range）为例和你介绍的。实际上，mysql还支持hash分区、 list分区等分区方法。你可以在需要用到的时候，再翻翻手册。\n\n实际使用时，分区表跟用户分表比起来，有两个绕不开的问题：一个是第一次访问的时候需要访问所有分区，另一个是共用mdl锁。\n\n因此，如果要使用分区表，就不要创建太多的分区。我见过一个用户做了按天分区策略，然后预先创建了10年的分区。这种情况下，访问分区表的性能自然是不好的。这里有两个问题需要注意：\n\n 1. 分区并不是越细越好。实际上，单表或者单分区的数据一千万行，只要没有特别大的索引， 对于现在的硬件能力来说都已经是小表了。\n\n 2. 分区也不要提前预留太多，在使用之前预先创建即可。比如，如果是按月分区，每年年底时再把下一年度的12个新分区创建上即可。对于没有数据的历史分区，要及时的drop掉。\n\n至于分区表的其他问题，比如查询需要跨多个分区取数据，查询性能就会比较慢，基本上就不是分区表本身的问题，而是数据量的问题或者说是使用方式的问题了。\n\n当然，如果你的团队已经维护了成熟的分库分表中间件，用业务分表，对业务开发同学没有额外的复杂性，对dba也更直观，自然是更好的。",charsets:{cjk:!0},lastUpdated:"2023/03/29, 21:03:43",lastUpdatedTimestamp:1680095023e3},{title:"test",frontmatter:{title:"test",date:"2023-04-15T17:00:06.000Z",permalink:"/pages/b55c23/",article:!1},regularPath:"/02.MySQL/test.html",relativePath:"02.MySQL/test.md",key:"v-1c9fd64e",path:"/pages/b55c23/",headersStr:null,content:"没写编号，就不会在页面中出现。显然这个结论是错误的。",normalizedContent:"没写编号，就不会在页面中出现。显然这个结论是错误的。",charsets:{cjk:!0}},{title:"Redis总",frontmatter:{title:"Redis总",date:"2023-03-16T23:27:49.000Z",permalink:"/pages/redis/"},regularPath:"/03.Redis/01.redis%E6%80%BB.html",relativePath:"03.Redis/01.redis总.md",key:"v-5f0f30c6",path:"/pages/redis/",headers:[{level:2,title:"Redis参考资料汇总",slug:"redis参考资料汇总",normalizedTitle:"redis参考资料汇总",charIndex:2},{level:2,title:"Redis优缺点？",slug:"redis优缺点",normalizedTitle:"redis优缺点？",charIndex:253},{level:2,title:"Redis为什么这么快？",slug:"redis为什么这么快",normalizedTitle:"redis为什么这么快？",charIndex:701},{level:2,title:"Redis 为什么用单线程？",slug:"redis-为什么用单线程",normalizedTitle:"redis 为什么用单线程？",charIndex:1010},{level:2,title:"Redis 中的Reactor模型",slug:"redis-中的reactor模型",normalizedTitle:"redis 中的reactor模型",charIndex:1164},{level:2,title:"应用场景",slug:"应用场景",normalizedTitle:"应用场景",charIndex:1903},{level:2,title:"Memcached和Redis的区别",slug:"memcached和redis的区别",normalizedTitle:"memcached和redis的区别",charIndex:2194},{level:2,title:"为什么要用 Redis 而不用 map/guava 做缓存?",slug:"为什么要用-redis-而不用-map-guava-做缓存",normalizedTitle:"为什么要用 redis 而不用 map/guava 做缓存?",charIndex:2393}],headersStr:"Redis参考资料汇总 Redis优缺点？ Redis为什么这么快？ Redis 为什么用单线程？ Redis 中的Reactor模型 应用场景 Memcached和Redis的区别 为什么要用 Redis 而不用 map/guava 做缓存?",content:"# Redis参考资料汇总\n\n * http://www.topjavaer.cn/redis/redis-basic/\n * https://www.iamshuaidi.com/redis-interview\n * https://xie.infoq.cn/article/6c3500c66c3cdee3d72b88780\n * https://zhuanlan.zhihu.com/p/553803052\n * https://segmentfault.com/blog/magebyte\n\n\n# Redis优缺点？\n\n优点：\n\n 1. 基于内存操作，内存读写速度快。\n 2. 支持多种数据类型，包括String、Hash、List、Set、ZSet等。\n 3. 支持持久化。Redis支持RDB和AOF两种持久化机制，持久化功能可以有效地避免数据丢失问题。\n 4. 支持事务。Redis的所有操作都是原子性的，同时Redis还支持对几个操作合并后的原子性执行。\n 5. 支持主从复制。主节点会自动将数据同步到从节点，可以进行读写分离。\n 6. Redis命令的处理是单线程的，避免线程切换开销及多线程的竞争问题。Redis6.0引入了多线程，需要注意的是，多线程用于处理网络数据的读写和协议解析，Redis命令执行还是单线程的。\n\n缺点：\n\n 1. 对结构化查询的支持比较差。\n 2. 数据库容量受到物理内存的限制，不适合用作海量数据的高性能读写，因此Redis适合的场景主要局限在较小数据量的操作。\n 3. Redis 较难支持在线扩容，在集群容量达到上限时在线扩容会变得很复杂。\n\n\n# Redis为什么这么快？\n\n * 基于内存：Redis是使用内存存储，没有磁盘IO上的开销。数据存在内存中，读写速度快。\n * IO多路复用模型：Redis 采用 IO 多路复用技术。Redis 使用单线程来轮询描述符，将数据库的操作都转换成了事件，不在网络I/O上浪费过多的时间。非阻塞 IO。\n * 高效的数据结构：Redis 每种数据类型底层都做了优化，目的就是为了追求更快的速度。动态字符串(SDS)，链表，字典，跳跃链表，整数集合和压缩列表。在这个基础上去实现用户能操作的对象：字符串，列表，哈希，集合，有序集合等对象。\n * 单线程避免了多线程的频繁上下文切换带来的性能问题，也不用考虑锁的问题。\n\n\n# Redis 为什么用单线程？\n\n因为 Redis 是基于内存的操作，CPU 不是 Redis 的瓶颈，Redis 的瓶颈可能是机器内存的大小或网络带宽。\n\n大多数Redis操作不需要太多的CPU计算，而是依赖于内存的快速读写。\n\n即然单线程容易实现，CPU又不是瓶颈，那就使用单线程，节省很多麻烦。\n\n\n# Redis 中的Reactor模型\n\nIO多路复用技术的好处：多个socket连接，复用一个线程。\n\nIO多路复用技术，借助操作系统的支持，服务端一个线程可以同时监听多个网络连接，一旦某个连接上有事件需要处理，就能通知线程执行相应的读写操作。\n\nLinux所提供的poll, select, epoll都属于IO多路复用技术，由于select和poll在实现上的缺陷（如内核和用户空间内存拷贝问题），现在服务端变成大多使用epoll。\n\nReactor 模型是一个比较广泛的概念。可以泛指IO多路复用技术。Reactor模式也叫Dispatcher模式，即I/O多路复用统一监听事件，收到事件后分配（Dispatch）给某个进程。\n\n> Reactor: The reactor design pattern is an event handling pattern for handling service delivered concurrently to a service handler by one or more inputs. The service handler then demultiplexes the incoming requests and dispatches them synchronously to the associated request handlers.\n\n单I/O线程模型图：\n\n\n\n\n\n多I/O线程模型图：\n\n\n\n * https://www.51cto.com/article/697808.html\n * https://juejin.cn/post/7124667316637270046#heading-1\n\n\n# 应用场景\n\n 1. 缓存热点数据，缓解数据库的压力。\n 2. 利用Redis中原子性的自增操作，可以用使用实现计算器的功能，比如统计用户点赞数、用户访问数等，这类操作如果用MySQL，频繁的读写会带来相当大的压力。\n 3. 简单消息队列，不要求高可靠的情况下，可以使用Redis自身的发布/订阅模式或者List来实现一个队列，实现异步操作。\n 4. 好友关系，利用集合的一些命令，比如求交集、并集、差集等。可以方便搞定一些共同好友、共同爱好之类的功能。\n 5. 限流，比较典型的使用场景是限制某个用户访问某个API的频率，常用的有抢购时，防止用户疯狂点击带来不必要的压力。\n\n\n# Memcached和Redis的区别\n\n * Redis只使用单核，而Memcached可以使用多核。\n * MemCached数据结构单一，仅用来缓存数据，而Redis支持更加丰富的数据类型，也可以在服务器端直接对数据进行丰富的操作，这样可以减少网络IO次数和数据体积。\n * MemCached不支持数据持久化，断电或重启后数据消失。Redis支持数据持久化和数据恢复，允许单点故障。\n\n\n# 为什么要用 Redis 而不用 map/guava 做缓存?\n\n使用自带的 map 或者 guava 实现的是本地缓存，最主要的特点是轻量以及快速，生命周期随着 jvm 的销毁而结束，并且在多实例的情况下，每个实例都需要各自保存一份缓存，缓存不具有一致性。\n\n使用 redis 或 memcached 之类的称为分布式缓存，在多实例的情况下，各实例共用一份缓存数据，缓存具有一致性。缺点是需要保持redis或memcached服务的高可用，整个程序架构上较为复杂。\n\n比如：\n\n1、Redis 可以用几十 G 内存来做缓存，Map 不行，一般 JVM 也就分几个 G 数据就够大了；\n\n2、Redis 的缓存可以持久化，Map 是内存对象，程序一重启数据就没了；\n\n3、Redis 可以实现分布式的缓存，Map 只能存在创建它的程序里；\n\n4、Redis 可以处理每秒百万级的并发，是专业的缓存服务，Map 只是一个普通的对象；\n\n5、Redis 缓存有过期机制，Map 本身无此功能；Redis 有丰富的 API，Map 就简单太多了；\n\n6、Redis可单独部署，多个项目之间可以共享，本地内存无法共享；\n\n7、Redis有专门的管理工具可以查看缓存数据。",normalizedContent:"# redis参考资料汇总\n\n * http://www.topjavaer.cn/redis/redis-basic/\n * https://www.iamshuaidi.com/redis-interview\n * https://xie.infoq.cn/article/6c3500c66c3cdee3d72b88780\n * https://zhuanlan.zhihu.com/p/553803052\n * https://segmentfault.com/blog/magebyte\n\n\n# redis优缺点？\n\n优点：\n\n 1. 基于内存操作，内存读写速度快。\n 2. 支持多种数据类型，包括string、hash、list、set、zset等。\n 3. 支持持久化。redis支持rdb和aof两种持久化机制，持久化功能可以有效地避免数据丢失问题。\n 4. 支持事务。redis的所有操作都是原子性的，同时redis还支持对几个操作合并后的原子性执行。\n 5. 支持主从复制。主节点会自动将数据同步到从节点，可以进行读写分离。\n 6. redis命令的处理是单线程的，避免线程切换开销及多线程的竞争问题。redis6.0引入了多线程，需要注意的是，多线程用于处理网络数据的读写和协议解析，redis命令执行还是单线程的。\n\n缺点：\n\n 1. 对结构化查询的支持比较差。\n 2. 数据库容量受到物理内存的限制，不适合用作海量数据的高性能读写，因此redis适合的场景主要局限在较小数据量的操作。\n 3. redis 较难支持在线扩容，在集群容量达到上限时在线扩容会变得很复杂。\n\n\n# redis为什么这么快？\n\n * 基于内存：redis是使用内存存储，没有磁盘io上的开销。数据存在内存中，读写速度快。\n * io多路复用模型：redis 采用 io 多路复用技术。redis 使用单线程来轮询描述符，将数据库的操作都转换成了事件，不在网络i/o上浪费过多的时间。非阻塞 io。\n * 高效的数据结构：redis 每种数据类型底层都做了优化，目的就是为了追求更快的速度。动态字符串(sds)，链表，字典，跳跃链表，整数集合和压缩列表。在这个基础上去实现用户能操作的对象：字符串，列表，哈希，集合，有序集合等对象。\n * 单线程避免了多线程的频繁上下文切换带来的性能问题，也不用考虑锁的问题。\n\n\n# redis 为什么用单线程？\n\n因为 redis 是基于内存的操作，cpu 不是 redis 的瓶颈，redis 的瓶颈可能是机器内存的大小或网络带宽。\n\n大多数redis操作不需要太多的cpu计算，而是依赖于内存的快速读写。\n\n即然单线程容易实现，cpu又不是瓶颈，那就使用单线程，节省很多麻烦。\n\n\n# redis 中的reactor模型\n\nio多路复用技术的好处：多个socket连接，复用一个线程。\n\nio多路复用技术，借助操作系统的支持，服务端一个线程可以同时监听多个网络连接，一旦某个连接上有事件需要处理，就能通知线程执行相应的读写操作。\n\nlinux所提供的poll, select, epoll都属于io多路复用技术，由于select和poll在实现上的缺陷（如内核和用户空间内存拷贝问题），现在服务端变成大多使用epoll。\n\nreactor 模型是一个比较广泛的概念。可以泛指io多路复用技术。reactor模式也叫dispatcher模式，即i/o多路复用统一监听事件，收到事件后分配（dispatch）给某个进程。\n\n> reactor: the reactor design pattern is an event handling pattern for handling service delivered concurrently to a service handler by one or more inputs. the service handler then demultiplexes the incoming requests and dispatches them synchronously to the associated request handlers.\n\n单i/o线程模型图：\n\n\n\n\n\n多i/o线程模型图：\n\n\n\n * https://www.51cto.com/article/697808.html\n * https://juejin.cn/post/7124667316637270046#heading-1\n\n\n# 应用场景\n\n 1. 缓存热点数据，缓解数据库的压力。\n 2. 利用redis中原子性的自增操作，可以用使用实现计算器的功能，比如统计用户点赞数、用户访问数等，这类操作如果用mysql，频繁的读写会带来相当大的压力。\n 3. 简单消息队列，不要求高可靠的情况下，可以使用redis自身的发布/订阅模式或者list来实现一个队列，实现异步操作。\n 4. 好友关系，利用集合的一些命令，比如求交集、并集、差集等。可以方便搞定一些共同好友、共同爱好之类的功能。\n 5. 限流，比较典型的使用场景是限制某个用户访问某个api的频率，常用的有抢购时，防止用户疯狂点击带来不必要的压力。\n\n\n# memcached和redis的区别\n\n * redis只使用单核，而memcached可以使用多核。\n * memcached数据结构单一，仅用来缓存数据，而redis支持更加丰富的数据类型，也可以在服务器端直接对数据进行丰富的操作，这样可以减少网络io次数和数据体积。\n * memcached不支持数据持久化，断电或重启后数据消失。redis支持数据持久化和数据恢复，允许单点故障。\n\n\n# 为什么要用 redis 而不用 map/guava 做缓存?\n\n使用自带的 map 或者 guava 实现的是本地缓存，最主要的特点是轻量以及快速，生命周期随着 jvm 的销毁而结束，并且在多实例的情况下，每个实例都需要各自保存一份缓存，缓存不具有一致性。\n\n使用 redis 或 memcached 之类的称为分布式缓存，在多实例的情况下，各实例共用一份缓存数据，缓存具有一致性。缺点是需要保持redis或memcached服务的高可用，整个程序架构上较为复杂。\n\n比如：\n\n1、redis 可以用几十 g 内存来做缓存，map 不行，一般 jvm 也就分几个 g 数据就够大了；\n\n2、redis 的缓存可以持久化，map 是内存对象，程序一重启数据就没了；\n\n3、redis 可以实现分布式的缓存，map 只能存在创建它的程序里；\n\n4、redis 可以处理每秒百万级的并发，是专业的缓存服务，map 只是一个普通的对象；\n\n5、redis 缓存有过期机制，map 本身无此功能；redis 有丰富的 api，map 就简单太多了；\n\n6、redis可单独部署，多个项目之间可以共享，本地内存无法共享；\n\n7、redis有专门的管理工具可以查看缓存数据。",charsets:{cjk:!0},lastUpdated:"2023/03/29, 21:03:43",lastUpdatedTimestamp:1680095023e3},{title:"Redis数据类型",frontmatter:{title:"Redis数据类型",date:"2023-03-17T16:49:06.000Z",permalink:"/pages/99d0e1/"},regularPath:"/03.Redis/02.redis%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.html",relativePath:"03.Redis/02.redis数据类型.md",key:"v-51da0e54",path:"/pages/99d0e1/",headers:[{level:2,title:"set集合运算",slug:"set集合运算",normalizedTitle:"set集合运算",charIndex:148},{level:2,title:"zset",slug:"zset",normalizedTitle:"zset",charIndex:77},{level:2,title:"bitmaps",slug:"bitmaps",normalizedTitle:"bitmaps",charIndex:97},{level:3,title:"实现判断海量用户是否在线：",slug:"实现判断海量用户是否在线",normalizedTitle:"实现判断海量用户是否在线：",charIndex:1107},{level:3,title:"实现用户每月的登录情况：",slug:"实现用户每月的登录情况",normalizedTitle:"实现用户每月的登录情况：",charIndex:1381},{level:3,title:"实现连续签到用户总数统计",slug:"实现连续签到用户总数统计",normalizedTitle:"实现连续签到用户总数统计",charIndex:1757},{level:2,title:"HyperLogLog",slug:"hyperloglog",normalizedTitle:"hyperloglog",charIndex:2260},{level:3,title:"统计页面的UV：",slug:"统计页面的uv",normalizedTitle:"统计页面的uv：",charIndex:2731},{level:2,title:"各数据类型使用场景",slug:"各数据类型使用场景",normalizedTitle:"各数据类型使用场景",charIndex:3021}],headersStr:"set集合运算 zset bitmaps 实现判断海量用户是否在线： 实现用户每月的登录情况： 实现连续签到用户总数统计 HyperLogLog 统计页面的UV： 各数据类型使用场景",content:"Redis支持：\n\n * string：值可以是字符串、数字或者二进制，但值最大不能超过512MB。\n * hash\n * list\n * set\n * zset(sorted set)\n * bitmaps\n * hyperloglog\n * stream\n * geospatial\n\n\n# set集合运算\n\nSDIFF setA setB  //差集运算\nSINTER setA setB //交集运算\nSUNION setA setB //并集运算\n\n\n三个命令都可以传进多个键 SDIFF setA setB setC\n\n\n# zset\n\nzadd zsetkey 50 e1 60 e2 30 e3\n\n\nZset每个元素都会关联一个double（超过17位使用科学计算法表示，可能丢失精度）类型的分数，通过分数来为集合中的成员进行排序。zset的成员是唯一的,但分数(score)可以重复。\n\n有序集合和列表相同点：\n\n 1. 都是有序的；\n 2. 都可以获得某个范围内的元素。lrange和zrange\n\n有序集合和列表不同点：\n\n 1. 列表基于链表实现，获取两端元素速度快，访问中间元素速度慢；\n 2. 有序集合基于散列表和跳跃表实现，访问中间元素时间复杂度是OlogN；\n 3. 列表不能简单的调整某个元素的位置，有序列表可以（更改元素的分数）；\n 4. 有序集合更耗内存。\n\n\n# bitmaps\n\nBitmaps本身不是一种数据结构，实际上它就是字符串，但是它可以对字符串的位进行操作，可以把Bitmaps想象成一个以位为单位的数组，数组的每个单元只能存储0和1。\n\nbitmap的长度与集合中元素个数无关，而是与基数的上限有关。假如要计算上限为1亿的基数，则需要12.5M字节的bitmap。就算集合中只有10个元素也需要12.5M。\n\noffset从0开始。\n\nSETBIT <key> <offset> <value>\nGETBIT <key> <offset>\nBITCOUNT <key>\nBITPOS key bitValue [start] [end] //返回数据表示 Bitmap 中第一个值为 bitValue 的 offset 位置。\nBITOP operation destkey key [key ...] //用于对一个或者多个 键 = key 的 Bitmap 进行位元操作。opration 可以是 and、OR、NOT、XOR。处理不同长度的字符串时，较短的那个字符串所缺少的部分会被看作 0 。空的 key 也被看作是包含 0 的字符串序列。\n\n\n\n# 实现判断海量用户是否在线：\n\nkey = login_status 表示存储用户登陆状态集合数据， 将用户 ID 作为 offset，在线就设置为 1，下线设置 0。通过 GETBIT判断对应的用户是否在线。 50000 万 用户只需要 6 MB 的空间。\n\n假如我们要判断 ID = 10086 的用户的登陆情况：\n\n1.表示用户登录\nSETBIT login_status 10086 1\n2.检查用户是否登录\nGETBIT login_status 10086\n3.用户登出\nSETBIT login_status 10086 0\n\n\n\n# 实现用户每月的登录情况：\n\nkey 可以设计成 uid:sign:{userId}:{yyyyMM}，月份的每一天的值 - 1 可以作为 offset（因为 offset 从 0 开始，所以 offset = 日期 - 1）。\n\n1.表示记录用户在 2021 年 5 月 16 号打卡。\nSETBIT uid:sign:89757:202105 15 1\n2.判断编号 89757 用户在 2021 年 5 月 16 号是否打卡。\nGETBIT uid:sign:89757:202105 15\n3.统计该用户在 5 月份的打卡次数。\nBITCOUNT uid:sign:89757:202105\n4.获取 userID = 89757 在 2021 年 5 月份首次打卡日期。\nBITPOS uid:sign:89757:202105 1\n\n\n\n# 实现连续签到用户总数统计\n\n在记录了一个亿的用户连续 7 天的打卡数据，如何统计出这连续 7 天连续打卡用户总数呢？\n\n我们把每天的日期作为 Bitmap 的 key，userId 作为 offset，若是打卡则将 offset 位置的 bit 设置成 1。\n\nkey 对应的集合的每个 bit 位的数据则是一个用户在该日期的打卡记录。\n\n一共有 7 个这样的 Bitmap，如果我们能对这 7 个 Bitmap 的对应的 bit 位做 『与』运算。\n\n// 与操作\nBITOP AND destmap bitmap:01 bitmap:02 bitmap:03\n// 统计 bit 位 =  1 的个数\nBITCOUNT destmap\n\n\n简单计算下 一个一亿个位的 Bitmap占用的内存开销，大约占 12 MB 的内存（10^8/8/1024/1024），7 天的 Bitmap 的内存开销约为 84 MB。同时我们最好给 Bitmap 设置过期时间，让 Redis 删除过期的打卡数据，节省内存。\n\nhttps://segmentfault.com/a/1190000040177140\n\n\n# HyperLogLog\n\nHyperLogLog 是用来做基数统计的算法，其优点是，它所需的内存并不会因为集合的大小而改变，无论集合包含的元素有多少个，HyperLogLog进行计算所需的内存总是固定的，并且是非常少的。\n\n目的是做基数统计，故不是集合，不会保存元数据，只记录数量而不是数值。\n\n每个 HyperLogLog 最多只需要花费 12KB 内存，在标准误差 0.81%的前提下，就可以计算 2 的 64 次方个元素的基数。\n\n基数：比如数据集 {1, 3, 5, 7, 5, 7, 8}， 那么这个数据集的基数集为 {1, 3, 5 ,7, 8}，基数即不重复元素为5。\n\n基数统计：统计一个集合中不重复元素的个数。\n\n核心是基数估算算法，主要表现为计算时内存的使用和数据合并的处理。最终数值存在一定误差。\n\n应用场景\n\n * 统计一个 APP 的日活、月活数；\n * 统计一个页面的每天被多少个不同账户访问量（Unique Visitor，UV））；\n * 统计用户每天搜索不同词条的个数；\n * 统计注册 IP 数。\n\n\n# 统计页面的UV：\n\n1.将访问页面的每个用户 ID 添加到 HyperLogLog 中。\nPFADD key:uv userID1 userID2 useID3\n2.利用 PFCOUNT 获取key的UV值。\nPFCOUNT key:uv\n\n\n合并\nPFADD Redis数据 user1 user2 user3\nPFADD MySQL数据 user1 user2 user4\nPFMERGE 数据库 Redis数据 MySQL数据\nPFCOUNT 数据库 // 返回值 = 4\n\n\nhttps://segmentfault.com/a/1190000041696066\n\n\n# 各数据类型使用场景\n\nstring：1、常规key-value缓存应用。常规计数如微博数、粉丝数。2、分布式锁。\n\nhash：存放结构化数据，如用户信息（昵称、年龄、性别、积分等）。\n\nlist：热门博客列表、消息队列系统。使用list可以构建队列系统，比如：将Redis用作日志收集器，多个端点将日志信息写入Redis，然后一个worker统一将所有日志写到磁盘。\n\nset：1、好友关系，微博粉丝的共同关注、共同喜好、共同好友等；2、利用唯一性，统计访问网站的所有独立ip 。\n\nzset：1、排行榜；2、优先级队列。",normalizedContent:"redis支持：\n\n * string：值可以是字符串、数字或者二进制，但值最大不能超过512mb。\n * hash\n * list\n * set\n * zset(sorted set)\n * bitmaps\n * hyperloglog\n * stream\n * geospatial\n\n\n# set集合运算\n\nsdiff seta setb  //差集运算\nsinter seta setb //交集运算\nsunion seta setb //并集运算\n\n\n三个命令都可以传进多个键 sdiff seta setb setc\n\n\n# zset\n\nzadd zsetkey 50 e1 60 e2 30 e3\n\n\nzset每个元素都会关联一个double（超过17位使用科学计算法表示，可能丢失精度）类型的分数，通过分数来为集合中的成员进行排序。zset的成员是唯一的,但分数(score)可以重复。\n\n有序集合和列表相同点：\n\n 1. 都是有序的；\n 2. 都可以获得某个范围内的元素。lrange和zrange\n\n有序集合和列表不同点：\n\n 1. 列表基于链表实现，获取两端元素速度快，访问中间元素速度慢；\n 2. 有序集合基于散列表和跳跃表实现，访问中间元素时间复杂度是ologn；\n 3. 列表不能简单的调整某个元素的位置，有序列表可以（更改元素的分数）；\n 4. 有序集合更耗内存。\n\n\n# bitmaps\n\nbitmaps本身不是一种数据结构，实际上它就是字符串，但是它可以对字符串的位进行操作，可以把bitmaps想象成一个以位为单位的数组，数组的每个单元只能存储0和1。\n\nbitmap的长度与集合中元素个数无关，而是与基数的上限有关。假如要计算上限为1亿的基数，则需要12.5m字节的bitmap。就算集合中只有10个元素也需要12.5m。\n\noffset从0开始。\n\nsetbit <key> <offset> <value>\ngetbit <key> <offset>\nbitcount <key>\nbitpos key bitvalue [start] [end] //返回数据表示 bitmap 中第一个值为 bitvalue 的 offset 位置。\nbitop operation destkey key [key ...] //用于对一个或者多个 键 = key 的 bitmap 进行位元操作。opration 可以是 and、or、not、xor。处理不同长度的字符串时，较短的那个字符串所缺少的部分会被看作 0 。空的 key 也被看作是包含 0 的字符串序列。\n\n\n\n# 实现判断海量用户是否在线：\n\nkey = login_status 表示存储用户登陆状态集合数据， 将用户 id 作为 offset，在线就设置为 1，下线设置 0。通过 getbit判断对应的用户是否在线。 50000 万 用户只需要 6 mb 的空间。\n\n假如我们要判断 id = 10086 的用户的登陆情况：\n\n1.表示用户登录\nsetbit login_status 10086 1\n2.检查用户是否登录\ngetbit login_status 10086\n3.用户登出\nsetbit login_status 10086 0\n\n\n\n# 实现用户每月的登录情况：\n\nkey 可以设计成 uid:sign:{userid}:{yyyymm}，月份的每一天的值 - 1 可以作为 offset（因为 offset 从 0 开始，所以 offset = 日期 - 1）。\n\n1.表示记录用户在 2021 年 5 月 16 号打卡。\nsetbit uid:sign:89757:202105 15 1\n2.判断编号 89757 用户在 2021 年 5 月 16 号是否打卡。\ngetbit uid:sign:89757:202105 15\n3.统计该用户在 5 月份的打卡次数。\nbitcount uid:sign:89757:202105\n4.获取 userid = 89757 在 2021 年 5 月份首次打卡日期。\nbitpos uid:sign:89757:202105 1\n\n\n\n# 实现连续签到用户总数统计\n\n在记录了一个亿的用户连续 7 天的打卡数据，如何统计出这连续 7 天连续打卡用户总数呢？\n\n我们把每天的日期作为 bitmap 的 key，userid 作为 offset，若是打卡则将 offset 位置的 bit 设置成 1。\n\nkey 对应的集合的每个 bit 位的数据则是一个用户在该日期的打卡记录。\n\n一共有 7 个这样的 bitmap，如果我们能对这 7 个 bitmap 的对应的 bit 位做 『与』运算。\n\n// 与操作\nbitop and destmap bitmap:01 bitmap:02 bitmap:03\n// 统计 bit 位 =  1 的个数\nbitcount destmap\n\n\n简单计算下 一个一亿个位的 bitmap占用的内存开销，大约占 12 mb 的内存（10^8/8/1024/1024），7 天的 bitmap 的内存开销约为 84 mb。同时我们最好给 bitmap 设置过期时间，让 redis 删除过期的打卡数据，节省内存。\n\nhttps://segmentfault.com/a/1190000040177140\n\n\n# hyperloglog\n\nhyperloglog 是用来做基数统计的算法，其优点是，它所需的内存并不会因为集合的大小而改变，无论集合包含的元素有多少个，hyperloglog进行计算所需的内存总是固定的，并且是非常少的。\n\n目的是做基数统计，故不是集合，不会保存元数据，只记录数量而不是数值。\n\n每个 hyperloglog 最多只需要花费 12kb 内存，在标准误差 0.81%的前提下，就可以计算 2 的 64 次方个元素的基数。\n\n基数：比如数据集 {1, 3, 5, 7, 5, 7, 8}， 那么这个数据集的基数集为 {1, 3, 5 ,7, 8}，基数即不重复元素为5。\n\n基数统计：统计一个集合中不重复元素的个数。\n\n核心是基数估算算法，主要表现为计算时内存的使用和数据合并的处理。最终数值存在一定误差。\n\n应用场景\n\n * 统计一个 app 的日活、月活数；\n * 统计一个页面的每天被多少个不同账户访问量（unique visitor，uv））；\n * 统计用户每天搜索不同词条的个数；\n * 统计注册 ip 数。\n\n\n# 统计页面的uv：\n\n1.将访问页面的每个用户 id 添加到 hyperloglog 中。\npfadd key:uv userid1 userid2 useid3\n2.利用 pfcount 获取key的uv值。\npfcount key:uv\n\n\n合并\npfadd redis数据 user1 user2 user3\npfadd mysql数据 user1 user2 user4\npfmerge 数据库 redis数据 mysql数据\npfcount 数据库 // 返回值 = 4\n\n\nhttps://segmentfault.com/a/1190000041696066\n\n\n# 各数据类型使用场景\n\nstring：1、常规key-value缓存应用。常规计数如微博数、粉丝数。2、分布式锁。\n\nhash：存放结构化数据，如用户信息（昵称、年龄、性别、积分等）。\n\nlist：热门博客列表、消息队列系统。使用list可以构建队列系统，比如：将redis用作日志收集器，多个端点将日志信息写入redis，然后一个worker统一将所有日志写到磁盘。\n\nset：1、好友关系，微博粉丝的共同关注、共同喜好、共同好友等；2、利用唯一性，统计访问网站的所有独立ip 。\n\nzset：1、排行榜；2、优先级队列。",charsets:{cjk:!0},lastUpdated:"2023/03/29, 21:03:43",lastUpdatedTimestamp:1680095023e3},{title:"Redis命令",frontmatter:{title:"Redis命令",date:"2023-03-17T17:01:07.000Z",permalink:"/pages/f706e8/"},regularPath:"/03.Redis/03.redis%E5%91%BD%E4%BB%A4.html",relativePath:"03.Redis/03.redis命令.md",key:"v-78eeb3d8",path:"/pages/f706e8/",headers:[{level:2,title:"keys和scan",slug:"keys和scan",normalizedTitle:"keys和scan",charIndex:2}],headersStr:"keys和scan",content:'# keys和scan\n\nredis的单线程的。keys指令会导致线程阻塞一段时间，直到执行完毕，服务才能恢复。\n\nscan采用渐进式遍历的方式来解决keys命令可能带来的阻塞问题，每次scan命令的时间复杂度是O（1），但是要真正实现keys的功能，需要执行多次scan。命令是一个基于游标的迭代器，每次被调用之后， 都会向用户返回一个新的游标， 用户在下次迭代时需要使用这个新游标作为 SCAN 命令的游标参数， 以此来延续之前的迭代过程。SCAN 返回一个包含两个元素的数组， 第一个元素是用于进行下一次迭代的新游标， 而第二个元素则是一个数组， 这个数组中包含了所有被迭代的元素。如果新游标返回 0 表示迭代已结束。\n\nscan的缺点：在scan的过程中如果有键的变化（增加、删除、修改），遍历过程可能会有以下问题：新增的键可能没有遍历到，遍历出了重复的键等情况，也就是说scan并不能保证完整的遍历出来所有的键。\n\nscan命令用于迭代当前数据库中的数据库键：SCAN cursor [MATCH pattern] [COUNT count]\n\nkeys * //查询所有建\nscan 0 match * count 10 //返回10个元素\n\nredis 127.0.0.1:6379> scan 0   # 使用 0 作为游标，开始新的迭代\n1) "17"                        # 第一次迭代时返回的游标\n2)  1) "key:12"\n    2) "key:8"\n    3) "key:4"\n    4) "key:14"\n    5) "key:16"\n    6) "key:17"\n    7) "key:15"\n    8) "key:10"\n    9) "key:3"\n   10) "key:7"\n   11) "key:1"\nredis 127.0.0.1:6379> scan 17  # 使用的是第一次迭代时返回的游标 17 开始新的迭代\n1) "0"\n2) 1) "key:5"\n   2) "key:18"\n   3) "key:0"\n   4) "key:2"\n   5) "key:19"\n   6) "key:13"\n   7) "key:6"\n   8) "key:9"\n   9) "key:11"\n',normalizedContent:'# keys和scan\n\nredis的单线程的。keys指令会导致线程阻塞一段时间，直到执行完毕，服务才能恢复。\n\nscan采用渐进式遍历的方式来解决keys命令可能带来的阻塞问题，每次scan命令的时间复杂度是o（1），但是要真正实现keys的功能，需要执行多次scan。命令是一个基于游标的迭代器，每次被调用之后， 都会向用户返回一个新的游标， 用户在下次迭代时需要使用这个新游标作为 scan 命令的游标参数， 以此来延续之前的迭代过程。scan 返回一个包含两个元素的数组， 第一个元素是用于进行下一次迭代的新游标， 而第二个元素则是一个数组， 这个数组中包含了所有被迭代的元素。如果新游标返回 0 表示迭代已结束。\n\nscan的缺点：在scan的过程中如果有键的变化（增加、删除、修改），遍历过程可能会有以下问题：新增的键可能没有遍历到，遍历出了重复的键等情况，也就是说scan并不能保证完整的遍历出来所有的键。\n\nscan命令用于迭代当前数据库中的数据库键：scan cursor [match pattern] [count count]\n\nkeys * //查询所有建\nscan 0 match * count 10 //返回10个元素\n\nredis 127.0.0.1:6379> scan 0   # 使用 0 作为游标，开始新的迭代\n1) "17"                        # 第一次迭代时返回的游标\n2)  1) "key:12"\n    2) "key:8"\n    3) "key:4"\n    4) "key:14"\n    5) "key:16"\n    6) "key:17"\n    7) "key:15"\n    8) "key:10"\n    9) "key:3"\n   10) "key:7"\n   11) "key:1"\nredis 127.0.0.1:6379> scan 17  # 使用的是第一次迭代时返回的游标 17 开始新的迭代\n1) "0"\n2) 1) "key:5"\n   2) "key:18"\n   3) "key:0"\n   4) "key:2"\n   5) "key:19"\n   6) "key:13"\n   7) "key:6"\n   8) "key:9"\n   9) "key:11"\n',charsets:{cjk:!0},lastUpdated:"2023/03/17, 19:41:31",lastUpdatedTimestamp:1679053291e3},{title:"Redis数据结构",frontmatter:{title:"Redis数据结构",date:"2023-03-17T20:59:04.000Z",permalink:"/pages/d7a25d/"},regularPath:"/03.Redis/04.redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html",relativePath:"03.Redis/04.redis数据结构.md",key:"v-26fa598d",path:"/pages/d7a25d/",headers:[{level:2,title:"动态字符串",slug:"动态字符串",normalizedTitle:"动态字符串",charIndex:2},{level:2,title:"跳表",slug:"跳表",normalizedTitle:"跳表",charIndex:478},{level:3,title:"skiplist与平衡树、哈希表的比较（待整理）",slug:"skiplist与平衡树、哈希表的比较-待整理",normalizedTitle:"skiplist与平衡树、哈希表的比较（待整理）",charIndex:595},{level:2,title:"字典",slug:"字典",normalizedTitle:"字典",charIndex:1276},{level:2,title:"整数集合",slug:"整数集合",normalizedTitle:"整数集合",charIndex:1283},{level:2,title:"压缩列表",slug:"压缩列表",normalizedTitle:"压缩列表",charIndex:1292},{level:2,title:"对象",slug:"对象",normalizedTitle:"对象",charIndex:1301}],headersStr:"动态字符串 跳表 skiplist与平衡树、哈希表的比较（待整理） 字典 整数集合 压缩列表 对象",content:"# 动态字符串\n\nSDS(simple dynamic string)\n\nstruct sdshdr {\n  // 记录 buf 数组中已使用字节的数量\n  // 等于 SDS 所保存字符串的长度\n  int len;\n  // 记录 buf 数组中未使用字节的数量\n  int free;\n  char buf[];\n}\n\n\n下面是SDS与C字符串的区别。\n\nC 字符串                         SDS\n获取字符串长度的复杂度为 O(N) 。           获取字符串长度的复杂度为 O(1) 。\nAPI 是不安全的，可能会造成缓冲区溢出。         API 是安全的，不会造成缓冲区溢出。\n修改字符串长度 N 次必然需要执行 N 次内存重分配。   修改字符串长度 N 次最多需要执行 N 次内存重分配。\n只能保存文本数据。                     可以保存文本或者二进制数据。\n可以使用所有 <string.h> 库中的函数。      可以使用一部分 <string.h> 库中的函数。\n\n\n# 跳表\n\n跳表可以看成多层链表，它有如下的性质：\n\n * 多层的结构组成，每层是一个有序的链表\n * 最底层的链表包含所有的元素\n * 跳跃表的查找次数近似于层数，时间复杂度为O(logn)，插入、删除也为 O(logn)\n\n\n\n\n# skiplist与平衡树、哈希表的比较（待整理）\n\n * skiplist和各种平衡树（如AVL、红黑树等）的元素是有序排列的，而哈希表不是有序的。因此，在哈希表上只能做单个key的查找，不适宜做范围查找。所谓范围查找，指的是查找那些大小在指定的两个值之间的所有节点。\n * 在做范围查找的时候，平衡树比skiplist操作要复杂。在平衡树上，我们找到指定范围的小值之后，还需要以中序遍历的顺序继续寻找其它不超过大值的节点。如果不对平衡树进行一定的改造，这里的中序遍历并不容易实现。而在skiplist上进行范围查找就非常简单，只需要在找到小值之后，对第1层链表进行若干步的遍历就可以实现。\n * 平衡树的插入和删除操作可能引发子树的调整，逻辑复杂，而skiplist的插入和删除只需要修改相邻节点的指针，操作简单又快速。\n * 从内存占用上来说，skiplist比平衡树更灵活一些。一般来说，平衡树每个节点包含2个指针（分别指向左右子树），而skiplist每个节点包含的指针数目平均为1/(1-p)，具体取决于参数p的大小。如果像Redis里的实现一样，取p=1/4，那么平均每个节点包含1.33个指针，比平衡树更有优势。\n * 查找单个key，skiplist和平衡树的时间复杂度都为O(log n)，大体相当；而哈希表在保持较低的哈希值冲突概率的前提下，查找时间复杂度接近O(1)，性能更高一些。所以我们平常使用的各种Map或dictionary结构，大都是基于哈希表实现的。\n * 从算法实现难度上来比较，skiplist比平衡树要简单得多。\n\n\n# 字典\n\n\n# 整数集合\n\n\n# 压缩列表\n\n\n# 对象\n\nhttp://www.topjavaer.cn/redis/redis-basic/3-data-structure.html",normalizedContent:"# 动态字符串\n\nsds(simple dynamic string)\n\nstruct sdshdr {\n  // 记录 buf 数组中已使用字节的数量\n  // 等于 sds 所保存字符串的长度\n  int len;\n  // 记录 buf 数组中未使用字节的数量\n  int free;\n  char buf[];\n}\n\n\n下面是sds与c字符串的区别。\n\nc 字符串                         sds\n获取字符串长度的复杂度为 o(n) 。           获取字符串长度的复杂度为 o(1) 。\napi 是不安全的，可能会造成缓冲区溢出。         api 是安全的，不会造成缓冲区溢出。\n修改字符串长度 n 次必然需要执行 n 次内存重分配。   修改字符串长度 n 次最多需要执行 n 次内存重分配。\n只能保存文本数据。                     可以保存文本或者二进制数据。\n可以使用所有 <string.h> 库中的函数。      可以使用一部分 <string.h> 库中的函数。\n\n\n# 跳表\n\n跳表可以看成多层链表，它有如下的性质：\n\n * 多层的结构组成，每层是一个有序的链表\n * 最底层的链表包含所有的元素\n * 跳跃表的查找次数近似于层数，时间复杂度为o(logn)，插入、删除也为 o(logn)\n\n\n\n\n# skiplist与平衡树、哈希表的比较（待整理）\n\n * skiplist和各种平衡树（如avl、红黑树等）的元素是有序排列的，而哈希表不是有序的。因此，在哈希表上只能做单个key的查找，不适宜做范围查找。所谓范围查找，指的是查找那些大小在指定的两个值之间的所有节点。\n * 在做范围查找的时候，平衡树比skiplist操作要复杂。在平衡树上，我们找到指定范围的小值之后，还需要以中序遍历的顺序继续寻找其它不超过大值的节点。如果不对平衡树进行一定的改造，这里的中序遍历并不容易实现。而在skiplist上进行范围查找就非常简单，只需要在找到小值之后，对第1层链表进行若干步的遍历就可以实现。\n * 平衡树的插入和删除操作可能引发子树的调整，逻辑复杂，而skiplist的插入和删除只需要修改相邻节点的指针，操作简单又快速。\n * 从内存占用上来说，skiplist比平衡树更灵活一些。一般来说，平衡树每个节点包含2个指针（分别指向左右子树），而skiplist每个节点包含的指针数目平均为1/(1-p)，具体取决于参数p的大小。如果像redis里的实现一样，取p=1/4，那么平均每个节点包含1.33个指针，比平衡树更有优势。\n * 查找单个key，skiplist和平衡树的时间复杂度都为o(log n)，大体相当；而哈希表在保持较低的哈希值冲突概率的前提下，查找时间复杂度接近o(1)，性能更高一些。所以我们平常使用的各种map或dictionary结构，大都是基于哈希表实现的。\n * 从算法实现难度上来比较，skiplist比平衡树要简单得多。\n\n\n# 字典\n\n\n# 整数集合\n\n\n# 压缩列表\n\n\n# 对象\n\nhttp://www.topjavaer.cn/redis/redis-basic/3-data-structure.html",charsets:{cjk:!0},lastUpdated:"2023/03/29, 21:03:43",lastUpdatedTimestamp:1680095023e3},{title:"redis持久化",frontmatter:{title:"redis持久化",date:"2023-03-17T21:11:09.000Z",permalink:"/pages/bc6be1/"},regularPath:"/03.Redis/05.redis%E6%8C%81%E4%B9%85%E5%8C%96.html",relativePath:"03.Redis/05.redis持久化.md",key:"v-f5ed38f8",path:"/pages/bc6be1/",headers:[{level:2,title:"RDB",slug:"rdb",normalizedTitle:"rdb",charIndex:19},{level:2,title:"AOF",slug:"aof",normalizedTitle:"aof",charIndex:26},{level:2,title:"混合持久化",slug:"混合持久化",normalizedTitle:"混合持久化",charIndex:1727},{level:2,title:"RDB和AOF如何选择",slug:"rdb和aof如何选择",normalizedTitle:"rdb和aof如何选择",charIndex:2261}],headersStr:"RDB AOF 混合持久化 RDB和AOF如何选择",content:"Redis 支持两种持久化方式，一种是RDB，一种是AOF。前者会根据指定的规则定时将内存中的数据存储在硬盘上，而后者在每次执行完命令后将命令记录下来。一般将两者结合使用。\n\n\n# RDB\n\nRDB 是 Redis 默认的持久化方案。RDB持久化时会将内存中的数据写入到磁盘中，在指定目录下生成一个dump.rdb文件。Redis 重启会加载dump.rdb文件恢复数据。\n\nRDB持久化的过程（即bgsave，执行SAVE命令除外）：\n\n * fork 创建一个子进程；\n * 父进程继续接收并处理客户端的请求，而子进程开始将内存中的数据写进硬盘的临时文件；\n * 当子进程写完所有数据后会用该临时文件替换旧的RDB文件。\n\nRedis启动时会读取RDB快照文件，将数据从硬盘载入内存。通过RDB方式的持久化，一旦Redis异常退出，就会丢失最近一次持久化以后更改的数据。\n\n触发RDB快照：\n\n 1. 手动触发：\n    * 用户执行SAVE或BGSAVE命令。SAVE命令执行快照的过程会阻塞所有来自客户端的请求，应避免在生产环境使用这个命令。BGSAVE命令可以在后台异步进行快照操作，快照的同时服务器还可以继续响应客户端的请求，因此需要手动执行快照时推荐使用BGSAVE命令；\n 2. 被动触发：\n    * 根据配置规则进行自动快照，如SAVE 300 10,300秒内至少有10个键被修改则进行快照。\n    * 如果从节点执行全量复制操作，主节点自动执行bgsave生成RDB文件并发送给从节点。\n    * 默认情况下执行shutdown命令时，如果没有开启AOF持久化功能则自动执行bgsave。\n    * 执行debug reload命令重新加载Redis时，也会自动触发save操作。\n\n优点：Redis加载RDB恢复数据远远快于AOF的方式。\n\n缺点：\n\n 1. RDB方式数据没办法做到实时持久化/秒级持久化。因为bgsave每次运行都要执行fork操作创建子进程，属于重量级操作，频繁执行成本过高。\n 2. 存在老版本Redis服务和新版本RDB格式兼容性问题。RDB文件使用特定二进制格式保存，Redis版本演进过程中有多个格式的RDB版本，存在老版本Redis服务无法兼容新版RDB格式的问题。\n\n\n# AOF\n\nAOF（append only file）持久化：以独立日志的方式记录每次写命令，Redis重启时会重新执行AOF文件中的命令达到恢复数据的目的。AOF的主要作用是解决了数据持久化的实时性，目前已经是Redis持久化的主流方式。\n\n默认情况下Redis没有开启AOF方式的持久化，可以通过appendonly参数启用appendonly yes。开启AOF方式持久化后每执行一条写命令，Redis就会将该命令写进aof_buf缓冲区，AOF缓冲区根据对应的策略向硬盘做同步操作。\n\n默认情况下系统每30秒会执行一次同步操作。为了防止缓冲区数据丢失，可以在Redis写入AOF文件后主动要求系统将缓冲区数据同步到硬盘上。可以通过appendfsync参数设置同步的时机。\n\nappendfsync always //每次写入aof文件都会执行同步，最安全最慢，只能支持几百TPS写入，不建议配置\nappendfsync everysec  //保证了性能也保证了安全，建议配置\nappendfsync no //由操作系统决定何时进行同步操作\n\n\n重写机制：\n\n随着命令不断写入AOF，文件会越来越大，为了解决这个问题，Redis引入AOF重写机制压缩文件体积。AOF文件重写是把Redis进程内的数据转化为写命令同步到新AOF文件的过程。\n\n优点：\n\n 1. AOF可以更好的保护数据不丢失，一般AOF会每秒去执行一次fsync操作，如果redis进程挂掉，最多丢失1秒的数据。\n 2. AOF以appen-only的模式写入，所以没有任何磁盘寻址的开销，写入性能非常高。\n\n缺点\n\n 1. 对于同一份文件AOF文件比RDB数据快照要大。\n 2. 不适合写多读少场景。\n 3. 数据恢复比较慢。\n\n\n# 混合持久化\n\n混合持久化并不是一种全新的持久化方式，而是对已有方式的优化。混合持久化只发生于 AOF 重写过程。使用了混合持久化，重写后的新 AOF 文件前半段是 RDB 格式的全量数据，后半段是 AOF 格式的增量数据。\n\n开启：混合持久化的配置参数为 aof-use-rdb-preamble，配置为 yes 时开启混合持久化，在 redis 4 刚引入时，默认是关闭混合持久化的，但是在 redis 5 中默认已经打开了。\n\n关闭：使用 aof-use-rdb-preamble no 配置即可关闭混合持久化。\n\n混合持久化本质是通过 AOF 后台重写（bgrewriteaof 命令）完成的，不同的是当开启混合持久化时，fork 出的子进程先将当前全量数据以 RDB 方式写入新的 AOF 文件，然后再将 AOF 重写缓冲区（aof_rewrite_buf_blocks）的增量命令以 AOF 方式写入到文件，写入完成后通知主进程将新的含有 RDB 格式和 AOF 格式的 AOF 文件替换旧的的 AOF 文件。\n\n优点：结合 RDB 和 AOF 的优点, 更快的重写和恢复。\n\n缺点：AOF 文件里面的 RDB 部分不再是 AOF 格式，可读性差。\n\n\n# RDB和AOF如何选择\n\n * 仅使用RDB这样会丢失很多数据。\n * 仅使用AOF，因为这一会有两个问题，第一通过AOF恢复速度慢；第二RDB每次简单粗暴生成数据快照，更加安全健壮。\n * 一般来说， 如果想尽量保证数据安全性， 你应该同时使用 RDB 和 AOF 持久化功能，同时可以开启混合持久化。\n * 综合AOF和RDB两种持久化方式，用AOF来保证数据不丢失，作为恢复数据的第一选择；用RDB来做不同程度的冷备，在AOF文件都丢失或损坏不可用的时候，可以使用RDB进行快速的数据恢复。\n\n",normalizedContent:"redis 支持两种持久化方式，一种是rdb，一种是aof。前者会根据指定的规则定时将内存中的数据存储在硬盘上，而后者在每次执行完命令后将命令记录下来。一般将两者结合使用。\n\n\n# rdb\n\nrdb 是 redis 默认的持久化方案。rdb持久化时会将内存中的数据写入到磁盘中，在指定目录下生成一个dump.rdb文件。redis 重启会加载dump.rdb文件恢复数据。\n\nrdb持久化的过程（即bgsave，执行save命令除外）：\n\n * fork 创建一个子进程；\n * 父进程继续接收并处理客户端的请求，而子进程开始将内存中的数据写进硬盘的临时文件；\n * 当子进程写完所有数据后会用该临时文件替换旧的rdb文件。\n\nredis启动时会读取rdb快照文件，将数据从硬盘载入内存。通过rdb方式的持久化，一旦redis异常退出，就会丢失最近一次持久化以后更改的数据。\n\n触发rdb快照：\n\n 1. 手动触发：\n    * 用户执行save或bgsave命令。save命令执行快照的过程会阻塞所有来自客户端的请求，应避免在生产环境使用这个命令。bgsave命令可以在后台异步进行快照操作，快照的同时服务器还可以继续响应客户端的请求，因此需要手动执行快照时推荐使用bgsave命令；\n 2. 被动触发：\n    * 根据配置规则进行自动快照，如save 300 10,300秒内至少有10个键被修改则进行快照。\n    * 如果从节点执行全量复制操作，主节点自动执行bgsave生成rdb文件并发送给从节点。\n    * 默认情况下执行shutdown命令时，如果没有开启aof持久化功能则自动执行bgsave。\n    * 执行debug reload命令重新加载redis时，也会自动触发save操作。\n\n优点：redis加载rdb恢复数据远远快于aof的方式。\n\n缺点：\n\n 1. rdb方式数据没办法做到实时持久化/秒级持久化。因为bgsave每次运行都要执行fork操作创建子进程，属于重量级操作，频繁执行成本过高。\n 2. 存在老版本redis服务和新版本rdb格式兼容性问题。rdb文件使用特定二进制格式保存，redis版本演进过程中有多个格式的rdb版本，存在老版本redis服务无法兼容新版rdb格式的问题。\n\n\n# aof\n\naof（append only file）持久化：以独立日志的方式记录每次写命令，redis重启时会重新执行aof文件中的命令达到恢复数据的目的。aof的主要作用是解决了数据持久化的实时性，目前已经是redis持久化的主流方式。\n\n默认情况下redis没有开启aof方式的持久化，可以通过appendonly参数启用appendonly yes。开启aof方式持久化后每执行一条写命令，redis就会将该命令写进aof_buf缓冲区，aof缓冲区根据对应的策略向硬盘做同步操作。\n\n默认情况下系统每30秒会执行一次同步操作。为了防止缓冲区数据丢失，可以在redis写入aof文件后主动要求系统将缓冲区数据同步到硬盘上。可以通过appendfsync参数设置同步的时机。\n\nappendfsync always //每次写入aof文件都会执行同步，最安全最慢，只能支持几百tps写入，不建议配置\nappendfsync everysec  //保证了性能也保证了安全，建议配置\nappendfsync no //由操作系统决定何时进行同步操作\n\n\n重写机制：\n\n随着命令不断写入aof，文件会越来越大，为了解决这个问题，redis引入aof重写机制压缩文件体积。aof文件重写是把redis进程内的数据转化为写命令同步到新aof文件的过程。\n\n优点：\n\n 1. aof可以更好的保护数据不丢失，一般aof会每秒去执行一次fsync操作，如果redis进程挂掉，最多丢失1秒的数据。\n 2. aof以appen-only的模式写入，所以没有任何磁盘寻址的开销，写入性能非常高。\n\n缺点\n\n 1. 对于同一份文件aof文件比rdb数据快照要大。\n 2. 不适合写多读少场景。\n 3. 数据恢复比较慢。\n\n\n# 混合持久化\n\n混合持久化并不是一种全新的持久化方式，而是对已有方式的优化。混合持久化只发生于 aof 重写过程。使用了混合持久化，重写后的新 aof 文件前半段是 rdb 格式的全量数据，后半段是 aof 格式的增量数据。\n\n开启：混合持久化的配置参数为 aof-use-rdb-preamble，配置为 yes 时开启混合持久化，在 redis 4 刚引入时，默认是关闭混合持久化的，但是在 redis 5 中默认已经打开了。\n\n关闭：使用 aof-use-rdb-preamble no 配置即可关闭混合持久化。\n\n混合持久化本质是通过 aof 后台重写（bgrewriteaof 命令）完成的，不同的是当开启混合持久化时，fork 出的子进程先将当前全量数据以 rdb 方式写入新的 aof 文件，然后再将 aof 重写缓冲区（aof_rewrite_buf_blocks）的增量命令以 aof 方式写入到文件，写入完成后通知主进程将新的含有 rdb 格式和 aof 格式的 aof 文件替换旧的的 aof 文件。\n\n优点：结合 rdb 和 aof 的优点, 更快的重写和恢复。\n\n缺点：aof 文件里面的 rdb 部分不再是 aof 格式，可读性差。\n\n\n# rdb和aof如何选择\n\n * 仅使用rdb这样会丢失很多数据。\n * 仅使用aof，因为这一会有两个问题，第一通过aof恢复速度慢；第二rdb每次简单粗暴生成数据快照，更加安全健壮。\n * 一般来说， 如果想尽量保证数据安全性， 你应该同时使用 rdb 和 aof 持久化功能，同时可以开启混合持久化。\n * 综合aof和rdb两种持久化方式，用aof来保证数据不丢失，作为恢复数据的第一选择；用rdb来做不同程度的冷备，在aof文件都丢失或损坏不可用的时候，可以使用rdb进行快速的数据恢复。\n\n",charsets:{cjk:!0},lastUpdated:"2023/03/29, 21:03:43",lastUpdatedTimestamp:1680095023e3},{title:"Redis高可用",frontmatter:{title:"Redis高可用",date:"2023-03-17T21:24:51.000Z",permalink:"/pages/effbd9/"},regularPath:"/03.Redis/06.redis%E9%AB%98%E5%8F%AF%E7%94%A8.html",relativePath:"03.Redis/06.redis高可用.md",key:"v-120df2fa",path:"/pages/effbd9/",headers:[{level:2,title:"主从模式",slug:"主从模式",normalizedTitle:"主从模式",charIndex:2},{level:2,title:"哨兵模式",slug:"哨兵模式",normalizedTitle:"哨兵模式",charIndex:1398},{level:2,title:"集群模式",slug:"集群模式",normalizedTitle:"集群模式",charIndex:2497},{level:2,title:"总结",slug:"总结",normalizedTitle:"总结",charIndex:4198},{level:2,title:"大厂的 redis 集群方案",slug:"大厂的-redis-集群方案",normalizedTitle:"大厂的 redis 集群方案",charIndex:4506}],headersStr:"主从模式 哨兵模式 集群模式 总结 大厂的 redis 集群方案",content:"# 主从模式\n\n一般，系统的高可用都是通过部署多台机器实现的。redis 为了避免单点故障，也需要部署多台机器。\n\n因为部署了多台机器，所以就会涉及到不同机器的的数据同步问题。\n\n为此，redis 提供了 Redis 提供了复制(replication)功能，当一台 redis 数据库中的数据发生了变化，这个变化会被自动的同步到其他的 redis 机器上去。\n\nredis 多机器部署时，这些机器节点会被分成两类，一类是主节点（master 节点），一类是从节点（slave 节点）。一般主节点可以进行读、写操作，而从节点只能进行读操作。一个主节点可以有多个从节点，但是一个从节点会只会有一个主节点，也就是所谓的一主多从结构。\n\n主节点正常配置即可。\n\n从节点配置：\n\n配置主节点的ip和端口\nslaveof 192.168.1.10 6379\n# 从redis2.6开始，从节点默认是只读的\nslave-read-only yes\n# 假设主节点有登录密码，是123456\nmasterauth 123456\n\n\n * 也可以不配置上面的文件，使用 redis-server 命令，在启动从节点时，通过参数--slaveof 指定主节点是谁./redis-server --slaveof 192.168.1.10 6379\n * 也可以不配上面的文件，正常启动 redis 机器，然后通过redis-cli的命令行执行slaveof 192.168.1.10 6379指定主节点是谁。\n\n系统运行时，如果 master 挂掉了，可以在一个从库（如 slave1）上手动执行命令slaveof no one，将 slave1 变成新的 master；在 slave2 和 slave3 上分别执行slaveof 192.168.1.11 6379 将这两个机器的主节点指向的这个新的 master；同时，挂掉的原 master 启动后作为新的 slave 也指向新的 master 上。\n\n执行命令slaveof no one命令，可以关闭从服务器的复制功能。同时原来同步的所得的数据集都不会被丢弃。\n\n主从复制过程：\n\n * 从数据库连接主数据库，发送 SYNC 命令;\n\n * 主数据库接收到 SYNC 命令后，可以执行 BGSAVE 命令生成 RDB 文件并使用缓冲区记录此后执行的所有写命令;\n\n * 主数据库 BGSAVE 执行完后，向所有从数据库发送快照文件，并在发送期间继续记录被执行的写命令;\n\n * 从数据库收到快照文件后丢弃所有旧数据，载入收到的快照;\n\n * 主数据库快照发送完毕后开始向从数据库发送缓冲区中的写命令;\n\n * 从数据库完成对快照的载入，开始接受命令请求，并执行来自主数据库缓冲区的写命令;(从数据库初始化完成)\n\n * 主数据库每执行一个写命令就会向从数据库发送相同的写命令，从数据库接收并执行收到的写命令(从数据库初始化完成后的操作)\n\n * 出现断开重连后，2.8 之后的版本会将断线期间的命令传给从数据库，增量复制。\n\n * 主从刚刚连接的时候，进行全量同步;全同步结束后，进行增量同步。当然，如果有需要，slave 在任何时候都可以发起全量同步。Redis 的策略是，无论如何，首先会尝试进行增量同步，如不成功，要求从机进行全量同步。\n\n\n# 哨兵模式\n\nsentinel\n\n主从模式下，当主服务器宕机后，需要手动把一台从服务器切换为主服务器，这就需要人工干预，费事费力，还会造成一段时间内服务不可用。这种方式并不推荐，实际生产中，我们优先考虑哨兵模式。这种模式下，master 宕机，哨兵会自动选举 master 并将其他的 slave 指向新的 master。\n\n在主从模式下，redis 同时提供了哨兵命令redis-sentinel，哨兵是一个独立的进程，作为进程，它会独立运行。其原理是哨兵进程向所有的 redis 机器发送ping命令，等待 Redis 服务器响应，从而监控运行的多个 Redis 实例。\n\n哨兵可以有多个，一般为了便于决策选举，使用奇数个哨兵。哨兵可以和 redis 机器部署在一起，也可以部署在其他的机器上。多个哨兵构成一个哨兵集群，哨兵直接也会相互通信，检查哨兵是否正常运行，同时发现 master 宕机哨兵之间会进行决策选举新的 master。\n\n哨兵配置文件：\n\n# 禁止保护模式\nprotected-mode no\n# 配置监听的主服务器，这里sentinel monitor代表监控，mymaster代表服务器的名称，可以自定义，\n#192.168.1.10代表监控的主服务器，6379代表端口，2代表只有两个或两个以上的哨兵认为主服务器不可用的时候，才会进行failover操作。\nsentinel monitor mymaster 192.168.1.10 6379 2\n# sentinel author-pass定义服务的密码，mymaster是服务名称，123456是Redis服务器密码\nsentinel auth-pass mymaster 123456\n\n\n首先启动主节点，然后一台一台启动从节点。\n\nredis 集群启动完成后，分别启动哨兵集群所在机器的三个哨兵，使用redis-sentinel /path/to/sentinel.conf命令。\n\n假设 master 宕机，sentinel 1 先检测到这个结果，系统并不会马上进行 failover(故障转移)选出新的 master，仅仅是 sentinel 1 主观的认为 master 不可用，这个现象成为主观下线。当后面的哨兵也检测到主服务器不可用，并且数量达到一定值时，那么哨兵之间就会进行一次投票，投票的结果由 sentinel 1 发起，进行 failover 操作。切换成功后，就会通过发布订阅模式，让各个哨兵把自己监控的从服务器实现切换主机，这个过程称为客观下线。这样对于客户端而言，一切都是透明的。\n\n\n# 集群模式\n\nRedis cluster\n\nredis 集群时 3.0 版本才出现的，出现的比较晚，在集群模式出现之前，很多公司都做了自己的 redis 集群了。这些自研的 redis 集群的实现方式有多种，比如在 redis 的 jedis 客户端 jar 包就是实现了一致性 hash 算法（客户端模式），或者在 redis 集群前面加上一层前置代理如 Twemproxy 也实现了 hash 一致性算法（代理模式）。Twemproxy，是 Twitter 开源出来的 Redis 和 Memcached 代理，使用这种代理模式搭建的集群，我们的客户端连接只需要连接代理服务器即可，不用连接代理后面具体的 redis 机器。Twemproxy 具体使用哪一种 hash 算法也是可以通过配置文件指定的。\n\nRedis 的集群模式本身没有使用一致性 hash 算法，而是使用 slots 插槽。\n\nRedis 的哨兵模式基本已经可以实现高可用，读写分离 ，但是在这种模式下每台 Redis 服务器都存储相同的数据，很浪费内存，所以在 redis3.0 上加入了 Cluster 集群模式，实现了 Redis 的分布式存储，对数据进行分片，也就是说每台 Redis 节点上存储不同的内容；\n\nredis.config:\n\n# 开启redis的集群模式\ncluster-enabled yes\n# 配置集群模式下的配置文件名称和位置,redis-cluster.conf这个文件是集群启动后自动生成的，不需要手动配置。\ncluster-config-file redis-cluster.conf\n\n\n6 个 Redis 服务分别启动成功之后，这时虽然配置了集群开启，但是这六台机器还是独立的。使用集群管理命令将这 6 台机器添加到一个集群中。\n\n借助 redis-tri.rb 工具可以快速的部署集群。\n\n只需要执行redis-trib.rb create --replicas 1 192.168.1.11:6379 192.168.1.21:6379 192.168.1.12:6379 192.168.1.22:6379 192.168.1.13:6379 192.168.1.23:6379就可以成功创建集群。\n\n运行机制：\n\n在 Redis 的每一个节点上，都有这么两个东西，一个是插槽（slot），它的的取值范围是：0-16383，可以从上面redis-trib.rb执行的结果看到这 16383 个 slot 在三个 master 上的分布。还有一个就是 cluster，可以理解为是一个集群管理的插件，类似的哨兵。\n\n当我们的存取的 Key 到达的时候，Redis 会根据 crc16 的算法对计算后得出一个结果，然后把结果和 16384 求余数，这样每个 key 都会对应一个编号在 0-16383 之间的哈希槽，通过这个值，去找到对应的插槽所对应的节点，然后直接自动跳转到这个对应的节点上进行存取操作。\n\n当数据写入到对应的 master 节点后，这个数据会同步给这个 master 对应的所有 slave 节点。\n\n为了保证高可用，redis-cluster 集群引入了主从模式，一个主节点对应一个或者多个从节点。当其它主节点 ping 主节点 master 1 时，如果半数以上的主节点与 master 1 通信超时，那么认为 master 1 宕机了，就会启用 master 1 的从节点 slave 1，将 slave 1 变成主节点继续提供服务。\n\n如果 master 1 和它的从节点 slave 1 都宕机了，整个集群就会进入 fail 状态，因为集群的 slot 映射不完整。如果集群超过半数以上的 master 挂掉，无论是否有 slave，集群都会进入 fail 状态。\n\nredis-cluster 采用去中心化的思想，没有中心节点的说法，客户端与 Redis 节点直连，不需要中间代理层，客户端不需要连接集群所有节点，连接集群中任何一个可用节点即可。\n\n\n# 总结\n\n主从模式：master 节点挂掉后，需要手动指定新的 master，可用性不高，基本不用。\n\n哨兵模式：master 节点挂掉后，哨兵进程会主动选举新的 master，可用性高，但是每个节点存储的数据是一样的，浪费内存空间。数据量不是很多，集群规模不是很大，需要自动容错容灾的时候使用。\n\n集群模式：数据量比较大，QPS 要求较高的时候使用。 Redis Cluster 是 Redis 3.0 以后才正式推出，时间较晚，目前能证明在大规模生产环境下成功的案例还不是很多，需要时间检验。\n\nhttps://xie.infoq.cn/article/6c3500c66c3cdee3d72b88780\n\n\n# 大厂的 redis 集群方案\n\n 1. 类 codis 架构\n 2. 基于官方 redis cluster\n\nhttps://www.cnblogs.com/me115/p/9043420.html\n\nhttps://zhuanlan.zhihu.com/p/517257460",normalizedContent:"# 主从模式\n\n一般，系统的高可用都是通过部署多台机器实现的。redis 为了避免单点故障，也需要部署多台机器。\n\n因为部署了多台机器，所以就会涉及到不同机器的的数据同步问题。\n\n为此，redis 提供了 redis 提供了复制(replication)功能，当一台 redis 数据库中的数据发生了变化，这个变化会被自动的同步到其他的 redis 机器上去。\n\nredis 多机器部署时，这些机器节点会被分成两类，一类是主节点（master 节点），一类是从节点（slave 节点）。一般主节点可以进行读、写操作，而从节点只能进行读操作。一个主节点可以有多个从节点，但是一个从节点会只会有一个主节点，也就是所谓的一主多从结构。\n\n主节点正常配置即可。\n\n从节点配置：\n\n配置主节点的ip和端口\nslaveof 192.168.1.10 6379\n# 从redis2.6开始，从节点默认是只读的\nslave-read-only yes\n# 假设主节点有登录密码，是123456\nmasterauth 123456\n\n\n * 也可以不配置上面的文件，使用 redis-server 命令，在启动从节点时，通过参数--slaveof 指定主节点是谁./redis-server --slaveof 192.168.1.10 6379\n * 也可以不配上面的文件，正常启动 redis 机器，然后通过redis-cli的命令行执行slaveof 192.168.1.10 6379指定主节点是谁。\n\n系统运行时，如果 master 挂掉了，可以在一个从库（如 slave1）上手动执行命令slaveof no one，将 slave1 变成新的 master；在 slave2 和 slave3 上分别执行slaveof 192.168.1.11 6379 将这两个机器的主节点指向的这个新的 master；同时，挂掉的原 master 启动后作为新的 slave 也指向新的 master 上。\n\n执行命令slaveof no one命令，可以关闭从服务器的复制功能。同时原来同步的所得的数据集都不会被丢弃。\n\n主从复制过程：\n\n * 从数据库连接主数据库，发送 sync 命令;\n\n * 主数据库接收到 sync 命令后，可以执行 bgsave 命令生成 rdb 文件并使用缓冲区记录此后执行的所有写命令;\n\n * 主数据库 bgsave 执行完后，向所有从数据库发送快照文件，并在发送期间继续记录被执行的写命令;\n\n * 从数据库收到快照文件后丢弃所有旧数据，载入收到的快照;\n\n * 主数据库快照发送完毕后开始向从数据库发送缓冲区中的写命令;\n\n * 从数据库完成对快照的载入，开始接受命令请求，并执行来自主数据库缓冲区的写命令;(从数据库初始化完成)\n\n * 主数据库每执行一个写命令就会向从数据库发送相同的写命令，从数据库接收并执行收到的写命令(从数据库初始化完成后的操作)\n\n * 出现断开重连后，2.8 之后的版本会将断线期间的命令传给从数据库，增量复制。\n\n * 主从刚刚连接的时候，进行全量同步;全同步结束后，进行增量同步。当然，如果有需要，slave 在任何时候都可以发起全量同步。redis 的策略是，无论如何，首先会尝试进行增量同步，如不成功，要求从机进行全量同步。\n\n\n# 哨兵模式\n\nsentinel\n\n主从模式下，当主服务器宕机后，需要手动把一台从服务器切换为主服务器，这就需要人工干预，费事费力，还会造成一段时间内服务不可用。这种方式并不推荐，实际生产中，我们优先考虑哨兵模式。这种模式下，master 宕机，哨兵会自动选举 master 并将其他的 slave 指向新的 master。\n\n在主从模式下，redis 同时提供了哨兵命令redis-sentinel，哨兵是一个独立的进程，作为进程，它会独立运行。其原理是哨兵进程向所有的 redis 机器发送ping命令，等待 redis 服务器响应，从而监控运行的多个 redis 实例。\n\n哨兵可以有多个，一般为了便于决策选举，使用奇数个哨兵。哨兵可以和 redis 机器部署在一起，也可以部署在其他的机器上。多个哨兵构成一个哨兵集群，哨兵直接也会相互通信，检查哨兵是否正常运行，同时发现 master 宕机哨兵之间会进行决策选举新的 master。\n\n哨兵配置文件：\n\n# 禁止保护模式\nprotected-mode no\n# 配置监听的主服务器，这里sentinel monitor代表监控，mymaster代表服务器的名称，可以自定义，\n#192.168.1.10代表监控的主服务器，6379代表端口，2代表只有两个或两个以上的哨兵认为主服务器不可用的时候，才会进行failover操作。\nsentinel monitor mymaster 192.168.1.10 6379 2\n# sentinel author-pass定义服务的密码，mymaster是服务名称，123456是redis服务器密码\nsentinel auth-pass mymaster 123456\n\n\n首先启动主节点，然后一台一台启动从节点。\n\nredis 集群启动完成后，分别启动哨兵集群所在机器的三个哨兵，使用redis-sentinel /path/to/sentinel.conf命令。\n\n假设 master 宕机，sentinel 1 先检测到这个结果，系统并不会马上进行 failover(故障转移)选出新的 master，仅仅是 sentinel 1 主观的认为 master 不可用，这个现象成为主观下线。当后面的哨兵也检测到主服务器不可用，并且数量达到一定值时，那么哨兵之间就会进行一次投票，投票的结果由 sentinel 1 发起，进行 failover 操作。切换成功后，就会通过发布订阅模式，让各个哨兵把自己监控的从服务器实现切换主机，这个过程称为客观下线。这样对于客户端而言，一切都是透明的。\n\n\n# 集群模式\n\nredis cluster\n\nredis 集群时 3.0 版本才出现的，出现的比较晚，在集群模式出现之前，很多公司都做了自己的 redis 集群了。这些自研的 redis 集群的实现方式有多种，比如在 redis 的 jedis 客户端 jar 包就是实现了一致性 hash 算法（客户端模式），或者在 redis 集群前面加上一层前置代理如 twemproxy 也实现了 hash 一致性算法（代理模式）。twemproxy，是 twitter 开源出来的 redis 和 memcached 代理，使用这种代理模式搭建的集群，我们的客户端连接只需要连接代理服务器即可，不用连接代理后面具体的 redis 机器。twemproxy 具体使用哪一种 hash 算法也是可以通过配置文件指定的。\n\nredis 的集群模式本身没有使用一致性 hash 算法，而是使用 slots 插槽。\n\nredis 的哨兵模式基本已经可以实现高可用，读写分离 ，但是在这种模式下每台 redis 服务器都存储相同的数据，很浪费内存，所以在 redis3.0 上加入了 cluster 集群模式，实现了 redis 的分布式存储，对数据进行分片，也就是说每台 redis 节点上存储不同的内容；\n\nredis.config:\n\n# 开启redis的集群模式\ncluster-enabled yes\n# 配置集群模式下的配置文件名称和位置,redis-cluster.conf这个文件是集群启动后自动生成的，不需要手动配置。\ncluster-config-file redis-cluster.conf\n\n\n6 个 redis 服务分别启动成功之后，这时虽然配置了集群开启，但是这六台机器还是独立的。使用集群管理命令将这 6 台机器添加到一个集群中。\n\n借助 redis-tri.rb 工具可以快速的部署集群。\n\n只需要执行redis-trib.rb create --replicas 1 192.168.1.11:6379 192.168.1.21:6379 192.168.1.12:6379 192.168.1.22:6379 192.168.1.13:6379 192.168.1.23:6379就可以成功创建集群。\n\n运行机制：\n\n在 redis 的每一个节点上，都有这么两个东西，一个是插槽（slot），它的的取值范围是：0-16383，可以从上面redis-trib.rb执行的结果看到这 16383 个 slot 在三个 master 上的分布。还有一个就是 cluster，可以理解为是一个集群管理的插件，类似的哨兵。\n\n当我们的存取的 key 到达的时候，redis 会根据 crc16 的算法对计算后得出一个结果，然后把结果和 16384 求余数，这样每个 key 都会对应一个编号在 0-16383 之间的哈希槽，通过这个值，去找到对应的插槽所对应的节点，然后直接自动跳转到这个对应的节点上进行存取操作。\n\n当数据写入到对应的 master 节点后，这个数据会同步给这个 master 对应的所有 slave 节点。\n\n为了保证高可用，redis-cluster 集群引入了主从模式，一个主节点对应一个或者多个从节点。当其它主节点 ping 主节点 master 1 时，如果半数以上的主节点与 master 1 通信超时，那么认为 master 1 宕机了，就会启用 master 1 的从节点 slave 1，将 slave 1 变成主节点继续提供服务。\n\n如果 master 1 和它的从节点 slave 1 都宕机了，整个集群就会进入 fail 状态，因为集群的 slot 映射不完整。如果集群超过半数以上的 master 挂掉，无论是否有 slave，集群都会进入 fail 状态。\n\nredis-cluster 采用去中心化的思想，没有中心节点的说法，客户端与 redis 节点直连，不需要中间代理层，客户端不需要连接集群所有节点，连接集群中任何一个可用节点即可。\n\n\n# 总结\n\n主从模式：master 节点挂掉后，需要手动指定新的 master，可用性不高，基本不用。\n\n哨兵模式：master 节点挂掉后，哨兵进程会主动选举新的 master，可用性高，但是每个节点存储的数据是一样的，浪费内存空间。数据量不是很多，集群规模不是很大，需要自动容错容灾的时候使用。\n\n集群模式：数据量比较大，qps 要求较高的时候使用。 redis cluster 是 redis 3.0 以后才正式推出，时间较晚，目前能证明在大规模生产环境下成功的案例还不是很多，需要时间检验。\n\nhttps://xie.infoq.cn/article/6c3500c66c3cdee3d72b88780\n\n\n# 大厂的 redis 集群方案\n\n 1. 类 codis 架构\n 2. 基于官方 redis cluster\n\nhttps://www.cnblogs.com/me115/p/9043420.html\n\nhttps://zhuanlan.zhihu.com/p/517257460",charsets:{cjk:!0},lastUpdated:"2023/03/29, 21:03:43",lastUpdatedTimestamp:1680095023e3},{title:"Redis删除策略及内存淘汰机制",frontmatter:{title:"Redis删除策略及内存淘汰机制",date:"2023-03-17T21:52:31.000Z",permalink:"/pages/428106/"},regularPath:"/03.Redis/07.redis%E5%88%A0%E9%99%A4%E7%AD%96%E7%95%A5%E5%8F%8A%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E6%9C%BA%E5%88%B6.html",relativePath:"03.Redis/07.redis删除策略及内存淘汰机制.md",key:"v-0082735a",path:"/pages/428106/",headersStr:null,content:"Redis 采用的是 定期删除+惰性/懒汉式删除\n\n 1. 惰性删除 ：只会在取出 key 的时候才对数据进行过期检查。这样对 CPU 最友好，但是可能会造成太多过期 key 没有被删除。\n 2. 定期删除 ： 每隔一段时间抽取一批 key 执行删除过期 key 操作。并且，Redis 底层会通过限制删除操作执行的时长和频率来减少删除操作对 CPU 时间的影响。\n\n但是，仅仅通过给 key 设置过期时间还是有问题的。因为还是可能存在定期删除和惰性删除漏掉了很多过期 key 的情况。这样就导致大量过期 key 堆积在内存里，然后就 Out of memory 了。\n\n怎么解决这个问题呢？答案就是：Redis 内存淘汰机制。\n\nRedis 提供 6 种数据淘汰策略：\n\n 1. volatile-lru（least recently used）：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰\n 2. volatile-ttl：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰\n 3. volatile-random：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰\n 4. allkeys-lru（least recently used）：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的 key（这个是最常用的）\n 5. allkeys-random：从数据集（server.db[i].dict）中任意选择数据淘汰\n 6. no-eviction（默认策略）：禁止驱逐数据，也就是说当内存不足以容纳新写入数据时，新写入操作会报错。这个应该没人使用吧！\n\n4.0 版本后增加以下两种：\n\n 1. volatile-lfu（least frequently used）：从已设置过期时间的数据集（server.db[i].expires）中挑选最不经常使用的数据淘汰\n 2. allkeys-lfu（least frequently used）：当内存不足以容纳新写入数据时，在键空间中，移除最不经常使用的 key",normalizedContent:"redis 采用的是 定期删除+惰性/懒汉式删除\n\n 1. 惰性删除 ：只会在取出 key 的时候才对数据进行过期检查。这样对 cpu 最友好，但是可能会造成太多过期 key 没有被删除。\n 2. 定期删除 ： 每隔一段时间抽取一批 key 执行删除过期 key 操作。并且，redis 底层会通过限制删除操作执行的时长和频率来减少删除操作对 cpu 时间的影响。\n\n但是，仅仅通过给 key 设置过期时间还是有问题的。因为还是可能存在定期删除和惰性删除漏掉了很多过期 key 的情况。这样就导致大量过期 key 堆积在内存里，然后就 out of memory 了。\n\n怎么解决这个问题呢？答案就是：redis 内存淘汰机制。\n\nredis 提供 6 种数据淘汰策略：\n\n 1. volatile-lru（least recently used）：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰\n 2. volatile-ttl：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰\n 3. volatile-random：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰\n 4. allkeys-lru（least recently used）：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的 key（这个是最常用的）\n 5. allkeys-random：从数据集（server.db[i].dict）中任意选择数据淘汰\n 6. no-eviction（默认策略）：禁止驱逐数据，也就是说当内存不足以容纳新写入数据时，新写入操作会报错。这个应该没人使用吧！\n\n4.0 版本后增加以下两种：\n\n 1. volatile-lfu（least frequently used）：从已设置过期时间的数据集（server.db[i].expires）中挑选最不经常使用的数据淘汰\n 2. allkeys-lfu（least frequently used）：当内存不足以容纳新写入数据时，在键空间中，移除最不经常使用的 key",charsets:{cjk:!0},lastUpdated:"2023/03/29, 21:03:43",lastUpdatedTimestamp:1680095023e3},{title:"缓存常见问题",frontmatter:{title:"缓存常见问题",date:"2023-03-17T21:54:33.000Z",permalink:"/pages/87b330/"},regularPath:"/03.Redis/08.%E7%BC%93%E5%AD%98%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98.html",relativePath:"03.Redis/08.缓存常见问题.md",key:"v-669c40a0",path:"/pages/87b330/",headers:[{level:2,title:"缓存穿透",slug:"缓存穿透",normalizedTitle:"缓存穿透",charIndex:2},{level:2,title:"缓存雪崩",slug:"缓存雪崩",normalizedTitle:"缓存雪崩",charIndex:381},{level:2,title:"缓存击穿",slug:"缓存击穿",normalizedTitle:"缓存击穿",charIndex:929},{level:2,title:"缓存预热",slug:"缓存预热",normalizedTitle:"缓存预热",charIndex:1248},{level:2,title:"缓存降级",slug:"缓存降级",normalizedTitle:"缓存降级",charIndex:1415}],headersStr:"缓存穿透 缓存雪崩 缓存击穿 缓存预热 缓存降级",content:"# 缓存穿透\n\n缓存穿透是指查询一个不存在的数据，由于缓存是不命中时被动写的，如果从DB查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到DB去查询，失去了缓存的意义。在流量大时，可能DB就挂掉了。\n\n解决方案：\n\n 1. 缓存空值，不会查数据库。\n 2. 采用布隆过滤器，将所有可能存在的数据哈希到一个足够大的bitmap中，查询不存在的数据会被这个bitmap拦截掉，从而避免了对DB的查询压力。\n\n布隆过滤器的原理：当一个元素被加入集合时，通过K个哈希函数将这个元素映射成一个位数组中的K个点，把它们置为1。查询时，将元素通过哈希函数映射之后会得到k个点，如果这些点有任何一个0，则被检元素一定不在，直接返回；如果都是1，则查询元素很可能存在，就会去查询Redis和数据库。\n\n布隆过滤器一般用于在大数据量的集合中判定某元素是否存在。\n\n\n# 缓存雪崩\n\n缓存雪崩指：缓存在同一时间大面积的失效，后面的请求都直接落到了数据库上，造成数据库短时间内承受大量请求。\n\n存在两种可能：\n\n * 系统缓存模块出问题，宕机不可用。\n * 大量访问数据（热点缓存）在某一时刻大面积失效\n\n解决方案：\n\n针对 Redis 服务不可用的情况：\n\n 1. 采用 Redis 集群，避免单机出现问题整个缓存服务都没办法使用。保证高可用，redis sentinel、redis cluster。\n 2. 限流，避免同时处理大量的请求。限流熔断降级，sentinel、hystrix。\n 3. 加锁排队可以起到缓冲的作用，防止大量的请求同时操作数据库，但它的缺点是增加了系统的响应时间，降低了系统的吞吐量，牺牲了一部分用户体验。当缓存未查询到时，对要请求的 key 进行加锁，只允许一个线程去数据库中查，其他线程等候排队。\n 4. 设置二级缓存。二级缓存指的是除了 Redis 本身的缓存，再设置一层缓存，当 Redis 失效之后，先去查询二级缓存。例如可以设置一个本地缓存，在 Redis 缓存失效的时候先去查询本地缓存而非查询数据库。\n\n针对热点缓存失效的情况：\n\n 1. 设置不同的失效时间比如随机设置缓存的失效时间。\n 2. 热点缓存永不失效。\n\n\n# 缓存击穿\n\n缓存击穿：大量的请求同时查询一个 key 时，此时这个 key 正好失效了，就会导致大量的请求都落到数据库。缓存击穿是查询缓存中失效的 key，而缓存穿透是查询不存在的 key。\n\n解决方案：\n\n1、加互斥锁。在并发的多个请求中，只有第一个请求线程能拿到锁并执行数据库查询操作，其他的线程拿不到锁就阻塞等着，等到第一个线程将数据写入缓存后，直接走缓存。可以使用Redis分布式锁实现。\n\n2、热点数据不过期。直接将缓存设置为不过期，然后由定时任务去异步加载数据，更新缓存。这种方式适用于比较极端的场景，例如流量特别特别大的场景，使用时需要考虑业务能接受数据不一致的时间，还有就是异常情况的处理，保证缓存可以定时刷新。\n\n\n# 缓存预热\n\n缓存预热就是系统上线后，将相关的缓存数据直接加载到缓存系统。这样就可以避免在用户请求的时候，先查询数据库，然后再将数据缓存的问题！用户直接查询事先被预热的缓存数据。\n\n解决方案：\n\n 1. 直接写个缓存刷新页面，上线时手工操作一下；\n 2. 数据量不大，可以在项目启动的时候自动进行加载；\n 3. 定时刷新缓存；\n\n\n# 缓存降级\n\n当访问量剧增、服务出现问题（如响应时间慢或不响应）或非核心服务影响到核心流程的性能时，即使是有损服务，系统可以根据一些关键数据进行自动降级，也可以配置开关实现人工降级。\n\n缓存降级的最终目的是保证核心服务可用，即使是有损的。而且有些服务是无法降级的（如加入购物车、结算）。\n\n在进行降级之前要对系统进行梳理，看看系统是不是可以丢卒保帅；从而梳理出哪些必须誓死保护，哪些可降级；比如可以参考日志级别设置预案：\n\n 1. 一般：比如有些服务偶尔因为网络抖动或者服务正在上线而超时，可以自动降级；\n 2. 警告：有些服务在一段时间内成功率有波动（如在95~100%之间），可以自动降级或人工降级，并发送告警；\n 3. 错误：比如可用率低于90%，或者数据库连接池被打爆了，或者访问量突然猛增到系统能承受的最大阀值，此时可以根据情况自动降级或者人工降级；\n 4. 严重错误：比如因为特殊原因数据错误了，此时需要紧急人工降级。\n\n服务降级的目的，是为了防止Redis服务故障，导致数据库跟着一起发生雪崩问题。因此，对于不重要的缓存数据，可以采取服务降级策略，例如一个比较常见的做法就是，Redis出现问题，不去数据库查询，而是直接返回默认值给用户。",normalizedContent:"# 缓存穿透\n\n缓存穿透是指查询一个不存在的数据，由于缓存是不命中时被动写的，如果从db查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到db去查询，失去了缓存的意义。在流量大时，可能db就挂掉了。\n\n解决方案：\n\n 1. 缓存空值，不会查数据库。\n 2. 采用布隆过滤器，将所有可能存在的数据哈希到一个足够大的bitmap中，查询不存在的数据会被这个bitmap拦截掉，从而避免了对db的查询压力。\n\n布隆过滤器的原理：当一个元素被加入集合时，通过k个哈希函数将这个元素映射成一个位数组中的k个点，把它们置为1。查询时，将元素通过哈希函数映射之后会得到k个点，如果这些点有任何一个0，则被检元素一定不在，直接返回；如果都是1，则查询元素很可能存在，就会去查询redis和数据库。\n\n布隆过滤器一般用于在大数据量的集合中判定某元素是否存在。\n\n\n# 缓存雪崩\n\n缓存雪崩指：缓存在同一时间大面积的失效，后面的请求都直接落到了数据库上，造成数据库短时间内承受大量请求。\n\n存在两种可能：\n\n * 系统缓存模块出问题，宕机不可用。\n * 大量访问数据（热点缓存）在某一时刻大面积失效\n\n解决方案：\n\n针对 redis 服务不可用的情况：\n\n 1. 采用 redis 集群，避免单机出现问题整个缓存服务都没办法使用。保证高可用，redis sentinel、redis cluster。\n 2. 限流，避免同时处理大量的请求。限流熔断降级，sentinel、hystrix。\n 3. 加锁排队可以起到缓冲的作用，防止大量的请求同时操作数据库，但它的缺点是增加了系统的响应时间，降低了系统的吞吐量，牺牲了一部分用户体验。当缓存未查询到时，对要请求的 key 进行加锁，只允许一个线程去数据库中查，其他线程等候排队。\n 4. 设置二级缓存。二级缓存指的是除了 redis 本身的缓存，再设置一层缓存，当 redis 失效之后，先去查询二级缓存。例如可以设置一个本地缓存，在 redis 缓存失效的时候先去查询本地缓存而非查询数据库。\n\n针对热点缓存失效的情况：\n\n 1. 设置不同的失效时间比如随机设置缓存的失效时间。\n 2. 热点缓存永不失效。\n\n\n# 缓存击穿\n\n缓存击穿：大量的请求同时查询一个 key 时，此时这个 key 正好失效了，就会导致大量的请求都落到数据库。缓存击穿是查询缓存中失效的 key，而缓存穿透是查询不存在的 key。\n\n解决方案：\n\n1、加互斥锁。在并发的多个请求中，只有第一个请求线程能拿到锁并执行数据库查询操作，其他的线程拿不到锁就阻塞等着，等到第一个线程将数据写入缓存后，直接走缓存。可以使用redis分布式锁实现。\n\n2、热点数据不过期。直接将缓存设置为不过期，然后由定时任务去异步加载数据，更新缓存。这种方式适用于比较极端的场景，例如流量特别特别大的场景，使用时需要考虑业务能接受数据不一致的时间，还有就是异常情况的处理，保证缓存可以定时刷新。\n\n\n# 缓存预热\n\n缓存预热就是系统上线后，将相关的缓存数据直接加载到缓存系统。这样就可以避免在用户请求的时候，先查询数据库，然后再将数据缓存的问题！用户直接查询事先被预热的缓存数据。\n\n解决方案：\n\n 1. 直接写个缓存刷新页面，上线时手工操作一下；\n 2. 数据量不大，可以在项目启动的时候自动进行加载；\n 3. 定时刷新缓存；\n\n\n# 缓存降级\n\n当访问量剧增、服务出现问题（如响应时间慢或不响应）或非核心服务影响到核心流程的性能时，即使是有损服务，系统可以根据一些关键数据进行自动降级，也可以配置开关实现人工降级。\n\n缓存降级的最终目的是保证核心服务可用，即使是有损的。而且有些服务是无法降级的（如加入购物车、结算）。\n\n在进行降级之前要对系统进行梳理，看看系统是不是可以丢卒保帅；从而梳理出哪些必须誓死保护，哪些可降级；比如可以参考日志级别设置预案：\n\n 1. 一般：比如有些服务偶尔因为网络抖动或者服务正在上线而超时，可以自动降级；\n 2. 警告：有些服务在一段时间内成功率有波动（如在95~100%之间），可以自动降级或人工降级，并发送告警；\n 3. 错误：比如可用率低于90%，或者数据库连接池被打爆了，或者访问量突然猛增到系统能承受的最大阀值，此时可以根据情况自动降级或者人工降级；\n 4. 严重错误：比如因为特殊原因数据错误了，此时需要紧急人工降级。\n\n服务降级的目的，是为了防止redis服务故障，导致数据库跟着一起发生雪崩问题。因此，对于不重要的缓存数据，可以采取服务降级策略，例如一个比较常见的做法就是，redis出现问题，不去数据库查询，而是直接返回默认值给用户。",charsets:{cjk:!0},lastUpdated:"2023/03/29, 21:03:43",lastUpdatedTimestamp:1680095023e3},{title:"Redis场景题",frontmatter:{title:"Redis场景题",date:"2023-03-17T22:00:32.000Z",permalink:"/pages/c8420f/"},regularPath:"/03.Redis/09.redis%E5%9C%BA%E6%99%AF%E9%A2%98.html",relativePath:"03.Redis/09.redis场景题.md",key:"v-09ae1176",path:"/pages/c8420f/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2023/03/29, 21:03:43",lastUpdatedTimestamp:1680095023e3},{title:"Redis分布式锁",frontmatter:{title:"Redis分布式锁",date:"2023-03-17T22:20:53.000Z",permalink:"/pages/5f810a/"},regularPath:"/03.Redis/10.redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81.html",relativePath:"03.Redis/10.redis分布式锁.md",key:"v-4050afac",path:"/pages/5f810a/",headers:[{level:2,title:"1. SEXNX key value",slug:"_1-sexnx-key-value",normalizedTitle:"1. sexnx key value",charIndex:2},{level:2,title:"2. SET key value [EX seconds | PX millseconds] [NX | XX]",slug:"_2-set-key-value-ex-seconds-px-millseconds-nx-xx",normalizedTitle:"2. set key value [ex seconds | px millseconds] [nx | xx]",charIndex:263},{level:2,title:"3. Redlock 原作者",slug:"_3-redlock-原作者",normalizedTitle:"3. redlock 原作者",charIndex:640},{level:2,title:"4. Redisson",slug:"_4-redisson",normalizedTitle:"4. redisson",charIndex:708}],headersStr:"1. SEXNX key value 2. SET key value [EX seconds | PX millseconds] [NX | XX] 3. Redlock 原作者 4. Redisson",content:'# 1. SEXNX key value\n\nset if not exists\n\n如果 key 存在，不执行操作。key 不存在，则将 key 设置为 value。\n\n * 如果 key 不存在，则显示插入成功，可以用来表示加锁成功；\n * 如果 key 存在，则会显示插入失败，可以用来表示加锁失败。\n\n解锁：删除 key。但不能乱删，要保证执行操作的客户端就是加锁的客户端。所以，要先通过 value 判断是否为加锁客户端。\n\n缺点：有没过期时间，锁不会过期。可能出现客户端拿到锁后发生异常，导致锁一直无法释放。\n\n\n# 2. SET key value [EX seconds | PX millseconds] [NX | XX]\n\n * EX seconds – 设置键key的过期时间，单位时秒\n * PX milliseconds – 设置键key的过期时间，单位是毫秒\n * NX – 只有键key不存在的时候才会设置key的值\n * XX – 只有键key存在的时候才会设置key的值\n\n缺点：解锁时，判断是否是当前锁，再删除 key，不是原子性操作。\n\n解决：用 lua 脚本\n\n// 释放锁时，先比较 value 是否相等，避免锁的误释放\nif redis.call("get",KEYS[1]) == ARGV[1] then\n    return redis.call("del",KEYS[1])\nelse\n    return 0\nend\n\n\n\n# 3. Redlock 原作者\n\n前两种方式更多是针对单节点的 redis，针对多节点的 redis，作者提出了 Redlock\n\n\n# 4. Redisson\n\n开门狗机制',normalizedContent:'# 1. sexnx key value\n\nset if not exists\n\n如果 key 存在，不执行操作。key 不存在，则将 key 设置为 value。\n\n * 如果 key 不存在，则显示插入成功，可以用来表示加锁成功；\n * 如果 key 存在，则会显示插入失败，可以用来表示加锁失败。\n\n解锁：删除 key。但不能乱删，要保证执行操作的客户端就是加锁的客户端。所以，要先通过 value 判断是否为加锁客户端。\n\n缺点：有没过期时间，锁不会过期。可能出现客户端拿到锁后发生异常，导致锁一直无法释放。\n\n\n# 2. set key value [ex seconds | px millseconds] [nx | xx]\n\n * ex seconds – 设置键key的过期时间，单位时秒\n * px milliseconds – 设置键key的过期时间，单位是毫秒\n * nx – 只有键key不存在的时候才会设置key的值\n * xx – 只有键key存在的时候才会设置key的值\n\n缺点：解锁时，判断是否是当前锁，再删除 key，不是原子性操作。\n\n解决：用 lua 脚本\n\n// 释放锁时，先比较 value 是否相等，避免锁的误释放\nif redis.call("get",keys[1]) == argv[1] then\n    return redis.call("del",keys[1])\nelse\n    return 0\nend\n\n\n\n# 3. redlock 原作者\n\n前两种方式更多是针对单节点的 redis，针对多节点的 redis，作者提出了 redlock\n\n\n# 4. redisson\n\n开门狗机制',charsets:{cjk:!0},lastUpdated:"2023/03/29, 21:03:43",lastUpdatedTimestamp:1680095023e3},{title:"redis的rehash",frontmatter:{title:"redis的rehash",date:"2023-09-01T00:27:59.000Z",permalink:"/pages/fafd87/"},regularPath:"/03.Redis/11.redis%E7%9A%84rehash.html",relativePath:"03.Redis/11.redis的rehash.md",key:"v-7dfe13a8",path:"/pages/fafd87/",headersStr:null,content:"Redis中的hash扩容渐进式rehash过程\n\n背景： redis字典（hash表）当数据越来越多的时候，就会发生扩容，也就是rehash\n\n对比：java中的hashmap，当数据数量达到阈值的时候(0.75)，就会发生rehash，hash表长度变为原来的二倍，将原hash表数据全部重新计算hash地址，重新分配位置，达到rehash目的。\n\n为了避免 rehash 对服务器性能造成影响， 服务器不是一次性将 ht[0]里面的所有键值对全部 rehash 到 ht[1]， 而是分多次、渐进式地将 ht[0]里面的键值对慢慢地 rehash 到 ht[1]。\n\n步骤：\n\n 1. 为ht[1]分配空间，让字典同时持有ht[0]和ht[1]两个哈希表\n 2. 将rehashindex的值设置为0，表示rehash工作正式开始\n 3. 在rehash期间，每次对字典执行增删改查操作是，程序除了执行指定的操作以外，还会顺带将ht[0]哈希表在rehashindex索引上的所有键值对rehash到ht[1]，当rehash工作完成以后，rehashindex的值+1\n 4. 随着字典操作的不断执行，最终会在某一时间段上ht[0]的所有键值对都会被rehash到ht[1]，这时将rehashindex的值设置为-1，表示rehash操作结束。\n\n渐进式rehash采用的是一种分而治之的方式，将rehash的操作分摊在每一个的访问中，避免集中式rehash而带来的庞大计算量。",normalizedContent:"redis中的hash扩容渐进式rehash过程\n\n背景： redis字典（hash表）当数据越来越多的时候，就会发生扩容，也就是rehash\n\n对比：java中的hashmap，当数据数量达到阈值的时候(0.75)，就会发生rehash，hash表长度变为原来的二倍，将原hash表数据全部重新计算hash地址，重新分配位置，达到rehash目的。\n\n为了避免 rehash 对服务器性能造成影响， 服务器不是一次性将 ht[0]里面的所有键值对全部 rehash 到 ht[1]， 而是分多次、渐进式地将 ht[0]里面的键值对慢慢地 rehash 到 ht[1]。\n\n步骤：\n\n 1. 为ht[1]分配空间，让字典同时持有ht[0]和ht[1]两个哈希表\n 2. 将rehashindex的值设置为0，表示rehash工作正式开始\n 3. 在rehash期间，每次对字典执行增删改查操作是，程序除了执行指定的操作以外，还会顺带将ht[0]哈希表在rehashindex索引上的所有键值对rehash到ht[1]，当rehash工作完成以后，rehashindex的值+1\n 4. 随着字典操作的不断执行，最终会在某一时间段上ht[0]的所有键值对都会被rehash到ht[1]，这时将rehashindex的值设置为-1，表示rehash操作结束。\n\n渐进式rehash采用的是一种分而治之的方式，将rehash的操作分摊在每一个的访问中，避免集中式rehash而带来的庞大计算量。",charsets:{cjk:!0}},{title:"网络协议分层",frontmatter:{title:"网络协议分层",date:"2023-03-20T19:32:26.000Z",permalink:"/pages/network/"},regularPath:"/04.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/01.%E5%9F%BA%E7%A1%80/01.%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E5%88%86%E5%B1%82.html",relativePath:"04.计算机网络/01.基础/01.网络协议分层.md",key:"v-3489417a",path:"/pages/network/",headers:[{level:2,title:"OSI七层模型",slug:"osi七层模型",normalizedTitle:"osi七层模型",charIndex:2},{level:2,title:"TCP/IP的四层模型",slug:"tcp-ip的四层模型",normalizedTitle:"tcp/ip的四层模型",charIndex:438},{level:2,title:"五层模型",slug:"五层模型",normalizedTitle:"五层模型",charIndex:537},{level:2,title:"OSI和TCP/IP的区别",slug:"osi和tcp-ip的区别",normalizedTitle:"osi和tcp/ip的区别",charIndex:619}],headersStr:"OSI七层模型 TCP/IP的四层模型 五层模型 OSI和TCP/IP的区别",content:"# OSI七层模型\n\nOSI七层模型   功能                               协议\n应用层       应用软件所使用的协议，规定了应用软件该以何种方式进行通讯。    HTTP，SMTP，DNS，FTP等\n表示层       决定数据的展现形式，如图片该使用JPEG、BMP还是PNG。   没有协议\n会话层       解除和建立与别的端点间的连接。                  没有协议\n传输层       提供端对端的接点（端口号这里给出），将数据斩件成小段。      TCP，UDP\n网络层       为数据包选择路由（路由选路）                   IP等\n数据链路层     传输有地址的帧以及错误检测功能                  PPP，ARP等\n物理层       将数据以二进制的形式在物理媒介上进行传输             ISO2110，IEEE802，IEEE802.2\n\n\n# TCP/IP的四层模型\n\n应用层：向用户提供数据加上编码和对话控制\n\n传输层：支持不同设备间通过不同网络通信\n\n网络层：确定通过该网络的最佳路径\n\n网络接入层：控制组成网络的硬件设备和介质\n\n\n# 五层模型\n\n应用层\n\n传输层 Transport layer\n\n网络层 Network layer\n\n数据链路层 Data link layer\n\n物理层\n\n\n# OSI和TCP/IP的区别\n\n * OSI 有七层，而 TCP/IP 有四层\n * 在 OSI 中，首先开发模型，然后开发每一层的协议。在 TCP/IP中，首先开发协议，然后开发模型\n * OSI模型是基于每一层功能的通用模型，TCP/IP模型是一种面向协议的标准\n * OSI模型区分了三个概念，即服务、接口和协议。TCP/IP在这三者之间没有明确的区别\n * OSI 模型提供了有关如何进行通信的指南，而 TCP/IP模型则制定了 Internet 开发的标准。因此，TCP/IP 是一种更实用的模型",normalizedContent:"# osi七层模型\n\nosi七层模型   功能                               协议\n应用层       应用软件所使用的协议，规定了应用软件该以何种方式进行通讯。    http，smtp，dns，ftp等\n表示层       决定数据的展现形式，如图片该使用jpeg、bmp还是png。   没有协议\n会话层       解除和建立与别的端点间的连接。                  没有协议\n传输层       提供端对端的接点（端口号这里给出），将数据斩件成小段。      tcp，udp\n网络层       为数据包选择路由（路由选路）                   ip等\n数据链路层     传输有地址的帧以及错误检测功能                  ppp，arp等\n物理层       将数据以二进制的形式在物理媒介上进行传输             iso2110，ieee802，ieee802.2\n\n\n# tcp/ip的四层模型\n\n应用层：向用户提供数据加上编码和对话控制\n\n传输层：支持不同设备间通过不同网络通信\n\n网络层：确定通过该网络的最佳路径\n\n网络接入层：控制组成网络的硬件设备和介质\n\n\n# 五层模型\n\n应用层\n\n传输层 transport layer\n\n网络层 network layer\n\n数据链路层 data link layer\n\n物理层\n\n\n# osi和tcp/ip的区别\n\n * osi 有七层，而 tcp/ip 有四层\n * 在 osi 中，首先开发模型，然后开发每一层的协议。在 tcp/ip中，首先开发协议，然后开发模型\n * osi模型是基于每一层功能的通用模型，tcp/ip模型是一种面向协议的标准\n * osi模型区分了三个概念，即服务、接口和协议。tcp/ip在这三者之间没有明确的区别\n * osi 模型提供了有关如何进行通信的指南，而 tcp/ip模型则制定了 internet 开发的标准。因此，tcp/ip 是一种更实用的模型",charsets:{cjk:!0},lastUpdated:"2023/03/29, 21:03:43",lastUpdatedTimestamp:1680095023e3},{title:"浏览器存储",frontmatter:{title:"浏览器存储",date:"2023-03-21T20:44:24.000Z",permalink:"/pages/f1d55e/"},regularPath:"/04.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/01.%E5%9F%BA%E7%A1%80/02.%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AD%98%E5%82%A8.html",relativePath:"04.计算机网络/01.基础/02.浏览器存储.md",key:"v-f8c2901e",path:"/pages/f1d55e/",headers:[{level:2,title:"Cookie",slug:"cookie",normalizedTitle:"cookie",charIndex:2},{level:2,title:"Cookie和Session区别",slug:"cookie和session区别",normalizedTitle:"cookie和session区别",charIndex:1044},{level:2,title:"LocalStorage 和 SessionStorage 区别",slug:"localstorage-和-sessionstorage-区别",normalizedTitle:"localstorage 和 sessionstorage 区别",charIndex:1244},{level:2,title:"localStorage设置过期时间",slug:"localstorage设置过期时间",normalizedTitle:"localstorage设置过期时间",charIndex:1664},{level:2,title:"cookie如何跨域",slug:"cookie如何跨域",normalizedTitle:"cookie如何跨域",charIndex:1846}],headersStr:"Cookie Cookie和Session区别 LocalStorage 和 SessionStorage 区别 localStorage设置过期时间 cookie如何跨域",content:'# Cookie\n\n * Cookie 是一些数据, 存储于你电脑上的文本文件中\n * 实现每次HTTP请求都自动带数据给服务器的技术\n * Cookie 的作用就是用于解决 "如何记录客户端的用户信息"\n * 一般配合Session一起使用：客户端发送账号密码给服务器，服务器通过账号密码生成SessionID给客户端，然后客户端每次请求都附带这个带有SessionID的cookie。\n\n首部字段\n\n首部字段名称       说明                   首部类型\nSet-Cookie   开始状态管理所使用的Cookie信息   响应首部字段\nCookie       服务器接收到的Cookie信息      请求首部字段\n\nSet-Cookie字段属性\n\n属性                             说明\n<cookie-name>=<cookie-value>   一个cookie必须始于一个名称/值对\nExpires=<date>                 (可选)cookie的最长有效时间\nMax-Age=<non-zero-digit>       (可选)优先级高于Expires，指失效所需经过的秒数\nDomain=<domain-value>          (可选)指定cookie可以送达的主机名\nPath=<path-value>              (可选)将服务器的文件目录（子目录）作为cookie的适用对象\nSecure                         (可选)仅在请求使用SSL和HTTPS协议的时候才会被发送到服务器\nHttpOnly                       (可选)设置了 HttpOnly 属性的 cookie 不能使用 JavaScript 经由\n                               Document.cookie属性、XMLHttpRequest和Request APIs 进行访问\nSameSite=Strict/Lax            (可选)允许服务器设定一则cookie不随着跨域请求一起发送\n\ncookie的sameSite：\n\n * strict：表示完全禁止第三方cookie，直接避免了CSRF攻击，但是同一个运营体的网站不能共用登陆信息\n\n * none：完全不做限制\n\n * lax：半放行\n\n\n# Cookie和Session区别\n\n * 存储位置：cookie保存在浏览器端；而session保存在服务器端\n * 存储方式：cookie只能保存字符串类型，以文本的方式存储（如果没有设置过期时间，会存储在内存中）；session通过类似与Hashtable的数据结构来保存\n * 存储大小：cookie小于4kb；session没有大小限制\n * 安全性：session大于cookie\n\n\n# LocalStorage 和 SessionStorage 区别\n\nWebStorage包括localStorage 和 sessionStorage两种方式。\n\nlocalStorage 和 sessionStorage 属性均允许在浏览器中存储 key/value 对的数据。均是为了弥补cookie所带来的限制，当数据需要严格控制在客户端，并且不需要持续的将数据发回服务器的时候，就需要使用WebStorage。\n\nlocalStorage用于长久保存数据，没有过期时间设置；sessionStorage用于临时保存同一窗口(或标签页)的数据，关闭对应浏览器窗口（Window）/ tab，数据将会被清除。\n\n * sessionStorage：只在同源的同窗口（或标签页）中共享数据，也就是只在当前会话中共享\n\n * localStorage：在所有的同源窗口中都是共享的\n\n * cookie：在所有同源窗口中都是共享的\n\n\n# localStorage设置过期时间\n\n存储localStorage的同时，存储一个过期时间\n\nlocalStorage[key] = value\nlocalStorage[`${key}__expires__`] = Date.now() + 1000*60*expired\n\n\n在获取的时候，先取对应的存储时间，如果过期，则删除。没过期再去取对应的值\n\n\n# cookie如何跨域\n\nA网站访问同源的服务器，获取到cookie，然后A网站发送请求到B服务器，想要带上这个cookie\n\n1.在请求头中添加Credentials：true\n\n2.在B服务器配置Access-Control-Allow-Origin和Access-Control-Allow-Credentials对A网站的请求进行放行\n\n但是在新版的chrome中，需要将cookie的samesite属性设置为none（完全放行，默认是lax半放行，stract禁止），设置为none的话并且必须使用https请求',normalizedContent:'# cookie\n\n * cookie 是一些数据, 存储于你电脑上的文本文件中\n * 实现每次http请求都自动带数据给服务器的技术\n * cookie 的作用就是用于解决 "如何记录客户端的用户信息"\n * 一般配合session一起使用：客户端发送账号密码给服务器，服务器通过账号密码生成sessionid给客户端，然后客户端每次请求都附带这个带有sessionid的cookie。\n\n首部字段\n\n首部字段名称       说明                   首部类型\nset-cookie   开始状态管理所使用的cookie信息   响应首部字段\ncookie       服务器接收到的cookie信息      请求首部字段\n\nset-cookie字段属性\n\n属性                             说明\n<cookie-name>=<cookie-value>   一个cookie必须始于一个名称/值对\nexpires=<date>                 (可选)cookie的最长有效时间\nmax-age=<non-zero-digit>       (可选)优先级高于expires，指失效所需经过的秒数\ndomain=<domain-value>          (可选)指定cookie可以送达的主机名\npath=<path-value>              (可选)将服务器的文件目录（子目录）作为cookie的适用对象\nsecure                         (可选)仅在请求使用ssl和https协议的时候才会被发送到服务器\nhttponly                       (可选)设置了 httponly 属性的 cookie 不能使用 javascript 经由\n                               document.cookie属性、xmlhttprequest和request apis 进行访问\nsamesite=strict/lax            (可选)允许服务器设定一则cookie不随着跨域请求一起发送\n\ncookie的samesite：\n\n * strict：表示完全禁止第三方cookie，直接避免了csrf攻击，但是同一个运营体的网站不能共用登陆信息\n\n * none：完全不做限制\n\n * lax：半放行\n\n\n# cookie和session区别\n\n * 存储位置：cookie保存在浏览器端；而session保存在服务器端\n * 存储方式：cookie只能保存字符串类型，以文本的方式存储（如果没有设置过期时间，会存储在内存中）；session通过类似与hashtable的数据结构来保存\n * 存储大小：cookie小于4kb；session没有大小限制\n * 安全性：session大于cookie\n\n\n# localstorage 和 sessionstorage 区别\n\nwebstorage包括localstorage 和 sessionstorage两种方式。\n\nlocalstorage 和 sessionstorage 属性均允许在浏览器中存储 key/value 对的数据。均是为了弥补cookie所带来的限制，当数据需要严格控制在客户端，并且不需要持续的将数据发回服务器的时候，就需要使用webstorage。\n\nlocalstorage用于长久保存数据，没有过期时间设置；sessionstorage用于临时保存同一窗口(或标签页)的数据，关闭对应浏览器窗口（window）/ tab，数据将会被清除。\n\n * sessionstorage：只在同源的同窗口（或标签页）中共享数据，也就是只在当前会话中共享\n\n * localstorage：在所有的同源窗口中都是共享的\n\n * cookie：在所有同源窗口中都是共享的\n\n\n# localstorage设置过期时间\n\n存储localstorage的同时，存储一个过期时间\n\nlocalstorage[key] = value\nlocalstorage[`${key}__expires__`] = date.now() + 1000*60*expired\n\n\n在获取的时候，先取对应的存储时间，如果过期，则删除。没过期再去取对应的值\n\n\n# cookie如何跨域\n\na网站访问同源的服务器，获取到cookie，然后a网站发送请求到b服务器，想要带上这个cookie\n\n1.在请求头中添加credentials：true\n\n2.在b服务器配置access-control-allow-origin和access-control-allow-credentials对a网站的请求进行放行\n\n但是在新版的chrome中，需要将cookie的samesite属性设置为none（完全放行，默认是lax半放行，stract禁止），设置为none的话并且必须使用https请求',charsets:{cjk:!0},lastUpdated:"2023/03/29, 21:03:43",lastUpdatedTimestamp:1680095023e3},{title:"网络攻击",frontmatter:{title:"网络攻击",date:"2023-03-21T20:59:09.000Z",permalink:"/pages/9ce3d9/"},regularPath:"/04.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/01.%E5%9F%BA%E7%A1%80/03.%E7%BD%91%E7%BB%9C%E6%94%BB%E5%87%BB.html",relativePath:"04.计算机网络/01.基础/03.网络攻击.md",key:"v-053a73e8",path:"/pages/9ce3d9/",headers:[{level:2,title:"CSRF攻击",slug:"csrf攻击",normalizedTitle:"csrf攻击",charIndex:2},{level:3,title:"简单的 CSRF 攻击代码示例：",slug:"简单的-csrf-攻击代码示例",normalizedTitle:"简单的 csrf 攻击代码示例：",charIndex:533},{level:3,title:"采用CSRF-token的方法",slug:"采用csrf-token的方法",normalizedTitle:"采用csrf-token的方法",charIndex:752},{level:2,title:"XSS攻击",slug:"xss攻击",normalizedTitle:"xss攻击",charIndex:2371},{level:2,title:"CSRF和XSS的区别",slug:"csrf和xss的区别",normalizedTitle:"csrf和xss的区别",charIndex:2538},{level:2,title:"DDoS攻击",slug:"ddos攻击",normalizedTitle:"ddos攻击",charIndex:3028}],headersStr:"CSRF攻击 简单的 CSRF 攻击代码示例： 采用CSRF-token的方法 XSS攻击 CSRF和XSS的区别 DDoS攻击",content:'# CSRF攻击\n\nCross-Site Request Forgery CSRF：跨站请求伪造（就是用户在第三方网站上向A发送请求，然后携带上了cookie）\n\nCSRF 攻击通常是通过在攻击者控制的网站中嵌入恶意代码，来利用用户在其他受信任网站上的身份认证，从而在用户不知情的情况下完成攻击。攻击者通过这种方式伪造用户的请求，从而达到盗取用户敏感信息、修改用户数据、执行非法操作等目的。\n\nCSRF 攻击的原理是利用浏览器的自动提交机制，当用户在已登录的受信任网站中进行某些操作时，攻击者通过恶意代码提交一些伪造的请求，从而冒充用户在其他网站上执行一些非法操作。由于这些请求的来源是用户受信任的网站，因此服务器往往会认为这些请求是合法的，从而执行这些请求所要求的操作。\n\n为了防止 CSRF 攻击，可以采取以下措施：\n\n 1. 在表单中添加 CSRF Token，以防止恶意请求被执行。\n 2. 检测 Referer 头，以防止非法请求被执行。\n 3. 对于敏感操作，采用双因素认证等安全措施，加强身份验证。\n 4. 及时更新软件和组件，以避免已知的安全漏洞被攻击者利用。\n\n总之，CSRF 攻击是一种常见的网络安全漏洞，需要采取相应的安全措施来防范。\n\n\n# 简单的 CSRF 攻击代码示例：\n\n 1. 攻击者准备一个钓鱼网站，伪装成银行网站。\n 2. 受害者登录银行网站并保持登录状态。\n 3. 受害者访问攻击者的钓鱼网站，触发钓鱼网站的转账表单提交请求。\n 4. 攻击者钓鱼网站上的表单会被自动提交到银行网站的转账接口，因为浏览器会自动带上受害者在银行网站上的登录凭证（比如 Cookie），所以银行网站会认为是受害者在进行转账操作。\n 5. 受害者的账户被攻击者转走了 100 元。\n\n\n# 采用CSRF-token的方法\n\nCSRF token（跨站请求伪造令牌）是一种防止 CSRF 攻击的常用方法。\n\n其实现原理是在页面中生成一个随机的 token，然后将其加入到表单中的隐藏字段中，并将其同时保存到服务器端。在表单提交时，除了将表单数据提交到服务器外，还需要将 token 一同提交到服务器端。服务器接收到表单请求时，首先会校验 token 的值是否正确，只有 token 的值正确，才会继续处理表单请求。\n\n这样做的原理是，攻击者虽然可以伪造请求，但是攻击者无法伪造合法的 token，因为 token 是随机生成的，并且只有服务器端知道正确的 token 值。因此，攻击者无法在伪造的请求中携带正确的 token 值，从而实现了防止 CSRF 攻击的目的。\n\n在服务端，可以将生成的 CSRF token 保存到会话（session）或者cookie中，并在表单提交时验证 token 的值是否和会话或者cookie中的值相同。\n\nconst express = require(\'express\');\nconst cookieParser = require(\'cookie-parser\');\nconst csrf = require(\'csurf\');\n\nconst app = express();\nconst csrfProtection = csrf({ cookie: true });\n\n// 使用 cookie-parser 中间件来解析 cookie\napp.use(cookieParser());\n\n// 添加 CSRF token 的中间件\napp.use(csrfProtection);\n\n// 生成 CSRF token 并将其保存到 cookie 中\napp.get(\'/\', (req, res) => {\n  const token = req.csrfToken();\n  res.cookie(\'XSRF-TOKEN\', token);\n  res.send(`\n    <html>\n      <head>\n        <title>CSRF Demo</title>\n      </head>\n      <body>\n        <form method="POST" action="/transfer">\n          <input type="hidden" name="_csrf" value="${token}">\n          <input type="text" name="to" placeholder="To">\n          <input type="number" name="amount" placeholder="Amount">\n          <button type="submit">Transfer</button>\n        </form>\n      </body>\n    </html>\n  `);\n});\n\n// 处理转账请求\napp.post(\'/transfer\', (req, res) => {\n  // 验证 CSRF token 的值是否正确\n  const token = req.cookies[\'XSRF-TOKEN\'];\n  if (!req.body._csrf || req.body._csrf !== token) {\n    res.status(403).send(\'Invalid CSRF token\');\n    return;\n  }\n\n  // 执行转账操作\n  // ...\n});\n\napp.listen(3000, () => console.log(\'Server started on port 3000\'));\n\n\n\n\n# XSS攻击\n\nCross-site scripting， XSS 跨站脚本攻击。\n\nXSS简单来说就是在Web页面中插入恶意的Script代码\n\nscript标签可以插入代码，img中的onerror也可以\n\neval（）会将编码之后的语句解码并执行\n\n防御手段：对script、img、a标签进行过滤\n\n较长的输入进行截断\n\n\n# CSRF和XSS的区别\n\nCSRF攻击是一种利用用户在已经登录的情况下，在用户不知情的情况下伪造用户请求，从而实现攻击的一种方式。攻击者通过各种方式欺骗用户点击恶意链接或访问恶意网站，在用户登录的情况下，攻击者伪造一个恶意请求，这个请求看起来像是合法的请求，实际上却是攻击者精心构造的，一旦用户点击这个请求，攻击者就可以对用户的账户进行恶意操作。\n\nXSS攻击则是指攻击者在Web应用程序中注入恶意脚本或HTML代码，使之在用户浏览网页时被执行，从而达到攻击的目的。攻击者通过各种手段将恶意脚本或HTML代码注入到Web页面中，当用户访问这个页面时，恶意脚本或HTML代码会被执行，从而实现攻击。XSS攻击可以分为存储型XSS和反射型XSS两种，分别是攻击者将恶意脚本存储在Web应用程序中，或者将恶意脚本作为参数发送给Web应用程序，再通过Web应用程序返回给用户。\n\n综上所述，CSRF和XSS虽然都是Web安全问题，但它们的攻击方式和实现方式不同。CSRF攻击利用用户在已经登录的情况下对用户进行伪造请求，而XSS攻击则是通过注入恶意代码来对用户的浏览器进行攻击。\n\n\n# DDoS攻击\n\n拒绝服务（DoS）攻击是一种网络攻击，恶意行为者通过中断设备的正常功能，使其目标用户无法使用计算机或其他设备。DoS 攻击通常通过请求压垮或淹没目标计算机，直到其无法处理正常流量，从而对其他用户造成拒绝服务。DoS 攻击的特征是使用一台计算机来发起攻击。\n\nDoS 攻击通常分为两类：\n\n * 缓冲区溢出攻击：在这一种攻击类型中，内存缓冲区溢出可能导致计算机耗尽所有可用的硬盘空间、内存或 CPU 时间。这种利用形式通常会导致行为缓慢、系统崩溃或其他有害的服务器行为，从而造成拒绝服务。\n * 洪水攻击：通过使目标服务器充满大量数据包，恶意行为者便能够使服务器容量过饱和，从而导致拒绝服务。大多数 DoS 洪水攻击若要得逞，恶意行为者必须具有比目标更多的可用带宽。\n\nDDoS 和 DoS 之间的显著区别是攻击中使用的连接数。DoS 攻击利用单个连接，而 DDoS 攻击则利用许多攻击流量来源，通常采用僵尸网络的形式。',normalizedContent:'# csrf攻击\n\ncross-site request forgery csrf：跨站请求伪造（就是用户在第三方网站上向a发送请求，然后携带上了cookie）\n\ncsrf 攻击通常是通过在攻击者控制的网站中嵌入恶意代码，来利用用户在其他受信任网站上的身份认证，从而在用户不知情的情况下完成攻击。攻击者通过这种方式伪造用户的请求，从而达到盗取用户敏感信息、修改用户数据、执行非法操作等目的。\n\ncsrf 攻击的原理是利用浏览器的自动提交机制，当用户在已登录的受信任网站中进行某些操作时，攻击者通过恶意代码提交一些伪造的请求，从而冒充用户在其他网站上执行一些非法操作。由于这些请求的来源是用户受信任的网站，因此服务器往往会认为这些请求是合法的，从而执行这些请求所要求的操作。\n\n为了防止 csrf 攻击，可以采取以下措施：\n\n 1. 在表单中添加 csrf token，以防止恶意请求被执行。\n 2. 检测 referer 头，以防止非法请求被执行。\n 3. 对于敏感操作，采用双因素认证等安全措施，加强身份验证。\n 4. 及时更新软件和组件，以避免已知的安全漏洞被攻击者利用。\n\n总之，csrf 攻击是一种常见的网络安全漏洞，需要采取相应的安全措施来防范。\n\n\n# 简单的 csrf 攻击代码示例：\n\n 1. 攻击者准备一个钓鱼网站，伪装成银行网站。\n 2. 受害者登录银行网站并保持登录状态。\n 3. 受害者访问攻击者的钓鱼网站，触发钓鱼网站的转账表单提交请求。\n 4. 攻击者钓鱼网站上的表单会被自动提交到银行网站的转账接口，因为浏览器会自动带上受害者在银行网站上的登录凭证（比如 cookie），所以银行网站会认为是受害者在进行转账操作。\n 5. 受害者的账户被攻击者转走了 100 元。\n\n\n# 采用csrf-token的方法\n\ncsrf token（跨站请求伪造令牌）是一种防止 csrf 攻击的常用方法。\n\n其实现原理是在页面中生成一个随机的 token，然后将其加入到表单中的隐藏字段中，并将其同时保存到服务器端。在表单提交时，除了将表单数据提交到服务器外，还需要将 token 一同提交到服务器端。服务器接收到表单请求时，首先会校验 token 的值是否正确，只有 token 的值正确，才会继续处理表单请求。\n\n这样做的原理是，攻击者虽然可以伪造请求，但是攻击者无法伪造合法的 token，因为 token 是随机生成的，并且只有服务器端知道正确的 token 值。因此，攻击者无法在伪造的请求中携带正确的 token 值，从而实现了防止 csrf 攻击的目的。\n\n在服务端，可以将生成的 csrf token 保存到会话（session）或者cookie中，并在表单提交时验证 token 的值是否和会话或者cookie中的值相同。\n\nconst express = require(\'express\');\nconst cookieparser = require(\'cookie-parser\');\nconst csrf = require(\'csurf\');\n\nconst app = express();\nconst csrfprotection = csrf({ cookie: true });\n\n// 使用 cookie-parser 中间件来解析 cookie\napp.use(cookieparser());\n\n// 添加 csrf token 的中间件\napp.use(csrfprotection);\n\n// 生成 csrf token 并将其保存到 cookie 中\napp.get(\'/\', (req, res) => {\n  const token = req.csrftoken();\n  res.cookie(\'xsrf-token\', token);\n  res.send(`\n    <html>\n      <head>\n        <title>csrf demo</title>\n      </head>\n      <body>\n        <form method="post" action="/transfer">\n          <input type="hidden" name="_csrf" value="${token}">\n          <input type="text" name="to" placeholder="to">\n          <input type="number" name="amount" placeholder="amount">\n          <button type="submit">transfer</button>\n        </form>\n      </body>\n    </html>\n  `);\n});\n\n// 处理转账请求\napp.post(\'/transfer\', (req, res) => {\n  // 验证 csrf token 的值是否正确\n  const token = req.cookies[\'xsrf-token\'];\n  if (!req.body._csrf || req.body._csrf !== token) {\n    res.status(403).send(\'invalid csrf token\');\n    return;\n  }\n\n  // 执行转账操作\n  // ...\n});\n\napp.listen(3000, () => console.log(\'server started on port 3000\'));\n\n\n\n\n# xss攻击\n\ncross-site scripting， xss 跨站脚本攻击。\n\nxss简单来说就是在web页面中插入恶意的script代码\n\nscript标签可以插入代码，img中的onerror也可以\n\neval（）会将编码之后的语句解码并执行\n\n防御手段：对script、img、a标签进行过滤\n\n较长的输入进行截断\n\n\n# csrf和xss的区别\n\ncsrf攻击是一种利用用户在已经登录的情况下，在用户不知情的情况下伪造用户请求，从而实现攻击的一种方式。攻击者通过各种方式欺骗用户点击恶意链接或访问恶意网站，在用户登录的情况下，攻击者伪造一个恶意请求，这个请求看起来像是合法的请求，实际上却是攻击者精心构造的，一旦用户点击这个请求，攻击者就可以对用户的账户进行恶意操作。\n\nxss攻击则是指攻击者在web应用程序中注入恶意脚本或html代码，使之在用户浏览网页时被执行，从而达到攻击的目的。攻击者通过各种手段将恶意脚本或html代码注入到web页面中，当用户访问这个页面时，恶意脚本或html代码会被执行，从而实现攻击。xss攻击可以分为存储型xss和反射型xss两种，分别是攻击者将恶意脚本存储在web应用程序中，或者将恶意脚本作为参数发送给web应用程序，再通过web应用程序返回给用户。\n\n综上所述，csrf和xss虽然都是web安全问题，但它们的攻击方式和实现方式不同。csrf攻击利用用户在已经登录的情况下对用户进行伪造请求，而xss攻击则是通过注入恶意代码来对用户的浏览器进行攻击。\n\n\n# ddos攻击\n\n拒绝服务（dos）攻击是一种网络攻击，恶意行为者通过中断设备的正常功能，使其目标用户无法使用计算机或其他设备。dos 攻击通常通过请求压垮或淹没目标计算机，直到其无法处理正常流量，从而对其他用户造成拒绝服务。dos 攻击的特征是使用一台计算机来发起攻击。\n\ndos 攻击通常分为两类：\n\n * 缓冲区溢出攻击：在这一种攻击类型中，内存缓冲区溢出可能导致计算机耗尽所有可用的硬盘空间、内存或 cpu 时间。这种利用形式通常会导致行为缓慢、系统崩溃或其他有害的服务器行为，从而造成拒绝服务。\n * 洪水攻击：通过使目标服务器充满大量数据包，恶意行为者便能够使服务器容量过饱和，从而导致拒绝服务。大多数 dos 洪水攻击若要得逞，恶意行为者必须具有比目标更多的可用带宽。\n\nddos 和 dos 之间的显著区别是攻击中使用的连接数。dos 攻击利用单个连接，而 ddos 攻击则利用许多攻击流量来源，通常采用僵尸网络的形式。',charsets:{cjk:!0},lastUpdated:"2023/03/29, 21:03:43",lastUpdatedTimestamp:1680095023e3},{title:"HTTP版本对比",frontmatter:{title:"HTTP版本对比",date:"2023-03-21T17:35:01.000Z",permalink:"/pages/e1cd04/"},regularPath:"/04.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/02.%E5%BA%94%E7%94%A8%E5%B1%82/01.http%E7%89%88%E6%9C%AC%E5%AF%B9%E6%AF%94.html",relativePath:"04.计算机网络/02.应用层/01.http版本对比.md",key:"v-6379fc2e",path:"/pages/e1cd04/",headers:[{level:2,title:"http1.1",slug:"http1-1",normalizedTitle:"http1.1",charIndex:47},{level:2,title:"https",slug:"https",normalizedTitle:"https",charIndex:15},{level:2,title:"http2",slug:"http2",normalizedTitle:"http2",charIndex:403},{level:2,title:"http3",slug:"http3",normalizedTitle:"http3",charIndex:678},{level:2,title:"Q & A",slug:"q-a",normalizedTitle:"q &amp; a",charIndex:null}],headersStr:"http1.1 https http2 http3 Q & A",content:" * http/1.1\n * https\n * http/2\n * http/3\n\n\n\n\n# http1.1\n\n优点：\n\n * 默认使用长连接。（HTTP/1.0协议支持，但是是默认关闭的，从HTTP/1.1以后，连接默认都是长连接。）\n * 支持管道（pipeline）传输，即允许浏览器同时发送多个请求，但响应还是要按序。\n\n缺点：\n\n * 响应要按需，可能造成队头阻塞\n * 头部未经压缩\n * 没有请求优先级\n * 请求只能从客户端开始，服务端只能被动响应\n * 明文传输，不安全\n\n\n# https\n\n在http和tcp之间，通过增加SSL/TLS协议实现。\n\n优点：\n\n * 采用信息加密（混合加密），解决明文传输会被窃听的问题。\n * 采用验证机制，通过摘要算法保证信息的完整性，解决了报文可能被篡改的问题。\n * 采用身份证书（数字证书），将公钥放到证书中。解决可能被冒充的问题。\n\n\n# http2\n\n优点：\n\n * 基于https的，安全有保障。\n * 使用HPACK算法进行头部压缩。如果同时发送过个请求，头部是相同的，会消除重复的部分。\n * 二进制格式的报文。由头信息帧+数据帧组成\n * 采用数据流，每个请求或响应的所有包，称为一个数据流，用来标识同一请求。每个数据流有唯一的编号。还可以指定数据流的优先级，优先级高的服务端优先响应。\n * 多路复用解决队头阻塞问题。\n * 支持服务端推送。\n\n缺点：\n\n * 多个http请求复用一个tcp连接，如果丢包，会触发tcp重传，同一tcp下的http请求都必须等这个包。\n\n\n# http3\n\n优点：\n\n * 把tcp协议改成udp。基于udp提出了QUIC协议。\n\n * * udp不管顺序，不管丢包，因此不会有队头阻塞和丢包重传问题。\n   * 可靠性由QUIC保证。\n\n * TLS升级成了TLS1.3，一个RTT就可以完成握手。\n\n * 头部压缩算法升级成了QPack\n\n\n# Q & A\n\nQ：TLS的握手阶段是再什么时候，是在TCP连接后吗？流程又是怎样的。\n\nA：先TCP三次握手，再TLS三次握手。",normalizedContent:" * http/1.1\n * https\n * http/2\n * http/3\n\n\n\n\n# http1.1\n\n优点：\n\n * 默认使用长连接。（http/1.0协议支持，但是是默认关闭的，从http/1.1以后，连接默认都是长连接。）\n * 支持管道（pipeline）传输，即允许浏览器同时发送多个请求，但响应还是要按序。\n\n缺点：\n\n * 响应要按需，可能造成队头阻塞\n * 头部未经压缩\n * 没有请求优先级\n * 请求只能从客户端开始，服务端只能被动响应\n * 明文传输，不安全\n\n\n# https\n\n在http和tcp之间，通过增加ssl/tls协议实现。\n\n优点：\n\n * 采用信息加密（混合加密），解决明文传输会被窃听的问题。\n * 采用验证机制，通过摘要算法保证信息的完整性，解决了报文可能被篡改的问题。\n * 采用身份证书（数字证书），将公钥放到证书中。解决可能被冒充的问题。\n\n\n# http2\n\n优点：\n\n * 基于https的，安全有保障。\n * 使用hpack算法进行头部压缩。如果同时发送过个请求，头部是相同的，会消除重复的部分。\n * 二进制格式的报文。由头信息帧+数据帧组成\n * 采用数据流，每个请求或响应的所有包，称为一个数据流，用来标识同一请求。每个数据流有唯一的编号。还可以指定数据流的优先级，优先级高的服务端优先响应。\n * 多路复用解决队头阻塞问题。\n * 支持服务端推送。\n\n缺点：\n\n * 多个http请求复用一个tcp连接，如果丢包，会触发tcp重传，同一tcp下的http请求都必须等这个包。\n\n\n# http3\n\n优点：\n\n * 把tcp协议改成udp。基于udp提出了quic协议。\n\n * * udp不管顺序，不管丢包，因此不会有队头阻塞和丢包重传问题。\n   * 可靠性由quic保证。\n\n * tls升级成了tls1.3，一个rtt就可以完成握手。\n\n * 头部压缩算法升级成了qpack\n\n\n# q & a\n\nq：tls的握手阶段是再什么时候，是在tcp连接后吗？流程又是怎样的。\n\na：先tcp三次握手，再tls三次握手。",charsets:{cjk:!0},lastUpdated:"2023/03/29, 21:03:43",lastUpdatedTimestamp:1680095023e3},{title:"HTTP",frontmatter:{title:"HTTP",date:"2023-03-21T17:54:59.000Z",permalink:"/pages/f502d9/"},regularPath:"/04.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/02.%E5%BA%94%E7%94%A8%E5%B1%82/02.http.html",relativePath:"04.计算机网络/02.应用层/02.http.md",key:"v-5140306c",path:"/pages/f502d9/",headers:[{level:2,title:"什么是 HTTP",slug:"什么是-http",normalizedTitle:"什么是 http",charIndex:2},{level:2,title:"HTTP 状态码",slug:"http-状态码",normalizedTitle:"http 状态码",charIndex:190},{level:2,title:"HTTP 请求方式",slug:"http-请求方式",normalizedTitle:"http 请求方式",charIndex:512},{level:2,title:"content-type",slug:"content-type",normalizedTitle:"content-type",charIndex:798},{level:2,title:"常见端口对应的服务",slug:"常见端口对应的服务",normalizedTitle:"常见端口对应的服务",charIndex:1128},{level:2,title:"GET和POST的区别",slug:"get和post的区别",normalizedTitle:"get和post的区别",charIndex:1312},{level:2,title:"如何理解 HTTP 是无状态的",slug:"如何理解-http-是无状态的",normalizedTitle:"如何理解 http 是无状态的",charIndex:1560},{level:2,title:"在交互过程中如果数据传送完了，还不想断开连接怎么办，怎么维持？",slug:"在交互过程中如果数据传送完了-还不想断开连接怎么办-怎么维持",normalizedTitle:"在交互过程中如果数据传送完了，还不想断开连接怎么办，怎么维持？",charIndex:1655},{level:2,title:"HTTP缓存",slug:"http缓存",normalizedTitle:"http缓存",charIndex:1725}],headersStr:"什么是 HTTP HTTP 状态码 HTTP 请求方式 content-type 常见端口对应的服务 GET和POST的区别 如何理解 HTTP 是无状态的 在交互过程中如果数据传送完了，还不想断开连接怎么办，怎么维持？ HTTP缓存",content:'# 什么是 HTTP\n\n超文本传输协议是一种用于分布式、协作式和超媒体信息系统的应用层协议，是因特网上应用最为广泛的一种网络传输协议，所有的 WWW 文件都必须遵守这个标准。\n\nHTTP 是为 Web 浏览器与 Web 服务器之间的通信而设计的，但也可以用于其他目的。\n\nHTTP 是一个基于 TCP/IP 通信协议来传递数据的（HTML 文件、图片文件、查询结果等）。\n\n\n# HTTP 状态码\n\n * 1xx：信息性状态码\n * 2xx：成功\n * 3xx：重定向\n * 4xx：客户端错误\n * 5xx：服务端错误\n\n\n常见状态码：\n\n * 101：切换请求协议。比如切换到 http2 或 websocket 协议。\n * 200：请求成功\n * 301：永久重定向，会缓存\n * 302：临时重定向，不会缓存。请求者之后应继续使用原地址请求。\n * 304 命中缓存，不具有跳转意义，重定向已存在的缓存文件。\n * 400：客户端请求的语法错误\n * 403：服务端禁止访问，跟权限有关\n * 404：服务端无法根据客户端请求找到资源\n * 500：服务端错误\n * 503：服务器当前很忙，暂时无法响应\n\n\n# HTTP 请求方式\n\n * GET：对服务器资源获取的请求，是安全幂等的。\n * POST：发送包含用户提交数据的请求\n * PUT：向服务端提交数据，以修改数据。和POST一样，但是PUT是幂等的（相同的多个PUT请求，等同于只发送了一个PUT请求，因为PUT是直接指向修改资源的，而POST是指向修改资源的父级资源）\n * DELETE：删除服务端某些资源\n * HEAD：请求页面的首部，获取资源的元信息\n * CONNECT：用于ssl隧道的基于代理的请求\n * OPTIONS：返回所有可用的方法，常用于跨域\n * TRACE：追踪请求-响应的传输路径\n\n\n# content-type\n\n即Internet Media Type（互联网媒体类型）。通过告知类型让接收方得以进行相应的处理。\n\nCONTENT-TYPE                        描述\napplication/xml                     xml数据格式\napplication/json                    json数据格式\napplication/pdf                     pdf格式\ntext/html                           HTML格式\napplication/x-www-form-urlencoded   表单提交数据默认格式\n\n\n# 常见端口对应的服务\n\n * 21：FTP 文件传输协议\n * 22：SSH\n * 23：telnet 远程登录服务\n * 25：SMTP 简单邮件传输协议\n * 53：DSN 域名服务器\n * 80：HTTP\n * 110：POP3 邮件协议\n * 443：HTTPS\n * 1080：SOCKETS\n * 1521：Oracle\n * 3306：MySQL\n\n\n# GET和POST的区别\n\n * 请求参数：GET 的请求参数在 URL 中，用 & 连接。POST 的通过 request body 传参。\n * 参数数据类型：GET 只能是 ASCII 的字符。POST 没有限制。\n * 请求缓存：GET 会被主动 cache。POST 不会被缓存，除非手动设置。\n * 数据包：GET 产生一个 TCP 数据包。POST 产生两个。（这好像跟浏览器的实现有关）\n * 历史记录：GET 参数会被保留。POST 不会保留。\n\ncontinue...\n\n\n# 如何理解 HTTP 是无状态的\n\n无状态意味着同个浏览器发起多次请求，虽然服务器会响应，但不会知道你是同一个浏览器。\n\nhttp + cookie/session 可以实现有状态。\n\n\n# 在交互过程中如果数据传送完了，还不想断开连接怎么办，怎么维持？\n\n设置 connection: keep-alive，使用长连接。\n\n\n# HTTP缓存\n\n强缓存：\n\n会有请求，但是不会向服务器发送请求，直接从缓存中读取资源，会有一个响应为200（from disk cache)的。\n\n响应头：\n\n * Expires（http1.0）：response header里的过期时间，浏览器再次加载资源时，如果在这个过期时间内，则命中强缓存。\n\n * Cache-Control（http1.1，优先级更高）：当值设为max-age=300时，表示五分钟内再次加载资源，就会命中缓存\n\n协商缓存（对比缓存）：\n\n需要向服务器发送header请求，服务器根据请求的request header的一些参数来判断是否命中协商缓存，如果命中，则返回304状态码并带上新的response header通知浏览器从缓存中读取资源。\n\n请求头：\n\n * If-None-Match（可靠性优先）：存放ETag的值。\n\n * If-Modified-Since（性能优先）：存放Last-Modified的值。\n\n响应头：\n\n * ETag（可靠性优先）：是对资源的一种唯一标识，只要资源内容有变化，ETag就会重新生成。\n\n * Last-Modified（性能优先）：是资源文件最后一次更改时间（时间单位是秒，如果1秒内修改N次，则Last-Modified不会做出变化）。\n\n浏览器缓存过程：\n\n1.浏览器第一次发送请求加载数据，服务器返回200，将资源文件从服务器下载下来，并保存响应头中的Cache-Control和Expires\n\n2.下一次需要加载资源时，先比较当前时间与上一次返回200时的时间差，如果没有超过Cache-Control设置的max-age，则没有过期，命中强缓存，不发送请求直接从本地缓存中读取文件（如果不支持HTTP1.1，则用Expires判断是否过期）\n\n3.如果时间过期，服务器则查看header里的If-None-Match和If-Modified-Since\n\n4.服务器优先根据ETag的值判断被请求的文件有没有做修改，Etag值一致则没有修改，命中协商缓存，返回304；如果不一致则有改动，直接返回新的资源文件带上新的Etag值并返回 200。（如果没有ETag则对比last-modified）\n\n用户行为对浏览器缓存的控制：\n\n1.地址栏访问：正常缓存流程。\n\n2.F5刷新：跳过强制缓存，但是会进行协商缓存。\n\n3.ctrl+F5强制刷新：跳过强缓存，跳过协商缓存，如同第一次一样向服务器拉取资源。\n\n如何不缓存：\n\nCache-Control: no-cache（对资源会使用缓存，但每次使用缓存前需要向服务器对缓存资源进行验证）, no-store（不使用任何缓存）, must-revalidate\n\n\nExpires：（设置当前时间之前）\n\n\n//在引用js、css文件的url后边加上 ?+Math.random()\n<script type=“text/javascript” src=“/js/test.js?+Math.random()”><\/script> \n\n\n//设置html页面不让浏览器缓存的方法\n<meta http-equiv="pragma" content="no-cache"> \n<meta http-equiv="Cache-Control" content="no-cache, must-revalidate"> \n<meta http-equiv="expires" content="Wed, 26 Feb 1997 00:00:00 GMT">\n',normalizedContent:'# 什么是 http\n\n超文本传输协议是一种用于分布式、协作式和超媒体信息系统的应用层协议，是因特网上应用最为广泛的一种网络传输协议，所有的 www 文件都必须遵守这个标准。\n\nhttp 是为 web 浏览器与 web 服务器之间的通信而设计的，但也可以用于其他目的。\n\nhttp 是一个基于 tcp/ip 通信协议来传递数据的（html 文件、图片文件、查询结果等）。\n\n\n# http 状态码\n\n * 1xx：信息性状态码\n * 2xx：成功\n * 3xx：重定向\n * 4xx：客户端错误\n * 5xx：服务端错误\n\n\n常见状态码：\n\n * 101：切换请求协议。比如切换到 http2 或 websocket 协议。\n * 200：请求成功\n * 301：永久重定向，会缓存\n * 302：临时重定向，不会缓存。请求者之后应继续使用原地址请求。\n * 304 命中缓存，不具有跳转意义，重定向已存在的缓存文件。\n * 400：客户端请求的语法错误\n * 403：服务端禁止访问，跟权限有关\n * 404：服务端无法根据客户端请求找到资源\n * 500：服务端错误\n * 503：服务器当前很忙，暂时无法响应\n\n\n# http 请求方式\n\n * get：对服务器资源获取的请求，是安全幂等的。\n * post：发送包含用户提交数据的请求\n * put：向服务端提交数据，以修改数据。和post一样，但是put是幂等的（相同的多个put请求，等同于只发送了一个put请求，因为put是直接指向修改资源的，而post是指向修改资源的父级资源）\n * delete：删除服务端某些资源\n * head：请求页面的首部，获取资源的元信息\n * connect：用于ssl隧道的基于代理的请求\n * options：返回所有可用的方法，常用于跨域\n * trace：追踪请求-响应的传输路径\n\n\n# content-type\n\n即internet media type（互联网媒体类型）。通过告知类型让接收方得以进行相应的处理。\n\ncontent-type                        描述\napplication/xml                     xml数据格式\napplication/json                    json数据格式\napplication/pdf                     pdf格式\ntext/html                           html格式\napplication/x-www-form-urlencoded   表单提交数据默认格式\n\n\n# 常见端口对应的服务\n\n * 21：ftp 文件传输协议\n * 22：ssh\n * 23：telnet 远程登录服务\n * 25：smtp 简单邮件传输协议\n * 53：dsn 域名服务器\n * 80：http\n * 110：pop3 邮件协议\n * 443：https\n * 1080：sockets\n * 1521：oracle\n * 3306：mysql\n\n\n# get和post的区别\n\n * 请求参数：get 的请求参数在 url 中，用 & 连接。post 的通过 request body 传参。\n * 参数数据类型：get 只能是 ascii 的字符。post 没有限制。\n * 请求缓存：get 会被主动 cache。post 不会被缓存，除非手动设置。\n * 数据包：get 产生一个 tcp 数据包。post 产生两个。（这好像跟浏览器的实现有关）\n * 历史记录：get 参数会被保留。post 不会保留。\n\ncontinue...\n\n\n# 如何理解 http 是无状态的\n\n无状态意味着同个浏览器发起多次请求，虽然服务器会响应，但不会知道你是同一个浏览器。\n\nhttp + cookie/session 可以实现有状态。\n\n\n# 在交互过程中如果数据传送完了，还不想断开连接怎么办，怎么维持？\n\n设置 connection: keep-alive，使用长连接。\n\n\n# http缓存\n\n强缓存：\n\n会有请求，但是不会向服务器发送请求，直接从缓存中读取资源，会有一个响应为200（from disk cache)的。\n\n响应头：\n\n * expires（http1.0）：response header里的过期时间，浏览器再次加载资源时，如果在这个过期时间内，则命中强缓存。\n\n * cache-control（http1.1，优先级更高）：当值设为max-age=300时，表示五分钟内再次加载资源，就会命中缓存\n\n协商缓存（对比缓存）：\n\n需要向服务器发送header请求，服务器根据请求的request header的一些参数来判断是否命中协商缓存，如果命中，则返回304状态码并带上新的response header通知浏览器从缓存中读取资源。\n\n请求头：\n\n * if-none-match（可靠性优先）：存放etag的值。\n\n * if-modified-since（性能优先）：存放last-modified的值。\n\n响应头：\n\n * etag（可靠性优先）：是对资源的一种唯一标识，只要资源内容有变化，etag就会重新生成。\n\n * last-modified（性能优先）：是资源文件最后一次更改时间（时间单位是秒，如果1秒内修改n次，则last-modified不会做出变化）。\n\n浏览器缓存过程：\n\n1.浏览器第一次发送请求加载数据，服务器返回200，将资源文件从服务器下载下来，并保存响应头中的cache-control和expires\n\n2.下一次需要加载资源时，先比较当前时间与上一次返回200时的时间差，如果没有超过cache-control设置的max-age，则没有过期，命中强缓存，不发送请求直接从本地缓存中读取文件（如果不支持http1.1，则用expires判断是否过期）\n\n3.如果时间过期，服务器则查看header里的if-none-match和if-modified-since\n\n4.服务器优先根据etag的值判断被请求的文件有没有做修改，etag值一致则没有修改，命中协商缓存，返回304；如果不一致则有改动，直接返回新的资源文件带上新的etag值并返回 200。（如果没有etag则对比last-modified）\n\n用户行为对浏览器缓存的控制：\n\n1.地址栏访问：正常缓存流程。\n\n2.f5刷新：跳过强制缓存，但是会进行协商缓存。\n\n3.ctrl+f5强制刷新：跳过强缓存，跳过协商缓存，如同第一次一样向服务器拉取资源。\n\n如何不缓存：\n\ncache-control: no-cache（对资源会使用缓存，但每次使用缓存前需要向服务器对缓存资源进行验证）, no-store（不使用任何缓存）, must-revalidate\n\n\nexpires：（设置当前时间之前）\n\n\n//在引用js、css文件的url后边加上 ?+math.random()\n<script type=“text/javascript” src=“/js/test.js?+math.random()”><\/script> \n\n\n//设置html页面不让浏览器缓存的方法\n<meta http-equiv="pragma" content="no-cache"> \n<meta http-equiv="cache-control" content="no-cache, must-revalidate"> \n<meta http-equiv="expires" content="wed, 26 feb 1997 00:00:00 gmt">\n',charsets:{cjk:!0},lastUpdated:"2023/03/29, 21:03:43",lastUpdatedTimestamp:1680095023e3},{title:"HTTPS",frontmatter:{title:"HTTPS",date:"2023-03-21T18:22:20.000Z",permalink:"/pages/43e2c1/"},regularPath:"/04.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/02.%E5%BA%94%E7%94%A8%E5%B1%82/03.https.html",relativePath:"04.计算机网络/02.应用层/03.https.md",key:"v-0b9e1aec",path:"/pages/43e2c1/",headers:[{level:2,title:"HTTP 和 HTTPS 的区别",slug:"http-和-https-的区别",normalizedTitle:"http 和 https 的区别",charIndex:2},{level:2,title:"HTTPS的特点",slug:"https的特点",normalizedTitle:"https的特点",charIndex:167},{level:2,title:"HTTPS流程",slug:"https流程",normalizedTitle:"https流程",charIndex:925},{level:2,title:"关于数字证书",slug:"关于数字证书",normalizedTitle:"关于数字证书",charIndex:1332},{level:2,title:"QA",slug:"qa",normalizedTitle:"qa",charIndex:1685}],headersStr:"HTTP 和 HTTPS 的区别 HTTPS的特点 HTTPS流程 关于数字证书 QA",content:"# HTTP 和 HTTPS 的区别\n\n * HTTP使用的80端口，HTTPS使用的是443端口\n * HTTP协议不提供任何方式的数据加密，HTTPS在HTTP协议的基础上加入了SSL/TSL协议（在应用层和传输层之间添加了安全层）\n * HTTPS协议需要向CA（证书权威机构）申请数字证书，来保证服务器的身份是可信的\n\n\n# HTTPS的特点\n\n * 混合加密（对称加密和非对称加密结合）\n   \n   通信建立前采用非对称加密的方式交换会话密钥，后续将不再使用非对称加密。通信过程中使用对称加密的会话密钥的方式加密明文数据。\n   \n   为什么要使用混合加密的方式\n   \n   对称加密使用一个密钥，运行速度快，密钥必须保密，无法做到安全的密钥交换。非对称加密使用两个密钥，公钥和私钥，公钥可以任意分发而私钥保密，解决了密钥交换问题但是速度慢。\n\n * 摘要算法\n   \n   要来验证数据的完整性\n   \n   传输之前将明文使用摘要算法进行加密生成摘要，然后将明文和摘要通过会话密钥进行加密后传输给对方，对方使用会话密钥解密之后，对明文再次进行摘要算法，对比先后生成的摘要是否一致来验证传输数据的完整性\n\n * 数字证书（对非对称加密的公钥进行加密）\n\n 1. 申请证书：申请人向数字证书颁发机构（CA）提交证书申请，并提供必要的身份信息，如姓名、公司名称、邮箱地址等。\n 2. 身份验证：CA会对申请人进行身份验证，以确保申请人的身份真实可信，一般包括验证身份证明、联系公司等方式。\n 3. 生成密钥对：CA为申请人生成密钥对（公钥和私钥），公钥用于加密数据，私钥用于解密数据。\n 4. 证书签名：CA使用自己的私钥对申请人的公钥和身份信息进行数字签名，生成数字证书。\n 5. 证书发布：CA将数字证书发布到证书发布系统中，申请人可以通过下载证书获得自己的公钥和数字签名等信息。CA 的公钥也是需要使用证书来分发的，所以电脑必须安装 CA 的证书，证书里包含了 CA 的公钥。\n 6. 证书验证：其他用户（如浏览器）在与申请人进行通信时，会通过CA的数字证书验证申请人的身份和公钥的真实性，并确保通信过程的安全和完整性。\n\n\n# HTTPS流程\n\n 1. 客户端发起HTTPS请求：客户端向服务器发起HTTPS请求，请求连接到服务器。（先进行TCP三次握手）\n 2. 服务器响应请求：服务器接收到客户端请求后，返回数字证书。\n 3. 客户端验证证书：客户端使用CA的公钥对数字证书解密，验证服务器的身份，并检查证书的有效性和完整性，并得到服务器的公钥。\n 4. 客户端生成随机密钥：客户端生成一个随机的对称密钥（会话密钥），用于加密通信过程中的数据。\n 5. 客户端使用服务器公钥加密密钥：客户端使用服务器公钥对随机生成的对称密钥进行加密，然后将加密后的密钥发送给服务器。\n 6. 服务器使用私钥解密密钥：服务器使用自己的私钥对接收到的加密密钥进行解密，得到对称密钥。\n 7. 客户端与服务器开始加密通信：客户端和服务器使用对称密钥进行加密通信，确保通信过程的安全性和隐私性。\n 8. 通信结束：客户端和服务器在通信结束时，关闭连接。\n\n\n# 关于数字证书\n\n证书颁发机构是有层级关系的，下级 CA 的证书是需要由上级 CA 签名的。\n\n换句话说一定存在根证书颁发机构，根证书可以自签，自己给自己认证。\n\n如何保证根证书的可靠性？这是操作系统和浏览器预装的，由微软、苹果等操作系统厂商来选择根证书。\n\n证书不可信？那么什么情况下浏览器会提示 “证书不可信” 呢？\n\n可能的原因：\n\n * 证书不是权威 CA 颁发：有些企业为了贪图便宜使用盗版的证书，没有经过 CA 认证。也就是无法使用浏览器内置 CA 公钥进行验证。\n\n * 证书过期：证书里有一项就是有效期，一般就是一年或者两年的时间。如果证书过期，那么浏览器就会提示“证书不可信”\n\n * 证书部署错误：可能是服务器证书部署出错，比如证书与域名不匹配，因为证书里有一项是持有人信息的。\n\n\n# QA\n\n 1. 非对称加密中公私钥都可以加密，那么什么时候用公钥加密，什么时候用私钥“加密” ？\n    * 加密场景，那么肯定希望只有我才能解密，别人只能加密。即公钥加密，私钥解密。\n    * 签名场景，既然是签名，就希望只能我才能签名，别人只能验证。即私钥签名，公钥验签\n 2. 什么是数字签名，数字签名的作用是什么？\n    * 数字签名就是使用私钥对数据摘要进行签名，并附带和数据一起发送。\n    * 可以起到防篡改、防伪装、防否认的作用。\n 3. 为什么要对数据的摘要进行签名，而不是直接计算原始数据的数字签名？\n    * 数据可能比较大，签名是使用非对称加密算法，比较耗时\n    * 防止第三方使用公钥解开签名后，拿到原始数据\n 4. 什么是数字证书，数字证书存在解决了什么问题？\n    * 数字证书就是由 CA 机构使用自己私钥，对证书申请者的公钥进行签名认证。\n    * 数字证书解决了如何安全分发公钥的问题，也奠定了信任链的基础。",normalizedContent:"# http 和 https 的区别\n\n * http使用的80端口，https使用的是443端口\n * http协议不提供任何方式的数据加密，https在http协议的基础上加入了ssl/tsl协议（在应用层和传输层之间添加了安全层）\n * https协议需要向ca（证书权威机构）申请数字证书，来保证服务器的身份是可信的\n\n\n# https的特点\n\n * 混合加密（对称加密和非对称加密结合）\n   \n   通信建立前采用非对称加密的方式交换会话密钥，后续将不再使用非对称加密。通信过程中使用对称加密的会话密钥的方式加密明文数据。\n   \n   为什么要使用混合加密的方式\n   \n   对称加密使用一个密钥，运行速度快，密钥必须保密，无法做到安全的密钥交换。非对称加密使用两个密钥，公钥和私钥，公钥可以任意分发而私钥保密，解决了密钥交换问题但是速度慢。\n\n * 摘要算法\n   \n   要来验证数据的完整性\n   \n   传输之前将明文使用摘要算法进行加密生成摘要，然后将明文和摘要通过会话密钥进行加密后传输给对方，对方使用会话密钥解密之后，对明文再次进行摘要算法，对比先后生成的摘要是否一致来验证传输数据的完整性\n\n * 数字证书（对非对称加密的公钥进行加密）\n\n 1. 申请证书：申请人向数字证书颁发机构（ca）提交证书申请，并提供必要的身份信息，如姓名、公司名称、邮箱地址等。\n 2. 身份验证：ca会对申请人进行身份验证，以确保申请人的身份真实可信，一般包括验证身份证明、联系公司等方式。\n 3. 生成密钥对：ca为申请人生成密钥对（公钥和私钥），公钥用于加密数据，私钥用于解密数据。\n 4. 证书签名：ca使用自己的私钥对申请人的公钥和身份信息进行数字签名，生成数字证书。\n 5. 证书发布：ca将数字证书发布到证书发布系统中，申请人可以通过下载证书获得自己的公钥和数字签名等信息。ca 的公钥也是需要使用证书来分发的，所以电脑必须安装 ca 的证书，证书里包含了 ca 的公钥。\n 6. 证书验证：其他用户（如浏览器）在与申请人进行通信时，会通过ca的数字证书验证申请人的身份和公钥的真实性，并确保通信过程的安全和完整性。\n\n\n# https流程\n\n 1. 客户端发起https请求：客户端向服务器发起https请求，请求连接到服务器。（先进行tcp三次握手）\n 2. 服务器响应请求：服务器接收到客户端请求后，返回数字证书。\n 3. 客户端验证证书：客户端使用ca的公钥对数字证书解密，验证服务器的身份，并检查证书的有效性和完整性，并得到服务器的公钥。\n 4. 客户端生成随机密钥：客户端生成一个随机的对称密钥（会话密钥），用于加密通信过程中的数据。\n 5. 客户端使用服务器公钥加密密钥：客户端使用服务器公钥对随机生成的对称密钥进行加密，然后将加密后的密钥发送给服务器。\n 6. 服务器使用私钥解密密钥：服务器使用自己的私钥对接收到的加密密钥进行解密，得到对称密钥。\n 7. 客户端与服务器开始加密通信：客户端和服务器使用对称密钥进行加密通信，确保通信过程的安全性和隐私性。\n 8. 通信结束：客户端和服务器在通信结束时，关闭连接。\n\n\n# 关于数字证书\n\n证书颁发机构是有层级关系的，下级 ca 的证书是需要由上级 ca 签名的。\n\n换句话说一定存在根证书颁发机构，根证书可以自签，自己给自己认证。\n\n如何保证根证书的可靠性？这是操作系统和浏览器预装的，由微软、苹果等操作系统厂商来选择根证书。\n\n证书不可信？那么什么情况下浏览器会提示 “证书不可信” 呢？\n\n可能的原因：\n\n * 证书不是权威 ca 颁发：有些企业为了贪图便宜使用盗版的证书，没有经过 ca 认证。也就是无法使用浏览器内置 ca 公钥进行验证。\n\n * 证书过期：证书里有一项就是有效期，一般就是一年或者两年的时间。如果证书过期，那么浏览器就会提示“证书不可信”\n\n * 证书部署错误：可能是服务器证书部署出错，比如证书与域名不匹配，因为证书里有一项是持有人信息的。\n\n\n# qa\n\n 1. 非对称加密中公私钥都可以加密，那么什么时候用公钥加密，什么时候用私钥“加密” ？\n    * 加密场景，那么肯定希望只有我才能解密，别人只能加密。即公钥加密，私钥解密。\n    * 签名场景，既然是签名，就希望只能我才能签名，别人只能验证。即私钥签名，公钥验签\n 2. 什么是数字签名，数字签名的作用是什么？\n    * 数字签名就是使用私钥对数据摘要进行签名，并附带和数据一起发送。\n    * 可以起到防篡改、防伪装、防否认的作用。\n 3. 为什么要对数据的摘要进行签名，而不是直接计算原始数据的数字签名？\n    * 数据可能比较大，签名是使用非对称加密算法，比较耗时\n    * 防止第三方使用公钥解开签名后，拿到原始数据\n 4. 什么是数字证书，数字证书存在解决了什么问题？\n    * 数字证书就是由 ca 机构使用自己私钥，对证书申请者的公钥进行签名认证。\n    * 数字证书解决了如何安全分发公钥的问题，也奠定了信任链的基础。",charsets:{cjk:!0},lastUpdated:"2023/03/29, 21:03:43",lastUpdatedTimestamp:1680095023e3},{title:"DNS",frontmatter:{title:"DNS",date:"2023-03-21T18:49:35.000Z",permalink:"/pages/524e17/"},regularPath:"/04.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/02.%E5%BA%94%E7%94%A8%E5%B1%82/04.dns.html",relativePath:"04.计算机网络/02.应用层/04.dns.md",key:"v-0bf64c24",path:"/pages/524e17/",headers:[{level:2,title:"DNS的解析流程",slug:"dns的解析流程",normalizedTitle:"dns的解析流程",charIndex:153},{level:2,title:"DNS解析优化",slug:"dns解析优化",normalizedTitle:"dns解析优化",charIndex:915}],headersStr:"DNS的解析流程 DNS解析优化",content:'DNS(Domain Name System)是“域名系统”的英文缩写，提供将域名和IP地址相互映射的服务，DNS是应用层协议，他是为其他应用层协议工作的，包括并不限于HTTP和SMTP以及FTP，具体将用户提供的主机名解析为ip地址。所有DNS请求和回答报文使用的UDP数据报经过端口53发送。\n\n\n# DNS的解析流程\n\n如果查找www.baidu.com\n\n * **浏览器缓存：**浏览器先检查自身缓存中有没有这个域名对应的IP地址，如果有，完成域名解析。\n * **本地hosts文件：**操作系统会先检查自己本地的hosts文件是否有这个网址映射关系，如果有，就先调用这个IP地址映射，完成域名解析。\n * **本地DNS客户端缓存：**如果hosts里没有这个域名的映射，则查找本地DNS解析器缓存，是否有这个网址映射关系，如果有，直接返回，完成域名解析。\n * 本地DNS服务器配置区域资源：（能上qq不能上网，是DNS解析器里面的DNS服务器地址错了）如果hosts与本地DNS解析器缓存都没有相应的网址映射关系，首先会找TCP/ip参数中设置的首选DNS服务器，在此我们叫它本地DNS服务器，此服务器收到查询时，如果要查询的域名，包含在本地配置区域资源中，则返回解析结果给客户机，完成域名解析，此解析具有权威性。\n * 本地DNS服务器缓存：如果要查询的域名，不由本地DNS服务器区域解析，但该服务器已缓存了此网址映射关系，则调用这个IP地址映射，完成域名解析，此解析是非权威的。\n * **迭代查询：**本地DNS就把请求发至13台根DNS，根DNS服务器收到请求后会判断这个域名(.com)是谁来授权管理，并会返回一个负责该顶级域名服务器的一个IP。本地DNS服务器收到IP信息后，将会联系负责.com域的这台服务器。这台负责.com域的服务器收到请求后，如果自己无法解析，它就会找一个管理.com域的下一级DNS服务器地址baidu.com给本地DNS服务器。当本地DNS服务器收到这个地址后，就会找baidu.com域服务器，重复上面的动作，进行查询，直至找到www.baidu.com主机。\n\n\n# DNS解析优化\n\n * 减少DNS查找：\n\n使用浏览器DNS缓存、计算机DNS缓存、服务器DNS缓存，防止DNS迭代查找｜使用Keep-Alive特性来减少DNS查找的频率｜使用较少的域名（服务器）来减少DNS查找的数量\n\n服务器查找返回的DNS记录包含TTL（存活时间，用于告诉客户端该记录可以缓存多久），操作系统会考虑TTL，但是浏览器会忽略该值，并设置自己的时间限制。HTTP协议中的Keep-Alive特性可以同时覆盖TTL和浏览器的时间限制（只要还保持着TCP连接打开状态，那么就不会进行DNS查询）。浏览器对DNS记录缓存数量有限制，未到时间，但是超出限制的最老一批记录将会被遗忘。\n\n * 在前端代码中添加DNS预解析：\n\n开启/关闭自动解析功能：\n\n<meta http-equiv="x-dns-prefetch-control" content="on">\n// off 则是关闭\n\n\n手动添加解析：\n\n<link rel="dns-prefetch" href="http://www.google.com">\n',normalizedContent:'dns(domain name system)是“域名系统”的英文缩写，提供将域名和ip地址相互映射的服务，dns是应用层协议，他是为其他应用层协议工作的，包括并不限于http和smtp以及ftp，具体将用户提供的主机名解析为ip地址。所有dns请求和回答报文使用的udp数据报经过端口53发送。\n\n\n# dns的解析流程\n\n如果查找www.baidu.com\n\n * **浏览器缓存：**浏览器先检查自身缓存中有没有这个域名对应的ip地址，如果有，完成域名解析。\n * **本地hosts文件：**操作系统会先检查自己本地的hosts文件是否有这个网址映射关系，如果有，就先调用这个ip地址映射，完成域名解析。\n * **本地dns客户端缓存：**如果hosts里没有这个域名的映射，则查找本地dns解析器缓存，是否有这个网址映射关系，如果有，直接返回，完成域名解析。\n * 本地dns服务器配置区域资源：（能上qq不能上网，是dns解析器里面的dns服务器地址错了）如果hosts与本地dns解析器缓存都没有相应的网址映射关系，首先会找tcp/ip参数中设置的首选dns服务器，在此我们叫它本地dns服务器，此服务器收到查询时，如果要查询的域名，包含在本地配置区域资源中，则返回解析结果给客户机，完成域名解析，此解析具有权威性。\n * 本地dns服务器缓存：如果要查询的域名，不由本地dns服务器区域解析，但该服务器已缓存了此网址映射关系，则调用这个ip地址映射，完成域名解析，此解析是非权威的。\n * **迭代查询：**本地dns就把请求发至13台根dns，根dns服务器收到请求后会判断这个域名(.com)是谁来授权管理，并会返回一个负责该顶级域名服务器的一个ip。本地dns服务器收到ip信息后，将会联系负责.com域的这台服务器。这台负责.com域的服务器收到请求后，如果自己无法解析，它就会找一个管理.com域的下一级dns服务器地址baidu.com给本地dns服务器。当本地dns服务器收到这个地址后，就会找baidu.com域服务器，重复上面的动作，进行查询，直至找到www.baidu.com主机。\n\n\n# dns解析优化\n\n * 减少dns查找：\n\n使用浏览器dns缓存、计算机dns缓存、服务器dns缓存，防止dns迭代查找｜使用keep-alive特性来减少dns查找的频率｜使用较少的域名（服务器）来减少dns查找的数量\n\n服务器查找返回的dns记录包含ttl（存活时间，用于告诉客户端该记录可以缓存多久），操作系统会考虑ttl，但是浏览器会忽略该值，并设置自己的时间限制。http协议中的keep-alive特性可以同时覆盖ttl和浏览器的时间限制（只要还保持着tcp连接打开状态，那么就不会进行dns查询）。浏览器对dns记录缓存数量有限制，未到时间，但是超出限制的最老一批记录将会被遗忘。\n\n * 在前端代码中添加dns预解析：\n\n开启/关闭自动解析功能：\n\n<meta http-equiv="x-dns-prefetch-control" content="on">\n// off 则是关闭\n\n\n手动添加解析：\n\n<link rel="dns-prefetch" href="http://www.google.com">\n',charsets:{cjk:!0},lastUpdated:"2023/03/29, 21:03:43",lastUpdatedTimestamp:1680095023e3},{title:"TCP",frontmatter:{title:"TCP",date:"2023-03-21T18:54:20.000Z",permalink:"/pages/5e312c/"},regularPath:"/04.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/03.%E4%BC%A0%E8%BE%93%E5%B1%82/01.tcp.html",relativePath:"04.计算机网络/03.传输层/01.tcp.md",key:"v-2767b19c",path:"/pages/5e312c/",headers:[{level:2,title:"TCP和UDP的区别",slug:"tcp和udp的区别",normalizedTitle:"tcp和udp的区别",charIndex:2},{level:3,title:"TCP和UDP应用",slug:"tcp和udp应用",normalizedTitle:"tcp和udp应用",charIndex:630},{level:3,title:"字节流和报文段",slug:"字节流和报文段",normalizedTitle:"字节流和报文段",charIndex:728},{level:2,title:"TCP粘包、拆包问题",slug:"tcp粘包、拆包问题",normalizedTitle:"tcp粘包、拆包问题",charIndex:897},{level:2,title:"TCP三次握手",slug:"tcp三次握手",normalizedTitle:"tcp三次握手",charIndex:1374},{level:2,title:"TCP四次挥手",slug:"tcp四次挥手",normalizedTitle:"tcp四次挥手",charIndex:2363},{level:2,title:"TCP可靠传输",slug:"tcp可靠传输",normalizedTitle:"tcp可靠传输",charIndex:3263},{level:3,title:"重传机制",slug:"重传机制",normalizedTitle:"重传机制",charIndex:3277},{level:3,title:"流量控制和拥塞控制的区别",slug:"流量控制和拥塞控制的区别",normalizedTitle:"流量控制和拥塞控制的区别",charIndex:3804},{level:3,title:"流量控制",slug:"流量控制",normalizedTitle:"流量控制",charIndex:215},{level:3,title:"拥塞控制",slug:"拥塞控制",normalizedTitle:"拥塞控制",charIndex:76},{level:2,title:"TCP 序列号的作用",slug:"tcp-序列号的作用",normalizedTitle:"tcp 序列号的作用",charIndex:5009},{level:2,title:"滑动窗口和拥塞窗口",slug:"滑动窗口和拥塞窗口",normalizedTitle:"滑动窗口和拥塞窗口",charIndex:5983}],headersStr:"TCP和UDP的区别 TCP和UDP应用 字节流和报文段 TCP粘包、拆包问题 TCP三次握手 TCP四次挥手 TCP可靠传输 重传机制 流量控制和拥塞控制的区别 流量控制 拥塞控制 TCP 序列号的作用 滑动窗口和拥塞窗口",content:"# TCP和UDP的区别\n\n用户数据报协议UDP（User Datagram Protocol）：\n\n是无连接的；尽最大可能交付；不能保证数据顺序；没有拥塞控制；面向报文（对于应用程序传下来的报文不合并也不拆分，只是添加UDP首部）；支持一对一、一对多、多对一和多对多的交互通信。\n\n传输控制协议TCP（Transmission Control Protocol）：\n\n是面向连接的；提供可靠交付；保证数据顺序（由于使用序号）；有流量控制；有拥塞控制；提供全双工通信；面向字节流（把应用层传下来的报文看成字节流，把字节流组织成大小不等的数据块）；仅支持一对一。\n\n\n * tcp是面向连接的可靠传输协议，是面向字节流的，会发生粘包和拆包现象，有流量控制和拥塞控制保证可靠传输，适合要求对数据传输可靠性要求高的场景。\n\n * udp是无连接的，不可靠的传输协议，会尽最大努力进行交付，面向报文，不会进行拆分和合并，没有拥塞控制，适合允许数据小量丢失的场景，能够实现1对1，1对多，多对多的实时交互通信。\n\n * udp首部长度只有8B，比TCP小。\n\n * 面向连接：一定是「一对一」才能连接，不能像 UDP 协议可以一个主机同时向多个主机发送消息，也就是一对多是无法做到的。\n\n * 可靠交付：无论的网络链路中出现了怎样的链路变化，TCP 都可以保证一个报文一定能够到达接收端。\n\n * 面向字节流：也就是说仅仅把上层协议传递过来的数据当成字节传输。\n\n\n# TCP和UDP应用\n\nTCP：要求通信数据的完整性和准确性较高（文件传输、邮件发送、重要状态的更新）\n\nUDP：要求通信响应度高，对数据信息的安全性和完整性要求较低（网络电话、网络视频）\n\n\n# 字节流和报文段\n\n区分字节流和报文关键在于：对使用协议的用户而言，读数据的时候，是不是有“边界”，有边界就是报文，没有边界就是字节流\n\n没有边界：上层协议读取数据的时候不知道读到了几个TCP数据包（因为有缓冲池，所以发送端发送数据和接收端处理数据的频率是可以不对等的）\n\n有边界：上层协议每一次读取必定是一个数据包（没有缓冲池）\n\n\n# TCP粘包、拆包问题\n\nTCP 是以流的方式来处理数据，一个完整的包可能会被 TCP 拆分成多个包进行发送，也可能把小的封装成一个大的数据包发送。\n\n\n发送方：关闭Nagle算法。接收方：没法处理，只能交给应用层来进行处理\n\n应用层：\n\n * 使用标准的应用层协议（http，https等）来封装要传输的不定长的数据包\n * 在每条数据的尾部添加特殊字符，如果遇到特殊字符表明当条数据接受完毕\n * 在发送数据前添加包头，数据格式为：数据头+数据块\n\n\nnetty的解决方案：\n\n * 消息定长：FixedLengthFrameDecoder\n * 包尾增加特殊字符分割：\n   * 行分隔符类：LineBasedFrameDecoder\n   * 自定义分隔符类 ：DelimiterBasedFrameDecoder\n * 将消息分为消息头和消息体：LengthFieldBasedFrameDecoder 类。分为有头部的拆包与粘包、长度字段在前且有头部的拆包与粘包、多扩展头部的拆包与粘包。\n\n也可以使用自定义协议，通过字段标明包长度。\n\n\n# TCP三次握手\n\n过程：\n\n * A 向 B 发送连接请求报文，SYN=1，ACK=0，seq=x。\n * B 收到连接请求报文，如果同意建立连接，则向 A 发送连接确认报文，SYN=1，ACK=1，ack=x+1，seq= y。\n * A 收到 B 的连接确认报文后，还要向 B 发出确认，ACK=1，ack= y+1，seq=x+1。\n\n第二次握手完成后SYN将被置为0，第三次握手可以携带数据，前两次不可以携带数据。\n\n为什么需要三次？\n\n * 三次连接才能可靠的同步双方的初始序列号。【tcp的可靠传输是靠同步序列号实现：序列号能保证数据包不重复、不丢弃和按序传输】\n * 防止重复的历史连接的建立，造成混乱。\n * 避免资源浪费。【重传情况】\n\n重复历史连接建立的具体场景：客户端先发送了 SYN（seq = 90） 报文，然后客户端宕机了，而且这个 SYN 报文还被网络阻塞了，服务端并没有收到，接着客户端重启后，又重新向服务端建立连接，发送了 SYN（seq = 100） 报文（注意不是重传 SYN，重传的 SYN 的序列号是一样的）。\n\n客户端连续发送多次 SYN 建立连接的报文，在网络拥堵情况下：\n\n * 一个「旧 SYN 报文」比「最新的 SYN 」 报文早到达了服务端；\n * 那么此时服务端就会回一个 SYN + ACK 报文给客户端；\n * 客户端收到后可以根据自身的上下文，判断这是一个历史连接（序列号过期或超时），那么客户端就会发送 RST 报文给服务端，表示中止这一次连接。\n\n**如果是两次握手连接，就无法阻止历史连接。**两次握手的情况下，「被动发起方」在收到 SYN 报文后，就进入 ESTABLISHED 状态，意味着这时可以给对方发送数据，但是「主动发起方」此时还没有进入 ESTABLISHED 状态，假设这次是历史连接，「主动发起方」判断到此次连接为历史连接，那么就会回 RST 报文来断开连接，而「被动发起方」在第一次握手的时候就进入 ESTABLISHED 状态，所以它可以发送数据的，但是它并不知道这个是历史连接，它只有在收到 RST 报文后，才会断开连接。\n\n两次握手的话，当客户端连续发送多个建立连接的报文，在网络阻塞的情况下，由于服务端收到应答后就建立了连接，所以会造成服务端多个连接的建立，从而尝试混乱。\n\n\n# TCP四次挥手\n\n * 过程：\n   \n   * 客户端发出连接释放报文段（FIN=1，序号seq=u），并停止再发送数据，主动关闭TCP连接，进入FIN_WAIT1（终止等待1）状态，等待服务端的确认。\n   * 服务端收到连接释放报文段后即发出确认报文段（ACK=1，确认号ack=u+1，序号seq=v），服务端进入CLOSE_WAIT（关闭等待）状态，此时的TCP处于半关闭状态，客户端到服务端的连接释放。客户端收到服务端的确认后，进入FIN_WAIT2（终止等待2）状态，等待服务端发出的连接释放报文段。\n   * 服务端没有要向客户端发出的数据，服务端发出连接释放报文段（FIN=1，ACK=1，序号seq=w，确认号ack=u+1），服务端进入LAST_ACK（最后确认）状态，等待客户端的确认。\n   * 客户端收到服务端的连接释放报文段后，对此发出确认报文段（ACK=1，seq=u+1，ack=w+1），客户端进入TIME_WAIT（时间等待）状态。此时TCP未释放掉，需要经过时间等待计时器设置的时间2MSL后，客户端才进入CLOSED状态。\n   \n   \n   \n   为什么是四次：\n   \n   这由TCP的半关闭（half-close）造成的。所谓的半关闭，其实就是TCP提供了连接的一端在结束它的发送后还能接收来自另一端数据的能力。\n   \n   为什么需要等待2个MSL\n   \n   防止主动接受方发送的最后确认报文，被动接受方没能接受到，触发被动接受方的超时重传，一来一回刚好两个2MSL\n   \n   MSL（Maximum Segment Lifetime）为报文最大生存时间，他是任何报文在网络上存在的最长时间，超过这个时间报文将会被丢弃，被接收方处理后又向发送方发送响应，一来一回需要等待2倍的时间\n   \n   为什么第二次挥手和第三次挥手不能合并成一次\n   \n   服务器需要先应答接受到了客户端需要断开的请求，但是服务器可能还有数据需要处理和发送，并且TCP具有一端在结束它发送后仍能接受数据的能力，因此服务器还能向客户端进行发送数据\n\n\n# TCP可靠传输\n\nTCP通过重传机制、流量控制、拥塞控制来实现可靠传输\n\n\n# 重传机制\n\n重传机制     描述\n超时重传     超出一定时间没有收到响应触发重传机制\n快速重传     连续收到三次相同的ACK触发重传机制\nSACK     TCP的字段中添加SACK，显示哪些数据被接收到\nD-SACK   用SACK字段表明哪些数据被重复接收，用ACK表明哪些字段丢失，可以用来检测是响应丢失还是请求丢失\n\nTCP超时重传和快速重传都是TCP协议在数据传输时使用的机制，用于提高数据传输的可靠性。它们的主要区别如下：\n\n 1. 触发机制：TCP超时重传是在发送数据后等待一段时间，如果未收到确认应答，就会触发重传机制；而快速重传是在接收到重复确认应答时触发的，这意味着网络出现拥塞，导致数据包丢失。\n 2. 重传次数：TCP超时重传会在每次超时后重传数据包，直到收到确认应答为止；而快速重传只会在接收到3个重复确认应答后立即重传数据包，避免了等待超时时间的延迟。\n 3. 对网络性能的影响：TCP超时重传会导致网络出现更多的拥塞，因为每次重传都会重新发送所有数据包，而这些数据包可能会增加网络拥塞的程度。而快速重传通过减少数据包的重传次数，可以减轻网络拥塞的程度。\n\n\n# 流量控制和拥塞控制的区别\n\nTCP流量控制和拥塞控制是TCP协议中两个重要的机制，它们的主要区别如下：\n\n 1. 目的不同：TCP流量控制的目的是确保发送方不会发送使接收方无法处理数据，通过动态调整发送方发送的数据量，控制接收方的接收速率，以达到平衡发送方和接收方之间的数据流量。拥塞控制则是为了防止网络拥塞而采取的一种机制。\n\n 2. 控制对象不同：TCP流量控制是对单个连接的发送方和接收方之间的数据流量进行控制，而拥塞控制是对整个网络的流量进行控制。\n\n 3. 触发机制不同：TCP流量控制是由接收方来触发的，当接收方处理不过来数据时，会发送窗口通告（Window Size），告诉发送方可以发送的数据量，从而控制发送方的发送速率。而拥塞控制则是由网络的拥塞情况来触发的，当网络拥塞时，发送方会收到拥塞信号（Congestion Signal），从而调整发送速率。\n\n 4. 实现方法不同：TCP流量控制通过调整窗口大小来控制发送方的发送速率。窗口大小是发送方和接收方之间的一个参数，发送方可以根据窗口大小来确定可以发送的数据量。而拥塞控制则采用了多种算法，例如TCP Reno、TCP Vegas等，通过不同的算法来调整发送方的发送速率，以避免网络拥塞。\n\n\n# 流量控制\n\n通过使用滑动窗口来进行流量控制\n\n * 滑动窗口的大小就是指发送方无需等待确认应答，而可以继续发送数据的最大值\n\n * 滑动窗口的大小是由接收方的窗口大小决定的：接收方告诉发送方自己有多少缓冲区可以接收数据，发送方根据这个接收端的处理能力来发送数据，而不会导致接收端处理不过来\n\n * 初始滑动窗口的大小=缓存池中数据量+动态变动后的滑动窗口大小\n\n注意事项：\n\n * 接收方需要更改滑动窗口的大小时，需要先发送更改大小的请求，然后再变更大小\n * 如果窗口大小为0的时，需要设置自动发送询问报文来询问接收方是否缓存池有可用大小（窗口关闭问题）\n * 滑动窗口过小的时候，不进行数据发送，等窗口恢复到一定大小时再进行发送（糊涂窗口综合症）\n\n\n# 拥塞控制\n\n根据网络环境（是否丢包）使用拥塞窗口进行拥塞控制，拥塞控制算法如下\n\n * 慢启动\n   \n   拥塞窗口<=慢启动门限：拥塞窗口呈指数型增长\n\n * 拥塞避免算法\n   \n   拥塞窗口>=慢启动门限：拥塞窗口呈线性增长\n\n * 拥塞发生算法\n   \n   出现丢包时：\n   \n   使用超时重传：慢启动门限=拥塞窗口/2｜拥塞窗口=1｜重新启动慢启动\n   \n   使用快速重传：拥塞窗口 = 拥塞窗口/2｜慢启动门限 = 拥塞窗口｜进入快速恢复算法\n\n * 快速恢复\n   \n   拥塞窗口 = 慢启动门限+3，通过重传一个包。\n   \n   如果接收到重复的ACK的话，那么拥塞窗口+1，继续重传\n   \n   如果是新的ACK，进入拥塞避免算法\n\n\n# TCP 序列号的作用\n\nTCP（传输控制协议）中的序列号用于标识TCP报文段中的数据部分。每个TCP报文段都包含一个序列号字段，该字段指示了报文段中第一个字节的序号。在后续的报文段中，序列号将递增，以指示下一个字节的序号。\n\nTCP序列号是一个32位的无符号整数。它是在TCP连接建立阶段由发送方随机生成的。序列号的初始值可以是任意值，但通常情况下，它是随机生成的。序列号的随机性可以减少连接被攻击者猜测、重放或欺骗的风险。\n\n在传输数据时，发送方将数据拆分成一个个TCP报文段，并将每个报文段中的数据部分按照序列号逐个发送。接收方在接收到报文段时，通过检查序列号字段来确定接收到的数据的顺序。如果接收到的报文段的序列号不是按照预期的顺序到达，则接收方可以丢弃该报文段并请求发送方重新发送该数据。\n\n在TCP连接中，序列号不仅用于标识数据部分的顺序，还用于实现TCP的流量控制和拥塞控制机制。TCP连接的每个端点都维护一个发送窗口和一个接收窗口。发送方使用序列号和发送窗口来确定可以发送的数据量，以避免发送方过度发送导致接收方无法处理的情况。接收方使用序列号和接收窗口来确定可以接收的数据量，并通知发送方窗口大小以控制发送速率，以避免网络拥塞。\n\n总之，TCP序列号是TCP连接中的重要组成部分，用于标识数据部分的顺序和实现TCP的流量控制和拥塞控制机制。它是由发送方随机生成的32位无符号整数。\n\nTCP的序列号总结起来主要有以下几个作用：\n\n 1. 数据分片与重组：当一个大数据包被分割成多个小的TCP报文段进行传输时，序列号用于标识这些报文段中的每一个字节。接收端通过检查序列号，可以准确地将这些报文段重新组合成完整的数据包。\n 2. 数据传输的可靠性：序列号用于追踪和确认已发送和已接收的数据。接收端发送确认（ACK）报文给发送端时，将确认的序列号放入ACK字段。这样，发送端就知道接收端已经成功接收到了该序列号之前的所有数据。\n 3. 流量控制：TCP使用滑动窗口机制进行流量控制。序列号与接收窗口大小一起，帮助发送端确定可以发送的数据量，防止接收端被发送端的数据淹没。\n 4. 防止旧报文段的干扰：在网络中，报文可能会因为各种原因而延迟到达目的地。序列号可以帮助接收端区分新旧报文段，从而避免因旧报文段的重传而引发的数据错误。\n\n\n# 滑动窗口和拥塞窗口\n\n * 滑动窗口，接收方通过通告发送方自己的可以接受缓冲区大小（这个字段越大说明网络吞吐量越高），从而控制发送方的发送速度。\n\n * 拥塞窗口：一个连接的TCP双端只是网络最边缘的两台主机，他们不知道整个网络是如何工作的，因此他们不知道彼此之间的有效吞吐量。因此，他们必须找到一种方法来确定它。我们称之为拥塞窗口 (CWND)。这是在我们必须停止并等待确认之前可以发送的字节数。拥塞窗口是决定任何时候可以发出的字节数的因素之一。拥塞窗口由发送方维护，是阻止发送方和接收方之间的链路因流量过多而过载的一种手段。这不应与发送方维护的滑动窗口相混淆，滑动窗口的存在是为了防止接收方过载。拥塞窗口是通过估计链路上有多少拥塞来计算的。\n\n共同点：提高网络性能。\n\n不同点：\n\n * 流量控制：在TCP连接上实现对发送流量的控制，考虑点对点之间对通信量的控制，端到端，即：控制发送端的数据发送速率，使接收端可以来得及接收，保证网络高效稳定运行。\n * 拥塞控制：处理网络拥塞现象，考虑网络能够承受现有的网络负荷，全局性变量，涉及所有的路由器、主机以及与降低网络传输性能有关的因素。防止过多的数据注入到网络，使网络中的路由器或链路不致过载，确保通信子网可以有效为主机传递分组。",normalizedContent:"# tcp和udp的区别\n\n用户数据报协议udp（user datagram protocol）：\n\n是无连接的；尽最大可能交付；不能保证数据顺序；没有拥塞控制；面向报文（对于应用程序传下来的报文不合并也不拆分，只是添加udp首部）；支持一对一、一对多、多对一和多对多的交互通信。\n\n传输控制协议tcp（transmission control protocol）：\n\n是面向连接的；提供可靠交付；保证数据顺序（由于使用序号）；有流量控制；有拥塞控制；提供全双工通信；面向字节流（把应用层传下来的报文看成字节流，把字节流组织成大小不等的数据块）；仅支持一对一。\n\n\n * tcp是面向连接的可靠传输协议，是面向字节流的，会发生粘包和拆包现象，有流量控制和拥塞控制保证可靠传输，适合要求对数据传输可靠性要求高的场景。\n\n * udp是无连接的，不可靠的传输协议，会尽最大努力进行交付，面向报文，不会进行拆分和合并，没有拥塞控制，适合允许数据小量丢失的场景，能够实现1对1，1对多，多对多的实时交互通信。\n\n * udp首部长度只有8b，比tcp小。\n\n * 面向连接：一定是「一对一」才能连接，不能像 udp 协议可以一个主机同时向多个主机发送消息，也就是一对多是无法做到的。\n\n * 可靠交付：无论的网络链路中出现了怎样的链路变化，tcp 都可以保证一个报文一定能够到达接收端。\n\n * 面向字节流：也就是说仅仅把上层协议传递过来的数据当成字节传输。\n\n\n# tcp和udp应用\n\ntcp：要求通信数据的完整性和准确性较高（文件传输、邮件发送、重要状态的更新）\n\nudp：要求通信响应度高，对数据信息的安全性和完整性要求较低（网络电话、网络视频）\n\n\n# 字节流和报文段\n\n区分字节流和报文关键在于：对使用协议的用户而言，读数据的时候，是不是有“边界”，有边界就是报文，没有边界就是字节流\n\n没有边界：上层协议读取数据的时候不知道读到了几个tcp数据包（因为有缓冲池，所以发送端发送数据和接收端处理数据的频率是可以不对等的）\n\n有边界：上层协议每一次读取必定是一个数据包（没有缓冲池）\n\n\n# tcp粘包、拆包问题\n\ntcp 是以流的方式来处理数据，一个完整的包可能会被 tcp 拆分成多个包进行发送，也可能把小的封装成一个大的数据包发送。\n\n\n发送方：关闭nagle算法。接收方：没法处理，只能交给应用层来进行处理\n\n应用层：\n\n * 使用标准的应用层协议（http，https等）来封装要传输的不定长的数据包\n * 在每条数据的尾部添加特殊字符，如果遇到特殊字符表明当条数据接受完毕\n * 在发送数据前添加包头，数据格式为：数据头+数据块\n\n\nnetty的解决方案：\n\n * 消息定长：fixedlengthframedecoder\n * 包尾增加特殊字符分割：\n   * 行分隔符类：linebasedframedecoder\n   * 自定义分隔符类 ：delimiterbasedframedecoder\n * 将消息分为消息头和消息体：lengthfieldbasedframedecoder 类。分为有头部的拆包与粘包、长度字段在前且有头部的拆包与粘包、多扩展头部的拆包与粘包。\n\n也可以使用自定义协议，通过字段标明包长度。\n\n\n# tcp三次握手\n\n过程：\n\n * a 向 b 发送连接请求报文，syn=1，ack=0，seq=x。\n * b 收到连接请求报文，如果同意建立连接，则向 a 发送连接确认报文，syn=1，ack=1，ack=x+1，seq= y。\n * a 收到 b 的连接确认报文后，还要向 b 发出确认，ack=1，ack= y+1，seq=x+1。\n\n第二次握手完成后syn将被置为0，第三次握手可以携带数据，前两次不可以携带数据。\n\n为什么需要三次？\n\n * 三次连接才能可靠的同步双方的初始序列号。【tcp的可靠传输是靠同步序列号实现：序列号能保证数据包不重复、不丢弃和按序传输】\n * 防止重复的历史连接的建立，造成混乱。\n * 避免资源浪费。【重传情况】\n\n重复历史连接建立的具体场景：客户端先发送了 syn（seq = 90） 报文，然后客户端宕机了，而且这个 syn 报文还被网络阻塞了，服务端并没有收到，接着客户端重启后，又重新向服务端建立连接，发送了 syn（seq = 100） 报文（注意不是重传 syn，重传的 syn 的序列号是一样的）。\n\n客户端连续发送多次 syn 建立连接的报文，在网络拥堵情况下：\n\n * 一个「旧 syn 报文」比「最新的 syn 」 报文早到达了服务端；\n * 那么此时服务端就会回一个 syn + ack 报文给客户端；\n * 客户端收到后可以根据自身的上下文，判断这是一个历史连接（序列号过期或超时），那么客户端就会发送 rst 报文给服务端，表示中止这一次连接。\n\n**如果是两次握手连接，就无法阻止历史连接。**两次握手的情况下，「被动发起方」在收到 syn 报文后，就进入 established 状态，意味着这时可以给对方发送数据，但是「主动发起方」此时还没有进入 established 状态，假设这次是历史连接，「主动发起方」判断到此次连接为历史连接，那么就会回 rst 报文来断开连接，而「被动发起方」在第一次握手的时候就进入 established 状态，所以它可以发送数据的，但是它并不知道这个是历史连接，它只有在收到 rst 报文后，才会断开连接。\n\n两次握手的话，当客户端连续发送多个建立连接的报文，在网络阻塞的情况下，由于服务端收到应答后就建立了连接，所以会造成服务端多个连接的建立，从而尝试混乱。\n\n\n# tcp四次挥手\n\n * 过程：\n   \n   * 客户端发出连接释放报文段（fin=1，序号seq=u），并停止再发送数据，主动关闭tcp连接，进入fin_wait1（终止等待1）状态，等待服务端的确认。\n   * 服务端收到连接释放报文段后即发出确认报文段（ack=1，确认号ack=u+1，序号seq=v），服务端进入close_wait（关闭等待）状态，此时的tcp处于半关闭状态，客户端到服务端的连接释放。客户端收到服务端的确认后，进入fin_wait2（终止等待2）状态，等待服务端发出的连接释放报文段。\n   * 服务端没有要向客户端发出的数据，服务端发出连接释放报文段（fin=1，ack=1，序号seq=w，确认号ack=u+1），服务端进入last_ack（最后确认）状态，等待客户端的确认。\n   * 客户端收到服务端的连接释放报文段后，对此发出确认报文段（ack=1，seq=u+1，ack=w+1），客户端进入time_wait（时间等待）状态。此时tcp未释放掉，需要经过时间等待计时器设置的时间2msl后，客户端才进入closed状态。\n   \n   \n   \n   为什么是四次：\n   \n   这由tcp的半关闭（half-close）造成的。所谓的半关闭，其实就是tcp提供了连接的一端在结束它的发送后还能接收来自另一端数据的能力。\n   \n   为什么需要等待2个msl\n   \n   防止主动接受方发送的最后确认报文，被动接受方没能接受到，触发被动接受方的超时重传，一来一回刚好两个2msl\n   \n   msl（maximum segment lifetime）为报文最大生存时间，他是任何报文在网络上存在的最长时间，超过这个时间报文将会被丢弃，被接收方处理后又向发送方发送响应，一来一回需要等待2倍的时间\n   \n   为什么第二次挥手和第三次挥手不能合并成一次\n   \n   服务器需要先应答接受到了客户端需要断开的请求，但是服务器可能还有数据需要处理和发送，并且tcp具有一端在结束它发送后仍能接受数据的能力，因此服务器还能向客户端进行发送数据\n\n\n# tcp可靠传输\n\ntcp通过重传机制、流量控制、拥塞控制来实现可靠传输\n\n\n# 重传机制\n\n重传机制     描述\n超时重传     超出一定时间没有收到响应触发重传机制\n快速重传     连续收到三次相同的ack触发重传机制\nsack     tcp的字段中添加sack，显示哪些数据被接收到\nd-sack   用sack字段表明哪些数据被重复接收，用ack表明哪些字段丢失，可以用来检测是响应丢失还是请求丢失\n\ntcp超时重传和快速重传都是tcp协议在数据传输时使用的机制，用于提高数据传输的可靠性。它们的主要区别如下：\n\n 1. 触发机制：tcp超时重传是在发送数据后等待一段时间，如果未收到确认应答，就会触发重传机制；而快速重传是在接收到重复确认应答时触发的，这意味着网络出现拥塞，导致数据包丢失。\n 2. 重传次数：tcp超时重传会在每次超时后重传数据包，直到收到确认应答为止；而快速重传只会在接收到3个重复确认应答后立即重传数据包，避免了等待超时时间的延迟。\n 3. 对网络性能的影响：tcp超时重传会导致网络出现更多的拥塞，因为每次重传都会重新发送所有数据包，而这些数据包可能会增加网络拥塞的程度。而快速重传通过减少数据包的重传次数，可以减轻网络拥塞的程度。\n\n\n# 流量控制和拥塞控制的区别\n\ntcp流量控制和拥塞控制是tcp协议中两个重要的机制，它们的主要区别如下：\n\n 1. 目的不同：tcp流量控制的目的是确保发送方不会发送使接收方无法处理数据，通过动态调整发送方发送的数据量，控制接收方的接收速率，以达到平衡发送方和接收方之间的数据流量。拥塞控制则是为了防止网络拥塞而采取的一种机制。\n\n 2. 控制对象不同：tcp流量控制是对单个连接的发送方和接收方之间的数据流量进行控制，而拥塞控制是对整个网络的流量进行控制。\n\n 3. 触发机制不同：tcp流量控制是由接收方来触发的，当接收方处理不过来数据时，会发送窗口通告（window size），告诉发送方可以发送的数据量，从而控制发送方的发送速率。而拥塞控制则是由网络的拥塞情况来触发的，当网络拥塞时，发送方会收到拥塞信号（congestion signal），从而调整发送速率。\n\n 4. 实现方法不同：tcp流量控制通过调整窗口大小来控制发送方的发送速率。窗口大小是发送方和接收方之间的一个参数，发送方可以根据窗口大小来确定可以发送的数据量。而拥塞控制则采用了多种算法，例如tcp reno、tcp vegas等，通过不同的算法来调整发送方的发送速率，以避免网络拥塞。\n\n\n# 流量控制\n\n通过使用滑动窗口来进行流量控制\n\n * 滑动窗口的大小就是指发送方无需等待确认应答，而可以继续发送数据的最大值\n\n * 滑动窗口的大小是由接收方的窗口大小决定的：接收方告诉发送方自己有多少缓冲区可以接收数据，发送方根据这个接收端的处理能力来发送数据，而不会导致接收端处理不过来\n\n * 初始滑动窗口的大小=缓存池中数据量+动态变动后的滑动窗口大小\n\n注意事项：\n\n * 接收方需要更改滑动窗口的大小时，需要先发送更改大小的请求，然后再变更大小\n * 如果窗口大小为0的时，需要设置自动发送询问报文来询问接收方是否缓存池有可用大小（窗口关闭问题）\n * 滑动窗口过小的时候，不进行数据发送，等窗口恢复到一定大小时再进行发送（糊涂窗口综合症）\n\n\n# 拥塞控制\n\n根据网络环境（是否丢包）使用拥塞窗口进行拥塞控制，拥塞控制算法如下\n\n * 慢启动\n   \n   拥塞窗口<=慢启动门限：拥塞窗口呈指数型增长\n\n * 拥塞避免算法\n   \n   拥塞窗口>=慢启动门限：拥塞窗口呈线性增长\n\n * 拥塞发生算法\n   \n   出现丢包时：\n   \n   使用超时重传：慢启动门限=拥塞窗口/2｜拥塞窗口=1｜重新启动慢启动\n   \n   使用快速重传：拥塞窗口 = 拥塞窗口/2｜慢启动门限 = 拥塞窗口｜进入快速恢复算法\n\n * 快速恢复\n   \n   拥塞窗口 = 慢启动门限+3，通过重传一个包。\n   \n   如果接收到重复的ack的话，那么拥塞窗口+1，继续重传\n   \n   如果是新的ack，进入拥塞避免算法\n\n\n# tcp 序列号的作用\n\ntcp（传输控制协议）中的序列号用于标识tcp报文段中的数据部分。每个tcp报文段都包含一个序列号字段，该字段指示了报文段中第一个字节的序号。在后续的报文段中，序列号将递增，以指示下一个字节的序号。\n\ntcp序列号是一个32位的无符号整数。它是在tcp连接建立阶段由发送方随机生成的。序列号的初始值可以是任意值，但通常情况下，它是随机生成的。序列号的随机性可以减少连接被攻击者猜测、重放或欺骗的风险。\n\n在传输数据时，发送方将数据拆分成一个个tcp报文段，并将每个报文段中的数据部分按照序列号逐个发送。接收方在接收到报文段时，通过检查序列号字段来确定接收到的数据的顺序。如果接收到的报文段的序列号不是按照预期的顺序到达，则接收方可以丢弃该报文段并请求发送方重新发送该数据。\n\n在tcp连接中，序列号不仅用于标识数据部分的顺序，还用于实现tcp的流量控制和拥塞控制机制。tcp连接的每个端点都维护一个发送窗口和一个接收窗口。发送方使用序列号和发送窗口来确定可以发送的数据量，以避免发送方过度发送导致接收方无法处理的情况。接收方使用序列号和接收窗口来确定可以接收的数据量，并通知发送方窗口大小以控制发送速率，以避免网络拥塞。\n\n总之，tcp序列号是tcp连接中的重要组成部分，用于标识数据部分的顺序和实现tcp的流量控制和拥塞控制机制。它是由发送方随机生成的32位无符号整数。\n\ntcp的序列号总结起来主要有以下几个作用：\n\n 1. 数据分片与重组：当一个大数据包被分割成多个小的tcp报文段进行传输时，序列号用于标识这些报文段中的每一个字节。接收端通过检查序列号，可以准确地将这些报文段重新组合成完整的数据包。\n 2. 数据传输的可靠性：序列号用于追踪和确认已发送和已接收的数据。接收端发送确认（ack）报文给发送端时，将确认的序列号放入ack字段。这样，发送端就知道接收端已经成功接收到了该序列号之前的所有数据。\n 3. 流量控制：tcp使用滑动窗口机制进行流量控制。序列号与接收窗口大小一起，帮助发送端确定可以发送的数据量，防止接收端被发送端的数据淹没。\n 4. 防止旧报文段的干扰：在网络中，报文可能会因为各种原因而延迟到达目的地。序列号可以帮助接收端区分新旧报文段，从而避免因旧报文段的重传而引发的数据错误。\n\n\n# 滑动窗口和拥塞窗口\n\n * 滑动窗口，接收方通过通告发送方自己的可以接受缓冲区大小（这个字段越大说明网络吞吐量越高），从而控制发送方的发送速度。\n\n * 拥塞窗口：一个连接的tcp双端只是网络最边缘的两台主机，他们不知道整个网络是如何工作的，因此他们不知道彼此之间的有效吞吐量。因此，他们必须找到一种方法来确定它。我们称之为拥塞窗口 (cwnd)。这是在我们必须停止并等待确认之前可以发送的字节数。拥塞窗口是决定任何时候可以发出的字节数的因素之一。拥塞窗口由发送方维护，是阻止发送方和接收方之间的链路因流量过多而过载的一种手段。这不应与发送方维护的滑动窗口相混淆，滑动窗口的存在是为了防止接收方过载。拥塞窗口是通过估计链路上有多少拥塞来计算的。\n\n共同点：提高网络性能。\n\n不同点：\n\n * 流量控制：在tcp连接上实现对发送流量的控制，考虑点对点之间对通信量的控制，端到端，即：控制发送端的数据发送速率，使接收端可以来得及接收，保证网络高效稳定运行。\n * 拥塞控制：处理网络拥塞现象，考虑网络能够承受现有的网络负荷，全局性变量，涉及所有的路由器、主机以及与降低网络传输性能有关的因素。防止过多的数据注入到网络，使网络中的路由器或链路不致过载，确保通信子网可以有效为主机传递分组。",charsets:{cjk:!0},lastUpdated:"2023/03/29, 21:03:43",lastUpdatedTimestamp:1680095023e3},{title:"IP",frontmatter:{title:"IP",date:"2023-03-21T20:54:06.000Z",permalink:"/pages/42791d/"},regularPath:"/04.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/04.%E7%BD%91%E7%BB%9C%E5%B1%82/01.IP.html",relativePath:"04.计算机网络/04.网络层/01.IP.md",key:"v-1d611f27",path:"/pages/42791d/",headers:[{level:2,title:"IP划分",slug:"ip划分",normalizedTitle:"ip划分",charIndex:34},{level:3,title:"ABCDE类网络",slug:"abcde类网络",normalizedTitle:"abcde类网络",charIndex:140},{level:3,title:"CIDR",slug:"cidr",normalizedTitle:"cidr",charIndex:116},{level:3,title:"子网掩码",slug:"子网掩码",normalizedTitle:"子网掩码",charIndex:121},{level:2,title:"公/私有IP",slug:"公-私有ip",normalizedTitle:"公/私有ip",charIndex:523},{level:2,title:"NAT",slug:"nat",normalizedTitle:"nat",charIndex:596}],headersStr:"IP划分 ABCDE类网络 CIDR 子网掩码 公/私有IP NAT",content:"IP的作用是在复杂的网络环境中将数据包发送给最终目的的主机\n\n\n# IP划分\n\nIP划分的优势\n\n如果网络号相同表示在同一个本地网络上，可以直接把数据包发送到目标主机。如果不同，网络号也可以配合路由来进行寻址工作。\n\nABCDE类、CIDR、子网掩码均可对IP进行分类：\n\n\n# ABCDE类网络\n\nABC类划分为网络号+主机号，分别A类1+7+24，B类2+14+16，C类3+21+8\n\nD类用于多播\n\nE类保留\n\n主机号全为1表示广播（本地广播和直接广播），主机号全为0表示某个网络\n\n优势：ABC类的划分，可以仅仅依靠头部几位数字判断出是哪类网络，并可以很快找出网络地址和主机地址\n\n缺点：ABC类不能很好的实现显示网络匹配，C类太少，B类太多\n\n\n# CIDR\n\n32位地址仅被划分为网络号+主机号：a.b.c.d/x(前x位是网络号)\n\n有点：用于很好的实现主机数目的划分\n\n\n# 子网掩码\n\n既可以用来划分网络号+主机号，又可以进一步划分主机号，划分为子网网络地址+子网主机地址\n\n优势：通过划分子网，可以1.节约IP地址，避免浪费。2.提高网络性能。3.可以保证网络的安全。4.易于扩大地理范围，有助于覆盖大型地理区域。\n\n\n# 公/私有IP\n\nipconfig查出来的是私有IP，只能在局域网中使用，不能上网。\n\n百度搜索出来的是共有IP，能上网，一般是运营商的。\n\n\n# NAT\n\n * NAT（Network Address Translation）网络地址转换\n   \n   私有IP在对外部通信的时候，将私有IP转化为NAT路由器的公有IP，解决IP地址不足的问题。\n\n * NAPT（Network Address and Port Translation）网络地址端口转换\n   \n   私有IP在对外部通信的时候，将私有IP转化为NAT路由器的公有IP+独一无二的端口号（并将私有IP和公有IP+端口号记录在转换表中，连接结束以后再转换表中删除）\n   \n   缺点：\n   \n   1.外部无法主动与NAT内部服务器建立连接，因为NAPT转换表没有转换记录\n   \n   2.转换表的生成与转换操作都会产生性能的开销\n   \n   3.通信过程中，如果NAT路由器重启，所有TCP连接都将被重制\n   \n   解决方法：\n   \n   NAT穿透技术：客户端主动从NAT设备获取公有IP地址，然后自己建立端口映射条目，然后用这个条目对外通信。",normalizedContent:"ip的作用是在复杂的网络环境中将数据包发送给最终目的的主机\n\n\n# ip划分\n\nip划分的优势\n\n如果网络号相同表示在同一个本地网络上，可以直接把数据包发送到目标主机。如果不同，网络号也可以配合路由来进行寻址工作。\n\nabcde类、cidr、子网掩码均可对ip进行分类：\n\n\n# abcde类网络\n\nabc类划分为网络号+主机号，分别a类1+7+24，b类2+14+16，c类3+21+8\n\nd类用于多播\n\ne类保留\n\n主机号全为1表示广播（本地广播和直接广播），主机号全为0表示某个网络\n\n优势：abc类的划分，可以仅仅依靠头部几位数字判断出是哪类网络，并可以很快找出网络地址和主机地址\n\n缺点：abc类不能很好的实现显示网络匹配，c类太少，b类太多\n\n\n# cidr\n\n32位地址仅被划分为网络号+主机号：a.b.c.d/x(前x位是网络号)\n\n有点：用于很好的实现主机数目的划分\n\n\n# 子网掩码\n\n既可以用来划分网络号+主机号，又可以进一步划分主机号，划分为子网网络地址+子网主机地址\n\n优势：通过划分子网，可以1.节约ip地址，避免浪费。2.提高网络性能。3.可以保证网络的安全。4.易于扩大地理范围，有助于覆盖大型地理区域。\n\n\n# 公/私有ip\n\nipconfig查出来的是私有ip，只能在局域网中使用，不能上网。\n\n百度搜索出来的是共有ip，能上网，一般是运营商的。\n\n\n# nat\n\n * nat（network address translation）网络地址转换\n   \n   私有ip在对外部通信的时候，将私有ip转化为nat路由器的公有ip，解决ip地址不足的问题。\n\n * napt（network address and port translation）网络地址端口转换\n   \n   私有ip在对外部通信的时候，将私有ip转化为nat路由器的公有ip+独一无二的端口号（并将私有ip和公有ip+端口号记录在转换表中，连接结束以后再转换表中删除）\n   \n   缺点：\n   \n   1.外部无法主动与nat内部服务器建立连接，因为napt转换表没有转换记录\n   \n   2.转换表的生成与转换操作都会产生性能的开销\n   \n   3.通信过程中，如果nat路由器重启，所有tcp连接都将被重制\n   \n   解决方法：\n   \n   nat穿透技术：客户端主动从nat设备获取公有ip地址，然后自己建立端口映射条目，然后用这个条目对外通信。",charsets:{cjk:!0},lastUpdated:"2023/03/29, 21:03:43",lastUpdatedTimestamp:1680095023e3},{title:"Ctrl+C发生了什么",frontmatter:{title:"Ctrl+C发生了什么",date:"2023-08-28T20:58:16.000Z",permalink:"/pages/0b3887/"},regularPath:"/05.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/02.Ctrl+C%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88.html",relativePath:"05.操作系统/02.Ctrl+C发生了什么.md",key:"v-8153bf3c",path:"/pages/0b3887/",headersStr:null,content:"https://www.timiguo.com/archives/209/\n\n用户按下Ctrl-C，这个键盘输入产生一个硬件中断。\n\n如果CPU当前正在执行这个进程的代码，则该进程的用户空间代码暂停执行，CPU从用户态切换到内核态处理硬件中断。\n\n终端驱动程序将Ctrl-C解释成一个SIGINT信号，记在该进程的PCB中（也可以说发送了一个SIGINT信号给该进程）。\n\n当某个时刻要从内核返回到该进程的用户空间代码继续执行之前，首先处理PCB中记录的信号，发现有一个SIGINT信号待处理，而这个信号的默认处理动作是终止进程，所以直接终止进程而不再返回它的用户空间代码执行。\n\n注意，Ctrl-C产生的信号只能发给前台进程。一个命令后面加个&可以放到后台运行，这样Shell不必等待进程结束就可以接受新的命令，启动新的进程。Shell可以同时运行一个前台进程和任意多个后台进程，只有前台进程才能接到像Ctrl-C这种控制键产生的信号。前台进程在运行过程中用户随时可能按下Ctrl-C而产生一个信号，也就是说该进程的用户空间代码执行到任何地方都有可能收到SIGINT信号而终止，所以信号相对于进程的控制流程来说是异步（Asynchronous）的。\n\n软中断信号（signal，又简称为信号）用来通知进程发生了异步事件。在软件层次上是对中断机制的一种模拟，在原理上，一个进程收到一个信号与处理器收到一个中断请求可以说是一样的。信号是进程间通信机制中唯一的异步通信机制，一个进程不必通过任何操作来等待信号的到达，事实上，进程也不知道信号到底什么时候到达。进程之间可以互相通过系统调用kill发送软中断信号。内核也可以因为内部事件而给进程发送信号，通知进程发生了某个事件。信号机制除了基本通知功能外，还可以传递附加信息。",normalizedContent:"https://www.timiguo.com/archives/209/\n\n用户按下ctrl-c，这个键盘输入产生一个硬件中断。\n\n如果cpu当前正在执行这个进程的代码，则该进程的用户空间代码暂停执行，cpu从用户态切换到内核态处理硬件中断。\n\n终端驱动程序将ctrl-c解释成一个sigint信号，记在该进程的pcb中（也可以说发送了一个sigint信号给该进程）。\n\n当某个时刻要从内核返回到该进程的用户空间代码继续执行之前，首先处理pcb中记录的信号，发现有一个sigint信号待处理，而这个信号的默认处理动作是终止进程，所以直接终止进程而不再返回它的用户空间代码执行。\n\n注意，ctrl-c产生的信号只能发给前台进程。一个命令后面加个&可以放到后台运行，这样shell不必等待进程结束就可以接受新的命令，启动新的进程。shell可以同时运行一个前台进程和任意多个后台进程，只有前台进程才能接到像ctrl-c这种控制键产生的信号。前台进程在运行过程中用户随时可能按下ctrl-c而产生一个信号，也就是说该进程的用户空间代码执行到任何地方都有可能收到sigint信号而终止，所以信号相对于进程的控制流程来说是异步（asynchronous）的。\n\n软中断信号（signal，又简称为信号）用来通知进程发生了异步事件。在软件层次上是对中断机制的一种模拟，在原理上，一个进程收到一个信号与处理器收到一个中断请求可以说是一样的。信号是进程间通信机制中唯一的异步通信机制，一个进程不必通过任何操作来等待信号的到达，事实上，进程也不知道信号到底什么时候到达。进程之间可以互相通过系统调用kill发送软中断信号。内核也可以因为内部事件而给进程发送信号，通知进程发生了某个事件。信号机制除了基本通知功能外，还可以传递附加信息。",charsets:{cjk:!0}},{title:"搜索效率为log的树",frontmatter:{title:"搜索效率为log的树",date:"2023-03-23T16:10:07.000Z",permalink:"/pages/f45a99/"},regularPath:"/06.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/01.%E6%90%9C%E7%B4%A2%E6%95%88%E7%8E%87%E4%B8%BAlog%E7%9A%84%E6%A0%91.html",relativePath:"06.数据结构和算法/01.搜索效率为log的树.md",key:"v-8f229662",path:"/pages/f45a99/",headersStr:null,content:" 1. 二叉搜索树（BST）：二叉搜索树是一种常用的树形数据结构，具有良好的搜索效率。它的每个节点都具有一个键值，且节点的左子树键值小于该节点的键值，节点的右子树键值大于该节点的键值。在二叉搜索树中查找某个元素时，每次都可以排除一半的元素，因此搜索效率为对数级别。\n 2. 平衡二叉搜索树（AVL树）：平衡二叉搜索树也是一种二叉搜索树，它能够自动平衡节点的高度，以保证查询的效率。AVL树中任何节点的左右子树高度最多相差1，因此在AVL树中查找元素的时间复杂度为O(log n)。\n 3. 红黑树：红黑树也是一种自平衡的二叉搜索树，具有良好的搜索效率。红黑树的每个节点都有一个颜色（红色或黑色），并且满足以下几个条件：（1）根节点是黑色的；（2）每个叶子节点都是黑色的空节点；（3）每个红色节点的两个子节点都是黑色的；（4）从任意节点到其每个叶子节点的所有路径都包含相同数目的黑色节点。在红黑树中查找元素的时间复杂度为O(log n)。\n 4. B树：B树是一种多路搜索树，每个节点可以有多个子节点。B树的每个节点都包含多个关键字，并且按照大小排序。在B树中查找元素的时间复杂度也为O(log n)。B树被广泛应用于文件系统、数据库系统等领域。\n 5. B+树：B+ 树在B树的基础上，为叶子节点增加了链表指针，所有数据都存储在叶子节点。非叶子节点作为叶子节点的索引。",normalizedContent:" 1. 二叉搜索树（bst）：二叉搜索树是一种常用的树形数据结构，具有良好的搜索效率。它的每个节点都具有一个键值，且节点的左子树键值小于该节点的键值，节点的右子树键值大于该节点的键值。在二叉搜索树中查找某个元素时，每次都可以排除一半的元素，因此搜索效率为对数级别。\n 2. 平衡二叉搜索树（avl树）：平衡二叉搜索树也是一种二叉搜索树，它能够自动平衡节点的高度，以保证查询的效率。avl树中任何节点的左右子树高度最多相差1，因此在avl树中查找元素的时间复杂度为o(log n)。\n 3. 红黑树：红黑树也是一种自平衡的二叉搜索树，具有良好的搜索效率。红黑树的每个节点都有一个颜色（红色或黑色），并且满足以下几个条件：（1）根节点是黑色的；（2）每个叶子节点都是黑色的空节点；（3）每个红色节点的两个子节点都是黑色的；（4）从任意节点到其每个叶子节点的所有路径都包含相同数目的黑色节点。在红黑树中查找元素的时间复杂度为o(log n)。\n 4. b树：b树是一种多路搜索树，每个节点可以有多个子节点。b树的每个节点都包含多个关键字，并且按照大小排序。在b树中查找元素的时间复杂度也为o(log n)。b树被广泛应用于文件系统、数据库系统等领域。\n 5. b+树：b+ 树在b树的基础上，为叶子节点增加了链表指针，所有数据都存储在叶子节点。非叶子节点作为叶子节点的索引。",charsets:{cjk:!0},lastUpdated:"2023/03/29, 21:03:43",lastUpdatedTimestamp:1680095023e3},{title:"二分查找",frontmatter:{title:"二分查找",date:"2023-04-20T15:36:10.000Z",permalink:"/pages/37ba80/"},regularPath:"/06.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/02.%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE.html",relativePath:"06.数据结构和算法/02.二分查找.md",key:"v-8bbcfd3a",path:"/pages/37ba80/",headersStr:null,content:"public int lowerBound(int[] nums, int target) {\n  int left = 0, right = nums.length - 1; // 闭区间 [left, right]\n  while (left <= right) { // 区间不为空\n    int mid = left + right >>> 1;\n    if (nums[mid] < target) left = mid + 1; // [mid + 1, right]\n    else right = mid - 1; // [left, mid -  1];\n  }\n  return left; // 返回right + 1也行\n}\n\npublic int lowerBound2(int[] nums, int target) {\n  int left = 0, right = nums.length; //左闭右开区间 [left, right)\n  while (left < right) {\n    int mid = left + right >>> 1;\n    if (nums[mid] < target) left = mid + 1; // [mid + 1, right)\n    else right = mid; // [left, mid)\n  }\n  return left; // 返回 right 也行\n}\n\npublic int lowerBound3(int[] nums, int target) {\n  int left = -1, right = nums.length; // 开区间 (left, right)\n  while (left + 1 < right) { \n    int mid = left + right >>> 1;\n    if (nums[mid] < target) left = mid; // (mid, right)\n    else right = mid; // (left, mid)\n  }\n  return right;\n}\n\n\n上面模板是找 >= target 的第一个数（最左边）\n\n找 > target 的数，等价于 >= target + 1（最右边 + 1）\n\n找 < target 的数，等价于 >= target - 1（最左边 - 1）\n\n找 <= target 的数，等价于 > target - 1 （最右边）",normalizedContent:"public int lowerbound(int[] nums, int target) {\n  int left = 0, right = nums.length - 1; // 闭区间 [left, right]\n  while (left <= right) { // 区间不为空\n    int mid = left + right >>> 1;\n    if (nums[mid] < target) left = mid + 1; // [mid + 1, right]\n    else right = mid - 1; // [left, mid -  1];\n  }\n  return left; // 返回right + 1也行\n}\n\npublic int lowerbound2(int[] nums, int target) {\n  int left = 0, right = nums.length; //左闭右开区间 [left, right)\n  while (left < right) {\n    int mid = left + right >>> 1;\n    if (nums[mid] < target) left = mid + 1; // [mid + 1, right)\n    else right = mid; // [left, mid)\n  }\n  return left; // 返回 right 也行\n}\n\npublic int lowerbound3(int[] nums, int target) {\n  int left = -1, right = nums.length; // 开区间 (left, right)\n  while (left + 1 < right) { \n    int mid = left + right >>> 1;\n    if (nums[mid] < target) left = mid; // (mid, right)\n    else right = mid; // (left, mid)\n  }\n  return right;\n}\n\n\n上面模板是找 >= target 的第一个数（最左边）\n\n找 > target 的数，等价于 >= target + 1（最右边 + 1）\n\n找 < target 的数，等价于 >= target - 1（最左边 - 1）\n\n找 <= target 的数，等价于 > target - 1 （最右边）",charsets:{cjk:!0}},{title:"操作系统",frontmatter:{title:"操作系统",date:"2023-03-30T13:45:12.000Z",permalink:"/pages/os/"},regularPath:"/05.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/01.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html",relativePath:"05.操作系统/01.操作系统.md",key:"v-45ced8ca",path:"/pages/os/",headers:[{level:2,title:"并行和并发",slug:"并行和并发",normalizedTitle:"并行和并发",charIndex:2},{level:2,title:"同步、异步、阻塞、非阻塞",slug:"同步、异步、阻塞、非阻塞",normalizedTitle:"同步、异步、阻塞、非阻塞",charIndex:88},{level:2,title:"进程和线程",slug:"进程和线程",normalizedTitle:"进程和线程",charIndex:269},{level:2,title:"有进程为什么还要有线程",slug:"有进程为什么还要有线程",normalizedTitle:"有进程为什么还要有线程",charIndex:1230},{level:2,title:"携程",slug:"携程",normalizedTitle:"携程",charIndex:1437},{level:2,title:"进程的状态转换",slug:"进程的状态转换",normalizedTitle:"进程的状态转换",charIndex:1829},{level:2,title:"进程间的通信方式",slug:"进程间的通信方式",normalizedTitle:"进程间的通信方式",charIndex:1882},{level:2,title:"进程调度算法",slug:"进程调度算法",normalizedTitle:"进程调度算法",charIndex:2726},{level:2,title:"用户态和内核态",slug:"用户态和内核态",normalizedTitle:"用户态和内核态",charIndex:2838},{level:2,title:"为什么要有用户态和内核态呢？",slug:"为什么要有用户态和内核态呢",normalizedTitle:"为什么要有用户态和内核态呢？",charIndex:3062},{level:2,title:"用户态和内核态是如何切换的？",slug:"用户态和内核态是如何切换的",normalizedTitle:"用户态和内核态是如何切换的？",charIndex:3160}],headersStr:"并行和并发 同步、异步、阻塞、非阻塞 进程和线程 有进程为什么还要有线程 携程 进程的状态转换 进程间的通信方式 进程调度算法 用户态和内核态 为什么要有用户态和内核态呢？ 用户态和内核态是如何切换的？",content:"# 并行和并发\n\n并行是指两个或者多个事件在同一时刻发生；而并发是指两个或多个事件在同一时间间隔发生；\n\n并行是在不同实体上的多个事件，并发是在同一实体上的多个事件；\n\n\n# 同步、异步、阻塞、非阻塞\n\n同步：当一个同步调用发出后，调用者要一直等待返回结果。通知后，才能进行后续的执行。\n\n异步：当一个异步过程调用发出后，调用者不能立刻得到返回结果。实际处理这个调用的部件在完成后，通过状态、通知和回调来通知调用者。\n\n阻塞：是指调用结果返回前，当前线程会被挂起，即阻塞。\n\n非阻塞：是指即使调用结果没返回，也不会阻塞当前线程。\n\n\n# 进程和线程\n\n进程和线程是操作系统中的两个基本概念，它们都是程序运行的基本单位。\n\n进程是指正在运行的一个程序实例。每个进程都有自己的地址空间、数据栈、文件句柄、系统资源等，可以独立地运行、停止和调度。操作系统为每个进程分配唯一的进程标识符PID，用于标识和管理进程。每个进程可以包含一个或多个线程。\n\n线程是进程的一个执行单元。一个进程可以包含多个线程，每个线程共享相同的地址空间和系统资源，包括打开的文件、信号处理程序、用户ID和组ID等。线程与进程不同，线程没有独立的地址空间，一个进程中的所有线程共享相同的地址空间和系统资源，因此线程之间的通信和同步更加容易和高效。\n\n与进程相比，线程的优点是更加轻量级和高效，线程之间的切换开销更小，可以更好地利用多核CPU，同时线程之间的通信和同步更加容易和高效。因此，在实际应用中，线程被广泛使用，例如在Web服务器、数据库服务器和操作系统等中。但是，线程之间的共享资源也会带来一些安全性和稳定性方面的问题，因此在使用时需要小心处理。\n\n总结来说，进程是指正在运行的一个程序实例，拥有独立的地址空间和系统资源，而线程是进程的一个执行单元，多个线程共享相同的地址空间和系统资源，可以更加高效地执行任务。\n\n区别：\n\n 1. 资源占用：一个进程拥有独立的地址空间和系统资源，包括内存、文件句柄、设备和信号处理等，而线程是进程中的一条执行路径，它与同一进程内的其他线程共享相同的资源。\n 2. 调度和切换：线程的切换比进程的切换更快，因为线程共享相同的地址空间和系统资源，上下文切换的开销比进程小。\n 3. 通信和同步：由于线程共享相同的资源，线程之间通信和同步更加容易和高效。而进程之间通信和同步需要使用进程间通信(IPC)机制，如管道、信号、消息队列、共享内存等，它们比线程间通信的开销更大。\n 4. 稳定性和安全性：由于线程共享相同的资源，一个线程的错误可能会导致整个进程崩溃，而一个进程的崩溃只会影响同一进程内的其他线程。因此，进程比线程更加稳定和安全。\n 5. 并发性和多核利用：由于线程共享相同的地址空间和系统资源，多个线程可以并发地执行同一进程的不同任务，从而提高CPU的利用率。而进程之间的并发需要在多个CPU上运行，因此进程在利用多核CPU时更加有效。\n\n\n# 有进程为什么还要有线程\n\n进程可以使多个程序并发执行，以提高资源的利用率和系统的吞吐量，但是其带来了一些缺点：\n\n 1. 进程在同一时间只能干一件事情；\n 2. 进程在执行的过程中如果阻塞，整个进程就会被挂起，即使进程中有些工作不依赖与等待的资源，仍然不会执行。\n\n基于以上的缺点，操作系统引入了比进程粒度更小的线程，作为并发执行的基本单位，从而减少程序在并发执行时所付出的时间和空间开销，提高并发性能。\n\n\n# 携程\n\n携程（Coroutine）是一种轻量级的线程，也称为协程。它与传统的操作系统线程（Thread）不同，操作系统线程由操作系统调度和管理，而携程则由程序本身控制。\n\n携程的特点是轻量级、高效、简单、易于使用。携程可以在一个线程中执行多个任务，通过在任务之间切换来实现并发和异步操作。与传统的多线程编程模型相比，携程的优点是更加高效、更加灵活、更加容易管理和调度，并且可以避免由于线程切换而带来的开销和竞争条件问题。\n\n携程在编写异步代码、网络编程、协议解析、爬虫等领域中广泛应用。在Python中，携程通过协程库（Coroutine Library）来实现，其中最著名的是asyncio库。在其他编程语言中，例如Go、C++、Lua等，也都支持携程的实现。\n\n总之，携程是一种轻量级的线程，具有高效、灵活、简单等特点，可以用于异步编程、网络编程、协议解析、爬虫等领域。\n\n\n# 进程的状态转换\n\n就绪态、运行态、阻塞态\n\n就绪<--\x3e运行\n\n运行--\x3e阻塞\n\n阻塞--\x3e就绪\n\n\n# 进程间的通信方式\n\n进程间通信（IPC，InterProcess Communication）是指在不同进程之间传播或交换信息。IPC 的方式通常有管道（包括无名管道和命名管道）、消息队列、信号量、共享存储、Socket、Streams 等。其中 Socket 和 Streams 支持不同主机上的两个进程 IPC。\n\n管道\n\n 1. 它是半双工的，具有固定的读端和写端；\n 2. 它只能用于父子进程或者兄弟进程之间的进程的通信；\n 3. 它可以看成是一种特殊的文件，对于它的读写也可以使用普通的 read、write 等函数。但是它不是普通的文件，并不属于其他任何文件系统，并且只存在于内存中。\n\n命名管道\n\n 1. FIFO 可以在无关的进程之间交换数据，与无名管道不同；\n 2. FIFO 有路径名与之相关联，它以一种特殊设备文件形式存在于文件系统中。\n\n消息队列\n\n 1. 消息队列，是消息的链接表，存放在内核中。一个消息队列由一个标识符 ID 来标识；\n 2. 消息队列是面向记录的，其中的消息具有特定的格式以及特定的优先级；\n 3. 消息队列独立于发送与接收进程。进程终止时，消息队列及其内容并不会被删除；\n 4. 消息队列可以实现消息的随机查询，消息不一定要以先进先出的次序读取，也可以按消息的类型读取。\n\n信号量\n\n 1. 信号量（semaphore）是一个计数器。用于实现进程间的互斥与同步，而不是用于存储进程间通信数据；\n 2. 信号量用于进程间同步，若要在进程间传递数据需要结合共享内存；\n 3. 信号量基于操作系统的 PV 操作，程序对信号量的操作都是原子操作；\n 4. 每次对信号量的 PV 操作不仅限于对信号量值加 1 或减 1，而且可以加减任意正整数；\n 5. 支持信号量组。\n\n共享内存\n\n 1. 共享内存（Shared Memory），指两个或多个进程共享一个给定的存储区；\n 2. 共享内存是最快的一种 IPC，因为进程是直接对内存进行存取。\n\n\n# 进程调度算法\n\n调度算法是指：根据系统的资源分配策略所规定的资源分配算法。\n\n常用的调度算法有：先来先服务调度算法、时间片轮转调度法、短作业优先调度算法、最短剩余时间优先、高响应比优先调度算法、优先级调度算法等等。\n\n\n# 用户态和内核态\n\n用户态和内核态是操作系统的两种运行状态。\n\n * 内核态：处于内核态的 CPU 可以访问任意的数据，包括外围设备，比如网卡、硬盘等，处于内核态的 CPU 可以从一个程序切换到另外一个程序，并且占用 CPU 不会发生抢占情况，一般处于特权级 0 的状态我们称之为内核态。\n * 用户态：处于用户态的 CPU 只能受限的访问内存，并且不允许访问外围设备，用户态下的 CPU 不允许独占，也就是说 CPU 能够被其他程序获取。\n\n\n# 为什么要有用户态和内核态呢？\n\n这个主要是对访问能力的限制，计算机中有一些比较危险的操作，比如设置时钟、内存清理，这些都需要在内核态下完成，如果随意进行这些操作，那你的系统得崩溃多少次。\n\n\n# 用户态和内核态是如何切换的？\n\n所有的用户进程都是运行在用户态的，但用户程序的访问能力有限，一些比较重要的比如从硬盘读取数据，从键盘获取数据的操作则是内核态才能做的事情，而这些数据却又对用户程序来说非常重要。所以就涉及到两种模式下的转换，即用户态 -> 内核态 -> 用户态，而唯一能够做这些操作的只有系统调用，而能够执行系统调用的就只有操作系统。\n\n\n\n * 首先用户程序会调用 glibc 库，glibc 是一个标准库，同时也是一套核心库，库中定义了很多关键 API。\n * glibc 库知道针对不同体系结构调用系统调用的正确方法，它会根据体系结构应用程序的二进制接口设置用户进程传递的参数，来准备系统调用。\n * 然后，glibc 库调用软件中断指令(SWI) ，这个指令通过更新 CPSR 寄存器将模式改为超级用户模式，然后跳转到地址 0x08 处。\n * 到目前为止，整个过程仍处于用户态下，在执行 SWI 指令后，允许进程执行内核代码，MMU 现在允许内核虚拟内存访问\n * 从地址 0x08 开始，进程执行加载并跳转到中断处理程序，这个程序就是 ARM 中的 vector_swi()。\n * 在 vector_swi() 处，从 SWI 指令中提取系统调用号 SCNO，然后使用 SCNO 作为系统调用表 sys_call_table 的索引，调转到系统调用函数。\n * 执行系统调用完成后，将还原用户模式寄存器，然后再以用户模式执行。",normalizedContent:"# 并行和并发\n\n并行是指两个或者多个事件在同一时刻发生；而并发是指两个或多个事件在同一时间间隔发生；\n\n并行是在不同实体上的多个事件，并发是在同一实体上的多个事件；\n\n\n# 同步、异步、阻塞、非阻塞\n\n同步：当一个同步调用发出后，调用者要一直等待返回结果。通知后，才能进行后续的执行。\n\n异步：当一个异步过程调用发出后，调用者不能立刻得到返回结果。实际处理这个调用的部件在完成后，通过状态、通知和回调来通知调用者。\n\n阻塞：是指调用结果返回前，当前线程会被挂起，即阻塞。\n\n非阻塞：是指即使调用结果没返回，也不会阻塞当前线程。\n\n\n# 进程和线程\n\n进程和线程是操作系统中的两个基本概念，它们都是程序运行的基本单位。\n\n进程是指正在运行的一个程序实例。每个进程都有自己的地址空间、数据栈、文件句柄、系统资源等，可以独立地运行、停止和调度。操作系统为每个进程分配唯一的进程标识符pid，用于标识和管理进程。每个进程可以包含一个或多个线程。\n\n线程是进程的一个执行单元。一个进程可以包含多个线程，每个线程共享相同的地址空间和系统资源，包括打开的文件、信号处理程序、用户id和组id等。线程与进程不同，线程没有独立的地址空间，一个进程中的所有线程共享相同的地址空间和系统资源，因此线程之间的通信和同步更加容易和高效。\n\n与进程相比，线程的优点是更加轻量级和高效，线程之间的切换开销更小，可以更好地利用多核cpu，同时线程之间的通信和同步更加容易和高效。因此，在实际应用中，线程被广泛使用，例如在web服务器、数据库服务器和操作系统等中。但是，线程之间的共享资源也会带来一些安全性和稳定性方面的问题，因此在使用时需要小心处理。\n\n总结来说，进程是指正在运行的一个程序实例，拥有独立的地址空间和系统资源，而线程是进程的一个执行单元，多个线程共享相同的地址空间和系统资源，可以更加高效地执行任务。\n\n区别：\n\n 1. 资源占用：一个进程拥有独立的地址空间和系统资源，包括内存、文件句柄、设备和信号处理等，而线程是进程中的一条执行路径，它与同一进程内的其他线程共享相同的资源。\n 2. 调度和切换：线程的切换比进程的切换更快，因为线程共享相同的地址空间和系统资源，上下文切换的开销比进程小。\n 3. 通信和同步：由于线程共享相同的资源，线程之间通信和同步更加容易和高效。而进程之间通信和同步需要使用进程间通信(ipc)机制，如管道、信号、消息队列、共享内存等，它们比线程间通信的开销更大。\n 4. 稳定性和安全性：由于线程共享相同的资源，一个线程的错误可能会导致整个进程崩溃，而一个进程的崩溃只会影响同一进程内的其他线程。因此，进程比线程更加稳定和安全。\n 5. 并发性和多核利用：由于线程共享相同的地址空间和系统资源，多个线程可以并发地执行同一进程的不同任务，从而提高cpu的利用率。而进程之间的并发需要在多个cpu上运行，因此进程在利用多核cpu时更加有效。\n\n\n# 有进程为什么还要有线程\n\n进程可以使多个程序并发执行，以提高资源的利用率和系统的吞吐量，但是其带来了一些缺点：\n\n 1. 进程在同一时间只能干一件事情；\n 2. 进程在执行的过程中如果阻塞，整个进程就会被挂起，即使进程中有些工作不依赖与等待的资源，仍然不会执行。\n\n基于以上的缺点，操作系统引入了比进程粒度更小的线程，作为并发执行的基本单位，从而减少程序在并发执行时所付出的时间和空间开销，提高并发性能。\n\n\n# 携程\n\n携程（coroutine）是一种轻量级的线程，也称为协程。它与传统的操作系统线程（thread）不同，操作系统线程由操作系统调度和管理，而携程则由程序本身控制。\n\n携程的特点是轻量级、高效、简单、易于使用。携程可以在一个线程中执行多个任务，通过在任务之间切换来实现并发和异步操作。与传统的多线程编程模型相比，携程的优点是更加高效、更加灵活、更加容易管理和调度，并且可以避免由于线程切换而带来的开销和竞争条件问题。\n\n携程在编写异步代码、网络编程、协议解析、爬虫等领域中广泛应用。在python中，携程通过协程库（coroutine library）来实现，其中最著名的是asyncio库。在其他编程语言中，例如go、c++、lua等，也都支持携程的实现。\n\n总之，携程是一种轻量级的线程，具有高效、灵活、简单等特点，可以用于异步编程、网络编程、协议解析、爬虫等领域。\n\n\n# 进程的状态转换\n\n就绪态、运行态、阻塞态\n\n就绪<--\x3e运行\n\n运行--\x3e阻塞\n\n阻塞--\x3e就绪\n\n\n# 进程间的通信方式\n\n进程间通信（ipc，interprocess communication）是指在不同进程之间传播或交换信息。ipc 的方式通常有管道（包括无名管道和命名管道）、消息队列、信号量、共享存储、socket、streams 等。其中 socket 和 streams 支持不同主机上的两个进程 ipc。\n\n管道\n\n 1. 它是半双工的，具有固定的读端和写端；\n 2. 它只能用于父子进程或者兄弟进程之间的进程的通信；\n 3. 它可以看成是一种特殊的文件，对于它的读写也可以使用普通的 read、write 等函数。但是它不是普通的文件，并不属于其他任何文件系统，并且只存在于内存中。\n\n命名管道\n\n 1. fifo 可以在无关的进程之间交换数据，与无名管道不同；\n 2. fifo 有路径名与之相关联，它以一种特殊设备文件形式存在于文件系统中。\n\n消息队列\n\n 1. 消息队列，是消息的链接表，存放在内核中。一个消息队列由一个标识符 id 来标识；\n 2. 消息队列是面向记录的，其中的消息具有特定的格式以及特定的优先级；\n 3. 消息队列独立于发送与接收进程。进程终止时，消息队列及其内容并不会被删除；\n 4. 消息队列可以实现消息的随机查询，消息不一定要以先进先出的次序读取，也可以按消息的类型读取。\n\n信号量\n\n 1. 信号量（semaphore）是一个计数器。用于实现进程间的互斥与同步，而不是用于存储进程间通信数据；\n 2. 信号量用于进程间同步，若要在进程间传递数据需要结合共享内存；\n 3. 信号量基于操作系统的 pv 操作，程序对信号量的操作都是原子操作；\n 4. 每次对信号量的 pv 操作不仅限于对信号量值加 1 或减 1，而且可以加减任意正整数；\n 5. 支持信号量组。\n\n共享内存\n\n 1. 共享内存（shared memory），指两个或多个进程共享一个给定的存储区；\n 2. 共享内存是最快的一种 ipc，因为进程是直接对内存进行存取。\n\n\n# 进程调度算法\n\n调度算法是指：根据系统的资源分配策略所规定的资源分配算法。\n\n常用的调度算法有：先来先服务调度算法、时间片轮转调度法、短作业优先调度算法、最短剩余时间优先、高响应比优先调度算法、优先级调度算法等等。\n\n\n# 用户态和内核态\n\n用户态和内核态是操作系统的两种运行状态。\n\n * 内核态：处于内核态的 cpu 可以访问任意的数据，包括外围设备，比如网卡、硬盘等，处于内核态的 cpu 可以从一个程序切换到另外一个程序，并且占用 cpu 不会发生抢占情况，一般处于特权级 0 的状态我们称之为内核态。\n * 用户态：处于用户态的 cpu 只能受限的访问内存，并且不允许访问外围设备，用户态下的 cpu 不允许独占，也就是说 cpu 能够被其他程序获取。\n\n\n# 为什么要有用户态和内核态呢？\n\n这个主要是对访问能力的限制，计算机中有一些比较危险的操作，比如设置时钟、内存清理，这些都需要在内核态下完成，如果随意进行这些操作，那你的系统得崩溃多少次。\n\n\n# 用户态和内核态是如何切换的？\n\n所有的用户进程都是运行在用户态的，但用户程序的访问能力有限，一些比较重要的比如从硬盘读取数据，从键盘获取数据的操作则是内核态才能做的事情，而这些数据却又对用户程序来说非常重要。所以就涉及到两种模式下的转换，即用户态 -> 内核态 -> 用户态，而唯一能够做这些操作的只有系统调用，而能够执行系统调用的就只有操作系统。\n\n\n\n * 首先用户程序会调用 glibc 库，glibc 是一个标准库，同时也是一套核心库，库中定义了很多关键 api。\n * glibc 库知道针对不同体系结构调用系统调用的正确方法，它会根据体系结构应用程序的二进制接口设置用户进程传递的参数，来准备系统调用。\n * 然后，glibc 库调用软件中断指令(swi) ，这个指令通过更新 cpsr 寄存器将模式改为超级用户模式，然后跳转到地址 0x08 处。\n * 到目前为止，整个过程仍处于用户态下，在执行 swi 指令后，允许进程执行内核代码，mmu 现在允许内核虚拟内存访问\n * 从地址 0x08 开始，进程执行加载并跳转到中断处理程序，这个程序就是 arm 中的 vector_swi()。\n * 在 vector_swi() 处，从 swi 指令中提取系统调用号 scno，然后使用 scno 作为系统调用表 sys_call_table 的索引，调转到系统调用函数。\n * 执行系统调用完成后，将还原用户模式寄存器，然后再以用户模式执行。",charsets:{cjk:!0}},{title:"内存管理",frontmatter:{title:"内存管理",date:"2023-09-04T21:01:14.000Z",permalink:"/pages/ceeb3f/"},regularPath:"/05.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/03.%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html",relativePath:"05.操作系统/03.内存管理.md",key:"v-50a497ba",path:"/pages/ceeb3f/",headers:[{level:2,title:"为什么要有虚拟内存",slug:"为什么要有虚拟内存",normalizedTitle:"为什么要有虚拟内存",charIndex:2},{level:2,title:"内存分页和分段",slug:"内存分页和分段",normalizedTitle:"内存分页和分段",charIndex:541},{level:2,title:"linux 的内存管理",slug:"linux-的内存管理",normalizedTitle:"linux 的内存管理",charIndex:1324},{level:2,title:"段页式内存管理",slug:"段页式内存管理",normalizedTitle:"段页式内存管理",charIndex:1552},{level:2,title:"内存分配的过程",slug:"内存分配的过程",normalizedTitle:"内存分配的过程",charIndex:1566},{level:2,title:"在 4GB 物理内存的机器上，申请 8G 内存会怎么样？",slug:"在-4gb-物理内存的机器上-申请-8g-内存会怎么样",normalizedTitle:"在 4gb 物理内存的机器上，申请 8g 内存会怎么样？",charIndex:2330}],headersStr:"为什么要有虚拟内存 内存分页和分段 linux 的内存管理 段页式内存管理 内存分配的过程 在 4GB 物理内存的机器上，申请 8G 内存会怎么样？",content:"# 为什么要有虚拟内存\n\n为了在多进程环境下，使得进程之间的内存地址不受影响，相互隔离，于是操作系统就为每个进程独立分配一套虚拟地址空间，每个程序只关心自己的虚拟地址就可以，实际上大家的虚拟地址都是一样的，但分布到物理地址内存是不一样的。作为程序，也不用关心物理地址的事情。\n\n每个进程都有自己的虚拟空间，而物理内存只有一个，所以当启用了大量的进程，物理内存必然会很紧张，于是操作系统会通过内存交换技术，把不常使用的内存暂时存放到硬盘（换出），在需要的时候再装载回物理内存（换入）。\n\n虚拟内存的作用：\n\n * 第一，虚拟内存可以使得进程对运行内存超过物理内存大小，因为程序运行符合局部性原理，CPU 访问内存会有很明显的重复访问的倾向性，对于那些没有被经常使用到的内存，我们可以把它换出到物理内存之外，比如硬盘上的 swap 区域。\n * 第二，由于每个进程都有自己的页表，所以每个进程的虚拟内存空间就是相互独立的。进程也没有办法访问其他进程的页表，所以这些页表是私有的，这就解决了多进程之间地址冲突的问题。\n * 第三，页表里的页表项中除了物理地址之外，还有一些标记属性的比特，比如控制一个页的读写权限，标记该页是否存在等。在内存访问方面，操作系统提供了更好的安全性。\n\n\n# 内存分页和分段\n\n那既然有了虚拟地址空间，那必然要把虚拟地址「映射」到物理地址，这个事情通常由操作系统来维护。\n\n那么对于虚拟地址与物理地址的映射关系，可以有分段和分页的方式，同时两者结合都是可以的。\n\n内存分段是根据程序的逻辑角度，分成了栈段、堆段、数据段、代码段等，这样可以分离出不同属性的段，同时是一块连续的空间。分段的好处就是能产生连续的内存空间。但是每个段的大小都不是统一的，这就会导致外部内存碎片和内存交换效率低的问题。\n\n> 分段为什么会导致内存交换效率低的问题？\n> \n> 对于多进程的系统来说，用分段的方式，外部内存碎片是很容易产生的，产生了外部内存碎片，那不得不重新 Swap 内存区域，这个过程会产生性能瓶颈。\n> \n> 因为硬盘的访问速度要比内存慢太多了，每一次内存交换，我们都需要把一大段连续的内存数据写到硬盘上。\n\n于是，就出现了内存分页，把虚拟空间和物理空间分成大小固定的页，如在 Linux 系统中，每一页的大小为 4KB。由于分了页后，就不会产生细小的内存碎片，解决了内存分段的外部内存碎片问题。同时在内存交换的时候，写入硬盘也就一个页或几个页，这就大大提高了内存交换的效率。\n\n分页的方式使得我们在加载程序的时候，不再需要一次性都把程序加载到物理内存中。我们完全可以在进行虚拟内存和物理内存的页之间的映射之后，并不真的把页加载到物理内存里，而是只有在程序运行中，需要用到对应虚拟内存页里面的指令和数据时，再加载到物理内存里面去。\n\n再来，为了解决简单分页产生的页表过大的问题，就有了多级页表，它解决了空间上的问题，但这就会导致 CPU 在寻址的过程中，需要有很多层表参与，加大了时间上的开销。于是根据程序的局部性原理，在 CPU 芯片中加入了 TLB，负责缓存最近常被访问的页表项，大大提高了地址的转换速度。\n\n\n\n\n\n\n\n\n# linux 的内存管理\n\nLinux 系统主要采用了分页管理，但是由于 Intel 处理器的发展史，Linux 系统无法避免分段管理。于是 Linux 就把所有段的基地址设为 0，也就意味着所有程序的地址空间都是线性地址空间（虚拟地址），相当于屏蔽了 CPU 逻辑地址的概念，所以段只被用于访问控制和内存保护。\n\n另外，Linux 系统中虚拟空间分布可分为用户态和内核态两部分，其中用户态的分布：代码段、全局变量、BSS、函数栈、堆内存、映射区。\n\n\n# 段页式内存管理\n\n\n\n\n# 内存分配的过程\n\n应用程序通过 malloc 函数申请内存的时候，实际上申请的是虚拟内存，此时并不会分配物理内存。\n\n当应用程序读写了这块虚拟内存，CPU 就会去访问这个虚拟内存， 这时会发现这个虚拟内存没有映射到物理内存， CPU 就会产生缺页中断，进程会从用户态切换到内核态，并将缺页中断交给内核的 Page Fault Handler （缺页中断函数）处理。\n\n缺页中断处理函数会看是否有空闲的物理内存，如果有，就直接分配物理内存，并建立虚拟内存与物理内存之间的映射关系。\n\n如果没有空闲的物理内存，那么内核就会开始进行回收内存的工作，回收的方式主要是两种：直接内存回收和后台内存回收。\n\n * 后台内存回收（kswapd）：在物理内存紧张的时候，会唤醒 kswapd 内核线程来回收内存，这个回收内存的过程异步的，不会阻塞进程的执行。\n * 直接内存回收（direct reclaim）：如果后台异步回收跟不上进程内存申请的速度，就会开始直接回收，这个回收内存的过程是同步的，会阻塞进程的执行。\n\n如果直接内存回收后，空闲的物理内存仍然无法满足此次物理内存的申请，那么内核就会放最后的大招了 ——触发 OOM （Out of Memory）机制。\n\nOOM Killer 机制会根据算法选择一个占用物理内存较高的进程，然后将其杀死，以便释放内存资源，如果物理内存依然不足，OOM Killer 会继续杀死占用物理内存较高的进程，直到释放足够的内存位置。\n\nOOM killer 会根据每个进程的内存占用情况和 oom_score_adj 的值进行打分，得分最高的进程就会被首先杀掉。\n\n我们可以通过调整进程的 /proc/[pid]/oom_score_adj 值，来降低被 OOM killer 杀掉的概率。\n\n\n# 在 4GB 物理内存的机器上，申请 8G 内存会怎么样？\n\nswap 机制，也就是内存交换技术。当系统的物理内存不够用的时候，就需要将物理内存中的一部分空间释放出来，以供当前运行的程序使用。那些被释放的空间可能来自一些很长时间没有什么操作的程序，这些被释放的空间会被临时保存到磁盘，等到那些程序要运行时，再从磁盘中恢复保存的数据到内存中。\n\n另外，当内存使用存在压力的时候，会开始触发内存回收行为，会把这些不常访问的内存先写到磁盘中，然后释放这些内存，给其他更需要的进程使用。再次访问这些内存时，重新从磁盘读入内存就可以了。\n\n这种，将内存数据换出磁盘，又从磁盘中恢复数据到内存的过程，就是 Swap 机制负责的。\n\nSwap 就是把一块磁盘空间或者本地文件，当成内存来使用，它包含换出和换入两个过程：\n\n * 换出（Swap Out） ，是把进程暂时不用的内存数据存储到磁盘中，并释放这些数据占用的内存；\n * 换入（Swap In），是在进程再次访问这些内存的时候，把它们从磁盘读到内存中来；\n\n在 32 位操作系统，因为进程理论上最大能申请 3 GB 大小的虚拟内存，所以直接申请 8G 内存，会申请失败。\n\n在 64位 位操作系统，因为进程理论上最大能申请 128 TB 大小的虚拟内存，即使物理内存只有 4GB，申请 8G 内存也是没问题，因为申请的内存是虚拟内存。如果这块虚拟内存被访问了，要看系统有没有 Swap 分区：\n\n * 如果没有 Swap 分区，因为物理空间不够，进程会被操作系统杀掉，原因是 OOM（内存溢出）；\n * 如果有 Swap 分区，即使物理内存只有 4GB，程序也能正常使用 8GB 的内存，进程可以正常运行；",normalizedContent:"# 为什么要有虚拟内存\n\n为了在多进程环境下，使得进程之间的内存地址不受影响，相互隔离，于是操作系统就为每个进程独立分配一套虚拟地址空间，每个程序只关心自己的虚拟地址就可以，实际上大家的虚拟地址都是一样的，但分布到物理地址内存是不一样的。作为程序，也不用关心物理地址的事情。\n\n每个进程都有自己的虚拟空间，而物理内存只有一个，所以当启用了大量的进程，物理内存必然会很紧张，于是操作系统会通过内存交换技术，把不常使用的内存暂时存放到硬盘（换出），在需要的时候再装载回物理内存（换入）。\n\n虚拟内存的作用：\n\n * 第一，虚拟内存可以使得进程对运行内存超过物理内存大小，因为程序运行符合局部性原理，cpu 访问内存会有很明显的重复访问的倾向性，对于那些没有被经常使用到的内存，我们可以把它换出到物理内存之外，比如硬盘上的 swap 区域。\n * 第二，由于每个进程都有自己的页表，所以每个进程的虚拟内存空间就是相互独立的。进程也没有办法访问其他进程的页表，所以这些页表是私有的，这就解决了多进程之间地址冲突的问题。\n * 第三，页表里的页表项中除了物理地址之外，还有一些标记属性的比特，比如控制一个页的读写权限，标记该页是否存在等。在内存访问方面，操作系统提供了更好的安全性。\n\n\n# 内存分页和分段\n\n那既然有了虚拟地址空间，那必然要把虚拟地址「映射」到物理地址，这个事情通常由操作系统来维护。\n\n那么对于虚拟地址与物理地址的映射关系，可以有分段和分页的方式，同时两者结合都是可以的。\n\n内存分段是根据程序的逻辑角度，分成了栈段、堆段、数据段、代码段等，这样可以分离出不同属性的段，同时是一块连续的空间。分段的好处就是能产生连续的内存空间。但是每个段的大小都不是统一的，这就会导致外部内存碎片和内存交换效率低的问题。\n\n> 分段为什么会导致内存交换效率低的问题？\n> \n> 对于多进程的系统来说，用分段的方式，外部内存碎片是很容易产生的，产生了外部内存碎片，那不得不重新 swap 内存区域，这个过程会产生性能瓶颈。\n> \n> 因为硬盘的访问速度要比内存慢太多了，每一次内存交换，我们都需要把一大段连续的内存数据写到硬盘上。\n\n于是，就出现了内存分页，把虚拟空间和物理空间分成大小固定的页，如在 linux 系统中，每一页的大小为 4kb。由于分了页后，就不会产生细小的内存碎片，解决了内存分段的外部内存碎片问题。同时在内存交换的时候，写入硬盘也就一个页或几个页，这就大大提高了内存交换的效率。\n\n分页的方式使得我们在加载程序的时候，不再需要一次性都把程序加载到物理内存中。我们完全可以在进行虚拟内存和物理内存的页之间的映射之后，并不真的把页加载到物理内存里，而是只有在程序运行中，需要用到对应虚拟内存页里面的指令和数据时，再加载到物理内存里面去。\n\n再来，为了解决简单分页产生的页表过大的问题，就有了多级页表，它解决了空间上的问题，但这就会导致 cpu 在寻址的过程中，需要有很多层表参与，加大了时间上的开销。于是根据程序的局部性原理，在 cpu 芯片中加入了 tlb，负责缓存最近常被访问的页表项，大大提高了地址的转换速度。\n\n\n\n\n\n\n\n\n# linux 的内存管理\n\nlinux 系统主要采用了分页管理，但是由于 intel 处理器的发展史，linux 系统无法避免分段管理。于是 linux 就把所有段的基地址设为 0，也就意味着所有程序的地址空间都是线性地址空间（虚拟地址），相当于屏蔽了 cpu 逻辑地址的概念，所以段只被用于访问控制和内存保护。\n\n另外，linux 系统中虚拟空间分布可分为用户态和内核态两部分，其中用户态的分布：代码段、全局变量、bss、函数栈、堆内存、映射区。\n\n\n# 段页式内存管理\n\n\n\n\n# 内存分配的过程\n\n应用程序通过 malloc 函数申请内存的时候，实际上申请的是虚拟内存，此时并不会分配物理内存。\n\n当应用程序读写了这块虚拟内存，cpu 就会去访问这个虚拟内存， 这时会发现这个虚拟内存没有映射到物理内存， cpu 就会产生缺页中断，进程会从用户态切换到内核态，并将缺页中断交给内核的 page fault handler （缺页中断函数）处理。\n\n缺页中断处理函数会看是否有空闲的物理内存，如果有，就直接分配物理内存，并建立虚拟内存与物理内存之间的映射关系。\n\n如果没有空闲的物理内存，那么内核就会开始进行回收内存的工作，回收的方式主要是两种：直接内存回收和后台内存回收。\n\n * 后台内存回收（kswapd）：在物理内存紧张的时候，会唤醒 kswapd 内核线程来回收内存，这个回收内存的过程异步的，不会阻塞进程的执行。\n * 直接内存回收（direct reclaim）：如果后台异步回收跟不上进程内存申请的速度，就会开始直接回收，这个回收内存的过程是同步的，会阻塞进程的执行。\n\n如果直接内存回收后，空闲的物理内存仍然无法满足此次物理内存的申请，那么内核就会放最后的大招了 ——触发 oom （out of memory）机制。\n\noom killer 机制会根据算法选择一个占用物理内存较高的进程，然后将其杀死，以便释放内存资源，如果物理内存依然不足，oom killer 会继续杀死占用物理内存较高的进程，直到释放足够的内存位置。\n\noom killer 会根据每个进程的内存占用情况和 oom_score_adj 的值进行打分，得分最高的进程就会被首先杀掉。\n\n我们可以通过调整进程的 /proc/[pid]/oom_score_adj 值，来降低被 oom killer 杀掉的概率。\n\n\n# 在 4gb 物理内存的机器上，申请 8g 内存会怎么样？\n\nswap 机制，也就是内存交换技术。当系统的物理内存不够用的时候，就需要将物理内存中的一部分空间释放出来，以供当前运行的程序使用。那些被释放的空间可能来自一些很长时间没有什么操作的程序，这些被释放的空间会被临时保存到磁盘，等到那些程序要运行时，再从磁盘中恢复保存的数据到内存中。\n\n另外，当内存使用存在压力的时候，会开始触发内存回收行为，会把这些不常访问的内存先写到磁盘中，然后释放这些内存，给其他更需要的进程使用。再次访问这些内存时，重新从磁盘读入内存就可以了。\n\n这种，将内存数据换出磁盘，又从磁盘中恢复数据到内存的过程，就是 swap 机制负责的。\n\nswap 就是把一块磁盘空间或者本地文件，当成内存来使用，它包含换出和换入两个过程：\n\n * 换出（swap out） ，是把进程暂时不用的内存数据存储到磁盘中，并释放这些数据占用的内存；\n * 换入（swap in），是在进程再次访问这些内存的时候，把它们从磁盘读到内存中来；\n\n在 32 位操作系统，因为进程理论上最大能申请 3 gb 大小的虚拟内存，所以直接申请 8g 内存，会申请失败。\n\n在 64位 位操作系统，因为进程理论上最大能申请 128 tb 大小的虚拟内存，即使物理内存只有 4gb，申请 8g 内存也是没问题，因为申请的内存是虚拟内存。如果这块虚拟内存被访问了，要看系统有没有 swap 分区：\n\n * 如果没有 swap 分区，因为物理空间不够，进程会被操作系统杀掉，原因是 oom（内存溢出）；\n * 如果有 swap 分区，即使物理内存只有 4gb，程序也能正常使用 8gb 的内存，进程可以正常运行；",charsets:{cjk:!0}},{title:"二叉树",frontmatter:{title:"二叉树",date:"2023-04-21T21:23:46.000Z",permalink:"/pages/d2945b/"},regularPath:"/06.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/03.%E4%BA%8C%E5%8F%89%E6%A0%91.html",relativePath:"06.数据结构和算法/03.二叉树.md",key:"v-d0cbc152",path:"/pages/d2945b/",headers:[{level:2,title:"递归遍历",slug:"递归遍历",normalizedTitle:"递归遍历",charIndex:2},{level:2,title:"迭代遍历（栈）",slug:"迭代遍历-栈",normalizedTitle:"迭代遍历（栈）",charIndex:594},{level:2,title:"层序遍历",slug:"层序遍历",normalizedTitle:"层序遍历",charIndex:3438}],headersStr:"递归遍历 迭代遍历（栈） 层序遍历",content:"# 递归遍历\n\nclass Solution {\n    List<Integer> ans = new ArrayList<>();\n    public List<Integer> preorderTraversal(TreeNode root) {\n        if (root == null) return ans;\n        ans.add(root.val);\n        preorderTraversal(root.left);\n        preorderTraversal(root.right);\n        return ans;\n    }\n}\n\n\nclass Solution {\n    List<Integer> ans = new ArrayList<>();\n    public List<Integer> inorderTraversal(TreeNode root) {\n        if (root == null) return ans;\n        preorderTraversal(root.left);\n        ans.add(root.val);\n        preorderTraversal(root.right);\n        return ans;\n    }\n}\n\n\n\n# 迭代遍历（栈）\n\n * 前序遍历顺序：中-左-右，入栈顺序：中-右-左\n * 中序遍历顺序: 左-中-右 入栈顺序： 左-右 ✨\n * 后序遍历顺序 左-右-中 入栈顺序：中-左-右 出栈顺序：中-右-左， 最后翻转结果\n\nclass Solution {\n    public List<Integer> preorderTraversal(TreeNode root) {\n        List<Integer> ans = new ArrayList<>();\n        if (root == null) return ans;\n        Deque<TreeNode> d = new ArrayDeque<>();\n        d.offerLast(root);\n        while (!d.isEmpty()) {\n            TreeNode t = d.pollLast();\n            ans.add(t.val);\n            if (t.right != null) d.offerLast(t.right);\n            if (t.left != null) d.offerLast(t.left);\n        }\n        return ans;\n    }\n}\n\n\nclass Solution {\n    public List<Integer> inorderTraversal(TreeNode root) {\n        List<Integer> ans = new ArrayList<>();\n        if (root == null) return ans;\n        Deque<TreeNode> d = new ArrayDeque<>();\n        TreeNode cur = root;\n        while (cur != null || !d.isEmpty()) {\n            if (cur != null) {\n                d.offerLast(cur);\n                cur = cur.left;\n            } else {\n                TreeNode t = d.pollLast();\n                ans.add(t.val);\n                cur = t.right;\n            }\n        }\n        return ans;\n    }\n}\n\n\n二叉树的统一迭代写法，标价法：将要处理的节点放入栈后，紧跟着放入一个空指针作为标记。\n\nclass Solution {\n    public List<Integer> preorderTraversal(TreeNode root) {\n        List<Integer> result = new LinkedList<>();\n        Stack<TreeNode> st = new Stack<>();\n        if (root != null) st.push(root);\n        while (!st.empty()) {\n            TreeNode node = st.peek();\n            if (node != null) {\n                st.pop(); // 将该节点弹出，避免重复操作，下面再将右中左节点添加到栈中\n                if (node.right!=null) st.push(node.right);  // 添加右节点（空节点不入栈）\n                if (node.left!=null) st.push(node.left);    // 添加左节点（空节点不入栈）\n                st.push(node);                          // 添加中节点\n                st.push(null); // 中节点访问过，但是还没有处理，加入空节点做为标记。\n                \n            } else { // 只有遇到空节点的时候，才将下一个节点放进结果集\n                st.pop();           // 将空节点弹出\n                node = st.pop();\n                result.add(node.val); // 加入到结果集\n            }\n        }\n        return result;\n    }\n}\n\n\nclass Solution {\n    public List<Integer> inorderTraversal(TreeNode root) {\n        List<Integer> ans = new ArrayList<>();\n        if (root == null) return ans;\n        Deque<TreeNode> d = new LinkedList<>(); // ArrayDeuqe 不能添加 null。\n        d.offerLast(root);\n        while (!d.isEmpty()) {\n            TreeNode t = d.pollLast();\n            if (t != null) {\n                if (t.right != null) d.offerLast(t.right);\n                d.offerLast(t);\n                d.offerLast(null); // 中节点访问过，但是还没有处理，加入空节点做为标记。\n                if (t.left != null) d.offerLast(t.left);\n            } else { // 只有遇到空节点的时候，才将下一个节点放进结果集\n                t = d.pollLast();\n                ans.add(t.val);\n            }\n        }\n        return ans;\n    }\n}\n\n\n\n# 层序遍历\n\n// bfs\nclass Solution {\n    public List<List<Integer>> levelOrder(TreeNode root) {\n        List<List<Integer>> ans = new ArrayList<>();\n        if (root == null) return ans;\n        Deque<TreeNode> d = new ArrayDeque<>();\n        d.offerLast(root);\n        while (!d.isEmpty()) {\n            int n = d.size();\n            List<Integer> list = new ArrayList<>();\n            ans.add(list);\n            while (n-- > 0) {\n                TreeNode t = d.pollFirst();\n                list.add(t.val);\n                if (t.left != null) d.offerLast(t.left);\n                if (t.right != null) d.offerLast(t.right);\n            }\n        }\n        return ans;\n    }\n}\n\n\n// dfs\nclass Solution {\n    List<List<Integer>> ans = new ArrayList<>();\n    public List<List<Integer>> levelOrder(TreeNode root) {\n        dfs(root, 1);\n        return ans;\n    }\n\n    public void dfs(TreeNode root, Integer deep) {\n        if (root == null) return;\n        if (ans.size() < deep) {\n            ans.add(new ArrayList<>());\n        }\n        ans.get(deep - 1).add(root.val);\n        dfs(root.left, deep + 1);\n        dfs(root.right, deep + 1);\n    }\n}\n",normalizedContent:"# 递归遍历\n\nclass solution {\n    list<integer> ans = new arraylist<>();\n    public list<integer> preordertraversal(treenode root) {\n        if (root == null) return ans;\n        ans.add(root.val);\n        preordertraversal(root.left);\n        preordertraversal(root.right);\n        return ans;\n    }\n}\n\n\nclass solution {\n    list<integer> ans = new arraylist<>();\n    public list<integer> inordertraversal(treenode root) {\n        if (root == null) return ans;\n        preordertraversal(root.left);\n        ans.add(root.val);\n        preordertraversal(root.right);\n        return ans;\n    }\n}\n\n\n\n# 迭代遍历（栈）\n\n * 前序遍历顺序：中-左-右，入栈顺序：中-右-左\n * 中序遍历顺序: 左-中-右 入栈顺序： 左-右 ✨\n * 后序遍历顺序 左-右-中 入栈顺序：中-左-右 出栈顺序：中-右-左， 最后翻转结果\n\nclass solution {\n    public list<integer> preordertraversal(treenode root) {\n        list<integer> ans = new arraylist<>();\n        if (root == null) return ans;\n        deque<treenode> d = new arraydeque<>();\n        d.offerlast(root);\n        while (!d.isempty()) {\n            treenode t = d.polllast();\n            ans.add(t.val);\n            if (t.right != null) d.offerlast(t.right);\n            if (t.left != null) d.offerlast(t.left);\n        }\n        return ans;\n    }\n}\n\n\nclass solution {\n    public list<integer> inordertraversal(treenode root) {\n        list<integer> ans = new arraylist<>();\n        if (root == null) return ans;\n        deque<treenode> d = new arraydeque<>();\n        treenode cur = root;\n        while (cur != null || !d.isempty()) {\n            if (cur != null) {\n                d.offerlast(cur);\n                cur = cur.left;\n            } else {\n                treenode t = d.polllast();\n                ans.add(t.val);\n                cur = t.right;\n            }\n        }\n        return ans;\n    }\n}\n\n\n二叉树的统一迭代写法，标价法：将要处理的节点放入栈后，紧跟着放入一个空指针作为标记。\n\nclass solution {\n    public list<integer> preordertraversal(treenode root) {\n        list<integer> result = new linkedlist<>();\n        stack<treenode> st = new stack<>();\n        if (root != null) st.push(root);\n        while (!st.empty()) {\n            treenode node = st.peek();\n            if (node != null) {\n                st.pop(); // 将该节点弹出，避免重复操作，下面再将右中左节点添加到栈中\n                if (node.right!=null) st.push(node.right);  // 添加右节点（空节点不入栈）\n                if (node.left!=null) st.push(node.left);    // 添加左节点（空节点不入栈）\n                st.push(node);                          // 添加中节点\n                st.push(null); // 中节点访问过，但是还没有处理，加入空节点做为标记。\n                \n            } else { // 只有遇到空节点的时候，才将下一个节点放进结果集\n                st.pop();           // 将空节点弹出\n                node = st.pop();\n                result.add(node.val); // 加入到结果集\n            }\n        }\n        return result;\n    }\n}\n\n\nclass solution {\n    public list<integer> inordertraversal(treenode root) {\n        list<integer> ans = new arraylist<>();\n        if (root == null) return ans;\n        deque<treenode> d = new linkedlist<>(); // arraydeuqe 不能添加 null。\n        d.offerlast(root);\n        while (!d.isempty()) {\n            treenode t = d.polllast();\n            if (t != null) {\n                if (t.right != null) d.offerlast(t.right);\n                d.offerlast(t);\n                d.offerlast(null); // 中节点访问过，但是还没有处理，加入空节点做为标记。\n                if (t.left != null) d.offerlast(t.left);\n            } else { // 只有遇到空节点的时候，才将下一个节点放进结果集\n                t = d.polllast();\n                ans.add(t.val);\n            }\n        }\n        return ans;\n    }\n}\n\n\n\n# 层序遍历\n\n// bfs\nclass solution {\n    public list<list<integer>> levelorder(treenode root) {\n        list<list<integer>> ans = new arraylist<>();\n        if (root == null) return ans;\n        deque<treenode> d = new arraydeque<>();\n        d.offerlast(root);\n        while (!d.isempty()) {\n            int n = d.size();\n            list<integer> list = new arraylist<>();\n            ans.add(list);\n            while (n-- > 0) {\n                treenode t = d.pollfirst();\n                list.add(t.val);\n                if (t.left != null) d.offerlast(t.left);\n                if (t.right != null) d.offerlast(t.right);\n            }\n        }\n        return ans;\n    }\n}\n\n\n// dfs\nclass solution {\n    list<list<integer>> ans = new arraylist<>();\n    public list<list<integer>> levelorder(treenode root) {\n        dfs(root, 1);\n        return ans;\n    }\n\n    public void dfs(treenode root, integer deep) {\n        if (root == null) return;\n        if (ans.size() < deep) {\n            ans.add(new arraylist<>());\n        }\n        ans.get(deep - 1).add(root.val);\n        dfs(root.left, deep + 1);\n        dfs(root.right, deep + 1);\n    }\n}\n",charsets:{cjk:!0}},{title:"redux",frontmatter:{title:"redux",date:"2023-03-29T19:59:44.000Z",permalink:"/pages/redux/"},regularPath:"/07.%E5%89%8D%E7%AB%AF/01.React/01.redux.html",relativePath:"07.前端/01.React/01.redux.md",key:"v-d35585c0",path:"/pages/redux/",headers:[{level:2,title:"redux原理",slug:"redux原理",normalizedTitle:"redux原理",charIndex:2},{level:3,title:"src目录下创建:",slug:"src目录下创建",normalizedTitle:"src目录下创建:",charIndex:235},{level:3,title:"store.js",slug:"store-js",normalizedTitle:"store.js",charIndex:260},{level:3,title:"count_reducer.js",slug:"count-reducer-js",normalizedTitle:"count_reducer.js",charIndex:274},{level:2,title:"react-redux插件库",slug:"react-redux插件库",normalizedTitle:"react-redux插件库",charIndex:622}],headersStr:"redux原理 src目录下创建: store.js count_reducer.js react-redux插件库",content:"# redux原理\n\n\n\nredux不是react插件库。\n\n集中管理react应用中的多个组件共享的状态。\n\n能不用就不用。\n\n自身的state是属于组件本身的。\n\nstore.dispatch(action)\n\nstore.subscribe(() => {})，检测redux中状态的变化，只要有变化，就调用\n\naction: {type:xxx, data:xxx}\n\nxxxReducer(preState, action)，return 新的状态值\n\n\n# src目录下创建:\n\n * redux\n   * store.js\n   * count_reducer.js\n   * count_action.js：专门用于创建action对象。\n   * constant.js\n\n\n# store.js\n\n * 引入redux中的createStore函数，创建一个store。\n * createStore调用时传入一个reducer\n * 暴露store对象\n\n\n# count_reducer.js\n\n * reducer本质是一个函数，输入preState和action，返回加工后的状态。\n * reducer有两个作用：初始化状态，加工状态\n * reducer第一次调用时候，是store自动触发，传递的preState是undefined\n\nredux只负责管理状态，状态改变后，页面的重写渲染需要自己写。\n\n\n# react-redux插件库\n\nfacebook官方出的。\n\n\n\n * https://juejin.cn/post/7079277020521185293",normalizedContent:"# redux原理\n\n\n\nredux不是react插件库。\n\n集中管理react应用中的多个组件共享的状态。\n\n能不用就不用。\n\n自身的state是属于组件本身的。\n\nstore.dispatch(action)\n\nstore.subscribe(() => {})，检测redux中状态的变化，只要有变化，就调用\n\naction: {type:xxx, data:xxx}\n\nxxxreducer(prestate, action)，return 新的状态值\n\n\n# src目录下创建:\n\n * redux\n   * store.js\n   * count_reducer.js\n   * count_action.js：专门用于创建action对象。\n   * constant.js\n\n\n# store.js\n\n * 引入redux中的createstore函数，创建一个store。\n * createstore调用时传入一个reducer\n * 暴露store对象\n\n\n# count_reducer.js\n\n * reducer本质是一个函数，输入prestate和action，返回加工后的状态。\n * reducer有两个作用：初始化状态，加工状态\n * reducer第一次调用时候，是store自动触发，传递的prestate是undefined\n\nredux只负责管理状态，状态改变后，页面的重写渲染需要自己写。\n\n\n# react-redux插件库\n\nfacebook官方出的。\n\n\n\n * https://juejin.cn/post/7079277020521185293",charsets:{cjk:!0},lastUpdated:"2023/03/29, 21:03:43",lastUpdatedTimestamp:1680095023e3},{title:"概念",frontmatter:{title:"概念",date:"2023-03-29T20:44:51.000Z",permalink:"/pages/2d7856/"},regularPath:"/07.%E5%89%8D%E7%AB%AF/01.React/02.%E6%A6%82%E5%BF%B5.html",relativePath:"07.前端/01.React/02.概念.md",key:"v-957f7b90",path:"/pages/2d7856/",headers:[{level:2,title:"ES5、ES6和ES2015有什么区别?",slug:"es5、es6和es2015有什么区别",normalizedTitle:"es5、es6和es2015有什么区别?",charIndex:2},{level:2,title:"ES5和ES6的功能区别",slug:"es5和es6的功能区别",normalizedTitle:"es5和es6的功能区别",charIndex:165},{level:2,title:"JavaScript和TypeScript的区别",slug:"javascript和typescript的区别",normalizedTitle:"javascript和typescript的区别",charIndex:626},{level:2,title:"let有什么用，有了var为什么还要用let？",slug:"let有什么用-有了var为什么还要用let",normalizedTitle:"let有什么用，有了var为什么还要用let？",charIndex:929},{level:2,title:"yarn和npm",slug:"yarn和npm",normalizedTitle:"yarn和npm",charIndex:1105}],headersStr:"ES5、ES6和ES2015有什么区别? ES5和ES6的功能区别 JavaScript和TypeScript的区别 let有什么用，有了var为什么还要用let？ yarn和npm",content:"# ES5、ES6和ES2015有什么区别?\n\nES2015特指在2015年发布的新一代JS语言标准，ES6泛指下一代JS语言标准，包含ES2015、ES2016、ES2017、ES2018等。现阶段在绝大部分场景下，ES2015默认等同ES6。ES5泛指上一代语言标准。ES2015可以理解为ES5和ES6的时间分界线\n\n\n# ES5和ES6的功能区别\n\n变量声明：在ES5中，使用var关键字来声明变量，而在ES6中，可以使用let和const关键字来声明变量。其中，let用于声明可变变量，const用于声明不可变变量。\n\n箭头函数：ES6引入了箭头函数的概念，使得函数的定义更加简单和清晰。箭头函数的语法比ES5中的函数定义更加简洁。\n\n类：在ES6中，引入了类的概念，使得JavaScript中的面向对象编程更加清晰和易于理解。类具有属性和方法，并且可以通过继承来扩展功能。\n\n模块：在ES6中，引入了模块的概念，可以将代码分成多个模块，使得代码更加模块化、可重用和易于维护。模块可以导出和导入变量和函数。\n\n解构赋值：ES6中引入了解构赋值，可以方便地从数组和对象中获取值并将其赋给变量，使得代码更加简洁和易于理解。\n\n扩展运算符：ES6中引入了扩展运算符，可以将数组和对象展开成多个值，也可以将多个值组合成一个数组或对象。\n\nPromise：ES6中引入了Promise的概念，可以更加方便地进行异步编程，避免了回调地狱的问题。\n\n\n# JavaScript和TypeScript的区别\n\n * JavaScript是一种脚本语言，可以帮助创建交互式网页，而TypeScript是JavaScript的超集。\n * 需要编译类型脚本代码，而不需要编译JavaScript代码。\n * 比较TypeScript和JS，TypeScript支持原型化特性，而JavaScript不支持该特性。\n * TypeScript使用类型和接口等概念来描述正在使用的数据，而JavaScript没有这样的概念。\n * TypeScript是一个功能强大的类型系统，包括用于大型项目的泛型和JS特性，而JavaScript则是用于小型项目的理想选择。\n\n\n# let有什么用，有了var为什么还要用let？\n\n在ES6之前，声明变量只能用var，var方式声明变量其实是很不合理的，准确的说，是因为ES5里面没有块级作用域是很不合理的。没有块级作用域回来带很多难以理解的问题，比如for循环var变量泄露，变量覆盖等问题。let声明的变量拥有自己的块级作用域，且修复了var声明变量带来的变量提升问题。\n\n\n# yarn和npm\n\nnpm install\nnpm run dev\n\n===\nyarn \nyarn start/dev\n\n===\nnpm install === yarn \nnpm install taco --save === yarn add taco\nnpm uninstall taco --save === yarn remove taco\nnpm install taco --save-dev === yarn add taco --dev\nnpm update --save === yarn upgrade\n\n\nhttps://zhuanlan.zhihu.com/p/23493436",normalizedContent:"# es5、es6和es2015有什么区别?\n\nes2015特指在2015年发布的新一代js语言标准，es6泛指下一代js语言标准，包含es2015、es2016、es2017、es2018等。现阶段在绝大部分场景下，es2015默认等同es6。es5泛指上一代语言标准。es2015可以理解为es5和es6的时间分界线\n\n\n# es5和es6的功能区别\n\n变量声明：在es5中，使用var关键字来声明变量，而在es6中，可以使用let和const关键字来声明变量。其中，let用于声明可变变量，const用于声明不可变变量。\n\n箭头函数：es6引入了箭头函数的概念，使得函数的定义更加简单和清晰。箭头函数的语法比es5中的函数定义更加简洁。\n\n类：在es6中，引入了类的概念，使得javascript中的面向对象编程更加清晰和易于理解。类具有属性和方法，并且可以通过继承来扩展功能。\n\n模块：在es6中，引入了模块的概念，可以将代码分成多个模块，使得代码更加模块化、可重用和易于维护。模块可以导出和导入变量和函数。\n\n解构赋值：es6中引入了解构赋值，可以方便地从数组和对象中获取值并将其赋给变量，使得代码更加简洁和易于理解。\n\n扩展运算符：es6中引入了扩展运算符，可以将数组和对象展开成多个值，也可以将多个值组合成一个数组或对象。\n\npromise：es6中引入了promise的概念，可以更加方便地进行异步编程，避免了回调地狱的问题。\n\n\n# javascript和typescript的区别\n\n * javascript是一种脚本语言，可以帮助创建交互式网页，而typescript是javascript的超集。\n * 需要编译类型脚本代码，而不需要编译javascript代码。\n * 比较typescript和js，typescript支持原型化特性，而javascript不支持该特性。\n * typescript使用类型和接口等概念来描述正在使用的数据，而javascript没有这样的概念。\n * typescript是一个功能强大的类型系统，包括用于大型项目的泛型和js特性，而javascript则是用于小型项目的理想选择。\n\n\n# let有什么用，有了var为什么还要用let？\n\n在es6之前，声明变量只能用var，var方式声明变量其实是很不合理的，准确的说，是因为es5里面没有块级作用域是很不合理的。没有块级作用域回来带很多难以理解的问题，比如for循环var变量泄露，变量覆盖等问题。let声明的变量拥有自己的块级作用域，且修复了var声明变量带来的变量提升问题。\n\n\n# yarn和npm\n\nnpm install\nnpm run dev\n\n===\nyarn \nyarn start/dev\n\n===\nnpm install === yarn \nnpm install taco --save === yarn add taco\nnpm uninstall taco --save === yarn remove taco\nnpm install taco --save-dev === yarn add taco --dev\nnpm update --save === yarn upgrade\n\n\nhttps://zhuanlan.zhihu.com/p/23493436",charsets:{cjk:!0},lastUpdated:"2023/03/29, 21:03:43",lastUpdatedTimestamp:1680095023e3},{title:"快捷键",frontmatter:{title:"快捷键",date:"2023-03-31T16:35:46.000Z",permalink:"/pages/960017/",article:!1},regularPath:"/07.%E5%89%8D%E7%AB%AF/01.React/%E5%BF%AB%E6%8D%B7%E9%94%AE.html",relativePath:"07.前端/01.React/快捷键.md",key:"v-224a9095",path:"/pages/960017/",headers:[{level:2,title:"react快捷键",slug:"react快捷键",normalizedTitle:"react快捷键",charIndex:2}],headersStr:"react快捷键",content:"# react快捷键\n\nrcc：react clss component\n\nrfc：react function component",normalizedContent:"# react快捷键\n\nrcc：react clss component\n\nrfc：react function component",charsets:{cjk:!0}},{title:"js异步编程",frontmatter:{title:"js异步编程",date:"2023-04-24T15:17:23.000Z",permalink:"/pages/9ba4c3/"},regularPath:"/07.%E5%89%8D%E7%AB%AF/01.js%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B.html",relativePath:"07.前端/01.js异步编程.md",key:"v-70032af0",path:"/pages/9ba4c3/",headers:[{level:2,title:"Promise",slug:"promise",normalizedTitle:"promise",charIndex:2},{level:3,title:"Promise.all",slug:"promise-all",normalizedTitle:"promise.all",charIndex:354},{level:2,title:"async/await",slug:"async-await",normalizedTitle:"async/await",charIndex:544},{level:2,title:"回调函数",slug:"回调函数",normalizedTitle:"回调函数",charIndex:1767}],headersStr:"Promise Promise.all async/await 回调函数",content:"# Promise\n\nPromise 是 JavaScript 中的一种异步编程解决方案。它可以用于解决回调地狱和多层嵌套的异步代码的问题，使得异步操作更加简单、可读性更高、可维护性更好。\n\nPromise 代表一个尚未完成的异步操作，它有三种状态：pending、fulfilled、rejected。\n\n当异步操作成功完成时，Promise 的状态变为 fulfilled，并返回一个结果；\n\n当异步操作失败时，Promise 的状态变为 rejected，并返回一个错误信息；\n\n当异步操作尚未完成时，Promise 的状态为 pending。\n\nPromise 可以通过 .then() 和 .catch() 方法来处理异步操作完成时的结果或错误信息，从而实现异步操作的链式调用。\n\n同时，可以使用 Promise.all() 方法将多个 Promise 对象组合成一个新的 Promise 对象，并在其中任意一个 Promise 对象变为 rejected 状态时就立即结束，从而实现多个异步操作的并行处理。\n\n在使用 Promise 进行异步编程时，可以将异步操作封装成一个函数，并返回一个 Promise 对象，从而使得异步操作的使用更加简单、可读性更好。此外，在配合使用 async/await 语法时，Promise 可以更加方便地进行异步操作的调用和处理。\n\n\n# Promise.all\n\n如果想要 async 函数中的多个 await 方法并发执行，可以使用 Promise.all 方法将这些 await 方法包装成多个 Promise 对象，然后使用 Promise.all 方法等待所有 Promise 对象的完成，并将它们的 resolved 值合并为一个数组返回。\n\nasync function getData() {\n  const promises = [\n    fetch('https://example.com/data1.json'),\n    fetch('https://example.com/data2.json'),\n    fetch('https://example.com/data3.json')\n  ];\n  const responses = await Promise.all(promises);\n  const data = await Promise.all(responses.map(response => response.json()));\n  console.log(data);\n}\n\ngetData();\n\n\n使用 Promise.all 方法可以让 async 函数中的多个 await 方法并发执行，从而提高异步代码的执行效率。需要注意的是，Promise.all 方法会等待所有 Promise 对象的完成，并将它们的 resolved 值合并为一个数组返回，因此，如果其中任何一个 Promise 对象被 rejected，Promise.all 方法会立即返回一个 rejected 状态的 Promise 对象，并将该 Promise 对象的 rejected 值传递给 catch 方法处理。\n\n相比之下，如果将多个 await 方法分开写成多个语句，每个 await 方法都会等待前一个 await 方法的完成，从而导致异步操作的串行执行，执行效率较低。\n\n\n# async/await\n\nasync 函数是 ES2017（ES8）引入的新特性，它允许在函数前面加上 async 关键字，将普通函数转化为异步函数。异步函数可以使用 await 关键字等待一个异步操作的完成，并将异步操作的结果返回给调用者。\n\nawait 是 ES2017（ES8）引入的新特性，它只能用在 async 函数内部，用于等待一个返回 Promise 对象的表达式完成，并返回该 Promise 对象的 resolved 值。简单来说，await 可以暂停当前 async 函数的执行，等待一个异步操作完成后再继续执行。\n\n使用 await 关键字可以让异步操作的代码更易于阅读和理解，因为它可以将异步代码转化为类似于同步代码的形式，而不需要使用回调函数或 Promise 链式调用的方式来处理异步操作的结果。同时，await 关键字也可以用于处理异步代码中的错误，可以使用 try-catch 语句捕获异步操作中的错误。\n\n// await expression\n\nasync function getData() {\n  const response = await fetch('https://example.com/data.json');\n  const data = await response.json();\n  console.log(data);\n}\n\ngetData();\n\n\n\n其中，expression 是一个返回 Promise 对象的表达式。如果表达式不是 Promise 对象，则会被自动包装成 Promise 对象，然后返回一个 resolved 状态的 Promise 对象。\n\nawait 表达式的执行流程如下：\n\n 1. 如果 expression 是一个已经 resolved 的 Promise 对象，则直接返回该 Promise 对象的 resolved 值。\n 2. 如果 expression 是一个未完成的 Promise 对象，则 await 表达式会暂停当前函数的执行，直到 Promise 对象变成 resolved 状态，然后返回该 Promise 对象的 resolved 值。\n 3. 如果 expression 是一个非 Promise 对象，则 await 表达式会将该对象自动包装成 resolved 状态的 Promise 对象，然后返回该 Promise 对象的 resolved 值。\n\nfunction getUserInfo(userId) {\n  return new Promise((resolve, reject) => {\n    // 模拟异步请求用户信息\n    setTimeout(() => {\n      const userInfo = { id: userId, name: 'Alice' };\n      if (userId === 1) {\n        resolve(userInfo);\n      } else {\n        reject(new Error('User not found'));\n      }\n    }, 1000);\n  });\n}\n\n// 调用异步操作函数并处理异步结果\ngetUserInfo(1)\n  .then(userInfo => console.log(userInfo))\n  .catch(error => console.error(error));\n\ngetUserInfo(2)\n  .then(userInfo => console.log(userInfo))\n  .catch(error => console.error(error));\n\n\n\nfunction getUserInfo(userId) {\n  return new Promise((resolve, reject) => {\n    // 模拟异步请求用户信息\n    setTimeout(() => {\n      const userInfo = { id: userId, name: 'Alice' };\n      if (userId === 1) {\n        resolve(userInfo);\n      } else {\n        reject(new Error('User not found'));\n      }\n    }, 1000);\n  });\n}\n\nasync function main() {\n  try {\n    // 等待异步操作完成并获取结果\n    const userInfo1 = await getUserInfo(1);\n    console.log(userInfo1);\n\n    // 等待异步操作完成并获取结果\n    const userInfo2 = await getUserInfo(2);\n    console.log(userInfo2);\n  } catch (error) {\n    console.error(error);\n  }\n}\n\n// 调用异步操作函数并处理异步结果\nmain();\n\n\n\n如果不使用 async 关键字，那么函数 main 中的异步调用 getUserInfo 实际上是同步执行的，即不会等待异步操作完成并返回结果，而是直接执行下一行代码。\n\n在这个代码中，我们在调用 getUserInfo(1) 和 getUserInfo(2) 时并没有使用 .then() 方法或 await 关键字等待异步操作完成，而是直接把 Promise 对象赋值给 userInfo1 和 userInfo2 变量。这样做的问题在于，由于异步操作的执行需要一定的时间，这些变量实际上是还没有得到值的 Promise 对象，而不是我们期望的用户信息对象。\n\n因此，在 console.log(userInfo1) 和 console.log(userInfo2) 中打印的实际上是 Promise 对象本身，而不是用户信息对象。此外，由于 try...catch 块只能捕获同步代码中的异常，因此如果异步操作抛出异常，我们无法在 catch 块中捕获该异常。\n\n上述代码返回值的区别：\n\n{ id: 1, name: 'Alice' }\nError: User not found\n    at Timeout._onTimeout (file:///Users/billy/Projects/web/vite-project-test/src/promise-test.js:9:18)\n    at listOnTimeout (node:internal/timers:569:17)\n    at process.processTimers (node:internal/timers:512:7)\n\n\n// 不加 async/await\nPromise { <pending> }\nPromise { <pending> }\nfile:///Users/billy/Projects/web/vite-project-test/src/promise-test.js:9\n          reject(new Error('User not found'));\n                 ^\n\nError: User not found\n    at Timeout._onTimeout (file:///Users/billy/Projects/web/vite-project-test/src/promise-test.js:9:18)\n    at listOnTimeout (node:internal/timers:569:17)\n    at process.processTimers (node:internal/timers:512:7)\n\n\n\n\n# 回调函数\n\n回调函数是一种传递函数作为参数的编程模式。在 JavaScript 中，回调函数常常被用于异步编程，将异步操作的结果通过回调函数传递给下一个任务。例如，使用 Node.js 的文件读取方法 fs.readFile() 进行文件读取时，就需要传入一个回调函数来处理读取结果。\n\nconst fs = require('fs');\n\nfs.readFile('file.txt', 'utf8', function(err, data) {\n  if (err) throw err;\n  console.log(data);\n});\n\n\n\n在上面的代码中，fs.readFile() 方法读取文件时是异步的，它需要传入一个回调函数来处理读取结果。回调函数在文件读取完成时被调用，传入两个参数 err 和 data，表示读取操作是否出错以及读取的文件内容。\n\n回调函数的缺点是会产生回调地狱问题，嵌套过多的回调函数会使代码变得难以阅读和维护。",normalizedContent:"# promise\n\npromise 是 javascript 中的一种异步编程解决方案。它可以用于解决回调地狱和多层嵌套的异步代码的问题，使得异步操作更加简单、可读性更高、可维护性更好。\n\npromise 代表一个尚未完成的异步操作，它有三种状态：pending、fulfilled、rejected。\n\n当异步操作成功完成时，promise 的状态变为 fulfilled，并返回一个结果；\n\n当异步操作失败时，promise 的状态变为 rejected，并返回一个错误信息；\n\n当异步操作尚未完成时，promise 的状态为 pending。\n\npromise 可以通过 .then() 和 .catch() 方法来处理异步操作完成时的结果或错误信息，从而实现异步操作的链式调用。\n\n同时，可以使用 promise.all() 方法将多个 promise 对象组合成一个新的 promise 对象，并在其中任意一个 promise 对象变为 rejected 状态时就立即结束，从而实现多个异步操作的并行处理。\n\n在使用 promise 进行异步编程时，可以将异步操作封装成一个函数，并返回一个 promise 对象，从而使得异步操作的使用更加简单、可读性更好。此外，在配合使用 async/await 语法时，promise 可以更加方便地进行异步操作的调用和处理。\n\n\n# promise.all\n\n如果想要 async 函数中的多个 await 方法并发执行，可以使用 promise.all 方法将这些 await 方法包装成多个 promise 对象，然后使用 promise.all 方法等待所有 promise 对象的完成，并将它们的 resolved 值合并为一个数组返回。\n\nasync function getdata() {\n  const promises = [\n    fetch('https://example.com/data1.json'),\n    fetch('https://example.com/data2.json'),\n    fetch('https://example.com/data3.json')\n  ];\n  const responses = await promise.all(promises);\n  const data = await promise.all(responses.map(response => response.json()));\n  console.log(data);\n}\n\ngetdata();\n\n\n使用 promise.all 方法可以让 async 函数中的多个 await 方法并发执行，从而提高异步代码的执行效率。需要注意的是，promise.all 方法会等待所有 promise 对象的完成，并将它们的 resolved 值合并为一个数组返回，因此，如果其中任何一个 promise 对象被 rejected，promise.all 方法会立即返回一个 rejected 状态的 promise 对象，并将该 promise 对象的 rejected 值传递给 catch 方法处理。\n\n相比之下，如果将多个 await 方法分开写成多个语句，每个 await 方法都会等待前一个 await 方法的完成，从而导致异步操作的串行执行，执行效率较低。\n\n\n# async/await\n\nasync 函数是 es2017（es8）引入的新特性，它允许在函数前面加上 async 关键字，将普通函数转化为异步函数。异步函数可以使用 await 关键字等待一个异步操作的完成，并将异步操作的结果返回给调用者。\n\nawait 是 es2017（es8）引入的新特性，它只能用在 async 函数内部，用于等待一个返回 promise 对象的表达式完成，并返回该 promise 对象的 resolved 值。简单来说，await 可以暂停当前 async 函数的执行，等待一个异步操作完成后再继续执行。\n\n使用 await 关键字可以让异步操作的代码更易于阅读和理解，因为它可以将异步代码转化为类似于同步代码的形式，而不需要使用回调函数或 promise 链式调用的方式来处理异步操作的结果。同时，await 关键字也可以用于处理异步代码中的错误，可以使用 try-catch 语句捕获异步操作中的错误。\n\n// await expression\n\nasync function getdata() {\n  const response = await fetch('https://example.com/data.json');\n  const data = await response.json();\n  console.log(data);\n}\n\ngetdata();\n\n\n\n其中，expression 是一个返回 promise 对象的表达式。如果表达式不是 promise 对象，则会被自动包装成 promise 对象，然后返回一个 resolved 状态的 promise 对象。\n\nawait 表达式的执行流程如下：\n\n 1. 如果 expression 是一个已经 resolved 的 promise 对象，则直接返回该 promise 对象的 resolved 值。\n 2. 如果 expression 是一个未完成的 promise 对象，则 await 表达式会暂停当前函数的执行，直到 promise 对象变成 resolved 状态，然后返回该 promise 对象的 resolved 值。\n 3. 如果 expression 是一个非 promise 对象，则 await 表达式会将该对象自动包装成 resolved 状态的 promise 对象，然后返回该 promise 对象的 resolved 值。\n\nfunction getuserinfo(userid) {\n  return new promise((resolve, reject) => {\n    // 模拟异步请求用户信息\n    settimeout(() => {\n      const userinfo = { id: userid, name: 'alice' };\n      if (userid === 1) {\n        resolve(userinfo);\n      } else {\n        reject(new error('user not found'));\n      }\n    }, 1000);\n  });\n}\n\n// 调用异步操作函数并处理异步结果\ngetuserinfo(1)\n  .then(userinfo => console.log(userinfo))\n  .catch(error => console.error(error));\n\ngetuserinfo(2)\n  .then(userinfo => console.log(userinfo))\n  .catch(error => console.error(error));\n\n\n\nfunction getuserinfo(userid) {\n  return new promise((resolve, reject) => {\n    // 模拟异步请求用户信息\n    settimeout(() => {\n      const userinfo = { id: userid, name: 'alice' };\n      if (userid === 1) {\n        resolve(userinfo);\n      } else {\n        reject(new error('user not found'));\n      }\n    }, 1000);\n  });\n}\n\nasync function main() {\n  try {\n    // 等待异步操作完成并获取结果\n    const userinfo1 = await getuserinfo(1);\n    console.log(userinfo1);\n\n    // 等待异步操作完成并获取结果\n    const userinfo2 = await getuserinfo(2);\n    console.log(userinfo2);\n  } catch (error) {\n    console.error(error);\n  }\n}\n\n// 调用异步操作函数并处理异步结果\nmain();\n\n\n\n如果不使用 async 关键字，那么函数 main 中的异步调用 getuserinfo 实际上是同步执行的，即不会等待异步操作完成并返回结果，而是直接执行下一行代码。\n\n在这个代码中，我们在调用 getuserinfo(1) 和 getuserinfo(2) 时并没有使用 .then() 方法或 await 关键字等待异步操作完成，而是直接把 promise 对象赋值给 userinfo1 和 userinfo2 变量。这样做的问题在于，由于异步操作的执行需要一定的时间，这些变量实际上是还没有得到值的 promise 对象，而不是我们期望的用户信息对象。\n\n因此，在 console.log(userinfo1) 和 console.log(userinfo2) 中打印的实际上是 promise 对象本身，而不是用户信息对象。此外，由于 try...catch 块只能捕获同步代码中的异常，因此如果异步操作抛出异常，我们无法在 catch 块中捕获该异常。\n\n上述代码返回值的区别：\n\n{ id: 1, name: 'alice' }\nerror: user not found\n    at timeout._ontimeout (file:///users/billy/projects/web/vite-project-test/src/promise-test.js:9:18)\n    at listontimeout (node:internal/timers:569:17)\n    at process.processtimers (node:internal/timers:512:7)\n\n\n// 不加 async/await\npromise { <pending> }\npromise { <pending> }\nfile:///users/billy/projects/web/vite-project-test/src/promise-test.js:9\n          reject(new error('user not found'));\n                 ^\n\nerror: user not found\n    at timeout._ontimeout (file:///users/billy/projects/web/vite-project-test/src/promise-test.js:9:18)\n    at listontimeout (node:internal/timers:569:17)\n    at process.processtimers (node:internal/timers:512:7)\n\n\n\n\n# 回调函数\n\n回调函数是一种传递函数作为参数的编程模式。在 javascript 中，回调函数常常被用于异步编程，将异步操作的结果通过回调函数传递给下一个任务。例如，使用 node.js 的文件读取方法 fs.readfile() 进行文件读取时，就需要传入一个回调函数来处理读取结果。\n\nconst fs = require('fs');\n\nfs.readfile('file.txt', 'utf8', function(err, data) {\n  if (err) throw err;\n  console.log(data);\n});\n\n\n\n在上面的代码中，fs.readfile() 方法读取文件时是异步的，它需要传入一个回调函数来处理读取结果。回调函数在文件读取完成时被调用，传入两个参数 err 和 data，表示读取操作是否出错以及读取的文件内容。\n\n回调函数的缺点是会产生回调地狱问题，嵌套过多的回调函数会使代码变得难以阅读和维护。",charsets:{cjk:!0}},{title:"JWT",frontmatter:{title:"JWT",date:"2023-03-30T21:17:16.000Z",permalink:"/pages/jwt/"},regularPath:"/08.%E6%96%B9%E6%A1%88/01.JWT.html",relativePath:"08.方案/01.JWT.md",key:"v-10ca5dc4",path:"/pages/jwt/",headers:[{level:2,title:"JWT和session的区别",slug:"jwt和session的区别",normalizedTitle:"jwt和session的区别",charIndex:2},{level:2,title:"JWT的组成",slug:"jwt的组成",normalizedTitle:"jwt的组成",charIndex:200},{level:2,title:"如何防止 Token 被串改？",slug:"如何防止-token-被串改",normalizedTitle:"如何防止 token 被串改？",charIndex:463}],headersStr:"JWT和session的区别 JWT的组成 如何防止 Token 被串改？",content:'# JWT和session的区别\n\n 1. session 存储在服务端占用服务器资源，而 JWT 存储在客户端\n 2. session 存储在 Cookie 中，存在**伪造跨站请求伪造攻击（CSRF）**的风险\n 3. session 只存在一台服务器上，那么下次请求就必须请求这台服务器，不利于分布式应用\n 4. 存储在客户端的 JWT 比存储在服务端的 session 更具有扩展性\n\n\n# JWT的组成\n\nJWT由三部分组成：header.payload.signature\n\nheader 中承载了两部分信息：声明加密算法、声明类型\n\npayload 是主体部分，意为载体，承载着有效的 JWT 数据包，它包含三个部分：标准声明、公共声明、私有声明\n\nJWT 的 Token 相当是明文，是可以解密的，任何存在 payload 的东西，都没有秘密可言，所以隐私数据不能签发 token。\n\nsignature 是签证信息，该签证信息是通过header和payload，加上secret，通过算法加密生成。\n\n\n# 如何防止 Token 被串改？\n\nsignature字段就是关键了，能被解密出明文的，只有header和payload\n\n假如黑客/中间人串改了payload，那么服务器可以通过signature去验证是否被篡改过。\n\n在服务端在执行一次 signature = 加密算法(header + "." + payload, 密钥);, 然后对比 signature 是否一致，如果一致则说明没有被篡改。\n\n所以服务器的密钥不能被泄漏。\n\n参考：https://cnodejs.org/topic/5b0c4a7b8a4f51e140d942fc',normalizedContent:'# jwt和session的区别\n\n 1. session 存储在服务端占用服务器资源，而 jwt 存储在客户端\n 2. session 存储在 cookie 中，存在**伪造跨站请求伪造攻击（csrf）**的风险\n 3. session 只存在一台服务器上，那么下次请求就必须请求这台服务器，不利于分布式应用\n 4. 存储在客户端的 jwt 比存储在服务端的 session 更具有扩展性\n\n\n# jwt的组成\n\njwt由三部分组成：header.payload.signature\n\nheader 中承载了两部分信息：声明加密算法、声明类型\n\npayload 是主体部分，意为载体，承载着有效的 jwt 数据包，它包含三个部分：标准声明、公共声明、私有声明\n\njwt 的 token 相当是明文，是可以解密的，任何存在 payload 的东西，都没有秘密可言，所以隐私数据不能签发 token。\n\nsignature 是签证信息，该签证信息是通过header和payload，加上secret，通过算法加密生成。\n\n\n# 如何防止 token 被串改？\n\nsignature字段就是关键了，能被解密出明文的，只有header和payload\n\n假如黑客/中间人串改了payload，那么服务器可以通过signature去验证是否被篡改过。\n\n在服务端在执行一次 signature = 加密算法(header + "." + payload, 密钥);, 然后对比 signature 是否一致，如果一致则说明没有被篡改。\n\n所以服务器的密钥不能被泄漏。\n\n参考：https://cnodejs.org/topic/5b0c4a7b8a4f51e140d942fc',charsets:{cjk:!0}},{title:"OAuth2",frontmatter:{title:"OAuth2",date:"2023-03-30T21:32:12.000Z",permalink:"/pages/8cac0f/"},regularPath:"/08.%E6%96%B9%E6%A1%88/02.OAuth2.html",relativePath:"08.方案/02.OAuth2.md",key:"v-c92a649c",path:"/pages/8cac0f/",headers:[{level:2,title:"接入Google OAuth2",slug:"接入google-oauth2",normalizedTitle:"接入google oauth2",charIndex:2}],headersStr:"接入Google OAuth2",content:"# 接入Google OAuth2\n\n在前后端分离的架构中，通常建议将 OAuth2.0 授权流程的前半部分（即用户授权）放在前端，将后半部分（即获取访问令牌和用户信息）放在后端。这样可以实现更好的安全性和可维护性。\n\n具体来说，你可以在前端中使用 Google 提供的 JavaScript API，在用户点击登录按钮时弹出 Google 的授权页面，让用户授权你的应用访问其 Google 账号。授权成功后，Google 将会重定向到你事先指定的回调 URL（通常是后端提供的一个 URL），并带上一个授权代码。\n\n在后端中，你可以使用 OAuth2.0 库（例如 Passport 或 Grant）来处理 Google 的授权代码，以获取访问令牌和用户信息。然后，你可以将用户信息存储在数据库中，或使用 JWT 生成一个加密的访问令牌，将其返回给前端。前端可以将这个访问令牌存储在本地（例如 LocalStorage），并在后续的 API 请求中携带这个令牌，以证明用户的身份。\n\n需要注意的是，OAuth2.0 授权流程涉及到敏感信息（例如 Google 账号的访问令牌和用户信息），因此必须采取一定的安全措施，以防止信息泄露和攻击。例如，你可以使用 HTTPS 来加密通信，使用 CORS 来限制跨域访问，使用 CSRF token 来防止 CSRF 攻击等。\n\n\ncode：https://github.com/0xMALVEE/mern-login-system-2022",normalizedContent:"# 接入google oauth2\n\n在前后端分离的架构中，通常建议将 oauth2.0 授权流程的前半部分（即用户授权）放在前端，将后半部分（即获取访问令牌和用户信息）放在后端。这样可以实现更好的安全性和可维护性。\n\n具体来说，你可以在前端中使用 google 提供的 javascript api，在用户点击登录按钮时弹出 google 的授权页面，让用户授权你的应用访问其 google 账号。授权成功后，google 将会重定向到你事先指定的回调 url（通常是后端提供的一个 url），并带上一个授权代码。\n\n在后端中，你可以使用 oauth2.0 库（例如 passport 或 grant）来处理 google 的授权代码，以获取访问令牌和用户信息。然后，你可以将用户信息存储在数据库中，或使用 jwt 生成一个加密的访问令牌，将其返回给前端。前端可以将这个访问令牌存储在本地（例如 localstorage），并在后续的 api 请求中携带这个令牌，以证明用户的身份。\n\n需要注意的是，oauth2.0 授权流程涉及到敏感信息（例如 google 账号的访问令牌和用户信息），因此必须采取一定的安全措施，以防止信息泄露和攻击。例如，你可以使用 https 来加密通信，使用 cors 来限制跨域访问，使用 csrf token 来防止 csrf 攻击等。\n\n\ncode：https://github.com/0xmalvee/mern-login-system-2022",charsets:{cjk:!0}},{title:"CORS的解决方案",frontmatter:{title:"CORS的解决方案",date:"2023-03-30T21:34:40.000Z",permalink:"/pages/fcd0f1/"},regularPath:"/08.%E6%96%B9%E6%A1%88/03.CORS%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88.html",relativePath:"08.方案/03.CORS的解决方案.md",key:"v-76c98d70",path:"/pages/fcd0f1/",headers:[{level:2,title:"使用代理",slug:"使用代理",normalizedTitle:"使用代理",charIndex:118},{level:2,title:"设置 CORS 头",slug:"设置-cors-头",normalizedTitle:"设置 cors 头",charIndex:242},{level:3,title:"spring cloud 可在 gateway 中统一配置",slug:"spring-cloud-可在-gateway-中统一配置",normalizedTitle:"spring cloud 可在 gateway 中统一配置",charIndex:1024},{level:2,title:"JSONP",slug:"jsonp",normalizedTitle:"jsonp",charIndex:1557}],headersStr:"使用代理 设置 CORS 头 spring cloud 可在 gateway 中统一配置 JSONP",content:'CORS（跨域资源共享）是浏览器中的一种安全机制，用于限制从一个域名下的网页去请求另一个域名下的资源，以保护用户的信息安全。如果在前端代码中直接发送跨域请求，可能会遭到浏览器的拦截，导致请求失败。\n\n以下是几种常见的解决方案：\n\n\n# 使用代理\n\n可以在前端代码中发送请求到前端自己的后端服务器，由后端服务器代理到需要请求的服务器上，这样就可以避免直接在前端发送跨域请求了。代理的具体实现可以使用 Node.js 中的 http-proxy-middleware 等中间件。\n\n\n# 设置 CORS 头\n\n如果需要在前端直接发送跨域请求，可以在服务器端设置 CORS 头来允许跨域请求。CORS 头指的是 HTTP 响应头中的一组字段，用于告知浏览器该资源是否允许跨域访问。一般来说，CORS 头包括以下字段：\n\n * Access-Control-Allow-Origin：指定允许访问该资源的域名；\n * Access-Control-Allow-Credentials：指定是否允许发送凭证信息，例如 Cookie；\n * Access-Control-Allow-Methods：指定允许的 HTTP 方法；\n * Access-Control-Allow-Headers：指定允许的自定义请求头。\n\n在服务器端，可以根据请求头中的 Origin 字段来判断是否是跨域请求，并在响应头中设置对应的 CORS 头，示例代码如下：\n\n@Configuration\npublic class WebConfig implements WebMvcConfigurer {\n  @Override\n  public void addCorsMappings(CorsRegistry registry) {\n    // 允许所有域名跨域访问，也可以根据实际情况指定允许的域名\n    registry.addMapping("/api/**")\n            .allowedOrigins("*")\n            .allowedMethods("GET", "POST", "PUT", "DELETE")\n            .allowedHeaders("*")\n            .allowCredentials(true)\n            .maxAge(3600);\n  }\n}\n\n\n\n# spring cloud 可在 gateway 中统一配置\n\n# application.properties\n\n# 允许请求来源（老版本叫allowedOrigin）\nspring.cloud.gateway.globalcors.cors-configurations.[/**].allowedOriginPatterns=*\n# 允许携带的头信息\nspring.cloud.gateway.globalcors.cors-configurations.[/**].allowedHeaders=*\n# 允许的请求方式\nspring.cloud.gateway.globalcors.cors-configurations.[/**].allowedMethods=*\n# 是否允许携带cookie\nspring.cloud.gateway.globalcors.cors-configurations.[/**].allowCredentials=true\n# 跨域检测的有效期，会发起一个OPTION请求\nspring.cloud.gateway.globalcors.cors-configurations.[/**].maxAge=3600\n\n\n\n# JSONP\n\nJSONP 是一种利用 <script> 标签来实现跨域数据传输的方式。通过在客户端动态创建 <script> 标签，设置其 src 属性为跨域的 URL，然后在服务端返回一段 JavaScript 代码，该代码会被客户端当做脚本执行。由于 <script> 标签没有同源策略限制，因此可以用来跨域获取数据。\n\nJSONP（JSON with Padding）是一种跨域解决方案，它利用了 HTML 中的 script 标签不受同源策略限制的特点，通过在客户端动态创建 script 标签，实现从另一个域名（或者同一个域名的不同端口）获取数据。\n\n具体来说，JSONP 的实现流程如下：\n\n 1. 客户端发送请求，请求的 URL 包含一个回调函数名，例如：http://example.com/data?callback=handleData。\n 2. 服务端接收请求后，将数据包装成 JSON 格式，并用回调函数名包裹起来，例如：handleData({"name": "Tom", "age": 20})。\n 3. 服务端将包裹后的数据返回给客户端。\n 4. 客户端收到响应后，会将响应的内容当做 script 代码执行，从而调用回调函数，并传入包裹的数据作为参数。\n 5. 客户端在回调函数中处理数据。\n\n由于 script 标签不受同源策略限制，因此 JSONP 可以跨域访问数据。同时，JSONP 只支持 GET 请求，且需要服务器端支持 JSONP 格式的数据返回。\n\n虽然 JSONP 在解决跨域问题上比较方便，但也存在一些安全风险，例如容易受到 XSS 攻击，因为返回的数据是可以被执行的脚本。因此，现在一般推荐使用设置 CORS 头的方式来解决跨域问题。\n\nJSONP示例代码：\n\nfunction handleData(data) {\n  console.log(data); // 处理获取到的数据\n}\n\nconst script = document.createElement(\'script\');\nscript.src = \'http://example.com/data?callback=handleData\';\ndocument.body.appendChild(script);\n\n\nconst data = {"name": "Tom", "age": 20};\nconst callback = req.query.callback;\nres.send(`${callback}(${JSON.stringify(data)})`);\n',normalizedContent:'cors（跨域资源共享）是浏览器中的一种安全机制，用于限制从一个域名下的网页去请求另一个域名下的资源，以保护用户的信息安全。如果在前端代码中直接发送跨域请求，可能会遭到浏览器的拦截，导致请求失败。\n\n以下是几种常见的解决方案：\n\n\n# 使用代理\n\n可以在前端代码中发送请求到前端自己的后端服务器，由后端服务器代理到需要请求的服务器上，这样就可以避免直接在前端发送跨域请求了。代理的具体实现可以使用 node.js 中的 http-proxy-middleware 等中间件。\n\n\n# 设置 cors 头\n\n如果需要在前端直接发送跨域请求，可以在服务器端设置 cors 头来允许跨域请求。cors 头指的是 http 响应头中的一组字段，用于告知浏览器该资源是否允许跨域访问。一般来说，cors 头包括以下字段：\n\n * access-control-allow-origin：指定允许访问该资源的域名；\n * access-control-allow-credentials：指定是否允许发送凭证信息，例如 cookie；\n * access-control-allow-methods：指定允许的 http 方法；\n * access-control-allow-headers：指定允许的自定义请求头。\n\n在服务器端，可以根据请求头中的 origin 字段来判断是否是跨域请求，并在响应头中设置对应的 cors 头，示例代码如下：\n\n@configuration\npublic class webconfig implements webmvcconfigurer {\n  @override\n  public void addcorsmappings(corsregistry registry) {\n    // 允许所有域名跨域访问，也可以根据实际情况指定允许的域名\n    registry.addmapping("/api/**")\n            .allowedorigins("*")\n            .allowedmethods("get", "post", "put", "delete")\n            .allowedheaders("*")\n            .allowcredentials(true)\n            .maxage(3600);\n  }\n}\n\n\n\n# spring cloud 可在 gateway 中统一配置\n\n# application.properties\n\n# 允许请求来源（老版本叫allowedorigin）\nspring.cloud.gateway.globalcors.cors-configurations.[/**].allowedoriginpatterns=*\n# 允许携带的头信息\nspring.cloud.gateway.globalcors.cors-configurations.[/**].allowedheaders=*\n# 允许的请求方式\nspring.cloud.gateway.globalcors.cors-configurations.[/**].allowedmethods=*\n# 是否允许携带cookie\nspring.cloud.gateway.globalcors.cors-configurations.[/**].allowcredentials=true\n# 跨域检测的有效期，会发起一个option请求\nspring.cloud.gateway.globalcors.cors-configurations.[/**].maxage=3600\n\n\n\n# jsonp\n\njsonp 是一种利用 <script> 标签来实现跨域数据传输的方式。通过在客户端动态创建 <script> 标签，设置其 src 属性为跨域的 url，然后在服务端返回一段 javascript 代码，该代码会被客户端当做脚本执行。由于 <script> 标签没有同源策略限制，因此可以用来跨域获取数据。\n\njsonp（json with padding）是一种跨域解决方案，它利用了 html 中的 script 标签不受同源策略限制的特点，通过在客户端动态创建 script 标签，实现从另一个域名（或者同一个域名的不同端口）获取数据。\n\n具体来说，jsonp 的实现流程如下：\n\n 1. 客户端发送请求，请求的 url 包含一个回调函数名，例如：http://example.com/data?callback=handledata。\n 2. 服务端接收请求后，将数据包装成 json 格式，并用回调函数名包裹起来，例如：handledata({"name": "tom", "age": 20})。\n 3. 服务端将包裹后的数据返回给客户端。\n 4. 客户端收到响应后，会将响应的内容当做 script 代码执行，从而调用回调函数，并传入包裹的数据作为参数。\n 5. 客户端在回调函数中处理数据。\n\n由于 script 标签不受同源策略限制，因此 jsonp 可以跨域访问数据。同时，jsonp 只支持 get 请求，且需要服务器端支持 jsonp 格式的数据返回。\n\n虽然 jsonp 在解决跨域问题上比较方便，但也存在一些安全风险，例如容易受到 xss 攻击，因为返回的数据是可以被执行的脚本。因此，现在一般推荐使用设置 cors 头的方式来解决跨域问题。\n\njsonp示例代码：\n\nfunction handledata(data) {\n  console.log(data); // 处理获取到的数据\n}\n\nconst script = document.createelement(\'script\');\nscript.src = \'http://example.com/data?callback=handledata\';\ndocument.body.appendchild(script);\n\n\nconst data = {"name": "tom", "age": 20};\nconst callback = req.query.callback;\nres.send(`${callback}(${json.stringify(data)})`);\n',charsets:{cjk:!0}},{title:"监控系统选型调研",frontmatter:{title:"监控系统选型调研",date:"2023-03-31T17:01:44.000Z",permalink:"/pages/95c00f/"},regularPath:"/08.%E6%96%B9%E6%A1%88/04.%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F%E9%80%89%E5%9E%8B%E8%B0%83%E7%A0%94.html",relativePath:"08.方案/04.监控系统选型调研.md",key:"v-ab00c88e",path:"/pages/95c00f/",headers:[{level:2,title:"监控系统的作用",slug:"监控系统的作用",normalizedTitle:"监控系统的作用",charIndex:2},{level:2,title:"如何使用监控系统",slug:"如何使用监控系统",normalizedTitle:"如何使用监控系统",charIndex:91},{level:2,title:"监控对象和指标",slug:"监控对象和指标",normalizedTitle:"监控对象和指标",charIndex:248},{level:2,title:"主流监控系统",slug:"主流监控系统",normalizedTitle:"主流监控系统",charIndex:874},{level:2,title:"Spring Boot Admin",slug:"spring-boot-admin",normalizedTitle:"spring boot admin",charIndex:1060},{level:2,title:"选型建议",slug:"选型建议",normalizedTitle:"选型建议",charIndex:1391},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:1862}],headersStr:"监控系统的作用 如何使用监控系统 监控对象和指标 主流监控系统 Spring Boot Admin 选型建议 参考",content:"# 监控系统的作用\n\n * 实时采集监控数据\n * 实时反馈监控状态\n * 预知故障和告警\n * 辅助定位故障\n * 辅助性能调优\n * 辅助容量规划\n * 辅助自动化运维\n\n\n# 如何使用监控系统\n\n * 了解监控对象的工作原理\n   * 比如想对JVM进行监控，就必须清楚JVM的堆内存结构和垃圾回收机制。\n * 确定监控对象的指标\n   * 比如想对某个接口进行监控，可以采用请求量、耗时、超时量、异常量等指标来衡量。\n * 定义合理的报警阈值和等级\n * 建立完善的故障处理流程\n\n\n# 监控对象和指标\n\n * 硬件监控\n   * 电源、CPU、机器温度、风扇、物理磁盘、raid、内存、网卡\n * 服务器基础监控\n   * CPU：单个CPU以及整体的使用情况\n   * 内存：已用内存、可用内存\n   * 磁盘：磁盘使用率、磁盘读写的吞吐量\n   * 网络：出口流量、入口流量、TCP连接状态\n * 数据库监控\n   * 数据库连接数\n   * QPS、TPS\n   * 并行处理的会话数\n   * 缓存命中率\n   * 主从时延\n   * 锁状态\n   * 慢查询\n * 中间件监控\n   * Nginx：活跃连接数、等待、连接数、丢弃连接数、请求量、耗时、5XX错误率\n   * Tomcat：最大线程数、当前线程数、请求量、耗时、错误量、堆内存使用情况、GC次数和耗时\n   * 缓存：成功连接数、阻塞连接数、已使用内存、内存碎片率、请求量、耗时、缓存命中率\n   * 消息队列：连接数、队列数、生成速率、消费速率、消息堆积量\n * 应用监控\n   * HTTP接口：URL存活、请求量、耗时、异常量\n   * RPC接口：请求量、耗时、超时量、拒绝量\n   * JVM：GC次数、GC耗时、各个内存区域的大小、当前线程数、死锁线程数\n   * 线程池：活跃线程数、任务队列大小、任务执行耗时、拒绝任务数\n   * 连接池：总连接数、活跃连接数\n   * 日志监控：访问日志、错误日志\n   * 业务指标：如PV、订单量\n\n\n# 主流监控系统\n\n老牌监控系统：\n\n * Zabbix\n * Nagios\n * Cacti\n * Ganglia\n * Garafana\n\n新一代监控系统：\n\n * Open-Falcon（自动采集，只要安装了falcon-agent的机器，就会自动开始采集各项指标，主动上报，不需要用户在server做任何配置）\n * Prometheus（采用pull模式）\n\n\n# Spring Boot Admin\n\n可以监控spring-boot项目的基本信息比如：Spring容器管理的所有的bean、详细的Health信息、内存信息、JVM信息、垃圾回收信息、各种配置信息（比如数据源、缓存列表和命中率）等，Threads 线程管理，Environment 管理等。\n\n支持多种告警方式接入，如企业微信、钉钉、邮件、短信。\n\n可满足spring boot项目轻量级的使用。\n\n在SBA中，Server作为注册中心，监控所有客户端当前的状态，服务端和客户端之间通过/health接口进行通信，依次来对客户端进行监听。服务端通过定时轮询客户端的/health接口来对客户端进行心态检测。\n\n客户端通过 Actuator 获取信息。\n\n\n# 选型建议\n\n * 首先要明确需求：要监控的对象有哪些，机器数量和监控指标有多少，需要具备什么样的功能。\n * 不要想一开始就all in one，从成本考虑，初期直接使用开源的方案即可，解决从无到有。\n * Zabbix在服务器监控方面占绝对优势，但对应用层监控并不擅长。这点Open-Falcon和Prometheus做的比较好。\n * 新一代监控系统的明显优势：灵活的数据模型，更成熟的时序数据库，强大的告警功能。如果没有对老牌监控系统的技术积累的话，建议直接使用Open-Falcon或Prometheus。\n * Open-Falcon的核心优势在于数据分片功能，能支撑更多的机器和监控项；Prometheus则是容器监控方面的标配，有Google和k8s加持。\n * Zabbix、Open-Falcon和Prometheus都支持和Grafana做快速集成，想要美观且强大的可视化体验，可以和Grafana进行组合。\n * 轻量级使用，可使用SBA，并可对其扩展。\n * Prometheus 也可以选择买阿里云的产品。\n\n\n# 参考\n\n 1. https://www.daimajiaoliu.com/daima/7b7376aeb0be805\n 2. https://cloud.tencent.com/developer/article/1704555\n 3. https://xie.infoq.cn/article/e1d2ad0d57d9fc6b2bb8fd6a5\n 4. https://github.com/codecentric/spring-boot-admin",normalizedContent:"# 监控系统的作用\n\n * 实时采集监控数据\n * 实时反馈监控状态\n * 预知故障和告警\n * 辅助定位故障\n * 辅助性能调优\n * 辅助容量规划\n * 辅助自动化运维\n\n\n# 如何使用监控系统\n\n * 了解监控对象的工作原理\n   * 比如想对jvm进行监控，就必须清楚jvm的堆内存结构和垃圾回收机制。\n * 确定监控对象的指标\n   * 比如想对某个接口进行监控，可以采用请求量、耗时、超时量、异常量等指标来衡量。\n * 定义合理的报警阈值和等级\n * 建立完善的故障处理流程\n\n\n# 监控对象和指标\n\n * 硬件监控\n   * 电源、cpu、机器温度、风扇、物理磁盘、raid、内存、网卡\n * 服务器基础监控\n   * cpu：单个cpu以及整体的使用情况\n   * 内存：已用内存、可用内存\n   * 磁盘：磁盘使用率、磁盘读写的吞吐量\n   * 网络：出口流量、入口流量、tcp连接状态\n * 数据库监控\n   * 数据库连接数\n   * qps、tps\n   * 并行处理的会话数\n   * 缓存命中率\n   * 主从时延\n   * 锁状态\n   * 慢查询\n * 中间件监控\n   * nginx：活跃连接数、等待、连接数、丢弃连接数、请求量、耗时、5xx错误率\n   * tomcat：最大线程数、当前线程数、请求量、耗时、错误量、堆内存使用情况、gc次数和耗时\n   * 缓存：成功连接数、阻塞连接数、已使用内存、内存碎片率、请求量、耗时、缓存命中率\n   * 消息队列：连接数、队列数、生成速率、消费速率、消息堆积量\n * 应用监控\n   * http接口：url存活、请求量、耗时、异常量\n   * rpc接口：请求量、耗时、超时量、拒绝量\n   * jvm：gc次数、gc耗时、各个内存区域的大小、当前线程数、死锁线程数\n   * 线程池：活跃线程数、任务队列大小、任务执行耗时、拒绝任务数\n   * 连接池：总连接数、活跃连接数\n   * 日志监控：访问日志、错误日志\n   * 业务指标：如pv、订单量\n\n\n# 主流监控系统\n\n老牌监控系统：\n\n * zabbix\n * nagios\n * cacti\n * ganglia\n * garafana\n\n新一代监控系统：\n\n * open-falcon（自动采集，只要安装了falcon-agent的机器，就会自动开始采集各项指标，主动上报，不需要用户在server做任何配置）\n * prometheus（采用pull模式）\n\n\n# spring boot admin\n\n可以监控spring-boot项目的基本信息比如：spring容器管理的所有的bean、详细的health信息、内存信息、jvm信息、垃圾回收信息、各种配置信息（比如数据源、缓存列表和命中率）等，threads 线程管理，environment 管理等。\n\n支持多种告警方式接入，如企业微信、钉钉、邮件、短信。\n\n可满足spring boot项目轻量级的使用。\n\n在sba中，server作为注册中心，监控所有客户端当前的状态，服务端和客户端之间通过/health接口进行通信，依次来对客户端进行监听。服务端通过定时轮询客户端的/health接口来对客户端进行心态检测。\n\n客户端通过 actuator 获取信息。\n\n\n# 选型建议\n\n * 首先要明确需求：要监控的对象有哪些，机器数量和监控指标有多少，需要具备什么样的功能。\n * 不要想一开始就all in one，从成本考虑，初期直接使用开源的方案即可，解决从无到有。\n * zabbix在服务器监控方面占绝对优势，但对应用层监控并不擅长。这点open-falcon和prometheus做的比较好。\n * 新一代监控系统的明显优势：灵活的数据模型，更成熟的时序数据库，强大的告警功能。如果没有对老牌监控系统的技术积累的话，建议直接使用open-falcon或prometheus。\n * open-falcon的核心优势在于数据分片功能，能支撑更多的机器和监控项；prometheus则是容器监控方面的标配，有google和k8s加持。\n * zabbix、open-falcon和prometheus都支持和grafana做快速集成，想要美观且强大的可视化体验，可以和grafana进行组合。\n * 轻量级使用，可使用sba，并可对其扩展。\n * prometheus 也可以选择买阿里云的产品。\n\n\n# 参考\n\n 1. https://www.daimajiaoliu.com/daima/7b7376aeb0be805\n 2. https://cloud.tencent.com/developer/article/1704555\n 3. https://xie.infoq.cn/article/e1d2ad0d57d9fc6b2bb8fd6a5\n 4. https://github.com/codecentric/spring-boot-admin",charsets:{cjk:!0}},{title:"Redis分布式锁实现",frontmatter:{title:"Redis分布式锁实现",date:"2023-03-31T17:10:21.000Z",permalink:"/pages/165ba8/"},regularPath:"/08.%E6%96%B9%E6%A1%88/05.redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%AE%9E%E7%8E%B0.html",relativePath:"08.方案/05.redis分布式锁实现.md",key:"v-6158f5dc",path:"/pages/165ba8/",headers:[{level:2,title:"什么是分布式锁？",slug:"什么是分布式锁",normalizedTitle:"什么是分布式锁？",charIndex:2},{level:2,title:"分布式锁的几种实现",slug:"分布式锁的几种实现",normalizedTitle:"分布式锁的几种实现",charIndex:75},{level:2,title:"SETNX指令",slug:"setnx指令",normalizedTitle:"setnx指令",charIndex:280},{level:2,title:"SETNX指令 + EXPIRE指令",slug:"setnx指令-expire指令",normalizedTitle:"setnx指令 + expire指令",charIndex:495},{level:2,title:"SET扩展指令",slug:"set扩展指令",normalizedTitle:"set扩展指令",charIndex:726},{level:2,title:"SET扩展指令 + Lua",slug:"set扩展指令-lua",normalizedTitle:"set扩展指令 + lua",charIndex:1214},{level:2,title:"Redisson",slug:"redisson",normalizedTitle:"redisson",charIndex:1627},{level:2,title:"基于Redis多机实现的Redlock",slug:"基于redis多机实现的redlock",normalizedTitle:"基于redis多机实现的redlock",charIndex:1769},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:2659}],headersStr:"什么是分布式锁？ 分布式锁的几种实现 SETNX指令 SETNX指令 + EXPIRE指令 SET扩展指令 SET扩展指令 + Lua Redisson 基于Redis多机实现的Redlock 参考",content:'# 什么是分布式锁？\n\n分布式锁顾名思义就是用在分布式系统中，用于控制分布式系统之间同步访问共享资源。\n\n核心操作：加锁、解锁、防止锁超时。\n\n\n# 分布式锁的几种实现\n\n * Memcached 分布式锁：Memecached add命令是原子性的。\n * Zookeeper 分布式锁：利用Zookeeper 的顺序临时节点，且临时节点连接中断会自动删除，来实现分布式锁。同时还提供watch机制，可以实现加锁失败就阻塞住，直到获取到锁为止。\n * Chubby：Google实现的粗粒度分布式锁服务。\n * Redis 分布式锁：下文详细讨论。\n\n\n# SETNX指令\n\nSETNX指令只在key不存在的情况下，将key设置为value值，若key存在，则不做任何操作。\n\nkey是锁的唯一标识，可以按业务需求锁定的资源命名。\n\nSETNX lock_key lock_value\ndo something\nDEL lock_key\n\n\n这一方式的问题在于：锁超时问题。如果获得锁的进程在业务处理过程中出现了异常，将导致DEL指令无法执行，锁无法释放，该资源将会被一直锁住。\n\n\n# SETNX指令 + EXPIRE指令\n\n因此很容易想到，给key设置一个过期时间。由于SETNX不支持设置过期时间，所以需要额外的EXPIRE指令\n\nSETNX lock_key lock_value\nEXPIRE lock_key 10\ndo something\nDEL lock_key\n\n\n这一方式的问题在于：SETNX 和 EXPIRE 这两个操作是非原子性的， 如果进程在执行 SETNX 和 EXPIRE 之间发生异常，同样会出现上述问题。\n\n\n# SET扩展指令\n\n为了解决 SETNX 和 EXPIRE 两个操作非原子性的问题，可以使用 Redis 的 SET 指令的扩展参数，使得 SETNX 和 EXPIRE 这两个操作可以原子执行。\n\nSET lock_key lock_value NX EX 10\ndo something\nDEL lock_key\n\n\n这一方式的问题在于：锁可能在业务处理结束前提前释放。从而也可能导致锁被误删。\n\n为了避免上述情况，建议不要在执行时间过长的场景中使用 Redis 分布式锁，同时一个比较安全的做法是在执行 DEL 释放锁之前对锁进行判断，验证当前锁的持有者是否是自己。\n\n具体实现就是在加锁时将 value 设置为一个唯一的随机数（或者线程 ID ），释放锁时先判断随机数是否一致，然后再执行释放操作，确保不会错误地释放其它线程持有的锁，除非是锁过期了被服务器自动释放。\n\nSET lock_key random_value nx ex 10\ndo something\nif random_value == lock_key.value\n\tDEL lock_key\n\n\n\n# SET扩展指令 + Lua\n\n但判断 value 和删除 key 是两个独立的操作，并不是原子性的，所以这个地方需要使用 Lua 脚本进行处理。\n\nif redis.call("get", KEYS[1]) == ARGV[1] then\n  return redis.call("del", KEYS[1])\nelse \n  return 0\nend\n\n\n> Redis使用Lua脚本时为什么能保证原子性?\n> \n> Redis使用同一个的Lua解释器，来运行所有的命令。Redis保证以一种原子性的方式来执行脚本。在执行脚本时，不会执行其他脚本或Redis命令。这个语义类似于MULTI（开启事务）/EXEC（触发事务，一并执行事务中的所有命令）。从所有其他客户端的角度来看，脚本的效果要么仍然不可见，要么已经完成。\n\n但这并不是一个完美的方案，只是相对完全一点，因为它并没有完全解决执行超时锁被提前释放的问题。\n\n\n# Redisson\n\n原理：可以利用锁的可重入特性，让获得锁的线程开启一个定时器的守护线程，每 expireTime/3 执行一次，去检查该线程的锁是否存在，如果存在则对锁的过期时间重新设置为 expireTime，即利用守护线程对锁进行“续命”，防止锁由于过期提前释放。\n\n\n\n\n# 基于Redis多机实现的Redlock\n\n以上几种基于 Redis 单机实现的分布式锁其实都存在一个问题，就是加锁时只作用在一个 Redis 节点上，即使 Redis 通过 Sentinel 保证了高可用，但由于 Redis 的复制是异步的，Master 节点获取到锁后在未完成数据同步的情况下发生故障转移，此时其他客户端上的线程依然可以获取到锁，因此会丧失锁的安全性。\n\n在 Redis 的分布式环境中，Redis 的作者 antirez 提供了 RedLock 的算法来实现一个分布式锁，该算法大概是这样的：\n\n假设有 N（N>=5）个 Redis 节点，这些节点完全互相独立，不存在主从复制或者其他集群协调机制，确保在这 N 个节点上使用与在 Redis 单实例下相同的方法获取和释放锁。\n\n获取锁的过程，客户端应执行如下操作：\n\n * 获取当前 Unix 时间，以毫秒为单位。\n * 按顺序依次尝试从 5 个实例使用相同的 key 和具有唯一性的 value（例如 UUID）获取锁。当向 Redis 请求获取锁时，客户端应该设置一个网络连接和响应超时时间，这个超时时间应该小于锁的失效时间。例如锁自动失效时间为 10 秒，则超时时间应该在 5-50 毫秒之间。这样可以避免服务器端 Redis 已经挂掉的情况下，客户端还在一直等待响应结果。如果服务器端没有在规定时间内响应，客户端应该尽快尝试去另外一个 Redis 实例请求获取锁。\n * 客户端使用当前时间减去开始获取锁时间（步骤 1 记录的时间）就得到获取锁使用的时间。当且仅当从大多数（N/2+1，这里是 3 个节点）的 Redis 节点都取到锁，并且使用的时间小于锁失效时间时，锁才算获取成功。\n * 如果取到了锁，key 的真正有效时间等于有效时间减去获取锁所使用的时间（步骤 3 计算的结果）。\n * 如果因为某些原因，获取锁失败（没有在至少 N/2+1 个 Redis 实例取到锁或者取锁时间已经超过了有效时间），客户端应该在所有的 Redis 实例上进行解锁（使用 Redis Lua 脚本）。\n\n\n# 参考\n\n 1. https://www.infoq.cn/article/dvaaj71f4fbqsxmgvdce\n\n 2. https://juejin.cn/post/6844903830442737671#heading-14',normalizedContent:'# 什么是分布式锁？\n\n分布式锁顾名思义就是用在分布式系统中，用于控制分布式系统之间同步访问共享资源。\n\n核心操作：加锁、解锁、防止锁超时。\n\n\n# 分布式锁的几种实现\n\n * memcached 分布式锁：memecached add命令是原子性的。\n * zookeeper 分布式锁：利用zookeeper 的顺序临时节点，且临时节点连接中断会自动删除，来实现分布式锁。同时还提供watch机制，可以实现加锁失败就阻塞住，直到获取到锁为止。\n * chubby：google实现的粗粒度分布式锁服务。\n * redis 分布式锁：下文详细讨论。\n\n\n# setnx指令\n\nsetnx指令只在key不存在的情况下，将key设置为value值，若key存在，则不做任何操作。\n\nkey是锁的唯一标识，可以按业务需求锁定的资源命名。\n\nsetnx lock_key lock_value\ndo something\ndel lock_key\n\n\n这一方式的问题在于：锁超时问题。如果获得锁的进程在业务处理过程中出现了异常，将导致del指令无法执行，锁无法释放，该资源将会被一直锁住。\n\n\n# setnx指令 + expire指令\n\n因此很容易想到，给key设置一个过期时间。由于setnx不支持设置过期时间，所以需要额外的expire指令\n\nsetnx lock_key lock_value\nexpire lock_key 10\ndo something\ndel lock_key\n\n\n这一方式的问题在于：setnx 和 expire 这两个操作是非原子性的， 如果进程在执行 setnx 和 expire 之间发生异常，同样会出现上述问题。\n\n\n# set扩展指令\n\n为了解决 setnx 和 expire 两个操作非原子性的问题，可以使用 redis 的 set 指令的扩展参数，使得 setnx 和 expire 这两个操作可以原子执行。\n\nset lock_key lock_value nx ex 10\ndo something\ndel lock_key\n\n\n这一方式的问题在于：锁可能在业务处理结束前提前释放。从而也可能导致锁被误删。\n\n为了避免上述情况，建议不要在执行时间过长的场景中使用 redis 分布式锁，同时一个比较安全的做法是在执行 del 释放锁之前对锁进行判断，验证当前锁的持有者是否是自己。\n\n具体实现就是在加锁时将 value 设置为一个唯一的随机数（或者线程 id ），释放锁时先判断随机数是否一致，然后再执行释放操作，确保不会错误地释放其它线程持有的锁，除非是锁过期了被服务器自动释放。\n\nset lock_key random_value nx ex 10\ndo something\nif random_value == lock_key.value\n\tdel lock_key\n\n\n\n# set扩展指令 + lua\n\n但判断 value 和删除 key 是两个独立的操作，并不是原子性的，所以这个地方需要使用 lua 脚本进行处理。\n\nif redis.call("get", keys[1]) == argv[1] then\n  return redis.call("del", keys[1])\nelse \n  return 0\nend\n\n\n> redis使用lua脚本时为什么能保证原子性?\n> \n> redis使用同一个的lua解释器，来运行所有的命令。redis保证以一种原子性的方式来执行脚本。在执行脚本时，不会执行其他脚本或redis命令。这个语义类似于multi（开启事务）/exec（触发事务，一并执行事务中的所有命令）。从所有其他客户端的角度来看，脚本的效果要么仍然不可见，要么已经完成。\n\n但这并不是一个完美的方案，只是相对完全一点，因为它并没有完全解决执行超时锁被提前释放的问题。\n\n\n# redisson\n\n原理：可以利用锁的可重入特性，让获得锁的线程开启一个定时器的守护线程，每 expiretime/3 执行一次，去检查该线程的锁是否存在，如果存在则对锁的过期时间重新设置为 expiretime，即利用守护线程对锁进行“续命”，防止锁由于过期提前释放。\n\n\n\n\n# 基于redis多机实现的redlock\n\n以上几种基于 redis 单机实现的分布式锁其实都存在一个问题，就是加锁时只作用在一个 redis 节点上，即使 redis 通过 sentinel 保证了高可用，但由于 redis 的复制是异步的，master 节点获取到锁后在未完成数据同步的情况下发生故障转移，此时其他客户端上的线程依然可以获取到锁，因此会丧失锁的安全性。\n\n在 redis 的分布式环境中，redis 的作者 antirez 提供了 redlock 的算法来实现一个分布式锁，该算法大概是这样的：\n\n假设有 n（n>=5）个 redis 节点，这些节点完全互相独立，不存在主从复制或者其他集群协调机制，确保在这 n 个节点上使用与在 redis 单实例下相同的方法获取和释放锁。\n\n获取锁的过程，客户端应执行如下操作：\n\n * 获取当前 unix 时间，以毫秒为单位。\n * 按顺序依次尝试从 5 个实例使用相同的 key 和具有唯一性的 value（例如 uuid）获取锁。当向 redis 请求获取锁时，客户端应该设置一个网络连接和响应超时时间，这个超时时间应该小于锁的失效时间。例如锁自动失效时间为 10 秒，则超时时间应该在 5-50 毫秒之间。这样可以避免服务器端 redis 已经挂掉的情况下，客户端还在一直等待响应结果。如果服务器端没有在规定时间内响应，客户端应该尽快尝试去另外一个 redis 实例请求获取锁。\n * 客户端使用当前时间减去开始获取锁时间（步骤 1 记录的时间）就得到获取锁使用的时间。当且仅当从大多数（n/2+1，这里是 3 个节点）的 redis 节点都取到锁，并且使用的时间小于锁失效时间时，锁才算获取成功。\n * 如果取到了锁，key 的真正有效时间等于有效时间减去获取锁所使用的时间（步骤 3 计算的结果）。\n * 如果因为某些原因，获取锁失败（没有在至少 n/2+1 个 redis 实例取到锁或者取锁时间已经超过了有效时间），客户端应该在所有的 redis 实例上进行解锁（使用 redis lua 脚本）。\n\n\n# 参考\n\n 1. https://www.infoq.cn/article/dvaaj71f4fbqsxmgvdce\n\n 2. https://juejin.cn/post/6844903830442737671#heading-14',charsets:{cjk:!0}},{title:"Spring",frontmatter:{title:"Spring",date:"2023-03-30T22:06:46.000Z",permalink:"/pages/spring/"},regularPath:"/09.Java%E6%A1%86%E6%9E%B6/01.Spring/01.Spring.html",relativePath:"09.Java框架/01.Spring/01.Spring.md",key:"v-68d67e22",path:"/pages/spring/",headers:[{level:2,title:"IOC的理解",slug:"ioc的理解",normalizedTitle:"ioc的理解",charIndex:2},{level:2,title:"IOC的实现原理",slug:"ioc的实现原理",normalizedTitle:"ioc的实现原理",charIndex:334},{level:2,title:"AOP的理解",slug:"aop的理解",normalizedTitle:"aop的理解",charIndex:957},{level:2,title:"AOP的实现原理",slug:"aop的实现原理",normalizedTitle:"aop的实现原理",charIndex:1791},{level:2,title:"Bean的生命周期",slug:"bean的生命周期",normalizedTitle:"bean的生命周期",charIndex:2092},{level:2,title:"Bean 的作用域",slug:"bean-的作用域",normalizedTitle:"bean 的作用域",charIndex:2734},{level:2,title:"单例Bean 的好处",slug:"单例bean-的好处",normalizedTitle:"单例bean 的好处",charIndex:3171},{level:2,title:"单例bean可能导致的线程问题",slug:"单例bean可能导致的线程问题",normalizedTitle:"单例bean可能导致的线程问题",charIndex:3598},{level:2,title:"Spring 事务",slug:"spring-事务",normalizedTitle:"spring 事务",charIndex:4263}],headersStr:"IOC的理解 IOC的实现原理 AOP的理解 AOP的实现原理 Bean的生命周期 Bean 的作用域 单例Bean 的好处 单例bean可能导致的线程问题 Spring 事务",content:"# IOC的理解\n\nIOC 是 Inversion of Control 控制反转。\n\n软件系统在没有引入 IOC 容器之前，对象 A 依赖于对象 B，那么对象 A 在初始化或者运行到某一点的时候，自己必须主动去创建对象 B 或者使用已经创建的对象 B。无论是创建还是使用对象 B，控制权都在自己手上。\n\n软件系统在引入 IOC 容器之后，这种情形就完全改变了，由于 IOC 容器的加入，对象 A 与对象 B 之间失去了直接联系，所以，当对象 A 运行到需要对象 B 的时候，IOC 容器会主动创建一个对象 B 注入到对象 A 需要的地方。\n\n对象 A 获得依赖对象 B 的过程，由主动行为变为了被动行为，控制权颠倒过来了，这就是“控制反转”这个名称的由来。\n\n\n# IOC的实现原理\n\nSpring IOC (Inversion of Control) 的实现原理基于依赖注入 (Dependency Injection) 模式，它主要包括以下几个步骤：\n\n 1. 配置：通过 XML 文件或 Java 配置类等方式，定义 Spring Bean 的配置信息，包括类名、构造函数参数、属性值等。\n 2. 实例化：Spring 根据配置信息创建 Bean 的实例，通常使用 Java 反射机制来实现。\n 3. 依赖注入：Spring 根据配置信息，将创建好的 Bean 实例注入到需要它的地方，包括构造函数注入、Setter 方法注入等。\n 4. 生命周期管理：Spring 管理 Bean 的生命周期，包括初始化和销毁等阶段，可以在 Bean 中定义初始化方法和销毁方法，Spring 会在相应的阶段调用它们。\n\n具体实现上，Spring 使用了一个叫做 BeanFactory 的容器来管理所有的 Bean，这个容器在初始化时会读取配置文件或配置类，然后根据配置信息创建 Bean 实例，并将它们存储在一个 Map 中。当其他 Bean 需要依赖这些 Bean 时，Spring 会从 Map 中取出相应的 Bean 实例，并将它们注入到需要它们的地方。\n\nSpring IOC 的实现原理使得开发者可以更加关注业务逻辑，而不需要过多关注 Bean 的创建和管理，从而提高了开发效率和代码的可维护性。\n\n\n# AOP的理解\n\nAOP（Aspect-Oriented Programming，面向切面编程），可以说是 OOP（Object-Oriented Programing，面向对象编程）的补充和完善。OOP 引入封装、继承和多态性等概念来建立一种对象层次结构，用以模拟公共行为的一个集合。当我们需要为分散的对象引入公共行为的时候，OOP 则显得无能为力。也就是说，OOP 允许你定义从上到下的关系，但并不适合定义从左到右的关系。例如日志功能。日志代码往往水平地散布在所有对象层次中，而与它所散布到的对象的核心功能毫无关系。对于其他类型的代码，如：安全性、异常处理和透明的持续性也是如此。这种散布在各处的无关的代码被称为横切（cross-cutting）代码，在 OOP 设计中，它导致了大量代码的重复，而不利于各个模块的重用。\n\n而 AOP 技术则恰恰相反，它利用一种称为“横切”的技术，剖解开封装的对象内部，并将那些影响了多个类的公共行为封装到一个可重用模块，并将其名为“Aspect”，即切面。所谓“切面”，简单地说，就是将那些与业务无关，却为业务模块所共同调用的逻辑或责任封装起来，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可操作性和可维护性。AOP 代表的是一个横向的关系，如果说“对象”是一个空心的圆柱体，其中封装的是对象的属性和行为；那么面向方面编程的方法，就仿佛一把利刃，将这些空心圆柱体剖开，以获得其内部的消息。而剖开的切面，也就是所谓的“方面”了。然后它又以巧夺天功的妙手将这些剖开的切面复原，不留痕迹。\n\n使用“横切”技术，AOP 把软件系统分为两个部分：核心关注点和横切关注点。业务处理的主要流程是核心关注点，与之关系不大的部分是横切关注点。横切关注点的一个特点是，它们经常发生在核心关注点的多处，而各处都基本相似。比如：权限认证、日志、事务处理。AOP 的作用在于分离系统中的各种关注点，将核心关注点和横切关注点分离开来。\n\n\n# AOP的实现原理\n\nAOP 思想的实现一般都是基于代理模式 ，在 Java 中一般采用 JDK 动态代理模式，但是我们都知道，JDK 动态代理模式只能代理接口而不能代理类。因此，Spring AOP 会按照下面两种情况进行切换，因为 Spring AOP 同时支持 CGLIB、ASPECTJ、JDK 动态代理。\n\n 1. 如果目标对象的实现类实现了接口，Spring AOP 将会采用 JDK 动态代理来生成 AOP 代理类；\n 2. 如果目标对象的实现类没有实现接口，Spring AOP 将会采用 CGLIB 来生成 AOP 代理类。不过这个选择过程对开发者完全透明、开发者也无需关心。\n\n\n# Bean的生命周期\n\n 1. 实例化：Spring 根据配置信息创建 Bean 实例，通常使用 Java 反射机制来实现。\n 2. 属性赋值：Spring 根据配置信息或注解将属性值注入到 Bean 中。\n 3. Aware 回调：Spring 调用实现了相应接口的 Bean 的回调方法，例如 BeanNameAware、BeanFactoryAware、ApplicationContextAware 等。\n 4. 初始化：Spring 执行初始化方法，这个方法可以通过配置文件或注解来指定，一般用于 Bean 的初始化工作。\n 5. 初始化后处理：Spring 执行实现了 BeanPostProcessor 接口的类的 postProcessBeforeInitialization 方法和 postProcessAfterInitialization 方法，这两个方法可以在 Bean 初始化前和初始化后进行一些操作。\n 6. 使用：Bean 可以被使用了，执行相关的业务逻辑。\n 7. 销毁：Spring 执行销毁方法，这个方法可以通过配置文件或注解来指定，一般用于释放资源等清理工作。\n\n需要注意的是，不是所有的 Bean 都需要实现所有阶段，可以根据具体需求来决定是否实现某个阶段的回调方法。而且，Bean 的生命周期也可以通过编写 BeanPostProcessor 的实现类来进行自定义，这可以让开发者在 Bean 初始化前或初始化后执行一些额外的操作。\n\n\n# Bean 的作用域\n\n 1. singleton : 唯一 bean 实例，Spring 中的 bean 默认都是单例的；\n 2. prototype : 每次请求都会创建一个新的 bean 实例；\n 3. request：每一次 HTTP 请求都会产生一个新的 bean，该 bean 仅在当前 HTTP request 内有效；\n 4. session : 每一次 HTTP 请求都会产生一个新的 bean，该 bean 仅在当前 HTTP session 内有效；\n 5. global-session：全局 session 作用域，仅仅在基于 portlet 的 web 应用中才有意义，Spring5 已经没有了。Portlet 是能够生成语义代码(例如：HTML)片段的小型 Java Web 插件。它们基于 portlet 容器，可以像 servlet 一样处理 HTTP 请求。但是，与 servlet 不同，每个 portlet 都有不同的会话。\n\n\n# 单例Bean 的好处\n\n单例 Bean 是 Spring 容器中最常见的一种 Bean，其主要好处包括：\n\n 1. 节省资源：单例 Bean 在 Spring 容器中只会被创建一次，这可以减少创建和销毁 Bean 的开销，从而减少内存和 CPU 的使用，提高系统性能。\n 2. 维护状态：单例 Bean 可以维护状态，因为它只会被创建一次，可以在整个应用程序的生命周期中保持状态的一致性。\n 3. 便于管理：单例 Bean 在整个应用程序中都是唯一的，这使得它们易于管理和维护，因为在整个应用程序中只有一个实例。\n 4. 提高性能：单例 Bean 的创建和销毁只会发生一次，这可以避免频繁地创建和销毁 Bean 所带来的性能损失。同时，由于单例 Bean 的实例只有一个，可以避免重复的对象创建和内存占用。\n 5. 简化依赖注入：单例 Bean 在整个应用程序中都是唯一的，因此可以很方便地被注入到其他 Bean 中，从而简化了依赖注入的代码。\n\n\n# 单例bean可能导致的线程问题\n\n单例 Bean 在 Spring 容器中只会创建一次，它会在容器初始化时被创建，之后会一直存在于容器中，直到容器被销毁。因为单例 Bean 只有一个实例，所以在多线程环境下，不同的线程可能会同时访问同一个单例 Bean 实例，从而可能导致线程安全问题。\n\n如果单例 Bean 存在共享的可变状态，比如属性或静态变量，那么多线程访问这些状态时就会存在竞争条件（Race Condition）和数据不一致等问题。比如，在一个多线程的环境下，一个线程正在修改 Bean 的某个属性，而另一个线程同时也在访问该属性，那么就可能导致该属性值的不确定性和线程安全问题。\n\n为了解决单例 Bean 的线程安全问题，可以采用以下几种方式：\n\n 1. 避免在单例 Bean 中定义共享的可变状态，或者将共享的可变状态限制在方法局部变量中。\n 2. 使用线程安全的数据结构，如 ConcurrentHashMap、ConcurrentLinkedQueue 等，来保证多线程访问时的线程安全。\n 3. 在需要共享状态的情况下，使用 synchronized 关键字或者 ReentrantLock 等方式来保证线程安全。\n 4. 将单例 Bean 替换成原型 Bean，即每次从容器中获取 Bean 时都会创建一个新的实例。这种方式可以保证 Bean 的线程安全，但会增加内存开销。\n 5. 在类中定义一个 ThreadLocal 成员变量，将需要的可变成员变量保存在 ThreadLocal 中（推荐）。\n\n\n# Spring 事务",normalizedContent:"# ioc的理解\n\nioc 是 inversion of control 控制反转。\n\n软件系统在没有引入 ioc 容器之前，对象 a 依赖于对象 b，那么对象 a 在初始化或者运行到某一点的时候，自己必须主动去创建对象 b 或者使用已经创建的对象 b。无论是创建还是使用对象 b，控制权都在自己手上。\n\n软件系统在引入 ioc 容器之后，这种情形就完全改变了，由于 ioc 容器的加入，对象 a 与对象 b 之间失去了直接联系，所以，当对象 a 运行到需要对象 b 的时候，ioc 容器会主动创建一个对象 b 注入到对象 a 需要的地方。\n\n对象 a 获得依赖对象 b 的过程，由主动行为变为了被动行为，控制权颠倒过来了，这就是“控制反转”这个名称的由来。\n\n\n# ioc的实现原理\n\nspring ioc (inversion of control) 的实现原理基于依赖注入 (dependency injection) 模式，它主要包括以下几个步骤：\n\n 1. 配置：通过 xml 文件或 java 配置类等方式，定义 spring bean 的配置信息，包括类名、构造函数参数、属性值等。\n 2. 实例化：spring 根据配置信息创建 bean 的实例，通常使用 java 反射机制来实现。\n 3. 依赖注入：spring 根据配置信息，将创建好的 bean 实例注入到需要它的地方，包括构造函数注入、setter 方法注入等。\n 4. 生命周期管理：spring 管理 bean 的生命周期，包括初始化和销毁等阶段，可以在 bean 中定义初始化方法和销毁方法，spring 会在相应的阶段调用它们。\n\n具体实现上，spring 使用了一个叫做 beanfactory 的容器来管理所有的 bean，这个容器在初始化时会读取配置文件或配置类，然后根据配置信息创建 bean 实例，并将它们存储在一个 map 中。当其他 bean 需要依赖这些 bean 时，spring 会从 map 中取出相应的 bean 实例，并将它们注入到需要它们的地方。\n\nspring ioc 的实现原理使得开发者可以更加关注业务逻辑，而不需要过多关注 bean 的创建和管理，从而提高了开发效率和代码的可维护性。\n\n\n# aop的理解\n\naop（aspect-oriented programming，面向切面编程），可以说是 oop（object-oriented programing，面向对象编程）的补充和完善。oop 引入封装、继承和多态性等概念来建立一种对象层次结构，用以模拟公共行为的一个集合。当我们需要为分散的对象引入公共行为的时候，oop 则显得无能为力。也就是说，oop 允许你定义从上到下的关系，但并不适合定义从左到右的关系。例如日志功能。日志代码往往水平地散布在所有对象层次中，而与它所散布到的对象的核心功能毫无关系。对于其他类型的代码，如：安全性、异常处理和透明的持续性也是如此。这种散布在各处的无关的代码被称为横切（cross-cutting）代码，在 oop 设计中，它导致了大量代码的重复，而不利于各个模块的重用。\n\n而 aop 技术则恰恰相反，它利用一种称为“横切”的技术，剖解开封装的对象内部，并将那些影响了多个类的公共行为封装到一个可重用模块，并将其名为“aspect”，即切面。所谓“切面”，简单地说，就是将那些与业务无关，却为业务模块所共同调用的逻辑或责任封装起来，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可操作性和可维护性。aop 代表的是一个横向的关系，如果说“对象”是一个空心的圆柱体，其中封装的是对象的属性和行为；那么面向方面编程的方法，就仿佛一把利刃，将这些空心圆柱体剖开，以获得其内部的消息。而剖开的切面，也就是所谓的“方面”了。然后它又以巧夺天功的妙手将这些剖开的切面复原，不留痕迹。\n\n使用“横切”技术，aop 把软件系统分为两个部分：核心关注点和横切关注点。业务处理的主要流程是核心关注点，与之关系不大的部分是横切关注点。横切关注点的一个特点是，它们经常发生在核心关注点的多处，而各处都基本相似。比如：权限认证、日志、事务处理。aop 的作用在于分离系统中的各种关注点，将核心关注点和横切关注点分离开来。\n\n\n# aop的实现原理\n\naop 思想的实现一般都是基于代理模式 ，在 java 中一般采用 jdk 动态代理模式，但是我们都知道，jdk 动态代理模式只能代理接口而不能代理类。因此，spring aop 会按照下面两种情况进行切换，因为 spring aop 同时支持 cglib、aspectj、jdk 动态代理。\n\n 1. 如果目标对象的实现类实现了接口，spring aop 将会采用 jdk 动态代理来生成 aop 代理类；\n 2. 如果目标对象的实现类没有实现接口，spring aop 将会采用 cglib 来生成 aop 代理类。不过这个选择过程对开发者完全透明、开发者也无需关心。\n\n\n# bean的生命周期\n\n 1. 实例化：spring 根据配置信息创建 bean 实例，通常使用 java 反射机制来实现。\n 2. 属性赋值：spring 根据配置信息或注解将属性值注入到 bean 中。\n 3. aware 回调：spring 调用实现了相应接口的 bean 的回调方法，例如 beannameaware、beanfactoryaware、applicationcontextaware 等。\n 4. 初始化：spring 执行初始化方法，这个方法可以通过配置文件或注解来指定，一般用于 bean 的初始化工作。\n 5. 初始化后处理：spring 执行实现了 beanpostprocessor 接口的类的 postprocessbeforeinitialization 方法和 postprocessafterinitialization 方法，这两个方法可以在 bean 初始化前和初始化后进行一些操作。\n 6. 使用：bean 可以被使用了，执行相关的业务逻辑。\n 7. 销毁：spring 执行销毁方法，这个方法可以通过配置文件或注解来指定，一般用于释放资源等清理工作。\n\n需要注意的是，不是所有的 bean 都需要实现所有阶段，可以根据具体需求来决定是否实现某个阶段的回调方法。而且，bean 的生命周期也可以通过编写 beanpostprocessor 的实现类来进行自定义，这可以让开发者在 bean 初始化前或初始化后执行一些额外的操作。\n\n\n# bean 的作用域\n\n 1. singleton : 唯一 bean 实例，spring 中的 bean 默认都是单例的；\n 2. prototype : 每次请求都会创建一个新的 bean 实例；\n 3. request：每一次 http 请求都会产生一个新的 bean，该 bean 仅在当前 http request 内有效；\n 4. session : 每一次 http 请求都会产生一个新的 bean，该 bean 仅在当前 http session 内有效；\n 5. global-session：全局 session 作用域，仅仅在基于 portlet 的 web 应用中才有意义，spring5 已经没有了。portlet 是能够生成语义代码(例如：html)片段的小型 java web 插件。它们基于 portlet 容器，可以像 servlet 一样处理 http 请求。但是，与 servlet 不同，每个 portlet 都有不同的会话。\n\n\n# 单例bean 的好处\n\n单例 bean 是 spring 容器中最常见的一种 bean，其主要好处包括：\n\n 1. 节省资源：单例 bean 在 spring 容器中只会被创建一次，这可以减少创建和销毁 bean 的开销，从而减少内存和 cpu 的使用，提高系统性能。\n 2. 维护状态：单例 bean 可以维护状态，因为它只会被创建一次，可以在整个应用程序的生命周期中保持状态的一致性。\n 3. 便于管理：单例 bean 在整个应用程序中都是唯一的，这使得它们易于管理和维护，因为在整个应用程序中只有一个实例。\n 4. 提高性能：单例 bean 的创建和销毁只会发生一次，这可以避免频繁地创建和销毁 bean 所带来的性能损失。同时，由于单例 bean 的实例只有一个，可以避免重复的对象创建和内存占用。\n 5. 简化依赖注入：单例 bean 在整个应用程序中都是唯一的，因此可以很方便地被注入到其他 bean 中，从而简化了依赖注入的代码。\n\n\n# 单例bean可能导致的线程问题\n\n单例 bean 在 spring 容器中只会创建一次，它会在容器初始化时被创建，之后会一直存在于容器中，直到容器被销毁。因为单例 bean 只有一个实例，所以在多线程环境下，不同的线程可能会同时访问同一个单例 bean 实例，从而可能导致线程安全问题。\n\n如果单例 bean 存在共享的可变状态，比如属性或静态变量，那么多线程访问这些状态时就会存在竞争条件（race condition）和数据不一致等问题。比如，在一个多线程的环境下，一个线程正在修改 bean 的某个属性，而另一个线程同时也在访问该属性，那么就可能导致该属性值的不确定性和线程安全问题。\n\n为了解决单例 bean 的线程安全问题，可以采用以下几种方式：\n\n 1. 避免在单例 bean 中定义共享的可变状态，或者将共享的可变状态限制在方法局部变量中。\n 2. 使用线程安全的数据结构，如 concurrenthashmap、concurrentlinkedqueue 等，来保证多线程访问时的线程安全。\n 3. 在需要共享状态的情况下，使用 synchronized 关键字或者 reentrantlock 等方式来保证线程安全。\n 4. 将单例 bean 替换成原型 bean，即每次从容器中获取 bean 时都会创建一个新的实例。这种方式可以保证 bean 的线程安全，但会增加内存开销。\n 5. 在类中定义一个 threadlocal 成员变量，将需要的可变成员变量保存在 threadlocal 中（推荐）。\n\n\n# spring 事务",charsets:{cjk:!0}},{title:"Spring boot 自动装配",frontmatter:{title:"Spring boot 自动装配",date:"2023-08-04T15:56:12.000Z",permalink:"/pages/581456/"},regularPath:"/09.Java%E6%A1%86%E6%9E%B6/01.Spring/02.Spring%20boot%20%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D.html",relativePath:"09.Java框架/01.Spring/02.Spring boot 自动装配.md",key:"v-097ed174",path:"/pages/581456/",headers:[{level:2,title:"什么是 spring boot 自动装配？",slug:"什么是-spring-boot-自动装配",normalizedTitle:"什么是 spring boot 自动装配？",charIndex:22},{level:2,title:"spring boot 自动装配的原理是什么？",slug:"spring-boot-自动装配的原理是什么",normalizedTitle:"spring boot 自动装配的原理是什么？",charIndex:304},{level:2,title:"spring.factories和spring-autoconfigure-metadata.properties区别",slug:"spring-factories和spring-autoconfigure-metadata-properties区别",normalizedTitle:"spring.factories和spring-autoconfigure-metadata.properties区别",charIndex:701},{level:2,title:"spring 3.0，弃用 spring.factories ！",slug:"spring-3-0-弃用-spring-factories",normalizedTitle:"spring 3.0，弃用 spring.factories ！",charIndex:805},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:1407}],headersStr:"什么是 spring boot 自动装配？ spring boot 自动装配的原理是什么？ spring.factories和spring-autoconfigure-metadata.properties区别 spring 3.0，弃用 spring.factories ！ 参考",content:"好多文章是写得真差。差那么点意思。\n\n\n# 什么是 spring boot 自动装配？\n\n实际上 Spring Framework 早就实现了这个功能。Spring Boot 只是在其基础上，通过 SPI 的方式，做了进一步优化。\n\nSpringBoot 定义了一套接口规范，这套规范规定：SpringBoot 在启动时会扫描外部引用 jar 包中的META-INF/spring.factories文件，将文件中配置的类型信息加载到 Spring 容器，并执行类中定义的各种操作。对于外部 jar 来说，只需要按照 SpringBoot 定义的标准，就能将自己的功能装置进 SpringBoot。\n\n\n# spring boot 自动装配的原理是什么？\n\nSpring Boot 自动配置主要是 @EnableAutoConfiguration 实现的，@EnableAutoConfiguration 注解导入 AutoConfigurationImportSelector类,通过 selectImports 方法调用 SpringFactoriesLoader.loadFactoryNames() 扫描所有含有 META-INF/spring.factories 文件的 jar 包，将 spring.factories 文件中 @EnableAutoConfiguration 对应的类注入到 IOC 容器中。\n\n这些属性自动配置到 IOC 之后就无需自己手动配置 bean 了，Spring boot 中的约定大于配置理念，约定是将需要的配置以约定的方式添加到 IOC 容器中。\n\n\n# spring.factories和spring-autoconfigure-metadata.properties区别\n\nhttps://zhuanlan.zhihu.com/p/594950918\n\n\n# spring 3.0，弃用 spring.factories ！\n\nSpring Boot 2.7中，有一个不推荐使用的内容就是关于/META-INF/spring.factories文件，所以对于有自定义Starter的开发者来说，有时间要抓紧把这一变化改起来了，因为在Spring Boot 3开始将移除对/META-INF/spring.factories的支持。\n\n具体变化：swagger的starter为例，它的``内容是这样的：\n\nbefore：/META-INF/spring.factories\n\norg.springframework.boot.autoconfigure.EnableAutoConfiguration=\\\n  com.spring4all.swagger.SwaggerAutoConfiguration\n\n\nafter：/META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports，只需要创建一个新的文件，内容的话只需要直接放配置类\n\ncom.spring4all.swagger.SwaggerAutoConfiguration\n\n\nhttps://blog.didispace.com/spring-factories-deprecations/\n\n\n# 参考\n\n * https://www.cnblogs.com/javaguide/p/springboot-auto-config.html\n\n * https://juejin.cn/post/7162568709955911717#heading-8\n\n * https://zhuanlan.zhihu.com/p/594950918\n\n * https://blog.didispace.com/spring-factories-deprecations/",normalizedContent:"好多文章是写得真差。差那么点意思。\n\n\n# 什么是 spring boot 自动装配？\n\n实际上 spring framework 早就实现了这个功能。spring boot 只是在其基础上，通过 spi 的方式，做了进一步优化。\n\nspringboot 定义了一套接口规范，这套规范规定：springboot 在启动时会扫描外部引用 jar 包中的meta-inf/spring.factories文件，将文件中配置的类型信息加载到 spring 容器，并执行类中定义的各种操作。对于外部 jar 来说，只需要按照 springboot 定义的标准，就能将自己的功能装置进 springboot。\n\n\n# spring boot 自动装配的原理是什么？\n\nspring boot 自动配置主要是 @enableautoconfiguration 实现的，@enableautoconfiguration 注解导入 autoconfigurationimportselector类,通过 selectimports 方法调用 springfactoriesloader.loadfactorynames() 扫描所有含有 meta-inf/spring.factories 文件的 jar 包，将 spring.factories 文件中 @enableautoconfiguration 对应的类注入到 ioc 容器中。\n\n这些属性自动配置到 ioc 之后就无需自己手动配置 bean 了，spring boot 中的约定大于配置理念，约定是将需要的配置以约定的方式添加到 ioc 容器中。\n\n\n# spring.factories和spring-autoconfigure-metadata.properties区别\n\nhttps://zhuanlan.zhihu.com/p/594950918\n\n\n# spring 3.0，弃用 spring.factories ！\n\nspring boot 2.7中，有一个不推荐使用的内容就是关于/meta-inf/spring.factories文件，所以对于有自定义starter的开发者来说，有时间要抓紧把这一变化改起来了，因为在spring boot 3开始将移除对/meta-inf/spring.factories的支持。\n\n具体变化：swagger的starter为例，它的``内容是这样的：\n\nbefore：/meta-inf/spring.factories\n\norg.springframework.boot.autoconfigure.enableautoconfiguration=\\\n  com.spring4all.swagger.swaggerautoconfiguration\n\n\nafter：/meta-inf/spring/org.springframework.boot.autoconfigure.autoconfiguration.imports，只需要创建一个新的文件，内容的话只需要直接放配置类\n\ncom.spring4all.swagger.swaggerautoconfiguration\n\n\nhttps://blog.didispace.com/spring-factories-deprecations/\n\n\n# 参考\n\n * https://www.cnblogs.com/javaguide/p/springboot-auto-config.html\n\n * https://juejin.cn/post/7162568709955911717#heading-8\n\n * https://zhuanlan.zhihu.com/p/594950918\n\n * https://blog.didispace.com/spring-factories-deprecations/",charsets:{cjk:!0}},{title:"Spring IOC",frontmatter:{title:"Spring IOC",date:"2023-08-25T14:37:06.000Z",permalink:"/pages/0bf668/"},regularPath:"/09.Java%E6%A1%86%E6%9E%B6/01.Spring/03.Spring%20IOC.html",relativePath:"09.Java框架/01.Spring/03.Spring IOC.md",key:"v-629046d2",path:"/pages/0bf668/",headers:[{level:2,title:"什么是 Spring IOC",slug:"什么是-spring-ioc",normalizedTitle:"什么是 spring ioc",charIndex:2},{level:2,title:"什么是 Spring Bean",slug:"什么是-spring-bean",normalizedTitle:"什么是 spring bean",charIndex:55},{level:2,title:"IOC的配置方式",slug:"ioc的配置方式",normalizedTitle:"ioc的配置方式",charIndex:214},{level:2,title:"依赖注入的方式",slug:"依赖注入的方式",normalizedTitle:"依赖注入的方式",charIndex:419},{level:2,title:"@Autowired和@Resource以及@Inject等注解注入有何区别？",slug:"autowired和-resource以及-inject等注解注入有何区别",normalizedTitle:"@autowired和@resource以及@inject等注解注入有何区别？",charIndex:1193},{level:2,title:"IOC 的底层实现",slug:"ioc-的底层实现",normalizedTitle:"ioc 的底层实现",charIndex:2343},{level:2,title:"Spring 中 Bean 的生命周期",slug:"spring-中-bean-的生命周期",normalizedTitle:"spring 中 bean 的生命周期",charIndex:2368},{level:2,title:"Spring 如何解决循环依赖问题",slug:"spring-如何解决循环依赖问题",normalizedTitle:"spring 如何解决循环依赖问题",charIndex:2392}],headersStr:"什么是 Spring IOC 什么是 Spring Bean IOC的配置方式 依赖注入的方式 @Autowired和@Resource以及@Inject等注解注入有何区别？ IOC 的底层实现 Spring 中 Bean 的生命周期 Spring 如何解决循环依赖问题",content:"# 什么是 Spring IOC\n\nIoC是设计思想，DI是实现方式。控制反转是通过依赖注入实现的。\n\n\n# 什么是 Spring Bean\n\nIoC Container管理的是Spring Bean， 那么Spring Bean是什么呢？\n\nSpring里面的bean就类似是定义的一个组件，而这个组件的作用就是实现某个功能的，这里所定义的bean就相当于给了你一个更为简便的方法来调用这个组件去实现你要完成的功能。\n\n\n# IOC的配置方式\n\n主流使用：Java 配置 + 注解配置\n\n三种：\n\n * xml 配置\n\n * Java 配置\n   \n   1. 创建一个配置类， 添加@Configuration注解声明为配置类\n   \n   2. 创建方法，方法上加上@bean，该方法用于创建实例并返回，该实例创建后会交给spring管理，方法名建议与实例名相同（首字母小写）。注：实例类不需要加任何注解\n\n * 注解配置\n\n\n# 依赖注入的方式\n\n三种：\n\n * 构造方法注入（在Spring4.x版本中推荐的注入方式）\n * setter注入\n * 基于注解的属性注入\n\n为什么推荐构造器注入方式？\n\n构造器注入的方式能够保证注入的组件不可变，并且确保需要的依赖不为空。此外，构造器注入的依赖总是能够在返回客户端（组件）代码的时候保证完全初始化的状态。\n\n * 依赖不可变：其实说的就是final关键字。\n * 依赖不为空（省去了我们对其检查）：当要实例化UserServiceImpl的时候，由于自己实现了有参数的构造函数，所以不会调用默认构造函数，那么就需要Spring容器传入所需要的参数，所以就两种情况：1、有该类型的参数->传入，OK 。2：无该类型的参数->报错。\n * 完全初始化的状态：这个可以跟上面的依赖不为空结合起来，向构造器传参之前，要确保注入的内容不为空，那么肯定要调用依赖组件的构造方法完成实例化。而在Java类加载实例化的过程中，构造方法是最后一步（之前如果有父类先初始化父类，然后自己的成员变量，最后才是构造方法），所以返回来的都是初始化之后的状态。\n\n@Service\npublic class UserServiceImpl {\n    /**\n     * user dao impl.\n     */\n    private final UserDaoImpl userDao;\n\n    /**\n     * init.\n     * @param userDaoImpl user dao impl\n     */\n    public UserServiceImpl(final UserDaoImpl userDaoImpl) {\n        this.userDao = userDaoImpl;\n    }\n}\n\n\n\n# @Autowired和@Resource以及@Inject等注解注入有何区别？\n\n三者对比：\n\n1、@Autowired是Spring自带的，@Resource是JSR250规范实现的，@Inject是JSR330规范实现的\n\n2、@Autowired、@Inject用法基本一样，不同的是@Inject没有required属性\n\n3、@Autowired、@Inject是默认按照类型bytype匹配的，@Resource是按照名称byname匹配的\n\n4、@Autowired如果需要按照名称匹配需要和@Qualifier一起使用，@Inject和@Named一起使用，@Resource则通过name进行指定\n\n@Autowired\n\n1、@Autowired是Spring自带的注解，通过AutowiredAnnotationBeanPostProcessor 类实现的依赖注入\n\n2、@Autowired可以作用在CONSTRUCTOR、METHOD、PARAMETER、FIELD、ANNOTATION_TYPE\n\n3、@Autowired默认是根据类型（byType ）进行自动装配的\n\n4、如果有多个类型一样的Bean候选者，需要指定按照名称（byName ）进行装配，则需要配合@Qualifier。\n\n指定名称后，如果Spring IOC容器中没有对应的组件bean抛出NoSuchBeanDefinitionException。也可以将@Autowired中required配置为false，如果配置为false之后，当没有找到相应bean的时候，系统不会抛异常\n\n@Resource\n\n1、@Resource是JSR250规范的实现，在javax.annotation包下\n\n2、@Resource可以作用TYPE、FIELD、METHOD上\n\n3、@Resource是默认根据属性名称进行自动装配的，如果有多个类型一样的Bean候选者，则可以通过name进行指定进行注入\n\n@Target(ElementType.TYPE) #接口、类、枚举、注解\n@Target(ElementType.FIELD) #字段、枚举的常量\n@Target(ElementType.METHOD) #方法\n\n\n@Inject\n\n1、@Inject是JSR330 (Dependency Injection for Java)中的规范，需要导入javax.inject.Inject jar包 ，才能实现注入\n\n2、@Inject可以作用CONSTRUCTOR、METHOD、FIELD上\n\n3、@Inject是根据类型进行自动装配的，如果需要按名称进行装配，则需要配合@Named；\n\n\n# IOC 的底层实现\n\n顶层设计：\n\n\n\n\n\n\n# Spring 中 Bean 的生命周期\n\n\n# Spring 如何解决循环依赖问题",normalizedContent:"# 什么是 spring ioc\n\nioc是设计思想，di是实现方式。控制反转是通过依赖注入实现的。\n\n\n# 什么是 spring bean\n\nioc container管理的是spring bean， 那么spring bean是什么呢？\n\nspring里面的bean就类似是定义的一个组件，而这个组件的作用就是实现某个功能的，这里所定义的bean就相当于给了你一个更为简便的方法来调用这个组件去实现你要完成的功能。\n\n\n# ioc的配置方式\n\n主流使用：java 配置 + 注解配置\n\n三种：\n\n * xml 配置\n\n * java 配置\n   \n   1. 创建一个配置类， 添加@configuration注解声明为配置类\n   \n   2. 创建方法，方法上加上@bean，该方法用于创建实例并返回，该实例创建后会交给spring管理，方法名建议与实例名相同（首字母小写）。注：实例类不需要加任何注解\n\n * 注解配置\n\n\n# 依赖注入的方式\n\n三种：\n\n * 构造方法注入（在spring4.x版本中推荐的注入方式）\n * setter注入\n * 基于注解的属性注入\n\n为什么推荐构造器注入方式？\n\n构造器注入的方式能够保证注入的组件不可变，并且确保需要的依赖不为空。此外，构造器注入的依赖总是能够在返回客户端（组件）代码的时候保证完全初始化的状态。\n\n * 依赖不可变：其实说的就是final关键字。\n * 依赖不为空（省去了我们对其检查）：当要实例化userserviceimpl的时候，由于自己实现了有参数的构造函数，所以不会调用默认构造函数，那么就需要spring容器传入所需要的参数，所以就两种情况：1、有该类型的参数->传入，ok 。2：无该类型的参数->报错。\n * 完全初始化的状态：这个可以跟上面的依赖不为空结合起来，向构造器传参之前，要确保注入的内容不为空，那么肯定要调用依赖组件的构造方法完成实例化。而在java类加载实例化的过程中，构造方法是最后一步（之前如果有父类先初始化父类，然后自己的成员变量，最后才是构造方法），所以返回来的都是初始化之后的状态。\n\n@service\npublic class userserviceimpl {\n    /**\n     * user dao impl.\n     */\n    private final userdaoimpl userdao;\n\n    /**\n     * init.\n     * @param userdaoimpl user dao impl\n     */\n    public userserviceimpl(final userdaoimpl userdaoimpl) {\n        this.userdao = userdaoimpl;\n    }\n}\n\n\n\n# @autowired和@resource以及@inject等注解注入有何区别？\n\n三者对比：\n\n1、@autowired是spring自带的，@resource是jsr250规范实现的，@inject是jsr330规范实现的\n\n2、@autowired、@inject用法基本一样，不同的是@inject没有required属性\n\n3、@autowired、@inject是默认按照类型bytype匹配的，@resource是按照名称byname匹配的\n\n4、@autowired如果需要按照名称匹配需要和@qualifier一起使用，@inject和@named一起使用，@resource则通过name进行指定\n\n@autowired\n\n1、@autowired是spring自带的注解，通过autowiredannotationbeanpostprocessor 类实现的依赖注入\n\n2、@autowired可以作用在constructor、method、parameter、field、annotation_type\n\n3、@autowired默认是根据类型（bytype ）进行自动装配的\n\n4、如果有多个类型一样的bean候选者，需要指定按照名称（byname ）进行装配，则需要配合@qualifier。\n\n指定名称后，如果spring ioc容器中没有对应的组件bean抛出nosuchbeandefinitionexception。也可以将@autowired中required配置为false，如果配置为false之后，当没有找到相应bean的时候，系统不会抛异常\n\n@resource\n\n1、@resource是jsr250规范的实现，在javax.annotation包下\n\n2、@resource可以作用type、field、method上\n\n3、@resource是默认根据属性名称进行自动装配的，如果有多个类型一样的bean候选者，则可以通过name进行指定进行注入\n\n@target(elementtype.type) #接口、类、枚举、注解\n@target(elementtype.field) #字段、枚举的常量\n@target(elementtype.method) #方法\n\n\n@inject\n\n1、@inject是jsr330 (dependency injection for java)中的规范，需要导入javax.inject.inject jar包 ，才能实现注入\n\n2、@inject可以作用constructor、method、field上\n\n3、@inject是根据类型进行自动装配的，如果需要按名称进行装配，则需要配合@named；\n\n\n# ioc 的底层实现\n\n顶层设计：\n\n\n\n\n\n\n# spring 中 bean 的生命周期\n\n\n# spring 如何解决循环依赖问题",charsets:{cjk:!0}},{title:"Spring AOP",frontmatter:{title:"Spring AOP",date:"2023-08-11T14:55:38.000Z",permalink:"/pages/8c1a59/"},regularPath:"/09.Java%E6%A1%86%E6%9E%B6/01.Spring/04.%20Spring%20AOP.html",relativePath:"09.Java框架/01.Spring/04. Spring AOP.md",key:"v-80c46bea",path:"/pages/8c1a59/",headers:[{level:2,title:"什么是 AOP",slug:"什么是-aop",normalizedTitle:"什么是 aop",charIndex:8},{level:2,title:"Spring AOP 和 AspectJ 的关系",slug:"spring-aop-和-aspectj-的关系",normalizedTitle:"spring aop 和 aspectj 的关系",charIndex:167},{level:2,title:"术语",slug:"术语",normalizedTitle:"术语",charIndex:1324},{level:2,title:"AOP 的底层原理是什么？",slug:"aop-的底层原理是什么",normalizedTitle:"aop 的底层原理是什么？",charIndex:2946},{level:3,title:"什么是代理模式？",slug:"什么是代理模式",normalizedTitle:"什么是代理模式？",charIndex:3062},{level:3,title:"什么是动态代理？",slug:"什么是动态代理",normalizedTitle:"什么是动态代理？",charIndex:3232},{level:3,title:"代理类型的比较",slug:"代理类型的比较",normalizedTitle:"代理类型的比较",charIndex:3495},{level:3,title:"什么是 CGLIB？",slug:"什么是-cglib",normalizedTitle:"什么是 cglib？",charIndex:3936},{level:3,title:"什么是 JDK proxy？",slug:"什么是-jdk-proxy",normalizedTitle:"什么是 jdk proxy？",charIndex:4265},{level:2,title:"AOP 的使用",slug:"aop-的使用",normalizedTitle:"aop 的使用",charIndex:4444},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:7284}],headersStr:"什么是 AOP Spring AOP 和 AspectJ 的关系 术语 AOP 的底层原理是什么？ 什么是代理模式？ 什么是动态代理？ 代理类型的比较 什么是 CGLIB？ 什么是 JDK proxy？ AOP 的使用 参考",content:'使用：\n\n\n# 什么是 AOP\n\n面向切面编程，目的是解耦。就是将分散在各个业务逻辑代码中相同的代码通过横向切割的方式抽取到一个独立的模块中。\n\nAOP从横向解决代码重复的问题，将业务逻辑和系统处理的代码解耦，如日志操作、事务管理、关闭连接。\n\nAOP可以做到在程序的运行期间, 不修改业务代码的情况下对方法进行功能的增强。\n\n\n# Spring AOP 和 AspectJ 的关系\n\nAspectJ是一个java实现的AOP框架，它能够对java代码进行AOP编译（一般在编译期进行），让java代码具有AspectJ的AOP功能（当然需要特殊的编译器）\n\n可以这样说AspectJ是目前实现AOP框架中最成熟，功能最丰富的语言，更幸运的是，AspectJ与java程序完全兼容，几乎是无缝关联，因此对于有java编程基础的工程师，上手和使用都非常容易。\n\n我们可以看到@Aspect以及增强的几个注解是来源于aspectJ，而不是Spring包。\n\nSpring AOP和AspectJ是什么关系？\n\n 1. AspectJ是更强的AOP框架，是实际意义的AOP标准；\n 2. Spring为何不写类似AspectJ的框架？ Spring AOP使用纯Java实现, 它不需要专门的编译过程, 它一个重要的原则就是无侵入性（non-invasiveness）; Spring 小组完全有能力写类似的框架，只是Spring AOP从来没有打算通过提供一种全面的AOP解决方案来与AspectJ竞争。Spring的开发小组相信无论是基于代理（proxy-based）的框架如Spring AOP或者是成熟的框架如AspectJ都是很有价值的，他们之间应该是互补而不是竞争的关系。\n 3. Spring小组喜欢@AspectJ注解风格更胜于Spring XML配置； 所以在Spring 2.0使用了和AspectJ 5一样的注解，并使用AspectJ来做切入点解析和匹配。但是，AOP在运行时仍旧是纯的Spring AOP，并不依赖于AspectJ的编译器或者织入器（weaver）。\n 4. Spring 2.5对AspectJ的支持：在一些环境下，增加了对AspectJ的装载时编织支持，同时提供了一个新的bean切入点。\n\n了解AspectJ应用到java代码的过程（这个过程称为织入），对于织入这个概念，可以简单理解为aspect(切面)应用到目标函数(类)的过程。\n\n对于这个过程，一般分为动态织入和静态织入：\n\n 1. 动态织入的方式是在运行时动态将要增强的代码织入到目标类中，这样往往是通过动态代理技术完成的，如Java JDK的动态代理(Proxy，底层通过反射实现)或者CGLIB的动态代理(底层通过继承实现)，Spring AOP采用的就是基于运行时增强的代理技术\n 2. ApectJ采用的就是静态织入的方式。ApectJ主要采用的是编译期织入，在这个期间使用AspectJ的acj编译器(类似javac)把aspect类编译成class字节码后，在java目标类编译时织入，即先编译aspect类再编译目标类。\n\n\n\n\n# 术语\n\n * 方面/切面（Aspect）：横切关注点的模块化，比如日志组件。可以认为是通知、引入和切入点的组合；在Spring中可以使用Schema和@AspectJ方式进行组织实现；在AOP中表示为在哪干和干什么集合；\n * 切入点（Pointcut）： 选择一组相关连接点的模式，即可以认为连接点的集合，Spring支持perl5正则表达式和AspectJ切入点模式，Spring默认使用AspectJ语法，在AOP中表示为在哪里干的集合；\n * 通知（Advice）：在连接点上执行的行为，通知提供了在AOP中需要在切入点所选择的连接点处进行扩展现有行为的手段；包括前置通知（before advice）、后置通知(after advice)、环绕通知（around advice），在Spring中通过代理模式实现AOP，并通过拦截器模式以环绕连接点的拦截器链织入通知；在AOP中表示为干什么；\n * 织入（Weaving）：把切面连接到其它的应用程序类型或者对象上，并创建一个被通知的对象。这些可以在编译时（例如使用AspectJ编译器），类加载时和运行时完成。Spring和其他纯Java AOP框架一样，在运行时完成织入。在AOP中表示为怎么实现的；\n * AOP代理（AOP Proxy）：AOP框架使用代理模式创建的对象，从而实现在连接点处插入通知（即应用切面），就是通过代理来对目标对象应用切面。在Spring中，AOP代理可以用JDK动态代理或CGLIB代理实现，而通过拦截器模型应用切面。在AOP中表示为怎么实现的一种典型方式；\n\n基于XML的声明式AspectJ存在一些不足，需要在Spring配置文件配置大量的代码信息，为了解决这个问题，Spring 使用了@AspectJ框架为AOP的实现提供了一套注解。\n\n注解名称              解释\n@Aspect           用来定义一个切面。\n@pointcut         用于定义切入点表达式。在使用时还需要定义一个包含名字和任意参数的方法签名来表示切入点名称，这个方法签名就是一个返回值为void，且方法体为空的普通方法。\n@Before           用于定义前置通知，相当于BeforeAdvice。在使用时，通常需要指定一个value属性值，该属性值用于指定一个切入点表达式(可以是已有的切入点，也可以直接定义切入点表达式)。\n@AfterReturning   用于定义后置通知，相当于AfterReturningAdvice。在使用时可以指定pointcut /\n                  value和returning属性，其中pointcut / value这两个属性的作用一样，都用于指定切入点表达式。\n@Around           用于定义环绕通知，相当于MethodInterceptor。在使用时需要指定一个value属性，该属性用于指定该通知被植入的切入点。\n@AfterThrowing    用于定义异常通知来处理程序中未处理的异常，相当于ThrowAdvice。在使用时可指定pointcut /\n                  value和throwing属性。其中pointcut/value用于指定切入点表达式，而throwing属性值用于指定-一个形参名来表示Advice方法中可定义与此同名的形参，该形参可用于访问目标方法抛出的异常。\n@After            用于定义最终final\n                  通知，不管是否异常，该通知都会执行。使用时需要指定一个value属性，该属性用于指定该通知被植入的切入点。\n@DeclareParents   用于定义引介通知，相当于IntroductionInterceptor (不要求掌握)。\n\n\n# AOP 的底层原理是什么？\n\nAOP的底层是通过spring提供的动态代理技术实现的. 在程序的运行期间, spring动态生成代理对象, 代理对象的方法在执行时就可以进行增强功能的介入, 从而完成目标对象方法的功能增强。\n\n\n# 什么是代理模式？\n\n代理模式(Proxy pattern): 为另一个对象提供一个替身或占位符以控制对这个对象的访问。\n\n\n\n我(client)如果要买(doOperation)房，可以找中介(proxy)买房，中介直接和卖方(target)买房。中介和卖方都实现买卖(doOperation)的操作。中介就是代理(proxy)。\n\n\n# 什么是动态代理？\n\n静态代理与动态代理的区别主要在：\n\n * 静态代理在编译时就已经实现，编译完成后代理类是一个实际的class文件\n * 动态代理是在运行时动态生成的，即编译完成后没有实际的class文件，而是在运行时动态生成类字节码，并加载到JVM中\n\n动态代理就是，在程序运行期，创建目标对象的代理对象，并对目标对象中的方法进行功能性增强的一种技术。\n\n在生成代理对象的过程中，目标对象不变，代理对象中的方法是目标对象方法的增强方法。可以理解为运行期间，对象中方法的动态拦截，在拦截方法的前后执行功能操作。\n\n\n\n\n# 代理类型的比较\n\n 1. 静态代理实现较简单，只要代理对象对目标对象进行包装，即可实现增强功能，但静态代理只能为一个目标对象服务，如果目标对象过多，则会产生很多代理类。\n 2. JDK动态代理需要目标对象实现业务接口，代理类只需实现InvocationHandler接口。\n 3. JDK动态代理生成的类为 lass com.sun.proxy.$Proxy4，cglib代理生成的类为class com.cglib.UserDao$$EnhancerByCGLIB$$552188b6。\n 4. 静态代理在编译时产生class字节码文件，可以直接使用，效率高。\n 5. JDK动态代理必须实现InvocationHandler接口，通过反射代理方法，比较消耗系统性能，但可以减少代理类的数量，使用更灵活。\n 6. cglib代理无需实现接口，通过生成类字节码实现代理，比反射稍快，不存在性能问题，但cglib会继承目标对象，需要重写方法，所以目标对象不能为final类。\n\n\n# 什么是 CGLIB？\n\nCglib是一个强大的、高性能的代码生成包，它广泛被许多AOP框架使用，为他们提供方法的拦截。\n\nSpringAOP封装了cglib，通过其进行动态代理的创建。\n\n\n\nCGLIB 流程图：\n\ncglib代理类，需要实现MethodInterceptor接口，并指定代理目标类target。\n\n * final方法为什么不能被代理？很显然final方法没法被子类覆盖，当然不能代理了。\n * Mockito为什么不能mock静态方法？因为mockito也是基于cglib动态代理来实现的，static方法也不能被子类覆盖，所以显然不能mock。但PowerMock可以mock静态方法，因为它直接在bytecode上工作。\n\n\n\n\n# 什么是 JDK proxy？\n\nJDK动态代理是有JDK提供的工具类Proxy实现的，动态代理类是在运行时生成指定接口的代理类，每个代理实例（实现需要代理的接口）都有一个关联的调用处理程序对象，此对象实现了InvocationHandler，最终的业务逻辑是在InvocationHandler实现类的invoke方法上。jdk代理不需要任何依赖。\n\n\n# AOP 的使用\n\nSpring AOP 支持对XML模式和基于@AspectJ注解的两种配置方式。\n\n下面展示的是使用 @AspectJ 注解的方式：\n\nSpring默认在目标类实现接口时是通过JDK代理实现的，只有非接口的是通过Cglib代理实现的。\n\n1. 定义接口\npublic interface IJdkProxyService {\n\n    void doMethod1();\n\n    String doMethod2();\n\n    String doMethod3() throws Exception;\n}\n\n\n2. 实现类\n@Service\npublic class JdkProxyDemoServiceImpl implements IJdkProxyService {\n\n    @Override\n    public void doMethod1() {\n        System.out.println("JdkProxyServiceImpl.doMethod1()");\n    }\n\n    @Override\n    public String doMethod2() {\n        System.out.println("JdkProxyServiceImpl.doMethod2()");\n        return "hello world";\n    }\n\n    @Override\n    public String doMethod3() throws Exception {\n        System.out.println("JdkProxyServiceImpl.doMethod3()");\n        throw new Exception("some exception");\n    }\n}\n\n\n3. 定义切面\n\nimport org.aspectj.lang.ProceedingJoinPoint;\nimport org.aspectj.lang.annotation.After;\nimport org.aspectj.lang.annotation.AfterReturning;\nimport org.aspectj.lang.annotation.AfterThrowing;\nimport org.aspectj.lang.annotation.Around;\nimport org.aspectj.lang.annotation.Aspect;\nimport org.aspectj.lang.annotation.Before;\nimport org.aspectj.lang.annotation.Pointcut;\nimport org.springframework.context.annotation.EnableAspectJAutoProxy;\nimport org.springframework.stereotype.Component;\n\n@EnableAspectJAutoProxy\n@Component\n@Aspect\npublic class LogAspect {\n\n    /**\n     * define point cut.\n     */\n    @Pointcut("execution(* tech.pdai.springframework.service.*.*(..))")\n    private void pointCutMethod() {\n    }\n\n\n    /**\n     * 环绕通知.\n     */\n    @Around("pointCutMethod()")\n    public Object doAround(ProceedingJoinPoint pjp) throws Throwable {\n        System.out.println("-----------------------");\n        System.out.println("环绕通知: 进入方法");\n        Object o = pjp.proceed();\n        System.out.println("环绕通知: 退出方法");\n        return o;\n    }\n\n    /**\n     * 前置通知.\n     */\n    @Before("pointCutMethod()")\n    public void doBefore() {\n        System.out.println("前置通知");\n    }\n\n\n    /**\n     * 后置通知.\n     */\n    @AfterReturning(pointcut = "pointCutMethod()", returning = "result")\n    public void doAfterReturning(String result) {\n        System.out.println("后置通知, 返回值: " + result);\n    }\n\n    /**\n     * 异常通知.\n     */\n    @AfterThrowing(pointcut = "pointCutMethod()", throwing = "e")\n    public void doAfterThrowing(Exception e) {\n        System.out.println("异常通知, 异常: " + e.getMessage());\n    }\n\n    /**\n     * 最终通知.\n     */\n    @After("pointCutMethod()")\n    public void doAfter() {\n        System.out.println("最终通知");\n    }\n\n}\n\n\n4. 输出\n-----------------------\n环绕通知: 进入方法\n前置通知\nJdkProxyServiceImpl.doMethod1()\n最终通知\n环绕通知: 退出方法\n-----------------------\n环绕通知: 进入方法\n前置通知\nJdkProxyServiceImpl.doMethod2()\n后置通知, 返回值: hello world\n最终通知\n环绕通知: 退出方法\n-----------------------\n环绕通知: 进入方法\n前置通知\nJdkProxyServiceImpl.doMethod3()\n异常通知, 异常: some exception\n最终通知\n\n\n\n# 参考\n\n * https://juejin.cn/post/7011728343947018248 cglib、jdk proxy 使用例子',normalizedContent:'使用：\n\n\n# 什么是 aop\n\n面向切面编程，目的是解耦。就是将分散在各个业务逻辑代码中相同的代码通过横向切割的方式抽取到一个独立的模块中。\n\naop从横向解决代码重复的问题，将业务逻辑和系统处理的代码解耦，如日志操作、事务管理、关闭连接。\n\naop可以做到在程序的运行期间, 不修改业务代码的情况下对方法进行功能的增强。\n\n\n# spring aop 和 aspectj 的关系\n\naspectj是一个java实现的aop框架，它能够对java代码进行aop编译（一般在编译期进行），让java代码具有aspectj的aop功能（当然需要特殊的编译器）\n\n可以这样说aspectj是目前实现aop框架中最成熟，功能最丰富的语言，更幸运的是，aspectj与java程序完全兼容，几乎是无缝关联，因此对于有java编程基础的工程师，上手和使用都非常容易。\n\n我们可以看到@aspect以及增强的几个注解是来源于aspectj，而不是spring包。\n\nspring aop和aspectj是什么关系？\n\n 1. aspectj是更强的aop框架，是实际意义的aop标准；\n 2. spring为何不写类似aspectj的框架？ spring aop使用纯java实现, 它不需要专门的编译过程, 它一个重要的原则就是无侵入性（non-invasiveness）; spring 小组完全有能力写类似的框架，只是spring aop从来没有打算通过提供一种全面的aop解决方案来与aspectj竞争。spring的开发小组相信无论是基于代理（proxy-based）的框架如spring aop或者是成熟的框架如aspectj都是很有价值的，他们之间应该是互补而不是竞争的关系。\n 3. spring小组喜欢@aspectj注解风格更胜于spring xml配置； 所以在spring 2.0使用了和aspectj 5一样的注解，并使用aspectj来做切入点解析和匹配。但是，aop在运行时仍旧是纯的spring aop，并不依赖于aspectj的编译器或者织入器（weaver）。\n 4. spring 2.5对aspectj的支持：在一些环境下，增加了对aspectj的装载时编织支持，同时提供了一个新的bean切入点。\n\n了解aspectj应用到java代码的过程（这个过程称为织入），对于织入这个概念，可以简单理解为aspect(切面)应用到目标函数(类)的过程。\n\n对于这个过程，一般分为动态织入和静态织入：\n\n 1. 动态织入的方式是在运行时动态将要增强的代码织入到目标类中，这样往往是通过动态代理技术完成的，如java jdk的动态代理(proxy，底层通过反射实现)或者cglib的动态代理(底层通过继承实现)，spring aop采用的就是基于运行时增强的代理技术\n 2. apectj采用的就是静态织入的方式。apectj主要采用的是编译期织入，在这个期间使用aspectj的acj编译器(类似javac)把aspect类编译成class字节码后，在java目标类编译时织入，即先编译aspect类再编译目标类。\n\n\n\n\n# 术语\n\n * 方面/切面（aspect）：横切关注点的模块化，比如日志组件。可以认为是通知、引入和切入点的组合；在spring中可以使用schema和@aspectj方式进行组织实现；在aop中表示为在哪干和干什么集合；\n * 切入点（pointcut）： 选择一组相关连接点的模式，即可以认为连接点的集合，spring支持perl5正则表达式和aspectj切入点模式，spring默认使用aspectj语法，在aop中表示为在哪里干的集合；\n * 通知（advice）：在连接点上执行的行为，通知提供了在aop中需要在切入点所选择的连接点处进行扩展现有行为的手段；包括前置通知（before advice）、后置通知(after advice)、环绕通知（around advice），在spring中通过代理模式实现aop，并通过拦截器模式以环绕连接点的拦截器链织入通知；在aop中表示为干什么；\n * 织入（weaving）：把切面连接到其它的应用程序类型或者对象上，并创建一个被通知的对象。这些可以在编译时（例如使用aspectj编译器），类加载时和运行时完成。spring和其他纯java aop框架一样，在运行时完成织入。在aop中表示为怎么实现的；\n * aop代理（aop proxy）：aop框架使用代理模式创建的对象，从而实现在连接点处插入通知（即应用切面），就是通过代理来对目标对象应用切面。在spring中，aop代理可以用jdk动态代理或cglib代理实现，而通过拦截器模型应用切面。在aop中表示为怎么实现的一种典型方式；\n\n基于xml的声明式aspectj存在一些不足，需要在spring配置文件配置大量的代码信息，为了解决这个问题，spring 使用了@aspectj框架为aop的实现提供了一套注解。\n\n注解名称              解释\n@aspect           用来定义一个切面。\n@pointcut         用于定义切入点表达式。在使用时还需要定义一个包含名字和任意参数的方法签名来表示切入点名称，这个方法签名就是一个返回值为void，且方法体为空的普通方法。\n@before           用于定义前置通知，相当于beforeadvice。在使用时，通常需要指定一个value属性值，该属性值用于指定一个切入点表达式(可以是已有的切入点，也可以直接定义切入点表达式)。\n@afterreturning   用于定义后置通知，相当于afterreturningadvice。在使用时可以指定pointcut /\n                  value和returning属性，其中pointcut / value这两个属性的作用一样，都用于指定切入点表达式。\n@around           用于定义环绕通知，相当于methodinterceptor。在使用时需要指定一个value属性，该属性用于指定该通知被植入的切入点。\n@afterthrowing    用于定义异常通知来处理程序中未处理的异常，相当于throwadvice。在使用时可指定pointcut /\n                  value和throwing属性。其中pointcut/value用于指定切入点表达式，而throwing属性值用于指定-一个形参名来表示advice方法中可定义与此同名的形参，该形参可用于访问目标方法抛出的异常。\n@after            用于定义最终final\n                  通知，不管是否异常，该通知都会执行。使用时需要指定一个value属性，该属性用于指定该通知被植入的切入点。\n@declareparents   用于定义引介通知，相当于introductioninterceptor (不要求掌握)。\n\n\n# aop 的底层原理是什么？\n\naop的底层是通过spring提供的动态代理技术实现的. 在程序的运行期间, spring动态生成代理对象, 代理对象的方法在执行时就可以进行增强功能的介入, 从而完成目标对象方法的功能增强。\n\n\n# 什么是代理模式？\n\n代理模式(proxy pattern): 为另一个对象提供一个替身或占位符以控制对这个对象的访问。\n\n\n\n我(client)如果要买(dooperation)房，可以找中介(proxy)买房，中介直接和卖方(target)买房。中介和卖方都实现买卖(dooperation)的操作。中介就是代理(proxy)。\n\n\n# 什么是动态代理？\n\n静态代理与动态代理的区别主要在：\n\n * 静态代理在编译时就已经实现，编译完成后代理类是一个实际的class文件\n * 动态代理是在运行时动态生成的，即编译完成后没有实际的class文件，而是在运行时动态生成类字节码，并加载到jvm中\n\n动态代理就是，在程序运行期，创建目标对象的代理对象，并对目标对象中的方法进行功能性增强的一种技术。\n\n在生成代理对象的过程中，目标对象不变，代理对象中的方法是目标对象方法的增强方法。可以理解为运行期间，对象中方法的动态拦截，在拦截方法的前后执行功能操作。\n\n\n\n\n# 代理类型的比较\n\n 1. 静态代理实现较简单，只要代理对象对目标对象进行包装，即可实现增强功能，但静态代理只能为一个目标对象服务，如果目标对象过多，则会产生很多代理类。\n 2. jdk动态代理需要目标对象实现业务接口，代理类只需实现invocationhandler接口。\n 3. jdk动态代理生成的类为 lass com.sun.proxy.$proxy4，cglib代理生成的类为class com.cglib.userdao$$enhancerbycglib$$552188b6。\n 4. 静态代理在编译时产生class字节码文件，可以直接使用，效率高。\n 5. jdk动态代理必须实现invocationhandler接口，通过反射代理方法，比较消耗系统性能，但可以减少代理类的数量，使用更灵活。\n 6. cglib代理无需实现接口，通过生成类字节码实现代理，比反射稍快，不存在性能问题，但cglib会继承目标对象，需要重写方法，所以目标对象不能为final类。\n\n\n# 什么是 cglib？\n\ncglib是一个强大的、高性能的代码生成包，它广泛被许多aop框架使用，为他们提供方法的拦截。\n\nspringaop封装了cglib，通过其进行动态代理的创建。\n\n\n\ncglib 流程图：\n\ncglib代理类，需要实现methodinterceptor接口，并指定代理目标类target。\n\n * final方法为什么不能被代理？很显然final方法没法被子类覆盖，当然不能代理了。\n * mockito为什么不能mock静态方法？因为mockito也是基于cglib动态代理来实现的，static方法也不能被子类覆盖，所以显然不能mock。但powermock可以mock静态方法，因为它直接在bytecode上工作。\n\n\n\n\n# 什么是 jdk proxy？\n\njdk动态代理是有jdk提供的工具类proxy实现的，动态代理类是在运行时生成指定接口的代理类，每个代理实例（实现需要代理的接口）都有一个关联的调用处理程序对象，此对象实现了invocationhandler，最终的业务逻辑是在invocationhandler实现类的invoke方法上。jdk代理不需要任何依赖。\n\n\n# aop 的使用\n\nspring aop 支持对xml模式和基于@aspectj注解的两种配置方式。\n\n下面展示的是使用 @aspectj 注解的方式：\n\nspring默认在目标类实现接口时是通过jdk代理实现的，只有非接口的是通过cglib代理实现的。\n\n1. 定义接口\npublic interface ijdkproxyservice {\n\n    void domethod1();\n\n    string domethod2();\n\n    string domethod3() throws exception;\n}\n\n\n2. 实现类\n@service\npublic class jdkproxydemoserviceimpl implements ijdkproxyservice {\n\n    @override\n    public void domethod1() {\n        system.out.println("jdkproxyserviceimpl.domethod1()");\n    }\n\n    @override\n    public string domethod2() {\n        system.out.println("jdkproxyserviceimpl.domethod2()");\n        return "hello world";\n    }\n\n    @override\n    public string domethod3() throws exception {\n        system.out.println("jdkproxyserviceimpl.domethod3()");\n        throw new exception("some exception");\n    }\n}\n\n\n3. 定义切面\n\nimport org.aspectj.lang.proceedingjoinpoint;\nimport org.aspectj.lang.annotation.after;\nimport org.aspectj.lang.annotation.afterreturning;\nimport org.aspectj.lang.annotation.afterthrowing;\nimport org.aspectj.lang.annotation.around;\nimport org.aspectj.lang.annotation.aspect;\nimport org.aspectj.lang.annotation.before;\nimport org.aspectj.lang.annotation.pointcut;\nimport org.springframework.context.annotation.enableaspectjautoproxy;\nimport org.springframework.stereotype.component;\n\n@enableaspectjautoproxy\n@component\n@aspect\npublic class logaspect {\n\n    /**\n     * define point cut.\n     */\n    @pointcut("execution(* tech.pdai.springframework.service.*.*(..))")\n    private void pointcutmethod() {\n    }\n\n\n    /**\n     * 环绕通知.\n     */\n    @around("pointcutmethod()")\n    public object doaround(proceedingjoinpoint pjp) throws throwable {\n        system.out.println("-----------------------");\n        system.out.println("环绕通知: 进入方法");\n        object o = pjp.proceed();\n        system.out.println("环绕通知: 退出方法");\n        return o;\n    }\n\n    /**\n     * 前置通知.\n     */\n    @before("pointcutmethod()")\n    public void dobefore() {\n        system.out.println("前置通知");\n    }\n\n\n    /**\n     * 后置通知.\n     */\n    @afterreturning(pointcut = "pointcutmethod()", returning = "result")\n    public void doafterreturning(string result) {\n        system.out.println("后置通知, 返回值: " + result);\n    }\n\n    /**\n     * 异常通知.\n     */\n    @afterthrowing(pointcut = "pointcutmethod()", throwing = "e")\n    public void doafterthrowing(exception e) {\n        system.out.println("异常通知, 异常: " + e.getmessage());\n    }\n\n    /**\n     * 最终通知.\n     */\n    @after("pointcutmethod()")\n    public void doafter() {\n        system.out.println("最终通知");\n    }\n\n}\n\n\n4. 输出\n-----------------------\n环绕通知: 进入方法\n前置通知\njdkproxyserviceimpl.domethod1()\n最终通知\n环绕通知: 退出方法\n-----------------------\n环绕通知: 进入方法\n前置通知\njdkproxyserviceimpl.domethod2()\n后置通知, 返回值: hello world\n最终通知\n环绕通知: 退出方法\n-----------------------\n环绕通知: 进入方法\n前置通知\njdkproxyserviceimpl.domethod3()\n异常通知, 异常: some exception\n最终通知\n\n\n\n# 参考\n\n * https://juejin.cn/post/7011728343947018248 cglib、jdk proxy 使用例子',charsets:{cjk:!0}},{title:"Spring MVC",frontmatter:{title:"Spring MVC",date:"2023-08-25T14:36:01.000Z",permalink:"/pages/c3ac4e/"},regularPath:"/09.Java%E6%A1%86%E6%9E%B6/01.Spring/05.Spring%20MVC.html",relativePath:"09.Java框架/01.Spring/05.Spring MVC.md",key:"v-1f84369c",path:"/pages/c3ac4e/",headers:[{level:2,title:"什么是 MVC",slug:"什么是-mvc",normalizedTitle:"什么是 mvc",charIndex:2},{level:2,title:"Spring MVC 的请求流程",slug:"spring-mvc-的请求流程",normalizedTitle:"spring mvc 的请求流程",charIndex:324}],headersStr:"什么是 MVC Spring MVC 的请求流程",content:"# 什么是 MVC\n\nMVC英文是Model View Controller，是模型(model)－视图(view)－控制器(controller)的缩写，一种软件设计规范。本质上也是一种解耦。\n\n用一种业务逻辑、数据、界面显示分离的方法，将业务逻辑聚集到一个部件里面，在改进界面时，不需要重新编写业务逻辑。\n\n\n\n * Model（模型）是应用程序中用于处理应用程序数据逻辑的部分。通常模型对象负责在数据库中存取数据。\n * View（视图）是应用程序中处理数据显示的部分。通常视图是依据模型数据创建的。\n * Controller（控制器）是应用程序中处理用户交互的部分。通常控制器负责从视图读取数据，控制用户输入，并向模型发送数据。\n\n\n# Spring MVC 的请求流程\n\n\n\n核心架构的具体流程步骤如下：\n\n 1. 首先用户发送请求——>DispatcherServlet，前端控制器收到请求后自己不进行处理，而是委托给其他的解析器进行处理，作为统一访问点，进行全局的流程控制；\n 2. DispatcherServlet——>HandlerMapping， HandlerMapping 将会把请求映射为 HandlerExecutionChain 对象（包含一 个Handler 处理器（页面控制器）对象、多个HandlerInterceptor 拦截器）对象，通过这种策略模式，很容易添加新的映射策略；\n 3. DispatcherServlet——>HandlerAdapter，HandlerAdapter 将会把处理器包装为适配器，从而支持多种类型的处理器， 即适配器设计模式的应用，从而很容易支持很多类型的处理器；\n 4. HandlerAdapter——>处理器功能处理方法的调用，HandlerAdapter 将会根据适配的结果调用真正的处理器的功能处 理方法，完成功能处理；并返回一个ModelAndView 对象（包含模型数据、逻辑视图名）；\n 5. ModelAndView 的逻辑视图名——> ViewResolver，ViewResolver 将把逻辑视图名解析为具体的View，通过这种策 略模式，很容易更换其他视图技术；\n 6. View——>渲染，View 会根据传进来的Model 模型数据进行渲染，此处的Model 实际是一个Map 数据结构，因此 很容易支持其他视图技术；\n 7. 返回控制权给DispatcherServlet，由DispatcherServlet 返回响应给用户，到此一个流程结束。",normalizedContent:"# 什么是 mvc\n\nmvc英文是model view controller，是模型(model)－视图(view)－控制器(controller)的缩写，一种软件设计规范。本质上也是一种解耦。\n\n用一种业务逻辑、数据、界面显示分离的方法，将业务逻辑聚集到一个部件里面，在改进界面时，不需要重新编写业务逻辑。\n\n\n\n * model（模型）是应用程序中用于处理应用程序数据逻辑的部分。通常模型对象负责在数据库中存取数据。\n * view（视图）是应用程序中处理数据显示的部分。通常视图是依据模型数据创建的。\n * controller（控制器）是应用程序中处理用户交互的部分。通常控制器负责从视图读取数据，控制用户输入，并向模型发送数据。\n\n\n# spring mvc 的请求流程\n\n\n\n核心架构的具体流程步骤如下：\n\n 1. 首先用户发送请求——>dispatcherservlet，前端控制器收到请求后自己不进行处理，而是委托给其他的解析器进行处理，作为统一访问点，进行全局的流程控制；\n 2. dispatcherservlet——>handlermapping， handlermapping 将会把请求映射为 handlerexecutionchain 对象（包含一 个handler 处理器（页面控制器）对象、多个handlerinterceptor 拦截器）对象，通过这种策略模式，很容易添加新的映射策略；\n 3. dispatcherservlet——>handleradapter，handleradapter 将会把处理器包装为适配器，从而支持多种类型的处理器， 即适配器设计模式的应用，从而很容易支持很多类型的处理器；\n 4. handleradapter——>处理器功能处理方法的调用，handleradapter 将会根据适配的结果调用真正的处理器的功能处 理方法，完成功能处理；并返回一个modelandview 对象（包含模型数据、逻辑视图名）；\n 5. modelandview 的逻辑视图名——> viewresolver，viewresolver 将把逻辑视图名解析为具体的view，通过这种策 略模式，很容易更换其他视图技术；\n 6. view——>渲染，view 会根据传进来的model 模型数据进行渲染，此处的model 实际是一个map 数据结构，因此 很容易支持其他视图技术；\n 7. 返回控制权给dispatcherservlet，由dispatcherservlet 返回响应给用户，到此一个流程结束。",charsets:{cjk:!0}},{title:"Spring boot starter",frontmatter:{title:"Spring boot starter",date:"2023-08-31T22:51:18.000Z",permalink:"/pages/e00296/"},regularPath:"/09.Java%E6%A1%86%E6%9E%B6/01.Spring/06.Spring%20boot%20starter.html",relativePath:"09.Java框架/01.Spring/06.Spring boot starter.md",key:"v-e7bc6886",path:"/pages/e00296/",headers:[{level:2,title:"自定义 Spring Boot Starter",slug:"自定义-spring-boot-starter",normalizedTitle:"自定义 spring boot starter",charIndex:2},{level:2,title:"spring boot 自动装配",slug:"spring-boot-自动装配",normalizedTitle:"spring boot 自动装配",charIndex:515},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:586}],headersStr:"自定义 Spring Boot Starter spring boot 自动装配 参考",content:"# 自定义 Spring Boot Starter\n\n官方命名空间：\n\n * 前缀：spring-boot-starter-\n * 模式：spring-boot-starter-模块名\n * 举例：spring-boot-starter-web、spring-boot-starter-jdbc\n\n自定义命名空间：\n\n * 后缀：-spring-boot-starter\n * 模式：模块-spring-boot-starter\n * 举例：demo-spring-boot-starter\n\n定义starter需要的配置：\n\n根据springboot的自动配置原理，可知自定义starter需要\n\n * 一个xxxxAutoConfigurartion的配置模块\n * 一个xxxxProperties:封装配置文件中相关属性\n * 需要一个META-INF/spring.factories文件来描述配置文件工厂类\n   * org.springframework.boot.autoconfigure.EnableAutoConfiguration=\\com.start.DemoAutoConfiguration\n\n\n# spring boot 自动装配\n\n[02.Spring boot 自动装配.md](02.Spring boot 自动装配.md)\n\n\n# 参考\n\n * https://pdai.tech/md/spring/springboot/springboot-y-starter.html\n\n * https://developer.aliyun.com/article/795773 这个很好理解",normalizedContent:"# 自定义 spring boot starter\n\n官方命名空间：\n\n * 前缀：spring-boot-starter-\n * 模式：spring-boot-starter-模块名\n * 举例：spring-boot-starter-web、spring-boot-starter-jdbc\n\n自定义命名空间：\n\n * 后缀：-spring-boot-starter\n * 模式：模块-spring-boot-starter\n * 举例：demo-spring-boot-starter\n\n定义starter需要的配置：\n\n根据springboot的自动配置原理，可知自定义starter需要\n\n * 一个xxxxautoconfigurartion的配置模块\n * 一个xxxxproperties:封装配置文件中相关属性\n * 需要一个meta-inf/spring.factories文件来描述配置文件工厂类\n   * org.springframework.boot.autoconfigure.enableautoconfiguration=\\com.start.demoautoconfiguration\n\n\n# spring boot 自动装配\n\n[02.spring boot 自动装配.md](02.spring boot 自动装配.md)\n\n\n# 参考\n\n * https://pdai.tech/md/spring/springboot/springboot-y-starter.html\n\n * https://developer.aliyun.com/article/795773 这个很好理解",charsets:{cjk:!0}},{title:"BeanFactory和FactoryBean",frontmatter:{title:"BeanFactory和FactoryBean",date:"2023-08-31T23:22:43.000Z",permalink:"/pages/643d4f/"},regularPath:"/09.Java%E6%A1%86%E6%9E%B6/01.Spring/07.BeanFactory%E5%92%8CFactoryBean.html",relativePath:"09.Java框架/01.Spring/07.BeanFactory和FactoryBean.md",key:"v-603745ce",path:"/pages/643d4f/",headers:[{level:2,title:"BeanFactory",slug:"beanfactory",normalizedTitle:"beanfactory",charIndex:2},{level:2,title:"FactoryBean",slug:"factorybean",normalizedTitle:"factorybean",charIndex:476},{level:3,title:"FactoryBean 在 Mybatis 中的应用",slug:"factorybean-在-mybatis-中的应用",normalizedTitle:"factorybean 在 mybatis 中的应用",charIndex:798},{level:2,title:"二者的区别",slug:"二者的区别",normalizedTitle:"二者的区别",charIndex:1269},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:1759}],headersStr:"BeanFactory FactoryBean FactoryBean 在 Mybatis 中的应用 二者的区别 参考",content:"# BeanFactory\n\nBeanFactory是一个接口，它是Spring中工厂的顶层规范，是Spring Ioc容器的核心接口，定义了IOC容器的最基本形式，并提供了IOC容器应遵守的的最基本的接口，职责包括实例化、定位、配置应用程序中的对象以及建立这些对象之间的依赖。\n\n它定义了getBean()、containsBean()等管理Bean的通用方法。\n\nBeanFacotry是spring中比较原始的Factory。原始的BeanFactory无法支持spring的许多插件，如AOP功能、Web应用等。\n\nSpring的容器都是它的具体实现如：\n\n * DefaultListableBeanFactory\n * XmlBeanFactory\n * ApplicationContext：ApplicationContext接口由BeanFactory接口派生而来，ApplicationContext包含BeanFactory的所有功能，通常建议比BeanFactory优先。\n\n这些实现类又从不同的维度分别有不同的扩展。\n\n\n# FactoryBean\n\n首先它是一个Bean，但又不仅仅是一个Bean。它是一个能生产或修饰对象生成的工厂Bean，类似于设计模式中的工厂模式和装饰器模式。\n\n方法：\n\n * getObject：自定义创建对象的过程（new，反射，动态代理）\n * isSingleton\n * getObjectType\n\nSpring 对实现了FactoryBean接口的Bean进行了特殊处理。\n\n主要表现为:\n\n1、FactoryBean本身是个Bean 2、试图获取FactoryBean时，得到的是 FactoryBean 的 getObject() 返回的对象 3、可以通过 “&”+”name” 得到FactoryBean 本体对象\n\n\n# FactoryBean 在 Mybatis 中的应用\n\n使用过Spring Boot的同学都知道，当我们需要扫描Mapper的时候，需要添加@MapperScan注解完成对Mapper对象的扫描，@MapperScan导入MapperScannerRegistrar类完成扫描。\n\n但是Mapper类都是接口，无法被实例化，那么为什么在Spring中能够直接注入Mapper对象呢？\n\n实际上Mybatis是通过FactoryBean对象创建Mapper对象的代理对象，完成Mapper接口的注入。\n\nMybatis通过JDK动态代理的方式，创建Mapper接口的代理对象，并通过接口声明的方法查找并执行SQL。\n\nhttps://juejin.cn/post/6844903878949863431#heading-2\n\nhttps://www.skypyb.com/2019/08/jishu/979/ 牛呀，还不知道FactoryBean有啥用？探寻FactoryBean的究极奥义之从Spring+MyBatis扫描源码说起\n\n\n# 二者的区别\n\nspring 的核心是 IOC 容器，IOC 容器本质上就是 bean 的容器，或者是一个 bean 的工厂。能够更具我们声明的配置或注解去进行 bean 的加载和初始化。然后通过 beanFactory 生产我们需要的各种各样的 bean。\n\nBeanFactory 是所有 Spring Bean 容器的顶级接口，它为 Spring 的容器定义了一套规范，并提供像 getBean 这样的方法从容器中获取指定的 bean 实例。\n\n而 FactoryBean 是一个工厂 bean，它也是一个接口，其主要能力是动态的去生成某一类型的 Bean 的实例，也就是我们可以自定义一个 Bean，并加载到 IOC 容器中。其中有一个重要的方法 getObject()，就是用来实现动态构建 bean 的一个过程\n\n相同点：都是用来创建 bean 的。\n\n不同点：是用 BeanFactory 创建对象时，必须遵循严格的生命周期流程。如果想要简单自定义某个对象的创建，同时将创建完成的对象交给 spring 容器管理，那么需要实现 FactoryBean 接口。\n\n\n# 参考\n\n * https://juejin.cn/post/6844903967600836621\n\n * https://bbs.huaweicloud.com/blogs/363939\n\n * https://www.bilibili.com/video/BV1ts4y1z7wJ/?spm_id_from=333.337.search-card.all.click&vd_source=56a32d67ac4f0ccac0c6360804c3cf67",normalizedContent:"# beanfactory\n\nbeanfactory是一个接口，它是spring中工厂的顶层规范，是spring ioc容器的核心接口，定义了ioc容器的最基本形式，并提供了ioc容器应遵守的的最基本的接口，职责包括实例化、定位、配置应用程序中的对象以及建立这些对象之间的依赖。\n\n它定义了getbean()、containsbean()等管理bean的通用方法。\n\nbeanfacotry是spring中比较原始的factory。原始的beanfactory无法支持spring的许多插件，如aop功能、web应用等。\n\nspring的容器都是它的具体实现如：\n\n * defaultlistablebeanfactory\n * xmlbeanfactory\n * applicationcontext：applicationcontext接口由beanfactory接口派生而来，applicationcontext包含beanfactory的所有功能，通常建议比beanfactory优先。\n\n这些实现类又从不同的维度分别有不同的扩展。\n\n\n# factorybean\n\n首先它是一个bean，但又不仅仅是一个bean。它是一个能生产或修饰对象生成的工厂bean，类似于设计模式中的工厂模式和装饰器模式。\n\n方法：\n\n * getobject：自定义创建对象的过程（new，反射，动态代理）\n * issingleton\n * getobjecttype\n\nspring 对实现了factorybean接口的bean进行了特殊处理。\n\n主要表现为:\n\n1、factorybean本身是个bean 2、试图获取factorybean时，得到的是 factorybean 的 getobject() 返回的对象 3、可以通过 “&”+”name” 得到factorybean 本体对象\n\n\n# factorybean 在 mybatis 中的应用\n\n使用过spring boot的同学都知道，当我们需要扫描mapper的时候，需要添加@mapperscan注解完成对mapper对象的扫描，@mapperscan导入mapperscannerregistrar类完成扫描。\n\n但是mapper类都是接口，无法被实例化，那么为什么在spring中能够直接注入mapper对象呢？\n\n实际上mybatis是通过factorybean对象创建mapper对象的代理对象，完成mapper接口的注入。\n\nmybatis通过jdk动态代理的方式，创建mapper接口的代理对象，并通过接口声明的方法查找并执行sql。\n\nhttps://juejin.cn/post/6844903878949863431#heading-2\n\nhttps://www.skypyb.com/2019/08/jishu/979/ 牛呀，还不知道factorybean有啥用？探寻factorybean的究极奥义之从spring+mybatis扫描源码说起\n\n\n# 二者的区别\n\nspring 的核心是 ioc 容器，ioc 容器本质上就是 bean 的容器，或者是一个 bean 的工厂。能够更具我们声明的配置或注解去进行 bean 的加载和初始化。然后通过 beanfactory 生产我们需要的各种各样的 bean。\n\nbeanfactory 是所有 spring bean 容器的顶级接口，它为 spring 的容器定义了一套规范，并提供像 getbean 这样的方法从容器中获取指定的 bean 实例。\n\n而 factorybean 是一个工厂 bean，它也是一个接口，其主要能力是动态的去生成某一类型的 bean 的实例，也就是我们可以自定义一个 bean，并加载到 ioc 容器中。其中有一个重要的方法 getobject()，就是用来实现动态构建 bean 的一个过程\n\n相同点：都是用来创建 bean 的。\n\n不同点：是用 beanfactory 创建对象时，必须遵循严格的生命周期流程。如果想要简单自定义某个对象的创建，同时将创建完成的对象交给 spring 容器管理，那么需要实现 factorybean 接口。\n\n\n# 参考\n\n * https://juejin.cn/post/6844903967600836621\n\n * https://bbs.huaweicloud.com/blogs/363939\n\n * https://www.bilibili.com/video/bv1ts4y1z7wj/?spm_id_from=333.337.search-card.all.click&vd_source=56a32d67ac4f0ccac0c6360804c3cf67",charsets:{cjk:!0}},{title:"Spring三级缓存解决循环依赖",frontmatter:{title:"Spring三级缓存解决循环依赖",date:"2023-09-05T00:24:02.000Z",permalink:"/pages/329b73/"},regularPath:"/09.Java%E6%A1%86%E6%9E%B6/01.Spring/08.Spring%E4%B8%89%E7%BA%A7%E7%BC%93%E5%AD%98%E8%A7%A3%E5%86%B3%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96.html",relativePath:"09.Java框架/01.Spring/08.Spring三级缓存解决循环依赖.md",key:"v-4ae61c39",path:"/pages/329b73/",headers:[{level:2,title:"为什么要三级缓存，二级不行吗？",slug:"为什么要三级缓存-二级不行吗",normalizedTitle:"为什么要三级缓存，二级不行吗？",charIndex:471},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:1279}],headersStr:"为什么要三级缓存，二级不行吗？ 参考",content:"在使用spring框架的日常开发中，bean之间的循环依赖太频繁了，spring已经帮我们去解决循环依赖问题，对我们开发者来说是无感知的，下面具体分析一下spring是如何解决bean之间循环依赖，为什么要使用到三级缓存，而不是二级缓存。\n\n首先需要了解一下bean在spring中的生命周期，bean在spring的加载流程，才能够更加清晰知道spring是如何解决循环依赖的。\n\nbean 的生命周期：\n\n 1. 实例化bean，分配内存地址\n 2. 属性注入\n 3. 初始化bean，执行init方法\n 4. 销毁 bean\n\n一级缓存：存放完全初始化好的 Bean，可以直接使用\n\n二级缓存：存放原始的 Bean 对象，即还没进行赋值，没有被依赖注入\n\n三级缓存：存放 Bean 工厂对象，该工厂对象负责生成原始 Bean 对象，并将其放入到二级缓存中。主要用于解决代理对象的循环依赖问题。\n\n\n\n其核心思想是将 Bean 的实例化和 Bean 中的属性依赖注入分离开。\n\nSpring 本身只能解决单例存在的循环引用问题。\n\n\n# 为什么要三级缓存，二级不行吗？\n\n需要三级缓存而不是二级，是为了针对有代理的情况。\n\n没有动态代理的情况，其实把二级缓存拿掉，在 B 尝试获取 A 的时候直接返回 A 的实例，也是可以的。\n\n循环依赖下，有没有代理情况下的区别就在：\n\nsingletonObject = singletonFactory.getObject();\n\n\n在循环依赖发生的情况下 B 中的 A 赋值时：\n\n 1. 无代理：getObject 直接返回原来的 Bean\n 2. 有代理：getObject 返回的是代理对象\n\n然后都放到二级缓存。\n\n假设去掉三级缓存\n\n去掉三级缓存之后，Bean 直接创建 earlySingletonObjects， 看着好像也可以。\n\n如果有代理的时候，在 earlySingletonObjects 直接放代理对象就行了。\n\n但是会导致一个问题：在实例化阶段就得执行后置处理器，判断有 AnnotationAwareAspectJAutoProxyCreator 并创建代理对象。\n\n这么一想，是不是会对 Bean 的生命周期有影响。\n\n同样，先创建 singletonFactory 的好处就是：在真正需要实例化的时候，再使用 singletonFactory.getObject() 获取 Bean 或者 Bean 的代理。相当于是延迟实例化。\n\n假设去掉二级缓存\n\n如果去掉了二级缓存，则需要直接在 singletonFactory.getObject() 阶段初始化完毕，并放到一级缓存中。\n\n那有这么一种场景，B 和 C 都依赖了 A。\n\n要知道在有代理的情况下 singletonFactory.getObject() 获取的是代理对象。\n\n而多次调用 singletonFactory.getObject() 返回的代理对象是不同的，就会导致 B 和 C 依赖了不同的 A。\n\n\n# 参考\n\n 1. https://zhuanlan.zhihu.com/p/377878056\n 2. https://www.bilibili.com/video/BV1Sm4y1N7FD/?vd_source=56a32d67ac4f0ccac0c6360804c3cf67\n 3. https://www.pdai.tech/md/spring/spring-x-framework-ioc-source-3.html#spring%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E4%B8%8B%E7%9A%84%E5%B1%9E%E6%80%A7%E4%BE%9D%E8%B5%96",normalizedContent:"在使用spring框架的日常开发中，bean之间的循环依赖太频繁了，spring已经帮我们去解决循环依赖问题，对我们开发者来说是无感知的，下面具体分析一下spring是如何解决bean之间循环依赖，为什么要使用到三级缓存，而不是二级缓存。\n\n首先需要了解一下bean在spring中的生命周期，bean在spring的加载流程，才能够更加清晰知道spring是如何解决循环依赖的。\n\nbean 的生命周期：\n\n 1. 实例化bean，分配内存地址\n 2. 属性注入\n 3. 初始化bean，执行init方法\n 4. 销毁 bean\n\n一级缓存：存放完全初始化好的 bean，可以直接使用\n\n二级缓存：存放原始的 bean 对象，即还没进行赋值，没有被依赖注入\n\n三级缓存：存放 bean 工厂对象，该工厂对象负责生成原始 bean 对象，并将其放入到二级缓存中。主要用于解决代理对象的循环依赖问题。\n\n\n\n其核心思想是将 bean 的实例化和 bean 中的属性依赖注入分离开。\n\nspring 本身只能解决单例存在的循环引用问题。\n\n\n# 为什么要三级缓存，二级不行吗？\n\n需要三级缓存而不是二级，是为了针对有代理的情况。\n\n没有动态代理的情况，其实把二级缓存拿掉，在 b 尝试获取 a 的时候直接返回 a 的实例，也是可以的。\n\n循环依赖下，有没有代理情况下的区别就在：\n\nsingletonobject = singletonfactory.getobject();\n\n\n在循环依赖发生的情况下 b 中的 a 赋值时：\n\n 1. 无代理：getobject 直接返回原来的 bean\n 2. 有代理：getobject 返回的是代理对象\n\n然后都放到二级缓存。\n\n假设去掉三级缓存\n\n去掉三级缓存之后，bean 直接创建 earlysingletonobjects， 看着好像也可以。\n\n如果有代理的时候，在 earlysingletonobjects 直接放代理对象就行了。\n\n但是会导致一个问题：在实例化阶段就得执行后置处理器，判断有 annotationawareaspectjautoproxycreator 并创建代理对象。\n\n这么一想，是不是会对 bean 的生命周期有影响。\n\n同样，先创建 singletonfactory 的好处就是：在真正需要实例化的时候，再使用 singletonfactory.getobject() 获取 bean 或者 bean 的代理。相当于是延迟实例化。\n\n假设去掉二级缓存\n\n如果去掉了二级缓存，则需要直接在 singletonfactory.getobject() 阶段初始化完毕，并放到一级缓存中。\n\n那有这么一种场景，b 和 c 都依赖了 a。\n\n要知道在有代理的情况下 singletonfactory.getobject() 获取的是代理对象。\n\n而多次调用 singletonfactory.getobject() 返回的代理对象是不同的，就会导致 b 和 c 依赖了不同的 a。\n\n\n# 参考\n\n 1. https://zhuanlan.zhihu.com/p/377878056\n 2. https://www.bilibili.com/video/bv1sm4y1n7fd/?vd_source=56a32d67ac4f0ccac0c6360804c3cf67\n 3. https://www.pdai.tech/md/spring/spring-x-framework-ioc-source-3.html#spring%e5%8d%95%e4%be%8b%e6%a8%a1%e5%bc%8f%e4%b8%8b%e7%9a%84%e5%b1%9e%e6%80%a7%e4%be%9d%e8%b5%96",charsets:{cjk:!0}},{title:"kafka零拷贝技术",frontmatter:{title:"kafka零拷贝技术",date:"2023-09-02T00:58:25.000Z",permalink:"/pages/40cb9b/"},regularPath:"/10.%E4%B8%AD%E9%97%B4%E4%BB%B6/01.Kafka/02.kafka%E9%9B%B6%E6%8B%B7%E8%B4%9D%E6%8A%80%E6%9C%AF.html",relativePath:"10.中间件/01.Kafka/02.kafka零拷贝技术.md",key:"v-01e74dde",path:"/pages/40cb9b/",headers:[{level:2,title:"在Java中零拷贝的实现",slug:"在java中零拷贝的实现",normalizedTitle:"在java中零拷贝的实现",charIndex:232},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:1273}],headersStr:"在Java中零拷贝的实现 参考",content:'kafka高性能读取：零拷贝技术\n\nKafka的数据是持久化到每个Partition下的.log文件中的，因此当需要消费已经持久化的消息时，势必需要从磁盘中将数据读取到内存中，并通过网卡发送给消费者。\n\n所谓的零拷贝是指将数据在内核空间直接从磁盘文件复制到网卡中，而不需要经由用户态的应用程序之手。这样既可以提高数据读取的性能，也能减少核心态和用户态之间的上下文切换，提高数据传输效率。其本质是通过DMA技术，使CPU得到解放，实现数据的高性能传输。\n\n\n\n\n# 在Java中零拷贝的实现\n\nJava中的零拷贝是依靠java.nio.channels.FileChannel中的transferTo(long position, long count, WritableByteChannel target)方法来实现的。transferTo方法的底层实现是基于操作系统的sendfile这个system call来实现的，无需将数据拷贝到用户态，sendfile负责把数据从某个fd（file descriptor）传输到另一个fd。这样就完成了零拷贝的过程。零拷贝的示例代码如下所示：\n\nimport java.io.File;\nimport java.io.RandomAccessFile;\nimport java.net.InetSocketAddress;\nimport java.nio.channels.FileChannel;\nimport java.nio.channels.SocketChannel;\n\npublic class ZeroCopy {\n    public static void main(String[] args) throws Exception {\n        File file  = new File("xxxxxx.log");\n\n        RandomAccessFile raf = new RandomAccessFile(file, "rw");\n\n        FileChannel channel = raf.getChannel();\n\n        //Opens a socket channel and connects it to a remote address.\n        SocketChannel socketChannel = SocketChannel.open(\n                new InetSocketAddress("192.168.2.222", 9091)\n        );\n\n        //Transfers bytes from this channel\'s file to the given writable byte channel.\n        channel.transferTo(0,channel.size(), socketChannel);\n    }\n}\n\n\n\n# 参考\n\nhttps://www.jianshu.com/p/0af1b4f1e164',normalizedContent:'kafka高性能读取：零拷贝技术\n\nkafka的数据是持久化到每个partition下的.log文件中的，因此当需要消费已经持久化的消息时，势必需要从磁盘中将数据读取到内存中，并通过网卡发送给消费者。\n\n所谓的零拷贝是指将数据在内核空间直接从磁盘文件复制到网卡中，而不需要经由用户态的应用程序之手。这样既可以提高数据读取的性能，也能减少核心态和用户态之间的上下文切换，提高数据传输效率。其本质是通过dma技术，使cpu得到解放，实现数据的高性能传输。\n\n\n\n\n# 在java中零拷贝的实现\n\njava中的零拷贝是依靠java.nio.channels.filechannel中的transferto(long position, long count, writablebytechannel target)方法来实现的。transferto方法的底层实现是基于操作系统的sendfile这个system call来实现的，无需将数据拷贝到用户态，sendfile负责把数据从某个fd（file descriptor）传输到另一个fd。这样就完成了零拷贝的过程。零拷贝的示例代码如下所示：\n\nimport java.io.file;\nimport java.io.randomaccessfile;\nimport java.net.inetsocketaddress;\nimport java.nio.channels.filechannel;\nimport java.nio.channels.socketchannel;\n\npublic class zerocopy {\n    public static void main(string[] args) throws exception {\n        file file  = new file("xxxxxx.log");\n\n        randomaccessfile raf = new randomaccessfile(file, "rw");\n\n        filechannel channel = raf.getchannel();\n\n        //opens a socket channel and connects it to a remote address.\n        socketchannel socketchannel = socketchannel.open(\n                new inetsocketaddress("192.168.2.222", 9091)\n        );\n\n        //transfers bytes from this channel\'s file to the given writable byte channel.\n        channel.transferto(0,channel.size(), socketchannel);\n    }\n}\n\n\n\n# 参考\n\nhttps://www.jianshu.com/p/0af1b4f1e164',charsets:{cjk:!0}},{title:"Kafka多线程消费",frontmatter:{title:"Kafka多线程消费",date:"2023-09-01T23:26:52.000Z",permalink:"/pages/5e6384/"},regularPath:"/10.%E4%B8%AD%E9%97%B4%E4%BB%B6/01.Kafka/Kafka%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%B6%88%E8%B4%B9.html",relativePath:"10.中间件/01.Kafka/Kafka多线程消费.md",key:"v-c9002668",path:"/pages/5e6384/",headersStr:null,content:"设置一个监听器，对提交的offset进行排序。\n\n提交连续的offset的最大值。\n\nhttps://www.bilibili.com/video/BV1iv4y1x7bg/?spm_id_from=333.337.search-card.all.click\n\nhttps://www.oomspot.com/post/injishuyushizhan20duoxianchengkaifaxiaofeizheshili",normalizedContent:"设置一个监听器，对提交的offset进行排序。\n\n提交连续的offset的最大值。\n\nhttps://www.bilibili.com/video/bv1iv4y1x7bg/?spm_id_from=333.337.search-card.all.click\n\nhttps://www.oomspot.com/post/injishuyushizhan20duoxianchengkaifaxiaofeizheshili",charsets:{cjk:!0}},{title:"RocketMQ",frontmatter:{title:"RocketMQ",date:"2023-03-31T14:08:22.000Z",permalink:"/pages/279572/"},regularPath:"/10.%E4%B8%AD%E9%97%B4%E4%BB%B6/02.RocketMQ.html",relativePath:"10.中间件/02.RocketMQ.md",key:"v-129110e4",path:"/pages/279572/",headers:[{level:2,title:"RocketMQ中的消息模型",slug:"rocketmq中的消息模型",normalizedTitle:"rocketmq中的消息模型",charIndex:2},{level:2,title:"RocketMQ的架构",slug:"rocketmq的架构",normalizedTitle:"rocketmq的架构",charIndex:965},{level:2,title:"重复消费问题",slug:"重复消费问题",normalizedTitle:"重复消费问题",charIndex:2407},{level:2,title:"实现顺序消费",slug:"实现顺序消费",normalizedTitle:"实现顺序消费",charIndex:2892},{level:2,title:"消息堆积问题",slug:"消息堆积问题",normalizedTitle:"消息堆积问题",charIndex:3163},{level:2,title:"回溯消费",slug:"回溯消费",normalizedTitle:"回溯消费",charIndex:3446},{level:2,title:"分布式事务",slug:"分布式事务",normalizedTitle:"分布式事务",charIndex:3662},{level:2,title:"RocketMQ 的刷盘机制",slug:"rocketmq-的刷盘机制",normalizedTitle:"rocketmq 的刷盘机制",charIndex:4495},{level:3,title:"同步刷盘和异步刷盘",slug:"同步刷盘和异步刷盘",normalizedTitle:"同步刷盘和异步刷盘",charIndex:4514},{level:2,title:"存储机制",slug:"存储机制",normalizedTitle:"存储机制",charIndex:4530}],headersStr:"RocketMQ中的消息模型 RocketMQ的架构 重复消费问题 实现顺序消费 消息堆积问题 回溯消费 分布式事务 RocketMQ 的刷盘机制 同步刷盘和异步刷盘 存储机制",content:"# RocketMQ中的消息模型\n\nRocketMQ 中的消息模型就是按照 主题模型（发布订阅模式） 所实现的。\n\n其实对于主题模型的实现来说每个消息中间件的底层设计都是不一样的，就比如 Kafka 中的 分区 ，RocketMQ 中的 队列 ，RabbitMQ 中的 Exchange 。我们可以理解为 主题模型/发布订阅模型 就是一个标准，那些中间件只不过照着这个标准去实现而已。\n\n\n\n生产者组中的生产者会向主题发送消息，而 主题中存在多个队列，生产者每次生产消息之后是指定主题中的某个队列发送消息的。\n\n每个主题中都有多个队列(分布在不同的 Broker中，如果是集群的话，Broker又分布在不同的服务器中)，集群消费模式下，一个消费者集群多台机器共同消费一个 topic 的多个队列，一个队列只会被一个消费者消费。如果某个消费者挂掉，分组内其它消费者会接替挂掉的消费者继续消费。就像上图中 Consumer1 和 Consumer2 分别对应着两个队列，而 Consumer3 是没有队列对应的，所以一般来讲要控制 消费者组中的消费者个数和主题中队列个数相同 。\n\n\n每个消费组在每个队列上维护一个消费位置 ，为什么呢？\n\n因为我们刚刚画的仅仅是一个消费者组，我们知道在发布订阅模式中一般会涉及到多个消费者组，而每个消费者组在每个队列中的消费位置都是不同的。如果此时有多个消费者组，那么消息被一个消费者组消费完之后是不会删除的(因为其它消费者组也需要呀)，它仅仅是为每个消费者组维护一个 消费位移(offset) ，每次消费者组消费完会返回一个成功的响应，然后队列再把维护的消费位移加一，这样就不会出现刚刚消费过的消息再一次被消费了。\n\n\n\n\n为什么一个主题中需要维护多个队列 ？\n\n为了 提高并发能力 。的确，每个主题中只存在一个队列也是可行的。但是，这样生产者是不是只能向一个队列发送消息？又因为需要维护消费位置所以一个队列只能对应一个消费者组中的消费者，这样是不是其他的 Consumer 就没有用武之地了？从这两个角度来讲，并发度一下子就小了很多。\n\n所以总结来说，RocketMQ 通过使用在一个 Topic 中配置多个队列并且每个队列维护每个消费者组的消费位置 实现了 主题模式/发布订阅模式 。\n\n\n# RocketMQ的架构\n\n\n\n * NameServer： 跟 ZooKeeper 和 Spring Cloud 中的 Eureka ，一样是一个 注册中心 ，主要提供两个功能：Broker管理 和 路由信息管理 。说白了就是 Broker 会将自己的信息注册到 NameServer 中，此时 NameServer 就存放了很多 Broker 的信息(Broker的路由表)，消费者和生产者就从 NameServer 中获取路由表然后照着路由表的信息和对应的 Broker 进行通信(生产者和消费者定期会向 NameServer 去查询相关的 Broker 的信息)。\n * Producer： 消息发布的角色，支持分布式集群方式部署。\n * Consumer： 消息消费的角色，支持分布式集群方式部署。支持以push推，pull拉两种模式对消息进行消费。同时也支持集群方式和广播方式的消费，它提供实时消息订阅机制。\n * Broker： 主要负责消息的存储、投递和查询以及服务高可用保证。就是消息队列服务器，生产者生产消息到 Broker ，消费者从 Broker 拉取消息并消费。\n   * Broker 、Topic 和 队列的关系。上面我讲解了 Topic 和队列的关系——一个 Topic 中存在多个队列，那么这个 Topic 和队列存放在哪呢？\n   * 一个 Topic 分布在多个 Broker上，一个 Broker 可以配置多个 Topic ，它们是多对多的关系。\n   * 如果某个 Topic 消息量很大，应该给它多配置几个队列(上文中提到了提高并发能力)，并且 尽量多分布在不同 Broker 上，以减轻某个 Broker 的压力 。\n\n\n\n\n\n第一、我们的 Broker 做了集群并且还进行了主从部署 ，由于消息分布在各个 Broker 上，一旦某个 Broker 宕机，则该Broker 上的消息读写都会受到影响。所以 Rocketmq 提供了 master/slave 的结构，salve 定时从 master 同步数据(同步刷盘或者异步刷盘)，如果 master 宕机，则 slave 提供消费服务，但是不能写入消息 (后面我还会提到哦)。\n\n第二、为了保证 HA ，我们的 NameServer 也做了集群部署，但是请注意它是 去中心化 的。也就意味着它没有主节点，你可以很明显地看出 NameServer 的所有节点是没有进行 Info Replicate 的，在 RocketMQ 中是通过 单个Broker和所有NameServer保持长连接 ，并且在每隔30秒 Broker 会向所有 Nameserver 发送心跳，心跳包含了自身的 Topic 配置信息，这个步骤就对应这上面的 Routing Info 。\n\n第三、在生产者需要向 Broker 发送消息的时候，需要先从 NameServer 获取关于 Broker 的路由信息，然后通过 轮询 的方法去向每个队列中生产数据以达到 负载均衡 的效果。\n\n第四、消费者通过 NameServer 获取所有 Broker 的路由信息后，向 Broker 发送 Pull 请求来获取消息数据。Consumer 可以以两种模式启动—— 广播（Broadcast）和集群（Cluster）。广播模式下，一条消息会发送给 同一个消费组中的所有消费者 ，集群模式下消息只会发送给一个消费者。\n\n\n# 重复消费问题\n\n解决方案：保证消费幂等 。在编程中一个幂等操作的特点是其任意多次执行所产生的影响均与一次执行的影响相同。\n\n所以我们需要给我们的消费者实现 幂等 ，也就是对同一个消息的处理结果，执行多少次都不变。\n\n那么如何给业务实现幂等呢？这个还是需要结合具体的业务的。你可以使用 写入 Redis 来保证，因为 Redis 的 key 和 value 就是天然支持幂等的。当然还有使用 数据库插入法 ，基于数据库的唯一键来保证重复数据不会被插入多条。\n\n不过最主要的还是需要 根据特定场景使用特定的解决方案 ，你要知道你的消息消费是否是完全不可重复消费还是可以忍受重复消费的，然后再选择强校验和弱校验的方式。毕竟在 CS 领域还是很少有技术银弹的说法。\n\n而在整个互联网领域，幂等不仅仅适用于消息队列的重复消费问题，这些实现幂等的方法，也同样适用于，在其他场景中来解决重复请求或者重复调用的问题 。比如将HTTP服务设计成幂等的，解决前端或者APP重复提交表单数据的问题 ，也可以将一个微服务设计成幂等的，解决 RPC 框架自动重试导致的 重复调用问题 。\n\n\n# 实现顺序消费\n\nRocketMQ 在主题上是无序的、它只有在队列层面才是保证有序 的。\n\n案例：在 Producer 生产消息的时候会进行轮询(取决你的负载均衡策略)来向同一主题的不同消息队列发送消息。如果此时我有几个消息分别是同一个订单的创建、支付、发货，在轮询的策略下这 三个消息会被发送到不同队列 ，因为在不同的队列此时就无法使用 RocketMQ 带来的队列有序特性来保证消息有序性了。\n\n解决方案：将同一语义下的消息放入同一个队列(比如这里是同一个订单)，那我们就可以使用 Hash取模法 来保证同一个订单在同一个队列中。\n\n\n# 消息堆积问题\n\n产生消息堆积的根源其实就只有两个：生产者生产太快或者消费者消费太慢。\n\n如果当流量到峰值的时候是因为生产者生产太快，我们可以使用一些 限流降级 的方法，当然你也可以增加多个消费者实例去水平扩展增加消费能力来匹配生产的激增。\n\n如果消费者消费过慢的话，我们可以先检查 是否是消费者出现了大量的消费错误 ，或者打印一下日志查看是否是哪一个线程卡死，出现了锁资源不释放等等的问题。\n\n当然，最快速解决消息堆积问题的方法还是增加消费者实例，不过 同时你还需要增加每个主题的队列数量 。别忘了在 RocketMQ 中，一个队列只会被一个消费者消费 。\n\n\n# 回溯消费\n\n回溯消费是指 Consumer 已经消费成功的消息，由于业务上需求需要重新消费，在RocketMQ 中， Broker 在向Consumer 投递成功消息后，消息仍然需要保留 。并且重新消费一般是按照时间维度，例如由于 Consumer 系统故障，恢复后需要重新消费1小时前的数据，那么 Broker 要提供一种机制，可以按照时间维度来回退消费进度。RocketMQ 支持按照时间回溯消费，时间维度精确到毫秒。\n\n\n# 分布式事务\n\n在同一个系统中我们可以轻松地实现事务，但是在分布式架构中，我们有很多服务是部署在不同系统之间的，而不同服务之间又需要进行调用。比如此时我下订单然后增加积分，如果保证不了分布式事务的话，就会出现A系统下了订单，但是B系统增加积分失败或者A系统没有下订单，B系统却增加了积分。\n\n如今比较常见的分布式事务实现有 2PC、TCC 和事务消息(half 半消息机制)。每一种实现都有其特定的使用场景，但是也有各自的问题，都不是完美的解决方案。\n\n在 RocketMQ 中使用的是 事务消息加上事务反查机制 来解决分布式事务问题的。\n\n\n\n在第一步发送的 half 消息 ，它的意思是 在事务提交之前，对于消费者来说，这个消息是不可见的 。\n\n如何做到写入消息但是对用户不可见呢？RocketMQ事务消息的做法是：如果消息是half消息，将备份原消息的主题与消息消费队列，然后 改变主题 为RMQ_SYS_TRANS_HALF_TOPIC。由于消费组未订阅该主题，故消费端无法消费half类型的消息，然后RocketMQ会开启一个定时任务，从Topic为RMQ_SYS_TRANS_HALF_TOPIC中拉取消息进行消费，根据生产者组获取一个服务提供者发送回查事务状态请求，根据事务状态来决定是提交或回滚消息。\n\n如果没有从第5步开始的 事务反查机制 ，如果出现网路波动第4步没有发送成功，这样就会产生 MQ 不知道是不是需要给消费者消费的问题，他就像一个无头苍蝇一样。在 RocketMQ 中就是使用的上述的事务反查来解决的，而在 Kafka 中通常是直接抛出一个异常让用户来自行解决。\n\n你还需要注意的是，在 MQ Server 指向系统B的操作已经和系统A不相关了，也就是说在消息队列中的分布式事务是——本地事务和存储消息到消息队列才是同一个事务。这样也就产生了事务的最终一致性，因为整个过程是异步的，每个系统只要保证它自己那一部分的事务就行了。\n\n\n# RocketMQ 的刷盘机制\n\n\n# 同步刷盘和异步刷盘\n\n\n\n\n# 存储机制\n\n在 Topic 中的 队列是以什么样的形式存在的？\n\n队列中的消息又是如何进行存储持久化的呢？\n\nRocketMQ 消息存储架构中的三大角色——CommitLog 、ConsumeQueue 和 IndexFile 。\n\n * CommitLog： 消息主体以及元数据的存储主体，存储 Producer 端写入的消息主体内容,消息内容不是定长的。单个文件大小默认1G ，文件名长度为20位，左边补零，剩余为起始偏移量，比如00000000000000000000代表了第一个文件，起始偏移量为0，文件大小为1G=1073741824；当第一个文件写满了，第二个文件为00000000001073741824，起始偏移量为1073741824，以此类推。消息主要是顺序写入日志文件，当文件满了，写入下一个文件。\n * ConsumeQueue： 消息消费队列，引入的目的主要是提高消息消费的性能(我们再前面也讲了)，由于RocketMQ 是基于主题 Topic 的订阅模式，消息消费是针对主题进行的，如果要遍历 commitlog 文件中根据 Topic 检索消息是非常低效的。Consumer 即可根据 ConsumeQueue 来查找待消费的消息。其中，ConsumeQueue（逻辑消费队列）作为消费消息的索引，保存了指定 Topic 下的队列消息在 CommitLog 中的起始物理偏移量 offset *，消息大小 size 和消息 Tag 的 HashCode 值。*consumequeue 文件可以看成是基于 topic 的 commitlog 索引文件，故 consumequeue 文件夹的组织方式如下：topic/queue/file三层组织结构，具体存储路径为：$HOME/store/consumequeue/{topic}/{queueId}/{fileName}。同样 consumequeue 文件采取定长设计，每一个条目共20个字节，分别为8字节的 commitlog 物理偏移量、4字节的消息长度、8字节tag hashcode，单个文件由30W个条目组成，可以像数组一样随机访问每一个条目，每个 ConsumeQueue文件大小约5.72M；\n * IndexFile： IndexFile（索引文件）提供了一种可以通过key或时间区间来查询消息的方法。这里只做科普不做详细介绍。\n\n总结来说，整个消息存储的结构，最主要的就是 CommitLoq 和 ConsumeQueue 。而 ConsumeQueue 你可以大概理解为 Topic 中的队列。\n\n\n\n红色方块代表被写入的消息，虚线方块代表等待被写入的。左边的生产者发送消息会指定 Topic 、QueueId 和具体消息内容，而在 Broker 中管你是哪门子消息，他直接 全部顺序存储到了 CommitLog。而根据生产者指定的 Topic 和 QueueId 将这条消息本身在 CommitLog 的偏移(offset)，消息本身大小，和tag的hash值存入对应的 ConsumeQueue 索引文件中。而在每个队列中都保存了 ConsumeOffset 即每个消费者组的消费位置(我在架构那里提到了，忘了的同学可以回去看一下)，而消费者拉取消息进行消费的时候只需要根据 ConsumeOffset 获取下一个未被消费的消息就行了。",normalizedContent:"# rocketmq中的消息模型\n\nrocketmq 中的消息模型就是按照 主题模型（发布订阅模式） 所实现的。\n\n其实对于主题模型的实现来说每个消息中间件的底层设计都是不一样的，就比如 kafka 中的 分区 ，rocketmq 中的 队列 ，rabbitmq 中的 exchange 。我们可以理解为 主题模型/发布订阅模型 就是一个标准，那些中间件只不过照着这个标准去实现而已。\n\n\n\n生产者组中的生产者会向主题发送消息，而 主题中存在多个队列，生产者每次生产消息之后是指定主题中的某个队列发送消息的。\n\n每个主题中都有多个队列(分布在不同的 broker中，如果是集群的话，broker又分布在不同的服务器中)，集群消费模式下，一个消费者集群多台机器共同消费一个 topic 的多个队列，一个队列只会被一个消费者消费。如果某个消费者挂掉，分组内其它消费者会接替挂掉的消费者继续消费。就像上图中 consumer1 和 consumer2 分别对应着两个队列，而 consumer3 是没有队列对应的，所以一般来讲要控制 消费者组中的消费者个数和主题中队列个数相同 。\n\n\n每个消费组在每个队列上维护一个消费位置 ，为什么呢？\n\n因为我们刚刚画的仅仅是一个消费者组，我们知道在发布订阅模式中一般会涉及到多个消费者组，而每个消费者组在每个队列中的消费位置都是不同的。如果此时有多个消费者组，那么消息被一个消费者组消费完之后是不会删除的(因为其它消费者组也需要呀)，它仅仅是为每个消费者组维护一个 消费位移(offset) ，每次消费者组消费完会返回一个成功的响应，然后队列再把维护的消费位移加一，这样就不会出现刚刚消费过的消息再一次被消费了。\n\n\n\n\n为什么一个主题中需要维护多个队列 ？\n\n为了 提高并发能力 。的确，每个主题中只存在一个队列也是可行的。但是，这样生产者是不是只能向一个队列发送消息？又因为需要维护消费位置所以一个队列只能对应一个消费者组中的消费者，这样是不是其他的 consumer 就没有用武之地了？从这两个角度来讲，并发度一下子就小了很多。\n\n所以总结来说，rocketmq 通过使用在一个 topic 中配置多个队列并且每个队列维护每个消费者组的消费位置 实现了 主题模式/发布订阅模式 。\n\n\n# rocketmq的架构\n\n\n\n * nameserver： 跟 zookeeper 和 spring cloud 中的 eureka ，一样是一个 注册中心 ，主要提供两个功能：broker管理 和 路由信息管理 。说白了就是 broker 会将自己的信息注册到 nameserver 中，此时 nameserver 就存放了很多 broker 的信息(broker的路由表)，消费者和生产者就从 nameserver 中获取路由表然后照着路由表的信息和对应的 broker 进行通信(生产者和消费者定期会向 nameserver 去查询相关的 broker 的信息)。\n * producer： 消息发布的角色，支持分布式集群方式部署。\n * consumer： 消息消费的角色，支持分布式集群方式部署。支持以push推，pull拉两种模式对消息进行消费。同时也支持集群方式和广播方式的消费，它提供实时消息订阅机制。\n * broker： 主要负责消息的存储、投递和查询以及服务高可用保证。就是消息队列服务器，生产者生产消息到 broker ，消费者从 broker 拉取消息并消费。\n   * broker 、topic 和 队列的关系。上面我讲解了 topic 和队列的关系——一个 topic 中存在多个队列，那么这个 topic 和队列存放在哪呢？\n   * 一个 topic 分布在多个 broker上，一个 broker 可以配置多个 topic ，它们是多对多的关系。\n   * 如果某个 topic 消息量很大，应该给它多配置几个队列(上文中提到了提高并发能力)，并且 尽量多分布在不同 broker 上，以减轻某个 broker 的压力 。\n\n\n\n\n\n第一、我们的 broker 做了集群并且还进行了主从部署 ，由于消息分布在各个 broker 上，一旦某个 broker 宕机，则该broker 上的消息读写都会受到影响。所以 rocketmq 提供了 master/slave 的结构，salve 定时从 master 同步数据(同步刷盘或者异步刷盘)，如果 master 宕机，则 slave 提供消费服务，但是不能写入消息 (后面我还会提到哦)。\n\n第二、为了保证 ha ，我们的 nameserver 也做了集群部署，但是请注意它是 去中心化 的。也就意味着它没有主节点，你可以很明显地看出 nameserver 的所有节点是没有进行 info replicate 的，在 rocketmq 中是通过 单个broker和所有nameserver保持长连接 ，并且在每隔30秒 broker 会向所有 nameserver 发送心跳，心跳包含了自身的 topic 配置信息，这个步骤就对应这上面的 routing info 。\n\n第三、在生产者需要向 broker 发送消息的时候，需要先从 nameserver 获取关于 broker 的路由信息，然后通过 轮询 的方法去向每个队列中生产数据以达到 负载均衡 的效果。\n\n第四、消费者通过 nameserver 获取所有 broker 的路由信息后，向 broker 发送 pull 请求来获取消息数据。consumer 可以以两种模式启动—— 广播（broadcast）和集群（cluster）。广播模式下，一条消息会发送给 同一个消费组中的所有消费者 ，集群模式下消息只会发送给一个消费者。\n\n\n# 重复消费问题\n\n解决方案：保证消费幂等 。在编程中一个幂等操作的特点是其任意多次执行所产生的影响均与一次执行的影响相同。\n\n所以我们需要给我们的消费者实现 幂等 ，也就是对同一个消息的处理结果，执行多少次都不变。\n\n那么如何给业务实现幂等呢？这个还是需要结合具体的业务的。你可以使用 写入 redis 来保证，因为 redis 的 key 和 value 就是天然支持幂等的。当然还有使用 数据库插入法 ，基于数据库的唯一键来保证重复数据不会被插入多条。\n\n不过最主要的还是需要 根据特定场景使用特定的解决方案 ，你要知道你的消息消费是否是完全不可重复消费还是可以忍受重复消费的，然后再选择强校验和弱校验的方式。毕竟在 cs 领域还是很少有技术银弹的说法。\n\n而在整个互联网领域，幂等不仅仅适用于消息队列的重复消费问题，这些实现幂等的方法，也同样适用于，在其他场景中来解决重复请求或者重复调用的问题 。比如将http服务设计成幂等的，解决前端或者app重复提交表单数据的问题 ，也可以将一个微服务设计成幂等的，解决 rpc 框架自动重试导致的 重复调用问题 。\n\n\n# 实现顺序消费\n\nrocketmq 在主题上是无序的、它只有在队列层面才是保证有序 的。\n\n案例：在 producer 生产消息的时候会进行轮询(取决你的负载均衡策略)来向同一主题的不同消息队列发送消息。如果此时我有几个消息分别是同一个订单的创建、支付、发货，在轮询的策略下这 三个消息会被发送到不同队列 ，因为在不同的队列此时就无法使用 rocketmq 带来的队列有序特性来保证消息有序性了。\n\n解决方案：将同一语义下的消息放入同一个队列(比如这里是同一个订单)，那我们就可以使用 hash取模法 来保证同一个订单在同一个队列中。\n\n\n# 消息堆积问题\n\n产生消息堆积的根源其实就只有两个：生产者生产太快或者消费者消费太慢。\n\n如果当流量到峰值的时候是因为生产者生产太快，我们可以使用一些 限流降级 的方法，当然你也可以增加多个消费者实例去水平扩展增加消费能力来匹配生产的激增。\n\n如果消费者消费过慢的话，我们可以先检查 是否是消费者出现了大量的消费错误 ，或者打印一下日志查看是否是哪一个线程卡死，出现了锁资源不释放等等的问题。\n\n当然，最快速解决消息堆积问题的方法还是增加消费者实例，不过 同时你还需要增加每个主题的队列数量 。别忘了在 rocketmq 中，一个队列只会被一个消费者消费 。\n\n\n# 回溯消费\n\n回溯消费是指 consumer 已经消费成功的消息，由于业务上需求需要重新消费，在rocketmq 中， broker 在向consumer 投递成功消息后，消息仍然需要保留 。并且重新消费一般是按照时间维度，例如由于 consumer 系统故障，恢复后需要重新消费1小时前的数据，那么 broker 要提供一种机制，可以按照时间维度来回退消费进度。rocketmq 支持按照时间回溯消费，时间维度精确到毫秒。\n\n\n# 分布式事务\n\n在同一个系统中我们可以轻松地实现事务，但是在分布式架构中，我们有很多服务是部署在不同系统之间的，而不同服务之间又需要进行调用。比如此时我下订单然后增加积分，如果保证不了分布式事务的话，就会出现a系统下了订单，但是b系统增加积分失败或者a系统没有下订单，b系统却增加了积分。\n\n如今比较常见的分布式事务实现有 2pc、tcc 和事务消息(half 半消息机制)。每一种实现都有其特定的使用场景，但是也有各自的问题，都不是完美的解决方案。\n\n在 rocketmq 中使用的是 事务消息加上事务反查机制 来解决分布式事务问题的。\n\n\n\n在第一步发送的 half 消息 ，它的意思是 在事务提交之前，对于消费者来说，这个消息是不可见的 。\n\n如何做到写入消息但是对用户不可见呢？rocketmq事务消息的做法是：如果消息是half消息，将备份原消息的主题与消息消费队列，然后 改变主题 为rmq_sys_trans_half_topic。由于消费组未订阅该主题，故消费端无法消费half类型的消息，然后rocketmq会开启一个定时任务，从topic为rmq_sys_trans_half_topic中拉取消息进行消费，根据生产者组获取一个服务提供者发送回查事务状态请求，根据事务状态来决定是提交或回滚消息。\n\n如果没有从第5步开始的 事务反查机制 ，如果出现网路波动第4步没有发送成功，这样就会产生 mq 不知道是不是需要给消费者消费的问题，他就像一个无头苍蝇一样。在 rocketmq 中就是使用的上述的事务反查来解决的，而在 kafka 中通常是直接抛出一个异常让用户来自行解决。\n\n你还需要注意的是，在 mq server 指向系统b的操作已经和系统a不相关了，也就是说在消息队列中的分布式事务是——本地事务和存储消息到消息队列才是同一个事务。这样也就产生了事务的最终一致性，因为整个过程是异步的，每个系统只要保证它自己那一部分的事务就行了。\n\n\n# rocketmq 的刷盘机制\n\n\n# 同步刷盘和异步刷盘\n\n\n\n\n# 存储机制\n\n在 topic 中的 队列是以什么样的形式存在的？\n\n队列中的消息又是如何进行存储持久化的呢？\n\nrocketmq 消息存储架构中的三大角色——commitlog 、consumequeue 和 indexfile 。\n\n * commitlog： 消息主体以及元数据的存储主体，存储 producer 端写入的消息主体内容,消息内容不是定长的。单个文件大小默认1g ，文件名长度为20位，左边补零，剩余为起始偏移量，比如00000000000000000000代表了第一个文件，起始偏移量为0，文件大小为1g=1073741824；当第一个文件写满了，第二个文件为00000000001073741824，起始偏移量为1073741824，以此类推。消息主要是顺序写入日志文件，当文件满了，写入下一个文件。\n * consumequeue： 消息消费队列，引入的目的主要是提高消息消费的性能(我们再前面也讲了)，由于rocketmq 是基于主题 topic 的订阅模式，消息消费是针对主题进行的，如果要遍历 commitlog 文件中根据 topic 检索消息是非常低效的。consumer 即可根据 consumequeue 来查找待消费的消息。其中，consumequeue（逻辑消费队列）作为消费消息的索引，保存了指定 topic 下的队列消息在 commitlog 中的起始物理偏移量 offset *，消息大小 size 和消息 tag 的 hashcode 值。*consumequeue 文件可以看成是基于 topic 的 commitlog 索引文件，故 consumequeue 文件夹的组织方式如下：topic/queue/file三层组织结构，具体存储路径为：$home/store/consumequeue/{topic}/{queueid}/{filename}。同样 consumequeue 文件采取定长设计，每一个条目共20个字节，分别为8字节的 commitlog 物理偏移量、4字节的消息长度、8字节tag hashcode，单个文件由30w个条目组成，可以像数组一样随机访问每一个条目，每个 consumequeue文件大小约5.72m；\n * indexfile： indexfile（索引文件）提供了一种可以通过key或时间区间来查询消息的方法。这里只做科普不做详细介绍。\n\n总结来说，整个消息存储的结构，最主要的就是 commitloq 和 consumequeue 。而 consumequeue 你可以大概理解为 topic 中的队列。\n\n\n\n红色方块代表被写入的消息，虚线方块代表等待被写入的。左边的生产者发送消息会指定 topic 、queueid 和具体消息内容，而在 broker 中管你是哪门子消息，他直接 全部顺序存储到了 commitlog。而根据生产者指定的 topic 和 queueid 将这条消息本身在 commitlog 的偏移(offset)，消息本身大小，和tag的hash值存入对应的 consumequeue 索引文件中。而在每个队列中都保存了 consumeoffset 即每个消费者组的消费位置(我在架构那里提到了，忘了的同学可以回去看一下)，而消费者拉取消息进行消费的时候只需要根据 consumeoffset 获取下一个未被消费的消息就行了。",charsets:{cjk:!0}},{title:"Flume快速上手",frontmatter:{title:"Flume快速上手",date:"2023-03-31T17:05:37.000Z",permalink:"/pages/0cf9ab/"},regularPath:"/10.%E4%B8%AD%E9%97%B4%E4%BB%B6/03.Flume%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B.html",relativePath:"10.中间件/03.Flume快速上手.md",key:"v-34c41a32",path:"/pages/0cf9ab/",headers:[{level:2,title:"什么是Flume",slug:"什么是flume",normalizedTitle:"什么是flume",charIndex:2},{level:2,title:"Demo",slug:"demo",normalizedTitle:"demo",charIndex:428},{level:3,title:"安装（针对Linux）",slug:"安装-针对linux",normalizedTitle:"安装（针对linux）",charIndex:437},{level:3,title:"使用",slug:"使用",normalizedTitle:"使用",charIndex:539},{level:2,title:"组件种类",slug:"组件种类",normalizedTitle:"组件种类",charIndex:1409},{level:3,title:"source",slug:"source",normalizedTitle:"source",charIndex:627},{level:3,title:"channel",slug:"channel",normalizedTitle:"channel",charIndex:699},{level:3,title:"sink",slug:"sink",normalizedTitle:"sink",charIndex:672},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:1800}],headersStr:"什么是Flume Demo 安装（针对Linux） 使用 组件种类 source channel sink 参考",content:"# 什么是Flume\n\n> Flume is a distributed, reliable, and available service for efficiently collecting, aggregating, and moving large amounts of log data.\n\nFlume 是一种分布式、可靠且可用的服务，用于高效地收集、聚合和移动大量日志数据。由此可见，flume的应用场景是处理大量的日志数据。\n\n\n\n其中框框部分就是Flume。\n由Source、Channel、Sink三个核心组件组成。整体构成一个Agent。\n\n名词解释：\n\n * Source：是负责接受数据到Agent的组件。\n * Channel：位于Source和Sink之间的缓冲区。\n * Sink：负责将事件从从Channel写入到其他地方。可以是另一个Agent也可以是存储系统。\n * Event：Flume以事件的形式传递数据。\n\n\n# Demo\n\n\n# 安装（针对Linux）\n\n 1. 官网下载 apache-flume-1.7.0-bin.tar.gz\n 2. 解压 tar -zxf apache-flume-1.7.0-bin.tar.gz\n\n\n# 使用\n\n主要是配置一个flume的配置文件，这里起名example.conf，规定以如下形式：\n\n# Name the components on this agent\na1.sources = r1 //定义了一个agent a1，r1为a1的source\na1.sinks = k1 //k1为a1的sink\na1.channels = c1 //c1为a1的channel\n\n# Describe/configure the source\na1.sources.r1.type = netcat #source r1的类型为netcat\na1.sources.r1.bind = localhost #source r1绑定的地址\na1.sources.r1.port = 44444 #source r1绑定的端口\n\n# Describe the sink\na1.sinks.k1.type = logger #sink k1的类型\n\n# Use a channel which buffers events in memory\na1.channels.c1.type = memory #channel c1的类型\na1.channels.c1.capacity = 1000 #channel c1的容量\na1.channels.c1.transactionCapacity = 100 #channel c1的事务容量\n\n# Bind the source and sink to the channel\na1.sources.r1.channels = c1 #source r1和channel c1绑定\na1.sinks.k1.channel = c1 #sink k1和channel c1绑定\n\n\n启动命令：\nbin/flume-ng agent --conf conf --conf-file example.conf --name a1 -Dflume.root.logger=INFO,console\n\n\n# 组件种类\n\n以下列举的是常用的组件类型，有用到其他的类型可以通过官网直接直接搜索类型查看详情\n\n\n# source\n\n * avro：用于接收从另一个flume（agent）中收到的数据\n * exec：用于接收从命令中获取的数据，如结合命令tail -f使用\n * netcat：用于接收端口传来的数据\n * spooling directory：用于接收文件变动的数据\n\n\n# channel\n\n * memory channel 内存，速度快，但宕机时有数据丢失的风险\n * file channel 速度比较慢，但安全\n * kafka channel\n\n\n# sink\n\n * avro 输出到另一个flume（agent）\n * hdfs 输出到hdfs\n * logger 日志形式输出\n * file 文件形式落地\n\n> To be continue...\n\n\n# 参考\n\n 1. Flume官网用户使用手册",normalizedContent:"# 什么是flume\n\n> flume is a distributed, reliable, and available service for efficiently collecting, aggregating, and moving large amounts of log data.\n\nflume 是一种分布式、可靠且可用的服务，用于高效地收集、聚合和移动大量日志数据。由此可见，flume的应用场景是处理大量的日志数据。\n\n\n\n其中框框部分就是flume。\n由source、channel、sink三个核心组件组成。整体构成一个agent。\n\n名词解释：\n\n * source：是负责接受数据到agent的组件。\n * channel：位于source和sink之间的缓冲区。\n * sink：负责将事件从从channel写入到其他地方。可以是另一个agent也可以是存储系统。\n * event：flume以事件的形式传递数据。\n\n\n# demo\n\n\n# 安装（针对linux）\n\n 1. 官网下载 apache-flume-1.7.0-bin.tar.gz\n 2. 解压 tar -zxf apache-flume-1.7.0-bin.tar.gz\n\n\n# 使用\n\n主要是配置一个flume的配置文件，这里起名example.conf，规定以如下形式：\n\n# name the components on this agent\na1.sources = r1 //定义了一个agent a1，r1为a1的source\na1.sinks = k1 //k1为a1的sink\na1.channels = c1 //c1为a1的channel\n\n# describe/configure the source\na1.sources.r1.type = netcat #source r1的类型为netcat\na1.sources.r1.bind = localhost #source r1绑定的地址\na1.sources.r1.port = 44444 #source r1绑定的端口\n\n# describe the sink\na1.sinks.k1.type = logger #sink k1的类型\n\n# use a channel which buffers events in memory\na1.channels.c1.type = memory #channel c1的类型\na1.channels.c1.capacity = 1000 #channel c1的容量\na1.channels.c1.transactioncapacity = 100 #channel c1的事务容量\n\n# bind the source and sink to the channel\na1.sources.r1.channels = c1 #source r1和channel c1绑定\na1.sinks.k1.channel = c1 #sink k1和channel c1绑定\n\n\n启动命令：\nbin/flume-ng agent --conf conf --conf-file example.conf --name a1 -dflume.root.logger=info,console\n\n\n# 组件种类\n\n以下列举的是常用的组件类型，有用到其他的类型可以通过官网直接直接搜索类型查看详情\n\n\n# source\n\n * avro：用于接收从另一个flume（agent）中收到的数据\n * exec：用于接收从命令中获取的数据，如结合命令tail -f使用\n * netcat：用于接收端口传来的数据\n * spooling directory：用于接收文件变动的数据\n\n\n# channel\n\n * memory channel 内存，速度快，但宕机时有数据丢失的风险\n * file channel 速度比较慢，但安全\n * kafka channel\n\n\n# sink\n\n * avro 输出到另一个flume（agent）\n * hdfs 输出到hdfs\n * logger 日志形式输出\n * file 文件形式落地\n\n> to be continue...\n\n\n# 参考\n\n 1. flume官网用户使用手册",charsets:{cjk:!0}},{title:"消息队列概述",frontmatter:{title:"消息队列概述",date:"2023-03-31T14:10:43.000Z",permalink:"/pages/mq/"},regularPath:"/10.%E4%B8%AD%E9%97%B4%E4%BB%B6/01.%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E6%A6%82%E8%BF%B0.html",relativePath:"10.中间件/01.消息队列概述.md",key:"v-79517efc",path:"/pages/mq/",headers:[{level:2,title:"常用MQ对比",slug:"常用mq对比",normalizedTitle:"常用mq对比",charIndex:239},{level:2,title:"JMS和AMQP",slug:"jms和amqp",normalizedTitle:"jms和amqp",charIndex:2352},{level:3,title:"JMS",slug:"jms",normalizedTitle:"jms",charIndex:482},{level:3,title:"AMQP",slug:"amqp",normalizedTitle:"amqp",charIndex:376},{level:3,title:"JMS vs AMQP",slug:"jms-vs-amqp",normalizedTitle:"jms vs amqp",charIndex:2824}],headersStr:"常用MQ对比 JMS和AMQP JMS AMQP JMS vs AMQP",content:"消息队列的主要作用是：\n\n 1. 解耦\n 2. 异步。减少响应所需时间\n 3. 削峰\n\n消息队列的缺点 ：\n\n 1. 降低系统的可用性：系统引入的外部依赖越多，越容易挂掉；\n 2. 系统复杂度提高：使用 MQ 后可能需要保证消息没有被重复消费、处理消息丢失的情况、保证消息传递的顺序性等等问题；\n 3. 一致性问题：A 系统处理完了直接返回成功了，但问题是：要是 B、C、D 三个系统那里，B 和 D 两个系统写库成功了，结果 C 系统写库失败了，就造成数据不一致了。\n\n\n# 常用MQ对比\n\n特性     RABBITMQ                        APACHE KAFKA                 APACHE ROCKETMQ                              ACTIVEMQ\n类型     AMQP、STOMP、MQTT等多种协议            Pub/Sub消息系统                  纯Java消息队列                                    JMS消息系统\n性能     稳定、性能一般，适合小规模应用                 高吞吐量、低延迟，适合大规模分布式系统          高吞吐量、低延迟，适合大规模分布式系统                          性能一般，适合小规模应用\n可用性    支持多种HA机制，包括主从复制、镜像队列、集群等        支持多种HA机制，包括主从复制、分区副本等        支持多种HA机制，包括主从复制、Broker HA、Namesrv HA、异地多活等   支持多种HA机制，包括主从复制、集群等\n可靠性    支持事务、持久化、消息确认等机制，保证消息可靠性        支持副本机制、持久化、消息确认等机制，保证消息可靠性   支持主从复制、持久化、消息确认等机制，保证消息可靠性                   支持持久化、消息确认等机制，保证消息可靠性\n管理工具   支持Web管理界面、CLI、REST API等多种管理工具   支持Web管理界面、CLI等多种管理工具         支持Web管理界面、CLI等多种管理工具                         支持Web管理界面、CLI等多种管理工具\n社区支持   开源社区活跃，文档丰富，插件丰富                开源社区活跃，文档丰富，插件丰富             开源社区活跃，文档丰富，插件丰富                             开源社区活跃，文档丰富，插件丰富\n适用场景   中小规模应用、需要事务支持、需要AMQP协议的应用       大规模分布式系统、实时数据处理、日志收集等        大规模分布式系统、高可用性场景、需要事务支持的应用                    中小规模应用、需要JMS协议的应用\n\n * 吞吐量：万级的 ActiveMQ 和 RabbitMQ 的吞吐量（ActiveMQ 的性能最差）要比十万级甚至是百万级的 RocketMQ 和 Kafka 低一个数量级。\n\n * 可用性：都可以实现高可用。ActiveMQ 和 RabbitMQ 都是基于主从架构实现高可用性。RocketMQ 基于分布式架构。 Kafka 也是分布式的，一个数据多个副本，少数机器宕机，不会丢失数据，不会导致不可用\n\n * 时效性：RabbitMQ 基于 Erlang 开发，所以并发能力很强，性能极其好，延时很低，达到微秒级，其他几个都是 ms 级。\n\n * 功能支持：Pulsar 的功能更全面，支持多租户、多种消费模式和持久性模式等功能，是下一代云原生分布式消息流平台。\n\n * 消息丢失：ActiveMQ 和 RabbitMQ 丢失的可能性非常低， Kafka、RocketMQ 和 Pulsar 理论上可以做到 0 丢失。\n\n * ActiveMQ 的社区算是比较成熟，但是较目前来说，ActiveMQ 的性能比较差，而且版本迭代很慢，不推荐使用，已经被淘汰了。\n\n * RabbitMQ 在吞吐量方面虽然稍逊于 Kafka 、RocketMQ 和 Pulsar，但是由于它基于 Erlang 开发，所以并发能力很强，性能极其好，延时很低，达到微秒级。但是也因为 RabbitMQ 基于 Erlang 开发，所以国内很少有公司有实力做 Erlang 源码级别的研究和定制。如果业务场景对并发量要求不是太高（十万级、百万级），那这几种消息队列中，RabbitMQ 或许是你的首选。\n\n * RocketMQ 和 Pulsar 支持强一致性，对消息一致性要求比较高的场景可以使用。\n\n * RocketMQ 阿里出品，Java 系开源项目，源代码我们可以直接阅读，然后可以定制自己公司的 MQ，并且 RocketMQ 有阿里巴巴的实际业务场景的实战考验。\n\n * Kafka 的特点其实很明显，就是仅仅提供较少的核心功能，但是提供超高的吞吐量，ms 级的延迟，极高的可用性以及可靠性，而且分布式可以任意扩展。同时 Kafka 最好是支撑较少的 topic 数量即可，保证其超高吞吐量。Kafka 唯一的一点劣势是有可能消息重复消费，那么对数据准确性会造成极其轻微的影响，在大数据领域中以及日志采集中，这点轻微影响可以忽略这个特性天然适合大数据实时计算以及日志收集。如果是大数据领域的实时计算、日志采集等场景，用 Kafka 是业内标准的。\n\n\n# JMS和AMQP\n\n\n# JMS\n\nJMS（JAVA Message Service,java 消息服务）是 Java 的消息服务，JMS 的客户端之间可以通过 JMS 服务进行异步的消息传输。JMS API 是一个消息服务的标准或者说是规范，允许应用程序组件基于 JavaEE 平台创建、发送、接收和读取消息。它使分布式通信耦合度更低，消息服务更加可靠以及异步性。\n\nActiveMQ 就是基于 JMS 规范实现的。\n\nJMS的两种消息模型\n\n * 点到点模式（P2P）\n * 发布/订阅模式（Pub/Sub），通过topic订阅，类似广播\n\n\n# AMQP\n\nAMQP，即 Advanced Message Queuing Protocol，一个提供统一消息服务的应用层标准高级消息队列协议（二进制应用层协议），是应用层协议的一个开放标准，为面向消息的中间件设计，兼容 JMS。基于此协议的客户端与消息中间件可传递消息，并不受客户端/中间件同产品，不同的开发语言等条件的限制。\n\nRabbitMQ 就是基于 AMQP 协议实现的。\n\n\n# JMS vs AMQP\n\n * AMQP 为消息定义了线路层（wire-level protocol）的协议，而 JMS 所定义的是 API 规范。在 Java 体系中，多个 client 均可以通过 JMS 进行交互，不需要应用修改代码，但是其对跨平台的支持较差。而 AMQP 天然具有跨平台、跨语言特性。\n * JMS 支持 TextMessage、MapMessage 等复杂的消息类型；而 AMQP 仅支持 byte[] 消息类型（复杂的类型可序列化后发送）。\n * 由于 Exchange 提供的路由算法，AMQP 可以提供多样化的路由方式来传递消息到消息队列，而 JMS 仅支持 队列 和 主题/订阅方式两种。",normalizedContent:"消息队列的主要作用是：\n\n 1. 解耦\n 2. 异步。减少响应所需时间\n 3. 削峰\n\n消息队列的缺点 ：\n\n 1. 降低系统的可用性：系统引入的外部依赖越多，越容易挂掉；\n 2. 系统复杂度提高：使用 mq 后可能需要保证消息没有被重复消费、处理消息丢失的情况、保证消息传递的顺序性等等问题；\n 3. 一致性问题：a 系统处理完了直接返回成功了，但问题是：要是 b、c、d 三个系统那里，b 和 d 两个系统写库成功了，结果 c 系统写库失败了，就造成数据不一致了。\n\n\n# 常用mq对比\n\n特性     rabbitmq                        apache kafka                 apache rocketmq                              activemq\n类型     amqp、stomp、mqtt等多种协议            pub/sub消息系统                  纯java消息队列                                    jms消息系统\n性能     稳定、性能一般，适合小规模应用                 高吞吐量、低延迟，适合大规模分布式系统          高吞吐量、低延迟，适合大规模分布式系统                          性能一般，适合小规模应用\n可用性    支持多种ha机制，包括主从复制、镜像队列、集群等        支持多种ha机制，包括主从复制、分区副本等        支持多种ha机制，包括主从复制、broker ha、namesrv ha、异地多活等   支持多种ha机制，包括主从复制、集群等\n可靠性    支持事务、持久化、消息确认等机制，保证消息可靠性        支持副本机制、持久化、消息确认等机制，保证消息可靠性   支持主从复制、持久化、消息确认等机制，保证消息可靠性                   支持持久化、消息确认等机制，保证消息可靠性\n管理工具   支持web管理界面、cli、rest api等多种管理工具   支持web管理界面、cli等多种管理工具         支持web管理界面、cli等多种管理工具                         支持web管理界面、cli等多种管理工具\n社区支持   开源社区活跃，文档丰富，插件丰富                开源社区活跃，文档丰富，插件丰富             开源社区活跃，文档丰富，插件丰富                             开源社区活跃，文档丰富，插件丰富\n适用场景   中小规模应用、需要事务支持、需要amqp协议的应用       大规模分布式系统、实时数据处理、日志收集等        大规模分布式系统、高可用性场景、需要事务支持的应用                    中小规模应用、需要jms协议的应用\n\n * 吞吐量：万级的 activemq 和 rabbitmq 的吞吐量（activemq 的性能最差）要比十万级甚至是百万级的 rocketmq 和 kafka 低一个数量级。\n\n * 可用性：都可以实现高可用。activemq 和 rabbitmq 都是基于主从架构实现高可用性。rocketmq 基于分布式架构。 kafka 也是分布式的，一个数据多个副本，少数机器宕机，不会丢失数据，不会导致不可用\n\n * 时效性：rabbitmq 基于 erlang 开发，所以并发能力很强，性能极其好，延时很低，达到微秒级，其他几个都是 ms 级。\n\n * 功能支持：pulsar 的功能更全面，支持多租户、多种消费模式和持久性模式等功能，是下一代云原生分布式消息流平台。\n\n * 消息丢失：activemq 和 rabbitmq 丢失的可能性非常低， kafka、rocketmq 和 pulsar 理论上可以做到 0 丢失。\n\n * activemq 的社区算是比较成熟，但是较目前来说，activemq 的性能比较差，而且版本迭代很慢，不推荐使用，已经被淘汰了。\n\n * rabbitmq 在吞吐量方面虽然稍逊于 kafka 、rocketmq 和 pulsar，但是由于它基于 erlang 开发，所以并发能力很强，性能极其好，延时很低，达到微秒级。但是也因为 rabbitmq 基于 erlang 开发，所以国内很少有公司有实力做 erlang 源码级别的研究和定制。如果业务场景对并发量要求不是太高（十万级、百万级），那这几种消息队列中，rabbitmq 或许是你的首选。\n\n * rocketmq 和 pulsar 支持强一致性，对消息一致性要求比较高的场景可以使用。\n\n * rocketmq 阿里出品，java 系开源项目，源代码我们可以直接阅读，然后可以定制自己公司的 mq，并且 rocketmq 有阿里巴巴的实际业务场景的实战考验。\n\n * kafka 的特点其实很明显，就是仅仅提供较少的核心功能，但是提供超高的吞吐量，ms 级的延迟，极高的可用性以及可靠性，而且分布式可以任意扩展。同时 kafka 最好是支撑较少的 topic 数量即可，保证其超高吞吐量。kafka 唯一的一点劣势是有可能消息重复消费，那么对数据准确性会造成极其轻微的影响，在大数据领域中以及日志采集中，这点轻微影响可以忽略这个特性天然适合大数据实时计算以及日志收集。如果是大数据领域的实时计算、日志采集等场景，用 kafka 是业内标准的。\n\n\n# jms和amqp\n\n\n# jms\n\njms（java message service,java 消息服务）是 java 的消息服务，jms 的客户端之间可以通过 jms 服务进行异步的消息传输。jms api 是一个消息服务的标准或者说是规范，允许应用程序组件基于 javaee 平台创建、发送、接收和读取消息。它使分布式通信耦合度更低，消息服务更加可靠以及异步性。\n\nactivemq 就是基于 jms 规范实现的。\n\njms的两种消息模型\n\n * 点到点模式（p2p）\n * 发布/订阅模式（pub/sub），通过topic订阅，类似广播\n\n\n# amqp\n\namqp，即 advanced message queuing protocol，一个提供统一消息服务的应用层标准高级消息队列协议（二进制应用层协议），是应用层协议的一个开放标准，为面向消息的中间件设计，兼容 jms。基于此协议的客户端与消息中间件可传递消息，并不受客户端/中间件同产品，不同的开发语言等条件的限制。\n\nrabbitmq 就是基于 amqp 协议实现的。\n\n\n# jms vs amqp\n\n * amqp 为消息定义了线路层（wire-level protocol）的协议，而 jms 所定义的是 api 规范。在 java 体系中，多个 client 均可以通过 jms 进行交互，不需要应用修改代码，但是其对跨平台的支持较差。而 amqp 天然具有跨平台、跨语言特性。\n * jms 支持 textmessage、mapmessage 等复杂的消息类型；而 amqp 仅支持 byte[] 消息类型（复杂的类型可序列化后发送）。\n * 由于 exchange 提供的路由算法，amqp 可以提供多样化的路由方式来传递消息到消息队列，而 jms 仅支持 队列 和 主题/订阅方式两种。",charsets:{cjk:!0}},{title:"RocketMQ 和 Kafka 对比",frontmatter:{title:"RocketMQ 和 Kafka 对比",date:"2023-07-20T22:44:48.000Z",permalink:"/pages/7c8ab7/"},regularPath:"/10.%E4%B8%AD%E9%97%B4%E4%BB%B6/04.%20RocketMQ%20%E5%92%8C%20Kafka%20%E5%AF%B9%E6%AF%94.html",relativePath:"10.中间件/04. RocketMQ 和 Kafka 对比.md",key:"v-6bc0f08b",path:"/pages/7c8ab7/",headersStr:null,content:"概念对比：\n\nKAFKA            ROCKETMQ\nTopic            Topic\nPartition        Queue\nProducer         Producer\nConsumer         Consumer\nConsumer Group   Consumer Group\nBroker           Broker\nMessage          Message\nOffset           Offset\nLeader           Master\nFollower         Slave\nZooKeeper        Nameserver\nConnector        Producer",normalizedContent:"概念对比：\n\nkafka            rocketmq\ntopic            topic\npartition        queue\nproducer         producer\nconsumer         consumer\nconsumer group   consumer group\nbroker           broker\nmessage          message\noffset           offset\nleader           master\nfollower         slave\nzookeeper        nameserver\nconnector        producer",charsets:{cjk:!0}},{title:"Git commit message 规范",frontmatter:{title:"Git commit message 规范",date:"2023-03-20T19:39:51.000Z",permalink:"/pages/git/"},regularPath:"/100.%E5%B7%A5%E5%85%B7/01.Git/01.Git%20commit%20message%20%E8%A7%84%E8%8C%83.html",relativePath:"100.工具/01.Git/01.Git commit message 规范.md",key:"v-c1084aa0",path:"/pages/git/",headersStr:null,content:"message type：\n\n * feat：新功能（feature）\n * fix：修补bug\n * perf：提高代码性能的变更\n * docs：文档（documentation）\n * style： 格式（不影响代码运行的变动），如格式化代码、删除空行\n * refactor：重构（即不是新增功能，也不是修改bug的代码变动）\n * test：增加测试\n * chore：其他类型，如构建过程、依赖管理、辅助工具的变动\n\n\n代码类：\n\n * feat\n * fix\n * perf\n * style\n * refactor\n\n\n非代码类：\n\n * test\n * ci\n * docs\n * chore\n\n参考：https://www.ruanyifeng.com/blog/2016/01/commit_message_change_log.html",normalizedContent:"message type：\n\n * feat：新功能（feature）\n * fix：修补bug\n * perf：提高代码性能的变更\n * docs：文档（documentation）\n * style： 格式（不影响代码运行的变动），如格式化代码、删除空行\n * refactor：重构（即不是新增功能，也不是修改bug的代码变动）\n * test：增加测试\n * chore：其他类型，如构建过程、依赖管理、辅助工具的变动\n\n\n代码类：\n\n * feat\n * fix\n * perf\n * style\n * refactor\n\n\n非代码类：\n\n * test\n * ci\n * docs\n * chore\n\n参考：https://www.ruanyifeng.com/blog/2016/01/commit_message_change_log.html",charsets:{cjk:!0},lastUpdated:"2023/03/29, 21:03:43",lastUpdatedTimestamp:1680095023e3},{title:"合并提交-rebase",frontmatter:{title:"合并提交-rebase",date:"2023-03-20T19:41:38.000Z",permalink:"/pages/6f9bb5/"},regularPath:"/100.%E5%B7%A5%E5%85%B7/01.Git/02.%E5%90%88%E5%B9%B6%E6%8F%90%E4%BA%A4-rebase.html",relativePath:"100.工具/01.Git/02.合并提交-rebase.md",key:"v-4c9cf11f",path:"/pages/6f9bb5/",headers:[{level:2,title:"在 idea 中操作 rebase 合并 commit",slug:"在-idea-中操作-rebase-合并-commit",normalizedTitle:"在 idea 中操作 rebase 合并 commit",charIndex:793}],headersStr:"在 idea 中操作 rebase 合并 commit",content:"如果觉得代码commit⽐较多，看起来⽐较随意。或者说，想等开发完⼀个完整的功能之后，放在⼀个commit中⼀起提交。这时候，我们可以在最后合并代码或者提交Pull Request前，执⾏git rebase -i合并之前的所有commit。\n\n\ngit rebase -i <commit ID>\n\n-i: interactive，进入到交互界面中，vim编辑器。\n\n这个交互界⾯会⾸先列出给定<commit ID>之前（不包括，越下⾯越新）的所有commit，每个commit\n\n前⾯有⼀个操作命令，默认是pick。我们可以选择不同的commit，并修改commit前⾯的命令，来对该\n\ncommit执⾏不同的变更操作。\n\n\ngit base支持的变更操作：\n\n * p，pick：不对该commit做任何处理\n * r，reword：保留该commit，但是修改提交信息\n * e，edit：保留该commit，但是rebase时会暂停，允许你修改这个commit\n * s，squash：保留该commit，但会将当前commit与上一个commit合并\n * f，fixup：与squash相同，但不会保存当前commit的信息\n * x，exec：执行其他shell命令\n * d，drop：删除该commit\n\n查看commit记录：git log --oneline\n\ngit reset 命令用于回退版本，可以指定退回某一次的提交。\n\n执行 git reset HEAD 以取消之前 git add 添加，但不希望包含在下一提交快照中的缓存。\n\n\n修改commit message的两种方法：\n\n * git commit --ament：修改最近一次commit的message\n * git rebase -i：选e，修改某次commit的message\n\n\n# 在 idea 中操作 rebase 合并 commit\n\n\n\n\n\nhttps://blog.csdn.net/oldshaui/article/details/103922368",normalizedContent:"如果觉得代码commit⽐较多，看起来⽐较随意。或者说，想等开发完⼀个完整的功能之后，放在⼀个commit中⼀起提交。这时候，我们可以在最后合并代码或者提交pull request前，执⾏git rebase -i合并之前的所有commit。\n\n\ngit rebase -i <commit id>\n\n-i: interactive，进入到交互界面中，vim编辑器。\n\n这个交互界⾯会⾸先列出给定<commit id>之前（不包括，越下⾯越新）的所有commit，每个commit\n\n前⾯有⼀个操作命令，默认是pick。我们可以选择不同的commit，并修改commit前⾯的命令，来对该\n\ncommit执⾏不同的变更操作。\n\n\ngit base支持的变更操作：\n\n * p，pick：不对该commit做任何处理\n * r，reword：保留该commit，但是修改提交信息\n * e，edit：保留该commit，但是rebase时会暂停，允许你修改这个commit\n * s，squash：保留该commit，但会将当前commit与上一个commit合并\n * f，fixup：与squash相同，但不会保存当前commit的信息\n * x，exec：执行其他shell命令\n * d，drop：删除该commit\n\n查看commit记录：git log --oneline\n\ngit reset 命令用于回退版本，可以指定退回某一次的提交。\n\n执行 git reset head 以取消之前 git add 添加，但不希望包含在下一提交快照中的缓存。\n\n\n修改commit message的两种方法：\n\n * git commit --ament：修改最近一次commit的message\n * git rebase -i：选e，修改某次commit的message\n\n\n# 在 idea 中操作 rebase 合并 commit\n\n\n\n\n\nhttps://blog.csdn.net/oldshaui/article/details/103922368",charsets:{cjk:!0},lastUpdated:"2023/03/29, 21:03:43",lastUpdatedTimestamp:1680095023e3},{title:"git fetch与git pull",frontmatter:{title:"git fetch与git pull",date:"2023-03-30T13:37:13.000Z",permalink:"/pages/0974e8/"},regularPath:"/100.%E5%B7%A5%E5%85%B7/01.Git/03.git%20pull%E5%92%8Cgit%20fetch.html",relativePath:"100.工具/01.Git/03.git pull和git fetch.md",key:"v-7181834a",path:"/pages/0974e8/",headersStr:null,content:"git pull = git fetch + git merge\n\ngit fetch和git pull都是Git版本控制系统中用于从远程仓库获取更新的命令，但它们之间有一些区别。\n\ngit fetch会从远程仓库下载最新的提交，但不会自动将这些更新合并到本地分支中。这意味着你可以在本地仓库中查看远程仓库的更新，但可以选择什么时候将这些更新合并到本地分支中。使用git fetch后，需要手动使用git merge或git rebase将远程更新合并到本地分支中。\n\ngit pull则会在运行git fetch命令之后自动将远程更新合并到本地分支中。这意味着git pull命令不仅会从远程仓库下载最新提交，还会自动合并到本地分支中。因此，如果你只是想查看远程更新，而不想立即合并到本地分支中，建议使用git fetch，而不是git pull。\n\n总结来说，git fetch和git pull的区别在于是否自动将远程更新合并到本地分支中。git fetch只下载最新的提交，但不会自动合并到本地分支中，而git pull则会自动将远程更新合并到本地分支中。",normalizedContent:"git pull = git fetch + git merge\n\ngit fetch和git pull都是git版本控制系统中用于从远程仓库获取更新的命令，但它们之间有一些区别。\n\ngit fetch会从远程仓库下载最新的提交，但不会自动将这些更新合并到本地分支中。这意味着你可以在本地仓库中查看远程仓库的更新，但可以选择什么时候将这些更新合并到本地分支中。使用git fetch后，需要手动使用git merge或git rebase将远程更新合并到本地分支中。\n\ngit pull则会在运行git fetch命令之后自动将远程更新合并到本地分支中。这意味着git pull命令不仅会从远程仓库下载最新提交，还会自动合并到本地分支中。因此，如果你只是想查看远程更新，而不想立即合并到本地分支中，建议使用git fetch，而不是git pull。\n\n总结来说，git fetch和git pull的区别在于是否自动将远程更新合并到本地分支中。git fetch只下载最新的提交，但不会自动合并到本地分支中，而git pull则会自动将远程更新合并到本地分支中。",charsets:{cjk:!0}},{title:"单例模式",frontmatter:{title:"单例模式",date:"2023-04-21T22:36:28.000Z",permalink:"/pages/c02964/"},regularPath:"/11.%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/01.%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F.html",relativePath:"11. 设计模式/01.单例模式.md",key:"v-ea66ad78",path:"/pages/c02964/",headersStr:null,content:"单例模式的主要作用是确保在一个进程中只有一个实例（对象）被创建和使用。避免资源的浪费和冲突，提高系统的性能和稳定性。\n\n优点：\n\n 1. 单例模式可以保证在一个进程中只有一个实例被创建，避免了资源的浪费和冲突。\n 2. 单例模式可以提高系统的性能和稳定性。由于单例模式只创建一个实例，可以减少对象的创建和销毁，降低系统的开销。同时，由于单例模式只有一个实例，可以避免多个实例之间的竞争和冲突，提高系统的稳定性。\n 3. 单例模式可以提高代码的可维护性和可扩展性。由于单例模式将对象的创建和管理集中在一个类中，可以方便地对单例对象进行统一的管理和维护。同时，由于单例模式只有一个实例，可以方便地对实例进行扩展和升级。\n 4. 单例模式可以提高代码的复用性。由于单例模式只创建一个实例，可以在不同的模块和类中方便地共享单例对象，提高代码的复用性。\n\n应用场景：\n\n 1. 资源共享：某些资源只需要被创建一次，例如线程池、数据库连接池等，采用单例模式可以确保只有一个实例被创建，避免资源的浪费和冲突。\n 2. 配置信息：某些配置信息只需要被读取一次，例如系统配置、日志配置等，采用单例模式可以确保配置信息只被读取一次，提高系统性能。\n 3. 日志对象：由于日志对象需要频繁地被调用，如果每次都创建新的对象，将会影响系统性能，采用单例模式可以确保只有一个日志对象被创建，提高系统性能。\n 4. 线程池：线程池是多线程编程中非常常见的一种技术，它可以提高系统的并发能力，避免线程的频繁创建和销毁。采用单例模式可以确保线程池只被创建一次，避免资源的浪费。\n\n// 使用 synchronized 双重校验锁的方法实现单例模式\npublic class Singleton {\n  private volatile static Singleton instance;\n  private Singleton(){}\n  public static Singleton getInstance() {\n    if (instance == null) {\n      synchronized(Singleton.class) {\n        if (instance == null) instance = new Singleton();\n      }\n    }\n    return instance;\n  }\n}\n\n\n另外，需要注意 instance 采用 volatile 关键字修饰也是很有必要。 因为 instance = new Singleton(); 这段代码其实是分为三步执行：\n\n 1. 为 instance 分配内存空间\n 2. 初始化 instance\n 3. 将 instance 指向分配的内存地址\n\n但是由于 JVM 具有指令重排的特性，执行顺序有可能变成 1 -> 3 -> 2。指令重排在单线程环境下不会出现问题，但是在多线程环境下会导致一个线程获得还没有初始化的实例。例如，线程 T1 执行了 1 和 3，此时 T2 调用 getInstance() 后发现 instance 不为空，因此返回 instance，但此时 instance 还未被初始化。\n\n使用 volatile 可以禁止 JVM 的指令重排，保证在多线程环境下也能正常运行。\n\n单例模式中volatile关键字引发的思考:\n\nhttp://www.imooc.com/article/276841\n\n结论：\n\n如果我们使用一个基于直接访问对象的编译器（如HotSpot默认编译器），不加volatile关键字也不会出现问题。\n\n如果我们使用一个基于句柄方式访问对象的编译器（如Symantec JIT），不加volatile关键字可能会导致重排序，返回一个未初始化完成的实例。\n\n> 网上有人说，这种实现方式有些问题。因为指令重排序，可能会导致 IdGenerator 对象被 new 出来，并且赋值给 instance 之后，还没来得及初始化（执行构造函数中的代码逻辑），就被另一个线程使用了。\n> \n> 要解决这个问题，我们需要给 instance 成员变量加上 volatile 关键字，禁止指令重排序才行。实际上，只有很低版本的 Java 才会有这个问题。我们现在用的高版本的 Java 已经在 JDK 内部实现中解决了这个问题（解决的方法很简单，只要把对象 new 操作和初始化操作设计为原子操作，就自然能禁止重排序）。\n\n似乎jdk8已经确保new、初始化为原子性操作，不会出现JIT导致指令重排的情况。\n\n----------------------------------------\n\n//静态内部类\npublic class Singleton {\n  private Singleton(){}\n  private static class SingletonHolder {\n    private static final Singleton instance = new Singleton();\n  }\n  \n  public static Singleton getInstance() {\n    return SingletonHolder.instance;\n  }\n}\n",normalizedContent:"单例模式的主要作用是确保在一个进程中只有一个实例（对象）被创建和使用。避免资源的浪费和冲突，提高系统的性能和稳定性。\n\n优点：\n\n 1. 单例模式可以保证在一个进程中只有一个实例被创建，避免了资源的浪费和冲突。\n 2. 单例模式可以提高系统的性能和稳定性。由于单例模式只创建一个实例，可以减少对象的创建和销毁，降低系统的开销。同时，由于单例模式只有一个实例，可以避免多个实例之间的竞争和冲突，提高系统的稳定性。\n 3. 单例模式可以提高代码的可维护性和可扩展性。由于单例模式将对象的创建和管理集中在一个类中，可以方便地对单例对象进行统一的管理和维护。同时，由于单例模式只有一个实例，可以方便地对实例进行扩展和升级。\n 4. 单例模式可以提高代码的复用性。由于单例模式只创建一个实例，可以在不同的模块和类中方便地共享单例对象，提高代码的复用性。\n\n应用场景：\n\n 1. 资源共享：某些资源只需要被创建一次，例如线程池、数据库连接池等，采用单例模式可以确保只有一个实例被创建，避免资源的浪费和冲突。\n 2. 配置信息：某些配置信息只需要被读取一次，例如系统配置、日志配置等，采用单例模式可以确保配置信息只被读取一次，提高系统性能。\n 3. 日志对象：由于日志对象需要频繁地被调用，如果每次都创建新的对象，将会影响系统性能，采用单例模式可以确保只有一个日志对象被创建，提高系统性能。\n 4. 线程池：线程池是多线程编程中非常常见的一种技术，它可以提高系统的并发能力，避免线程的频繁创建和销毁。采用单例模式可以确保线程池只被创建一次，避免资源的浪费。\n\n// 使用 synchronized 双重校验锁的方法实现单例模式\npublic class singleton {\n  private volatile static singleton instance;\n  private singleton(){}\n  public static singleton getinstance() {\n    if (instance == null) {\n      synchronized(singleton.class) {\n        if (instance == null) instance = new singleton();\n      }\n    }\n    return instance;\n  }\n}\n\n\n另外，需要注意 instance 采用 volatile 关键字修饰也是很有必要。 因为 instance = new singleton(); 这段代码其实是分为三步执行：\n\n 1. 为 instance 分配内存空间\n 2. 初始化 instance\n 3. 将 instance 指向分配的内存地址\n\n但是由于 jvm 具有指令重排的特性，执行顺序有可能变成 1 -> 3 -> 2。指令重排在单线程环境下不会出现问题，但是在多线程环境下会导致一个线程获得还没有初始化的实例。例如，线程 t1 执行了 1 和 3，此时 t2 调用 getinstance() 后发现 instance 不为空，因此返回 instance，但此时 instance 还未被初始化。\n\n使用 volatile 可以禁止 jvm 的指令重排，保证在多线程环境下也能正常运行。\n\n单例模式中volatile关键字引发的思考:\n\nhttp://www.imooc.com/article/276841\n\n结论：\n\n如果我们使用一个基于直接访问对象的编译器（如hotspot默认编译器），不加volatile关键字也不会出现问题。\n\n如果我们使用一个基于句柄方式访问对象的编译器（如symantec jit），不加volatile关键字可能会导致重排序，返回一个未初始化完成的实例。\n\n> 网上有人说，这种实现方式有些问题。因为指令重排序，可能会导致 idgenerator 对象被 new 出来，并且赋值给 instance 之后，还没来得及初始化（执行构造函数中的代码逻辑），就被另一个线程使用了。\n> \n> 要解决这个问题，我们需要给 instance 成员变量加上 volatile 关键字，禁止指令重排序才行。实际上，只有很低版本的 java 才会有这个问题。我们现在用的高版本的 java 已经在 jdk 内部实现中解决了这个问题（解决的方法很简单，只要把对象 new 操作和初始化操作设计为原子操作，就自然能禁止重排序）。\n\n似乎jdk8已经确保new、初始化为原子性操作，不会出现jit导致指令重排的情况。\n\n----------------------------------------\n\n//静态内部类\npublic class singleton {\n  private singleton(){}\n  private static class singletonholder {\n    private static final singleton instance = new singleton();\n  }\n  \n  public static singleton getinstance() {\n    return singletonholder.instance;\n  }\n}\n",charsets:{cjk:!0}},{title:"Docker命令",frontmatter:{title:"Docker命令",date:"2023-03-30T13:34:56.000Z",permalink:"/pages/aa154b/"},regularPath:"/100.%E5%B7%A5%E5%85%B7/03.Docker/01.Docker%E5%91%BD%E4%BB%A4.html",relativePath:"100.工具/03.Docker/01.Docker命令.md",key:"v-2ede7bc6",path:"/pages/aa154b/",headers:[{level:2,title:"docker命令总结",slug:"docker命令总结",normalizedTitle:"docker命令总结",charIndex:2},{level:2,title:"docker run",slug:"docker-run",normalizedTitle:"docker run",charIndex:76},{level:2,title:"demo: docker启动redis",slug:"demo-docker启动redis",normalizedTitle:"demo: docker启动redis",charIndex:437}],headersStr:"docker命令总结 docker run demo: docker启动redis",content:"# docker命令总结\n\ndocker images //查看镜像\n\ndocker pull elasticsearch:5.6.8 //下载镜像\n\ndocker run ‐di ‐‐name=tensquare_elasticsearch ‐p 9200:9200 ‐p 9300:9300 elasticsearch:5.6.8 //创建容器\n\ndocker ps //查看已启动容器\n\ndocker ps -a//查看所有容器\n\ndocker exec ‐it tensquare_elasticsearch /bin/bash //进入容器\n\ndocker cp ik tensquare_elasticsearch:/usr/share/elasticsearch/plugins/ //拷贝文件到容器中\n\ndocker start id //启动一个已停止的容器\n\n\n# docker run\n\n-i: 交互式操作\n\n-t: 终端\n\n-d: 后台运行\n\n\n# demo: docker启动redis\n\n 1. docker search redis\n 2. docker pull redis:latest\n 3. docker images\n 4. docker run -itd --name redis-test -p 6379:6379 redis\n 5. docker ps\n 6. docker exec -it redis-test /bin/bash",normalizedContent:"# docker命令总结\n\ndocker images //查看镜像\n\ndocker pull elasticsearch:5.6.8 //下载镜像\n\ndocker run ‐di ‐‐name=tensquare_elasticsearch ‐p 9200:9200 ‐p 9300:9300 elasticsearch:5.6.8 //创建容器\n\ndocker ps //查看已启动容器\n\ndocker ps -a//查看所有容器\n\ndocker exec ‐it tensquare_elasticsearch /bin/bash //进入容器\n\ndocker cp ik tensquare_elasticsearch:/usr/share/elasticsearch/plugins/ //拷贝文件到容器中\n\ndocker start id //启动一个已停止的容器\n\n\n# docker run\n\n-i: 交互式操作\n\n-t: 终端\n\n-d: 后台运行\n\n\n# demo: docker启动redis\n\n 1. docker search redis\n 2. docker pull redis:latest\n 3. docker images\n 4. docker run -itd --name redis-test -p 6379:6379 redis\n 5. docker ps\n 6. docker exec -it redis-test /bin/bash",charsets:{cjk:!0}},{title:"Linux命令",frontmatter:{title:"Linux命令",date:"2023-03-31T17:32:08.000Z",permalink:"/pages/d3d9ca/"},regularPath:"/100.%E5%B7%A5%E5%85%B7/02.Linux/02.Linux%E5%91%BD%E4%BB%A4.html",relativePath:"100.工具/02.Linux/02.Linux命令.md",key:"v-165dc3de",path:"/pages/d3d9ca/",headers:[{level:2,title:"统计词频",slug:"统计词频",normalizedTitle:"统计词频",charIndex:2},{level:2,title:"正则表达式",slug:"正则表达式",normalizedTitle:"正则表达式",charIndex:173},{level:2,title:"查看磁盘空间",slug:"查看磁盘空间",normalizedTitle:"查看磁盘空间",charIndex:392},{level:3,title:"查看磁盘整体情况，包括磁盘大小，已使用，可用。",slug:"查看磁盘整体情况-包括磁盘大小-已使用-可用。",normalizedTitle:"查看磁盘整体情况，包括磁盘大小，已使用，可用。",charIndex:504},{level:3,title:"计算文件夹大小",slug:"计算文件夹大小",normalizedTitle:"计算文件夹大小",charIndex:557},{level:3,title:"目录文件件占用详情",slug:"目录文件件占用详情",normalizedTitle:"目录文件件占用详情",charIndex:596},{level:2,title:"根据pid查看进程信息",slug:"根据pid查看进程信息",normalizedTitle:"根据pid查看进程信息",charIndex:663}],headersStr:"统计词频 正则表达式 查看磁盘空间 查看磁盘整体情况，包括磁盘大小，已使用，可用。 计算文件夹大小 目录文件件占用详情 根据pid查看进程信息",content:"# 统计词频\n\ncat words.txt | tr -s \" \" \"\\n\" | sort | uniq -c | sort -r | awk '{print $2, $1}'\n\n\ncat words.txt | xargs -n 1 | sort | uniq -c | sort -r | awk '{print $2, $1}'\n\n\n\n# 正则表达式\n\n * ^ 开始\n * $ 结束\n * [0-9] 匹配数字\n * | 或者\n * () 子表达式\n * . 匹配除换行符\\n之外的任何单字符\n * \\ 用于转义\n\n限定符，表示限定符前面字符出现的次数：\n\n * * 出现次数>=0\n * + 出现次数>=1\n * ? 出现次数 0 or 1, 等价{0,1}\n * {n} 出现次数=n\n * {n,} 出现次数>=n\n * {n, m} n=< 出现次数<= m\n\n\n# 查看磁盘空间\n\ndf: disk free\n\ndu: disk usage\n\n-h, --human-readable 使用人类可读的格式(预设值是不加这个选项的...) -s或--summarize 仅显示总计。\n\n\n# 查看磁盘整体情况，包括磁盘大小，已使用，可用。\n\n * df -h\n * df -h /usr/\n\n\n# 计算文件夹大小\n\n * du -sh\n * du -sh /usr/\n\n\n# 目录文件件占用详情\n\n * du --max-depth=1 -h\n * du --max-depth=1 -h /usr/\n\n\n# 根据pid查看进程信息\n\n * ll /proc/pid",normalizedContent:"# 统计词频\n\ncat words.txt | tr -s \" \" \"\\n\" | sort | uniq -c | sort -r | awk '{print $2, $1}'\n\n\ncat words.txt | xargs -n 1 | sort | uniq -c | sort -r | awk '{print $2, $1}'\n\n\n\n# 正则表达式\n\n * ^ 开始\n * $ 结束\n * [0-9] 匹配数字\n * | 或者\n * () 子表达式\n * . 匹配除换行符\\n之外的任何单字符\n * \\ 用于转义\n\n限定符，表示限定符前面字符出现的次数：\n\n * * 出现次数>=0\n * + 出现次数>=1\n * ? 出现次数 0 or 1, 等价{0,1}\n * {n} 出现次数=n\n * {n,} 出现次数>=n\n * {n, m} n=< 出现次数<= m\n\n\n# 查看磁盘空间\n\ndf: disk free\n\ndu: disk usage\n\n-h, --human-readable 使用人类可读的格式(预设值是不加这个选项的...) -s或--summarize 仅显示总计。\n\n\n# 查看磁盘整体情况，包括磁盘大小，已使用，可用。\n\n * df -h\n * df -h /usr/\n\n\n# 计算文件夹大小\n\n * du -sh\n * du -sh /usr/\n\n\n# 目录文件件占用详情\n\n * du --max-depth=1 -h\n * du --max-depth=1 -h /usr/\n\n\n# 根据pid查看进程信息\n\n * ll /proc/pid",charsets:{cjk:!0}},{title:"工厂模式",frontmatter:{title:"工厂模式",date:"2023-09-08T00:48:05.000Z",permalink:"/pages/da6600/"},regularPath:"/11.%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/02.%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F.html",relativePath:"11. 设计模式/02.工厂模式.md",key:"v-5798a127",path:"/pages/da6600/",headers:[{level:2,title:"应用场景，什么时候该用工厂模式？",slug:"应用场景-什么时候该用工厂模式",normalizedTitle:"应用场景，什么时候该用工厂模式？",charIndex:2},{level:2,title:"工厂模式的优点：",slug:"工厂模式的优点",normalizedTitle:"工厂模式的优点：",charIndex:123},{level:2,title:"工厂模式分类：",slug:"工厂模式分类",normalizedTitle:"工厂模式分类：",charIndex:171},{level:2,title:"代码",slug:"代码",normalizedTitle:"代码",charIndex:63},{level:2,title:"工厂模式与依赖注入容器有何区别？",slug:"工厂模式与依赖注入容器有何区别",normalizedTitle:"工厂模式与依赖注入容器有何区别？",charIndex:2036},{level:2,title:"spring 使用到的工厂模式",slug:"spring-使用到的工厂模式",normalizedTitle:"spring 使用到的工厂模式",charIndex:2208},{level:2,title:"DI容器的核心功能",slug:"di容器的核心功能",normalizedTitle:"di容器的核心功能",charIndex:2278},{level:2,title:"BeansFactory中的createBean()是一个递归函数，如何解决循环依赖问题",slug:"beansfactory中的createbean-是一个递归函数-如何解决循环依赖问题",normalizedTitle:"beansfactory中的createbean()是一个递归函数，如何解决循环依赖问题",charIndex:2440}],headersStr:"应用场景，什么时候该用工厂模式？ 工厂模式的优点： 工厂模式分类： 代码 工厂模式与依赖注入容器有何区别？ spring 使用到的工厂模式 DI容器的核心功能 BeansFactory中的createBean()是一个递归函数，如何解决循环依赖问题",content:'# 应用场景，什么时候该用工厂模式？\n\n如果创建对象逻辑不复杂，直接用new即可。创建逻辑复杂的情况：\n\n * 类似规则匹配，代码中存在if-else，动态的根据不同的类型创建不同的对象。\n * 单个对象本身创建复杂，各种组合，初始化。\n\n\n# 工厂模式的优点：\n\n * 封装变化\n * 代码复用\n * 隔离复杂性\n * 控制复杂度\n\n\n# 工厂模式分类：\n\n * 简单工厂（Simple Factory）：也叫静态工厂方法。\n   * 把对象的创建逻辑独立成一个工厂类。\n   * 如果对象可复用，可用map将其缓存起来。\n * 工厂方法（Factory Method）：将if逻辑去除，利用多态。但使用时可能又有许多if-else，因此可以为工厂类再创建一个简单工厂，工厂的工厂，用来创建工厂类对象。\n * 抽象工厂（Abstract Factory）：复杂，不常用。让一个工厂负责创建多个不同的类型对象。\n\n复杂度无法被消除，只能被转移：\n\n * 不用工厂模式，if-else 逻辑、创建逻辑和业务代码耦合在一起\n * 简单工厂是将不同创建逻辑放到一个工厂类中，if-else 逻辑在这个工厂类中\n * 工厂方法是将不同创建逻辑放到不同工厂类中，先用一个工厂类的工厂来得到某个工厂，再用这个工厂来创建，if-else 逻辑在工厂类的工厂中\n\n\n# 代码\n\n//简单工厂模式，方法1\npublic class RuleConfigParserFactory {\n  public static IRuleConfigParser createParser(String configFormat) {\n    IRuleConfigParser parser = null;\n    if ("json".equalsIgnoreCase(configFormat)) {\n      parser = new JsonRuleConfigParser();\n    } else if ("xml".equalsIgnoreCase(configFormat)) {\n      parser = new XmlRuleConfigParser();\n    }...\n    return parser;\n  }\n}\n\n////简单工厂模式，方法2（对象可复用时，去除了if-else）\npublic class RuleConfigParserFactory {\n  private static final Map<String, RuleConfigParser> cachedParsers = new HashMap<>();\n  static {\n    cachedParsers.put("json", new JsonRuleConfigParser());\n    cachedParsers.put("xml", new XmlRuleConfigParser());\n    ...\n  }\n  public static IRuleConfigParser createParser(String configFormat) {\n    IRuleConfigParser parser = cachedParsers.get(configFormat);\n    return parser;\n  }\n}\n\n\n//工厂方法，新增一种parser时，只需新增一个实现的factory就行了。\npublic interface IRuleConfigParserFactory {\n  IRuleConfigParser createParser();\n}\n\npublic class JsonRuleConfigParserFactory implements IRuleConfigParserFactory {\n  @Override\n  public IRuleConfigParser createParser() {\n    return new JsonRuleConfigParser();\n  }\n}\n...\n//使用\npublic RuleConfig load(String fileExtension) {\n    IRuleConfigParserFactory parserFactory = null;\n    if ("json".equals(fileExtension)) {\n        parserFactory = new JsonRuleConfigParserFactory();\n    }...\n    IRuleConfigParser parser = parserFactory.createParser();\n    return parser.parse();\n}\n\n\n\n# 工厂模式与依赖注入容器有何区别？\n\nDI容器底层的设计思路就是基于工厂模式。DI容器相当于一个大的工厂类，负责在程序启动时，根据配置事先创建好对象。当程序需要使用某个类的对象时，直接从容器中获取。因为持有一堆对象，才称为容器。\n\n工厂类只负责某个类或一组相关类对象的创建。DI容器负责整个应用中所有类对象的创建，且负责的内容也比较多。\n\n\n# spring 使用到的工厂模式\n\nBeanFactory 采用的是简单工厂模式。\n\nFactoryBean 采用的是工厂方法模式。\n\n\n# DI容器的核心功能\n\n有3个核心功能：\n\n * 配置解析。BeanConfigParser，负责将配置文件解析为BeanDefinition结构。\n * 对象创建。通过反射机制，将所有类对象的创建都放在一个工厂类中完成，如BeansFactory，根据BeanDefinition创建对象。\n * 对象生命周期管理\n\n\n# BeansFactory中的createBean()是一个递归函数，如何解决循环依赖问题\n\nSpring解决循环依赖的办法是多级缓存。\n\n构造器初始化方式，无法解决循环依赖\n\nset注入方式初始化，有两种:\n\n * 第一种，创建的是单例对象，可以解决。\n * 第二种，创建的是原型对象，由于DI容器不缓存对象导致无法提前暴露一个创建中的对象，故无法解决。',normalizedContent:'# 应用场景，什么时候该用工厂模式？\n\n如果创建对象逻辑不复杂，直接用new即可。创建逻辑复杂的情况：\n\n * 类似规则匹配，代码中存在if-else，动态的根据不同的类型创建不同的对象。\n * 单个对象本身创建复杂，各种组合，初始化。\n\n\n# 工厂模式的优点：\n\n * 封装变化\n * 代码复用\n * 隔离复杂性\n * 控制复杂度\n\n\n# 工厂模式分类：\n\n * 简单工厂（simple factory）：也叫静态工厂方法。\n   * 把对象的创建逻辑独立成一个工厂类。\n   * 如果对象可复用，可用map将其缓存起来。\n * 工厂方法（factory method）：将if逻辑去除，利用多态。但使用时可能又有许多if-else，因此可以为工厂类再创建一个简单工厂，工厂的工厂，用来创建工厂类对象。\n * 抽象工厂（abstract factory）：复杂，不常用。让一个工厂负责创建多个不同的类型对象。\n\n复杂度无法被消除，只能被转移：\n\n * 不用工厂模式，if-else 逻辑、创建逻辑和业务代码耦合在一起\n * 简单工厂是将不同创建逻辑放到一个工厂类中，if-else 逻辑在这个工厂类中\n * 工厂方法是将不同创建逻辑放到不同工厂类中，先用一个工厂类的工厂来得到某个工厂，再用这个工厂来创建，if-else 逻辑在工厂类的工厂中\n\n\n# 代码\n\n//简单工厂模式，方法1\npublic class ruleconfigparserfactory {\n  public static iruleconfigparser createparser(string configformat) {\n    iruleconfigparser parser = null;\n    if ("json".equalsignorecase(configformat)) {\n      parser = new jsonruleconfigparser();\n    } else if ("xml".equalsignorecase(configformat)) {\n      parser = new xmlruleconfigparser();\n    }...\n    return parser;\n  }\n}\n\n////简单工厂模式，方法2（对象可复用时，去除了if-else）\npublic class ruleconfigparserfactory {\n  private static final map<string, ruleconfigparser> cachedparsers = new hashmap<>();\n  static {\n    cachedparsers.put("json", new jsonruleconfigparser());\n    cachedparsers.put("xml", new xmlruleconfigparser());\n    ...\n  }\n  public static iruleconfigparser createparser(string configformat) {\n    iruleconfigparser parser = cachedparsers.get(configformat);\n    return parser;\n  }\n}\n\n\n//工厂方法，新增一种parser时，只需新增一个实现的factory就行了。\npublic interface iruleconfigparserfactory {\n  iruleconfigparser createparser();\n}\n\npublic class jsonruleconfigparserfactory implements iruleconfigparserfactory {\n  @override\n  public iruleconfigparser createparser() {\n    return new jsonruleconfigparser();\n  }\n}\n...\n//使用\npublic ruleconfig load(string fileextension) {\n    iruleconfigparserfactory parserfactory = null;\n    if ("json".equals(fileextension)) {\n        parserfactory = new jsonruleconfigparserfactory();\n    }...\n    iruleconfigparser parser = parserfactory.createparser();\n    return parser.parse();\n}\n\n\n\n# 工厂模式与依赖注入容器有何区别？\n\ndi容器底层的设计思路就是基于工厂模式。di容器相当于一个大的工厂类，负责在程序启动时，根据配置事先创建好对象。当程序需要使用某个类的对象时，直接从容器中获取。因为持有一堆对象，才称为容器。\n\n工厂类只负责某个类或一组相关类对象的创建。di容器负责整个应用中所有类对象的创建，且负责的内容也比较多。\n\n\n# spring 使用到的工厂模式\n\nbeanfactory 采用的是简单工厂模式。\n\nfactorybean 采用的是工厂方法模式。\n\n\n# di容器的核心功能\n\n有3个核心功能：\n\n * 配置解析。beanconfigparser，负责将配置文件解析为beandefinition结构。\n * 对象创建。通过反射机制，将所有类对象的创建都放在一个工厂类中完成，如beansfactory，根据beandefinition创建对象。\n * 对象生命周期管理\n\n\n# beansfactory中的createbean()是一个递归函数，如何解决循环依赖问题\n\nspring解决循环依赖的办法是多级缓存。\n\n构造器初始化方式，无法解决循环依赖\n\nset注入方式初始化，有两种:\n\n * 第一种，创建的是单例对象，可以解决。\n * 第二种，创建的是原型对象，由于di容器不缓存对象导致无法提前暴露一个创建中的对象，故无法解决。',charsets:{cjk:!0}},{title:"AI tools",frontmatter:{title:"AI tools",date:"2023-06-01T12:45:24.000Z",permalink:"/pages/aitools/"},regularPath:"/12.AI/01.AI%20%20tools.html",relativePath:"12.AI/01.AI  tools.md",key:"v-94d81df6",path:"/pages/aitools/",headersStr:null,content:"chatgpt\n\nchatgpt official\n\nopencat\n\nchatgpt ios client\n\nOpenAI Translator\n\nchatgpt client [open source]\n\nsnackprompt\n\nprompt收集网站\n\nflowgpt\n\nprompt收集网站\n\ntheresanaiforthat\n\nwebsite AI aggregator\n\n- name: chatgpt\n  desc: chatgpt official\n  link: https://chat.openai.com/chat\n  bgColor: '#DFEEE7'\n  textColor: '#2A3344'\n- name: opencat\n  desc: chatgpt ios client\n  bgColor: '#DFEEE7'\n  textColor: '#2A3344'\n- name: OpenAI Translator\n  desc: chatgpt client [open source]\n  link: https://github.com/openai-translator/openai-translator\n  bgColor: '#DFEEE7'\n  textColor: '#2A3344'\n- name: snackprompt\n  desc: prompt收集网站\n  link: https://snackprompt.com/\n  bgColor: '#DFEEE7'\n  textColor: '#2A3344'\n- name: flowgpt\n  desc: prompt收集网站\n  link: https://flowgpt.com/\n  bgColor: '#DFEEE7'\n  textColor: '#2A3344'\n- name: theresanaiforthat\n  desc: website AI aggregator\n  link: https://theresanaiforthat.com/\n  bgColor: '#DFEEE7'\n  textColor: '#2A3344'\n",normalizedContent:"chatgpt\n\nchatgpt official\n\nopencat\n\nchatgpt ios client\n\nopenai translator\n\nchatgpt client [open source]\n\nsnackprompt\n\nprompt收集网站\n\nflowgpt\n\nprompt收集网站\n\ntheresanaiforthat\n\nwebsite ai aggregator\n\n- name: chatgpt\n  desc: chatgpt official\n  link: https://chat.openai.com/chat\n  bgcolor: '#dfeee7'\n  textcolor: '#2a3344'\n- name: opencat\n  desc: chatgpt ios client\n  bgcolor: '#dfeee7'\n  textcolor: '#2a3344'\n- name: openai translator\n  desc: chatgpt client [open source]\n  link: https://github.com/openai-translator/openai-translator\n  bgcolor: '#dfeee7'\n  textcolor: '#2a3344'\n- name: snackprompt\n  desc: prompt收集网站\n  link: https://snackprompt.com/\n  bgcolor: '#dfeee7'\n  textcolor: '#2a3344'\n- name: flowgpt\n  desc: prompt收集网站\n  link: https://flowgpt.com/\n  bgcolor: '#dfeee7'\n  textcolor: '#2a3344'\n- name: theresanaiforthat\n  desc: website ai aggregator\n  link: https://theresanaiforthat.com/\n  bgcolor: '#dfeee7'\n  textcolor: '#2a3344'\n",charsets:{cjk:!0}},{title:"Linux常用命令",frontmatter:{title:"Linux常用命令",date:"2023-03-31T17:30:37.000Z",permalink:"/pages/linux/"},regularPath:"/100.%E5%B7%A5%E5%85%B7/02.Linux/01.Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.html",relativePath:"100.工具/02.Linux/01.Linux常用命令.md",key:"v-49c893e5",path:"/pages/linux/",headers:[{level:2,title:"查看端口占用",slug:"查看端口占用",normalizedTitle:"查看端口占用",charIndex:2},{level:2,title:"杀死进程",slug:"杀死进程",normalizedTitle:"杀死进程",charIndex:303},{level:2,title:"后台运行脚本",slug:"后台运行脚本",normalizedTitle:"后台运行脚本",charIndex:325},{level:2,title:"ps -ef",slug:"ps-ef",normalizedTitle:"ps -ef",charIndex:471},{level:2,title:"ll /proc/pid 查看进程所在的目录",slug:"ll-proc-pid-查看进程所在的目录",normalizedTitle:"ll /proc/pid 查看进程所在的目录",charIndex:978},{level:2,title:"常用记录",slug:"常用记录",normalizedTitle:"常用记录",charIndex:1005}],headersStr:"查看端口占用 杀死进程 后台运行脚本 ps -ef ll /proc/pid 查看进程所在的目录 常用记录",content:"# 查看端口占用\n\nlsof(list open files)，在linux中，一切皆文件。\n\nlsof -i tcp:8080\n\nlsof -i :8080\n\n * lsof -i:端口号\n\n * netstat -tunpl | grep 端口号\n\n * * -t tcp\n   * -u udp\n   * -n 拒绝显示别名，能显示成数字的全转化成数字\n   * -l listen状态的\n   * -p 显示建立相关链接的程序名\n\n * 然后就是kill -9 PID\n\nhttps://www.runoob.com/w3cnote/linux-check-port-usage.html\n\n\n# 杀死进程\n\nkill -9 pid\n\n\n# 后台运行脚本\n\n * ./xxx.sh & (终端退出时，就停了)\n * nohup ./xxx.sh & (不中断在后台运行。打印信息会输出到当前目录下的nohup.out中)\n * jobs查看当前shell环境中启动的任务情况。退出当前终端，再重新打开时，jobs看不到正在运行的脚本，ps -ef可以看到。\n * ps -ef | grep xxx.sh 查看正在运行脚本进程\n * ctrl + c是中断脚本。ctrl + z是切换到后台并暂停。\n * bg number 使其在后台执行，fg number 切换到前台执行。（number是使用jobs命令查询到的数字，不是pid）。\n\n\n# ps -ef\n\nps: process status\n\n-e: all the processes with in the system, not just the ones from the current terminal\n\n-f: see a more detailed output\n\nhttps://www.baeldung.com/linux/ps-command#1-listing-all-processes\n\nps aux 和ps -ef两者的输出结果差别不大，但展示风格不同。aux是BSD风格，-ef是System V风格。这是次要的区别，一个影响使用的区别是aux会截断command列，而-ef不会。当结合grep时这种区别会影响到结果。\n\n推荐使用ps -ef。\n\n\n# ll /proc/pid 查看进程所在的目录\n\n\n# 常用记录\n\n * ps -ef | grep xxx\n * source ~／.bash_pro\n * tail -f xxx文件\n * telnet host port\n * lsof -i tcp :8080 查看端口\n * netstat -tunlp | grep 8080 查看端口占用\n * curl -X POST -H 'Content-Type:application/json' -H 'charset=UTF-8' -d '{\"xxx\":\"xxx\"}' http://xxxxx 在服务器里通过curl请求接口，这在生产的服务器中很有用。",normalizedContent:"# 查看端口占用\n\nlsof(list open files)，在linux中，一切皆文件。\n\nlsof -i tcp:8080\n\nlsof -i :8080\n\n * lsof -i:端口号\n\n * netstat -tunpl | grep 端口号\n\n * * -t tcp\n   * -u udp\n   * -n 拒绝显示别名，能显示成数字的全转化成数字\n   * -l listen状态的\n   * -p 显示建立相关链接的程序名\n\n * 然后就是kill -9 pid\n\nhttps://www.runoob.com/w3cnote/linux-check-port-usage.html\n\n\n# 杀死进程\n\nkill -9 pid\n\n\n# 后台运行脚本\n\n * ./xxx.sh & (终端退出时，就停了)\n * nohup ./xxx.sh & (不中断在后台运行。打印信息会输出到当前目录下的nohup.out中)\n * jobs查看当前shell环境中启动的任务情况。退出当前终端，再重新打开时，jobs看不到正在运行的脚本，ps -ef可以看到。\n * ps -ef | grep xxx.sh 查看正在运行脚本进程\n * ctrl + c是中断脚本。ctrl + z是切换到后台并暂停。\n * bg number 使其在后台执行，fg number 切换到前台执行。（number是使用jobs命令查询到的数字，不是pid）。\n\n\n# ps -ef\n\nps: process status\n\n-e: all the processes with in the system, not just the ones from the current terminal\n\n-f: see a more detailed output\n\nhttps://www.baeldung.com/linux/ps-command#1-listing-all-processes\n\nps aux 和ps -ef两者的输出结果差别不大，但展示风格不同。aux是bsd风格，-ef是system v风格。这是次要的区别，一个影响使用的区别是aux会截断command列，而-ef不会。当结合grep时这种区别会影响到结果。\n\n推荐使用ps -ef。\n\n\n# ll /proc/pid 查看进程所在的目录\n\n\n# 常用记录\n\n * ps -ef | grep xxx\n * source ~／.bash_pro\n * tail -f xxx文件\n * telnet host port\n * lsof -i tcp :8080 查看端口\n * netstat -tunlp | grep 8080 查看端口占用\n * curl -x post -h 'content-type:application/json' -h 'charset=utf-8' -d '{\"xxx\":\"xxx\"}' http://xxxxx 在服务器里通过curl请求接口，这在生产的服务器中很有用。",charsets:{cjk:!0}},{title:"集群搭建总思路",frontmatter:{title:"集群搭建总思路",date:"2023-08-28T21:02:00.000Z",permalink:"/pages/e945bb/"},regularPath:"/13.%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/01.%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA%E6%80%BB%E6%80%9D%E8%B7%AF.html",relativePath:"13.系统设计/01.集群搭建总思路.md",key:"v-b28245d2",path:"/pages/e945bb/",headers:[{level:2,title:"维护集群的元数据的两种方案介绍及对比",slug:"维护集群的元数据的两种方案介绍及对比",normalizedTitle:"维护集群的元数据的两种方案介绍及对比",charIndex:2},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:329}],headersStr:"维护集群的元数据的两种方案介绍及对比 参考",content:"# 维护集群的元数据的两种方案介绍及对比\n\n在分布式存储中需要提供维护节点元数据信息的机制，所谓元数据是指：节点负责哪些数据，是否出现故障等状态信息。常见的元数据维护方式分为：集中式和P2P方式。\n\n 1. 集中式：\n    * 优点 ：元数据的更新和读取，时效性非常好，一旦元数据出现了变更，立即就更新到集中式的存储中。\n    * 缺点 ：所有的元数据的更新压力全部集中在一个地方，可能导致元数据的存储有压力。\n 2. gossip：\n    * 优点 ：元数据的更新比较分散，不是集中在同一个地方，更新请求会陆陆续续到达所有节点上去更新，有一定的延时，降低了压力。\n    * 缺点 ：元数据更新有延时，可能会导致集群的一些操作会有一些滞后。\n\n\n# 参考\n\nhttps://www.cnblogs.com/duanxz/p/15893958.html",normalizedContent:"# 维护集群的元数据的两种方案介绍及对比\n\n在分布式存储中需要提供维护节点元数据信息的机制，所谓元数据是指：节点负责哪些数据，是否出现故障等状态信息。常见的元数据维护方式分为：集中式和p2p方式。\n\n 1. 集中式：\n    * 优点 ：元数据的更新和读取，时效性非常好，一旦元数据出现了变更，立即就更新到集中式的存储中。\n    * 缺点 ：所有的元数据的更新压力全部集中在一个地方，可能导致元数据的存储有压力。\n 2. gossip：\n    * 优点 ：元数据的更新比较分散，不是集中在同一个地方，更新请求会陆陆续续到达所有节点上去更新，有一定的延时，降低了压力。\n    * 缺点 ：元数据更新有延时，可能会导致集群的一些操作会有一些滞后。\n\n\n# 参考\n\nhttps://www.cnblogs.com/duanxz/p/15893958.html",charsets:{cjk:!0}},{title:"QuickSort",frontmatter:{title:"QuickSort",date:"2023-03-31T22:59:14.000Z",permalink:"/pages/27d05d/"},regularPath:"/99.Code%20Snippet/01.QuickSort.html",relativePath:"99.Code Snippet/01.QuickSort.md",key:"v-153f7b50",path:"/pages/27d05d/",headersStr:null,content:"import java.util.Arrays;\nimport java.util.Random;\n\npublic class QuickSort {\n    public static void quickSort(int[] arr, int left, int right) {\n        if (left < right) {\n            int p = partition(arr, left, right);\n            quickSort(arr, 0, p - 1);\n            quickSort(arr, p + 1, right);\n        }\n    }\n\n    public static int partition(int[] arr, int left, int right) {\n        Random random = new Random();\n        int pivot = random.nextInt(right - left + 1) + left;\n        swap(arr, left, pivot);\n//        int pivot = left;\n        while (left < right) {\n            while (left < right && arr[right] >= arr[pivot]) right--;\n            while (left < right && arr[left] <= arr[pivot]) left++;\n            swap(arr, left, right);\n        }\n        swap(arr, pivot, left);\n        return left;\n    }\n\n    public static void swap(int[] arr, int i, int j) {\n        int temp = arr[i];\n        arr[i] = arr[j];\n        arr[j] = temp;\n    }\n\n    public static void main(String[] args) {\n        int[] arr = {1,3,5,2,6};\n        quickSort(arr, 0, arr.length - 1);\n        Arrays.stream(arr).forEach(System.out::println);\n    }\n}\n\n",normalizedContent:"import java.util.arrays;\nimport java.util.random;\n\npublic class quicksort {\n    public static void quicksort(int[] arr, int left, int right) {\n        if (left < right) {\n            int p = partition(arr, left, right);\n            quicksort(arr, 0, p - 1);\n            quicksort(arr, p + 1, right);\n        }\n    }\n\n    public static int partition(int[] arr, int left, int right) {\n        random random = new random();\n        int pivot = random.nextint(right - left + 1) + left;\n        swap(arr, left, pivot);\n//        int pivot = left;\n        while (left < right) {\n            while (left < right && arr[right] >= arr[pivot]) right--;\n            while (left < right && arr[left] <= arr[pivot]) left++;\n            swap(arr, left, right);\n        }\n        swap(arr, pivot, left);\n        return left;\n    }\n\n    public static void swap(int[] arr, int i, int j) {\n        int temp = arr[i];\n        arr[i] = arr[j];\n        arr[j] = temp;\n    }\n\n    public static void main(string[] args) {\n        int[] arr = {1,3,5,2,6};\n        quicksort(arr, 0, arr.length - 1);\n        arrays.stream(arr).foreach(system.out::println);\n    }\n}\n\n",charsets:{}},{title:"HeapSort",frontmatter:{title:"HeapSort",date:"2023-03-31T22:59:59.000Z",permalink:"/pages/dfcd0a/"},regularPath:"/99.Code%20Snippet/02.HeapSort.html",relativePath:"99.Code Snippet/02.HeapSort.md",key:"v-be922ec8",path:"/pages/dfcd0a/",headersStr:null,content:'import java.util.Arrays;\n\npublic class HeapSort {\n    public static void main(String[] args) {\n        int[] arr = {1,3,5,2,6,12};\n        heapSort(arr);\n        Arrays.stream(arr).forEach((x) -> System.out.print(x + ","));\n    }\n\n    public static void heapSort(int[] arr) {\n        int len = arr.length;\n        buildHeap(arr, len);\n        for (int i = len - 1; i >= 0; i--) {\n            swap(arr, i, 0);\n            heapify(arr, 0, --len);\n        }\n    }\n\n    public static void buildHeap(int[] arr, int len) {\n        for (int i = len / 2; i >= 0; i--) {\n            heapify(arr, i, len);\n        }\n    }\n\n    public static void heapify(int [] arr, int i, int len) {\n        int left = i * 2 + 1;\n        int right = i * 2 + 2;\n        int largest = i;\n        if (left < len && arr[left] > arr[largest]) largest = left;\n        if (right < len && arr[right] > arr[largest]) largest = right;\n        if (largest != i) {\n            swap(arr, i, largest);\n            heapify(arr, largest, len);\n        }\n    }\n\n    public static void swap(int[] arr, int i, int j) {\n        int t = arr[i];\n        arr[i] = arr[j];\n        arr[j] = t;\n    }\n}\n\n',normalizedContent:'import java.util.arrays;\n\npublic class heapsort {\n    public static void main(string[] args) {\n        int[] arr = {1,3,5,2,6,12};\n        heapsort(arr);\n        arrays.stream(arr).foreach((x) -> system.out.print(x + ","));\n    }\n\n    public static void heapsort(int[] arr) {\n        int len = arr.length;\n        buildheap(arr, len);\n        for (int i = len - 1; i >= 0; i--) {\n            swap(arr, i, 0);\n            heapify(arr, 0, --len);\n        }\n    }\n\n    public static void buildheap(int[] arr, int len) {\n        for (int i = len / 2; i >= 0; i--) {\n            heapify(arr, i, len);\n        }\n    }\n\n    public static void heapify(int [] arr, int i, int len) {\n        int left = i * 2 + 1;\n        int right = i * 2 + 2;\n        int largest = i;\n        if (left < len && arr[left] > arr[largest]) largest = left;\n        if (right < len && arr[right] > arr[largest]) largest = right;\n        if (largest != i) {\n            swap(arr, i, largest);\n            heapify(arr, largest, len);\n        }\n    }\n\n    public static void swap(int[] arr, int i, int j) {\n        int t = arr[i];\n        arr[i] = arr[j];\n        arr[j] = t;\n    }\n}\n\n',charsets:{}},{title:"Java实现生产者消费者模式",frontmatter:{title:"Java实现生产者消费者模式",date:"2023-03-31T23:00:48.000Z",permalink:"/pages/c708a0/"},regularPath:"/99.Code%20Snippet/03.Java%E5%AE%9E%E7%8E%B0%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%BC%8F.html",relativePath:"99.Code Snippet/03.Java实现生产者消费者模式.md",key:"v-af878584",path:"/pages/c708a0/",headers:[{level:2,title:"synchronized, wait, notify",slug:"synchronized-wait-notify",normalizedTitle:"synchronized, wait, notify",charIndex:2},{level:2,title:"ReentrantLock, Condiction->await signal",slug:"reentrantlock-condiction-await-signal",normalizedTitle:"reentrantlock, condiction-&gt;await signal",charIndex:null}],headersStr:"synchronized, wait, notify ReentrantLock, Condiction->await signal",content:'# synchronized, wait, notify\n\nimport java.util.LinkedList;\nimport java.util.Queue;\n\npublic class ProducerConsumer {\n    private Queue<Integer> buffer = new LinkedList<>(); // 共享缓冲区\n    private int capacity = 5; // 缓冲区容量\n\n    public void produce() throws InterruptedException {\n        int value = 0;\n        while (true) {\n            synchronized (this) { // 获取锁\n                while (buffer.size() == capacity) { // 缓冲区满，等待消费者消费\n                    wait();\n                }\n                buffer.add(value++);\n                System.out.println("Produced: " + value);\n                notify(); // 唤醒消费者\n                Thread.sleep(1000); // 生产者休眠1秒\n            }\n        }\n    }\n\n    public void consume() throws InterruptedException {\n        while (true) {\n            synchronized (this) { // 获取锁\n                while (buffer.isEmpty()) { // 缓冲区空，等待生产者生产\n                    wait();\n                }\n                int value = buffer.poll();\n                System.out.println("Consumed: " + value);\n                notify(); // 唤醒生产者\n                Thread.sleep(1000); // 消费者休眠1秒\n            }\n        }\n    }\n}\n\n\n\npublic class Main {\n    public static void main(String[] args) {\n        ProducerConsumer pc = new ProducerConsumer();\n        new Thread(() -> {\n            try {\n                pc.produce();\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }).start();\n        new Thread(() -> {\n            try {\n                pc.consume();\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }).start();\n    }\n}\n\n\n\n\n# ReentrantLock, Condiction->await signal\n\nimport java.util.LinkedList;\nimport java.util.Queue;\nimport java.util.concurrent.locks.Condition;\nimport java.util.concurrent.locks.ReentrantLock;\n\npublic class ProducerConsumer2 {\n    private Queue<Integer> buffer = new LinkedList<>();\n    private int capacity = 5;\n    private ReentrantLock lock = new ReentrantLock();\n    private Condition notFull = lock.newCondition();\n    private Condition notEmpty = lock.newCondition();\n\n    public void produce() throws InterruptedException {\n        int value = 0;\n        try {\n            while (true) {\n                lock.lock();\n                while (buffer.size() == capacity) {\n                    notFull.await();\n                }\n                buffer.add(value++);\n                System.out.println("Produced:" + value);\n                notEmpty.signal();\n                Thread.sleep(1000);\n            }\n        } finally {\n            lock.unlock();\n        }\n    }\n\n    public void consume() throws InterruptedException {\n        try {\n            while (true) {\n                lock.lock();\n                while (buffer.isEmpty()) {\n                    notEmpty.await();\n                }\n                int value = buffer.poll();\n                System.out.println("Consumed:" + value);\n                notFull.signal();\n                Thread.sleep(1000);\n            }\n        } finally {\n            lock.unlock();\n        }\n    }\n\n}\n',normalizedContent:'# synchronized, wait, notify\n\nimport java.util.linkedlist;\nimport java.util.queue;\n\npublic class producerconsumer {\n    private queue<integer> buffer = new linkedlist<>(); // 共享缓冲区\n    private int capacity = 5; // 缓冲区容量\n\n    public void produce() throws interruptedexception {\n        int value = 0;\n        while (true) {\n            synchronized (this) { // 获取锁\n                while (buffer.size() == capacity) { // 缓冲区满，等待消费者消费\n                    wait();\n                }\n                buffer.add(value++);\n                system.out.println("produced: " + value);\n                notify(); // 唤醒消费者\n                thread.sleep(1000); // 生产者休眠1秒\n            }\n        }\n    }\n\n    public void consume() throws interruptedexception {\n        while (true) {\n            synchronized (this) { // 获取锁\n                while (buffer.isempty()) { // 缓冲区空，等待生产者生产\n                    wait();\n                }\n                int value = buffer.poll();\n                system.out.println("consumed: " + value);\n                notify(); // 唤醒生产者\n                thread.sleep(1000); // 消费者休眠1秒\n            }\n        }\n    }\n}\n\n\n\npublic class main {\n    public static void main(string[] args) {\n        producerconsumer pc = new producerconsumer();\n        new thread(() -> {\n            try {\n                pc.produce();\n            } catch (interruptedexception e) {\n                e.printstacktrace();\n            }\n        }).start();\n        new thread(() -> {\n            try {\n                pc.consume();\n            } catch (interruptedexception e) {\n                e.printstacktrace();\n            }\n        }).start();\n    }\n}\n\n\n\n\n# reentrantlock, condiction->await signal\n\nimport java.util.linkedlist;\nimport java.util.queue;\nimport java.util.concurrent.locks.condition;\nimport java.util.concurrent.locks.reentrantlock;\n\npublic class producerconsumer2 {\n    private queue<integer> buffer = new linkedlist<>();\n    private int capacity = 5;\n    private reentrantlock lock = new reentrantlock();\n    private condition notfull = lock.newcondition();\n    private condition notempty = lock.newcondition();\n\n    public void produce() throws interruptedexception {\n        int value = 0;\n        try {\n            while (true) {\n                lock.lock();\n                while (buffer.size() == capacity) {\n                    notfull.await();\n                }\n                buffer.add(value++);\n                system.out.println("produced:" + value);\n                notempty.signal();\n                thread.sleep(1000);\n            }\n        } finally {\n            lock.unlock();\n        }\n    }\n\n    public void consume() throws interruptedexception {\n        try {\n            while (true) {\n                lock.lock();\n                while (buffer.isempty()) {\n                    notempty.await();\n                }\n                int value = buffer.poll();\n                system.out.println("consumed:" + value);\n                notfull.signal();\n                thread.sleep(1000);\n            }\n        } finally {\n            lock.unlock();\n        }\n    }\n\n}\n',charsets:{cjk:!0}},{title:"chatgpt promt engineering for develpers",frontmatter:{title:"chatgpt promt engineering for develpers",date:"2023-05-05T20:29:26.000Z",permalink:"/pages/3c8ef8/",article:!1},regularPath:"/temp/chatgpt%20promt%20engineering%20for%20develpers.html",relativePath:"temp/chatgpt promt engineering for develpers.md",key:"v-2ffbbf7d",path:"/pages/3c8ef8/",headers:[{level:2,title:"Prompting Principles",slug:"prompting-principles",normalizedTitle:"prompting principles",charIndex:138},{level:3,title:"Principle 1: Write clear and specific instructions",slug:"principle-1-write-clear-and-specific-instructions",normalizedTitle:"principle 1: write clear and specific instructions",charIndex:163},{level:3,title:"Principle 2: Give the model time to “think”",slug:"principle-2-give-the-model-time-to-think",normalizedTitle:"principle 2: give the model time to “think”",charIndex:217},{level:2,title:"Iterative",slug:"iterative",normalizedTitle:"iterative",charIndex:1200},{level:2,title:"Summarizing",slug:"summarizing",normalizedTitle:"summarizing",charIndex:1214},{level:2,title:"Inferring",slug:"inferring",normalizedTitle:"inferring",charIndex:1230},{level:2,title:"Transforming",slug:"transforming",normalizedTitle:"transforming",charIndex:1244},{level:2,title:"Expanding",slug:"expanding",normalizedTitle:"expanding",charIndex:1261},{level:2,title:"Chatbot",slug:"chatbot",normalizedTitle:"chatbot",charIndex:1275},{level:2,title:"Conclusion",slug:"conclusion",normalizedTitle:"conclusion",charIndex:1287}],headersStr:"Prompting Principles Principle 1: Write clear and specific instructions Principle 2: Give the model time to “think” Iterative Summarizing Inferring Transforming Expanding Chatbot Conclusion",content:'two types of large language models (LLMs)\n\n * Base LLM\n * Instruction Tuned LLM\n   * RLHF: Reinforcement Learning with Human Feedback\n\n\n# Prompting Principles\n\n * Principle 1: Write clear and specific instructions\n * Principle 2: Give the model time to “think”\n\n\n# Principle 1: Write clear and specific instructions\n\n * Tactic 1: Use delimiters to clearly indicate distinct parts of the input\n   \n   * Delimiters can be anything like: ```, """, < >, <tag></tag>, :\n\n * Tactic 2: Ask for a structured output\n   \n   * JSON or Html\n\n * Tactic 3: Ask the model to check whether conditions are satisfied\n\ntext = f""" \nxxx\n"""\n\nprompt = f"""\nYou will be provided with text delimited by triple quotes. \nIf it contains a sequence of instructions, \\ \nre-write those instructions in the following format:\n\nStep 1 - ...\nStep 2 - …\n…\nStep N - …\n\nIf the text does not contain a sequence of instructions, \\ \nthen simply write \\"No steps provided.\\"\n\n\\"\\"\\"{text}\\"\\"\\"\n"""\n\n\n * Tactic 4: "Few-shot" prompting\n\n\n# Principle 2: Give the model time to “think”\n\n * Tactic 1: Specify the steps required to complete a task\n\n * Tactic 2: Instruct the model to work out its own solution before rushing to a conclusion\n\n\n# Iterative\n\n\n# Summarizing\n\n\n# Inferring\n\n\n# Transforming\n\n\n# Expanding\n\n\n# Chatbot\n\n\n# Conclusion',normalizedContent:'two types of large language models (llms)\n\n * base llm\n * instruction tuned llm\n   * rlhf: reinforcement learning with human feedback\n\n\n# prompting principles\n\n * principle 1: write clear and specific instructions\n * principle 2: give the model time to “think”\n\n\n# principle 1: write clear and specific instructions\n\n * tactic 1: use delimiters to clearly indicate distinct parts of the input\n   \n   * delimiters can be anything like: ```, """, < >, <tag></tag>, :\n\n * tactic 2: ask for a structured output\n   \n   * json or html\n\n * tactic 3: ask the model to check whether conditions are satisfied\n\ntext = f""" \nxxx\n"""\n\nprompt = f"""\nyou will be provided with text delimited by triple quotes. \nif it contains a sequence of instructions, \\ \nre-write those instructions in the following format:\n\nstep 1 - ...\nstep 2 - …\n…\nstep n - …\n\nif the text does not contain a sequence of instructions, \\ \nthen simply write \\"no steps provided.\\"\n\n\\"\\"\\"{text}\\"\\"\\"\n"""\n\n\n * tactic 4: "few-shot" prompting\n\n\n# principle 2: give the model time to “think”\n\n * tactic 1: specify the steps required to complete a task\n\n * tactic 2: instruct the model to work out its own solution before rushing to a conclusion\n\n\n# iterative\n\n\n# summarizing\n\n\n# inferring\n\n\n# transforming\n\n\n# expanding\n\n\n# chatbot\n\n\n# conclusion',charsets:{}},{title:"Untitled",frontmatter:{title:"Untitled",date:"2023-04-19T14:34:15.000Z",permalink:"/pages/a3d6e4/",article:!1},regularPath:"/temp/gradle%E5%92%8Cmaven%E5%AF%B9%E7%85%A7.html",relativePath:"temp/gradle和maven对照.md",key:"v-6d33b879",path:"/pages/a3d6e4/",headers:[{level:2,title:"gradle",slug:"gradle",normalizedTitle:"gradle",charIndex:101},{level:3,title:"Gradle Wrapper",slug:"gradle-wrapper",normalizedTitle:"gradle wrapper",charIndex:2649}],headersStr:"gradle Gradle Wrapper",content:"功能           GRADLE                                                         MAVEN\n配置文件         build.gradle                                                   pom.xml\n添加依赖         implementation 'groupId:artifactId:version'                    <dependency><groupId>groupId</groupId><artifactId>artifactId</artifactId><version>version</version></dependency>\n执行构建         ./gradlew build                                                mvn clean package\n运行应用程序       ./gradlew bootRun                                              mvn spring-boot:run\n发布到Maven仓库   ./gradlew publishToMavenLocal                                  mvn deploy\n插件管理         plugins { id 'java' }                                          <build><plugins><plugin><groupId>groupId</groupId><artifactId>artifactId</artifactId><version>version</version></plugin></plugins></build>\n多项目构建        include 'module1', 'module2'                                   <modules><module>module1</module><module>module2</module></modules>\n自定义构建任务      task myTask { ... }                                            <build><plugins><plugin><executions><execution><phase>phase</phase><goals><goal>goal</goal></goals></execution></executions></plugin></plugins></build>\n依赖管理         dependencies { implementation 'groupId:artifactId:version' }   <dependencies><dependency><groupId>groupId</groupId><artifactId>artifactId</artifactId><version>version</version></dependency></dependencies>\n配置环境变量       systemProperty 'propertyName', 'propertyValue'                 <build><plugins><plugin><configuration><systemProperties><propertyName>propertyValue</propertyName></systemProperties></configuration></plugin></plugins></build>\n\n\n# gradle\n\nGradle 是一种构建工具，可以用于构建、编译、测试和部署 Java 项目。在 Java 中使用 Gradle 可以简化项目的构建流程，并提高构建的效率和可维护性。\n\n下面是 Gradle 在 Java 中的使用方法：\n\n 1. 安装 Gradle\n\n首先需要安装 Gradle，可以在 Gradle 官网下载最新版本的 Gradle，或者使用包管理工具（如 Homebrew）进行安装。\n\n 2. 初始化 Gradle 项目\n\n要使用 Gradle 构建 Java 项目，需要先在项目中添加 Gradle 的配置文件 build.gradle。可以使用以下命令初始化一个空的 Gradle 项目：\n\ngradle init --type java-library\n\n\n该命令会创建一个新的 Java 项目，并在项目中生成一个基本的 build.gradle 文件。\n\n 3. 配置 Gradle 项目\n\n在 build.gradle 文件中配置项目的构建过程，例如添加依赖、定义任务等。以下是一个简单的 build.gradle 配置文件的示例：\n\nplugins {\n    id 'java'\n}\n\ngroup 'com.example'\nversion '1.0-SNAPSHOT'\n\nrepositories {\n    mavenCentral()\n}\n\ndependencies {\n    implementation 'com.google.guava:guava:30.1-jre'\n    testImplementation 'junit:junit:4.13.2'\n}\n\ntest {\n    useJUnitPlatform()\n}\n\n\n 4. 运行 Gradle 任务\n\n使用 Gradle 运行构建任务可以使用以下命令：\n\ngradle build\n\n\n该命令会执行项目中定义的所有任务，例如编译 Java 代码、运行单元测试、生成 JAR 文件等。\n\n 5. 打包成 JAR 文件\n\n使用 Gradle 打包 Java 项目可以使用以下命令：\n\ngradle jar\n\n\n该命令会将编译好的 Java 代码打包成一个 JAR 文件，可以通过该文件发布和部署 Java 应用程序。\n\n\n# Gradle Wrapper\n\nGradle Wrapper 是 Gradle 构建工具中的一个功能，可以用于自动下载和安装 Gradle 并运行构建任务。Gradle Wrapper 是一个命令行脚本，可以在不需要手动安装 Gradle 的情况下运行 Gradle 构建任务。可以保证项目中使用的 Gradle 版本与项目开发者使用的 Gradle 版本一致。\n\n通常情况下，在使用 Gradle 构建项目时需要手动安装 Gradle，并在命令行中使用 gradle 命令来执行构建任务。使用 Gradle Wrapper 可以省去手动安装 Gradle 的步骤，并且保证项目中使用的 Gradle 版本与项目开发者使用的 Gradle 版本一致。\n\nGradle Wrapper 的工作原理是在项目中添加一些文件（如 gradlew 和 gradlew.bat），这些文件包含了 Gradle Wrapper 的相关信息和 Gradle 的下载链接。当开发者在项目中执行构建任务时，Gradle Wrapper 会自动检查本地是否已经安装了指定版本的 Gradle，如果没有安装，则会自动下载并安装该版本的 Gradle，然后使用下载的 Gradle 执行构建任务。\n\nGradle Wrapper 的使用方法很简单，只需要在项目中执行以下命令：\n\ngradle wrapper\n\n\n该命令会在项目中生成 Gradle Wrapper 相关的文件，并自动下载并安装指定版本的 Gradle。\n\n然后可以使用以下命令来执行 Gradle 构建任务：\n\n./gradlew <task>\n\n\n其中 <task> 是需要执行的构建任务，例如 build、test",normalizedContent:"功能           gradle                                                         maven\n配置文件         build.gradle                                                   pom.xml\n添加依赖         implementation 'groupid:artifactid:version'                    <dependency><groupid>groupid</groupid><artifactid>artifactid</artifactid><version>version</version></dependency>\n执行构建         ./gradlew build                                                mvn clean package\n运行应用程序       ./gradlew bootrun                                              mvn spring-boot:run\n发布到maven仓库   ./gradlew publishtomavenlocal                                  mvn deploy\n插件管理         plugins { id 'java' }                                          <build><plugins><plugin><groupid>groupid</groupid><artifactid>artifactid</artifactid><version>version</version></plugin></plugins></build>\n多项目构建        include 'module1', 'module2'                                   <modules><module>module1</module><module>module2</module></modules>\n自定义构建任务      task mytask { ... }                                            <build><plugins><plugin><executions><execution><phase>phase</phase><goals><goal>goal</goal></goals></execution></executions></plugin></plugins></build>\n依赖管理         dependencies { implementation 'groupid:artifactid:version' }   <dependencies><dependency><groupid>groupid</groupid><artifactid>artifactid</artifactid><version>version</version></dependency></dependencies>\n配置环境变量       systemproperty 'propertyname', 'propertyvalue'                 <build><plugins><plugin><configuration><systemproperties><propertyname>propertyvalue</propertyname></systemproperties></configuration></plugin></plugins></build>\n\n\n# gradle\n\ngradle 是一种构建工具，可以用于构建、编译、测试和部署 java 项目。在 java 中使用 gradle 可以简化项目的构建流程，并提高构建的效率和可维护性。\n\n下面是 gradle 在 java 中的使用方法：\n\n 1. 安装 gradle\n\n首先需要安装 gradle，可以在 gradle 官网下载最新版本的 gradle，或者使用包管理工具（如 homebrew）进行安装。\n\n 2. 初始化 gradle 项目\n\n要使用 gradle 构建 java 项目，需要先在项目中添加 gradle 的配置文件 build.gradle。可以使用以下命令初始化一个空的 gradle 项目：\n\ngradle init --type java-library\n\n\n该命令会创建一个新的 java 项目，并在项目中生成一个基本的 build.gradle 文件。\n\n 3. 配置 gradle 项目\n\n在 build.gradle 文件中配置项目的构建过程，例如添加依赖、定义任务等。以下是一个简单的 build.gradle 配置文件的示例：\n\nplugins {\n    id 'java'\n}\n\ngroup 'com.example'\nversion '1.0-snapshot'\n\nrepositories {\n    mavencentral()\n}\n\ndependencies {\n    implementation 'com.google.guava:guava:30.1-jre'\n    testimplementation 'junit:junit:4.13.2'\n}\n\ntest {\n    usejunitplatform()\n}\n\n\n 4. 运行 gradle 任务\n\n使用 gradle 运行构建任务可以使用以下命令：\n\ngradle build\n\n\n该命令会执行项目中定义的所有任务，例如编译 java 代码、运行单元测试、生成 jar 文件等。\n\n 5. 打包成 jar 文件\n\n使用 gradle 打包 java 项目可以使用以下命令：\n\ngradle jar\n\n\n该命令会将编译好的 java 代码打包成一个 jar 文件，可以通过该文件发布和部署 java 应用程序。\n\n\n# gradle wrapper\n\ngradle wrapper 是 gradle 构建工具中的一个功能，可以用于自动下载和安装 gradle 并运行构建任务。gradle wrapper 是一个命令行脚本，可以在不需要手动安装 gradle 的情况下运行 gradle 构建任务。可以保证项目中使用的 gradle 版本与项目开发者使用的 gradle 版本一致。\n\n通常情况下，在使用 gradle 构建项目时需要手动安装 gradle，并在命令行中使用 gradle 命令来执行构建任务。使用 gradle wrapper 可以省去手动安装 gradle 的步骤，并且保证项目中使用的 gradle 版本与项目开发者使用的 gradle 版本一致。\n\ngradle wrapper 的工作原理是在项目中添加一些文件（如 gradlew 和 gradlew.bat），这些文件包含了 gradle wrapper 的相关信息和 gradle 的下载链接。当开发者在项目中执行构建任务时，gradle wrapper 会自动检查本地是否已经安装了指定版本的 gradle，如果没有安装，则会自动下载并安装该版本的 gradle，然后使用下载的 gradle 执行构建任务。\n\ngradle wrapper 的使用方法很简单，只需要在项目中执行以下命令：\n\ngradle wrapper\n\n\n该命令会在项目中生成 gradle wrapper 相关的文件，并自动下载并安装指定版本的 gradle。\n\n然后可以使用以下命令来执行 gradle 构建任务：\n\n./gradlew <task>\n\n\n其中 <task> 是需要执行的构建任务，例如 build、test",charsets:{cjk:!0}},{title:"Untitled",frontmatter:{title:"Untitled",date:"2023-04-16T15:21:47.000Z",permalink:"/pages/08f55c/",article:!1},regularPath:"/temp/jdk%E6%96%B0%E7%89%B9%E6%80%A7.html",relativePath:"temp/jdk新特性.md",key:"v-365b0049",path:"/pages/08f55c/",headers:[{level:2,title:"jdk 9 新特性",slug:"jdk-9-新特性",normalizedTitle:"jdk 9 新特性",charIndex:2},{level:3,title:"模块化开发",slug:"模块化开发",normalizedTitle:"模块化开发",charIndex:16},{level:2,title:"jdk 10 新特性",slug:"jdk-10-新特性",normalizedTitle:"jdk 10 新特性",charIndex:225},{level:3,title:"var 局部变量推导",slug:"var-局部变量推导",normalizedTitle:"var 局部变量推导",charIndex:240},{level:2,title:"jdk 11 性特性",slug:"jdk-11-性特性",normalizedTitle:"jdk 11 性特性",charIndex:289},{level:3,title:"单文件程序",slug:"单文件程序",normalizedTitle:"单文件程序",charIndex:304},{level:3,title:"支持shebang脚本",slug:"支持shebang脚本",normalizedTitle:"支持shebang脚本",charIndex:369},{level:2,title:"jdk14新特性",slug:"jdk14新特性",normalizedTitle:"jdk14新特性",charIndex:466},{level:3,title:"文本块",slug:"文本块",normalizedTitle:"文本块",charIndex:479},{level:3,title:"instanceof 增强",slug:"instanceof-增强",normalizedTitle:"instanceof 增强",charIndex:510},{level:2,title:"jdk16 新特性",slug:"jdk16-新特性",normalizedTitle:"jdk16 新特性",charIndex:700},{level:3,title:"record类",slug:"record类",normalizedTitle:"record类",charIndex:714},{level:2,title:"jdk17 新特性",slug:"jdk17-新特性",normalizedTitle:"jdk17 新特性",charIndex:797},{level:3,title:"sealed类",slug:"sealed类",normalizedTitle:"sealed类",charIndex:811},{level:3,title:"switch 增强",slug:"switch-增强",normalizedTitle:"switch 增强",charIndex:1087}],headersStr:"jdk 9 新特性 模块化开发 jdk 10 新特性 var 局部变量推导 jdk 11 性特性 单文件程序 支持shebang脚本 jdk14新特性 文本块 instanceof 增强 jdk16 新特性 record类 jdk17 新特性 sealed类 switch 增强",content:'# jdk 9 新特性\n\n\n# 模块化开发\n\n * 使用 module-info.java 来声明一个模块，名字是固定的，在顶层包的同目录下。\n\n * 使用 exports 声明可以被外部引用的包，可以有多个 exports 语句。\n\n * 使用 requires 声明依赖的外部模块，可以有多个 requires 语句。\n\n优点：\n\n * 更好的代码隔离性和安全性\n * 更简单的依赖管理\n * 更好的性能\n * 更好的可重用性和可扩展性\n\n\n# jdk 10 新特性\n\n\n# var 局部变量推导\n\n要求：\n\n 1. 必须能推导出实际类型\n 2. 只能用于局部变量\n\n\n# jdk 11 性特性\n\n\n# 单文件程序\n\n可以直接在命令行使用 java Test.java 运行单文件。而不用javac去编译.class再运行。\n\n\n# 支持shebang脚本\n\n#!符号叫做shebang。是linux的命令。\n\n#!/bin/bash 表示以此开头的文件，在执行时会调用/bin/bash程序来执行\n\n#!+jdk位置\n\n\n# jdk14新特性\n\n\n# 文本块\n\n方便写多行字符串\n\n用法：使用三个双引号。\n\n\n# instanceof 增强\n\n//jdk8\nObject a = "hello";\nif (a instanceof String) {\n  String b = (String)a;\n  System.out.println(b);\n}\n\n//jdk14\nif (a instanceof String b) {\n  System.out.println(b);\n}\n\n\n\n# jdk16 新特性\n\n\n# record类\n\n跟 class、interface同级\n\n只能初始化一次，不能再修改。\n\npublic record Test(String a) {}\n\n\n\n# jdk17 新特性\n\n\n# sealed类\n\nsealed 是个关键字。\n\npublic sealed class Test1 permits Test2,Test3 {}\n\npublic non-sealed class Test2 extends Test1 {}\n\npublic final class Test3 extends sealed {}\n\n\n痛点：类的继承难被管理，使用 sealed显示管理\n\n规则：\n\n * 父类如果是sealed类，则必须至少有一个子类。\n * sealed类的子类，必须是final，sealed，non-sealed 之一。\n\n\n# switch 增强\n\nObject a = "hello";\nswitch (a) {\n    case String b -> System.out.println(b);\n    case Integer b -> System.out.println(b);\n    default -> System.out.println("default");\n}\n',normalizedContent:'# jdk 9 新特性\n\n\n# 模块化开发\n\n * 使用 module-info.java 来声明一个模块，名字是固定的，在顶层包的同目录下。\n\n * 使用 exports 声明可以被外部引用的包，可以有多个 exports 语句。\n\n * 使用 requires 声明依赖的外部模块，可以有多个 requires 语句。\n\n优点：\n\n * 更好的代码隔离性和安全性\n * 更简单的依赖管理\n * 更好的性能\n * 更好的可重用性和可扩展性\n\n\n# jdk 10 新特性\n\n\n# var 局部变量推导\n\n要求：\n\n 1. 必须能推导出实际类型\n 2. 只能用于局部变量\n\n\n# jdk 11 性特性\n\n\n# 单文件程序\n\n可以直接在命令行使用 java test.java 运行单文件。而不用javac去编译.class再运行。\n\n\n# 支持shebang脚本\n\n#!符号叫做shebang。是linux的命令。\n\n#!/bin/bash 表示以此开头的文件，在执行时会调用/bin/bash程序来执行\n\n#!+jdk位置\n\n\n# jdk14新特性\n\n\n# 文本块\n\n方便写多行字符串\n\n用法：使用三个双引号。\n\n\n# instanceof 增强\n\n//jdk8\nobject a = "hello";\nif (a instanceof string) {\n  string b = (string)a;\n  system.out.println(b);\n}\n\n//jdk14\nif (a instanceof string b) {\n  system.out.println(b);\n}\n\n\n\n# jdk16 新特性\n\n\n# record类\n\n跟 class、interface同级\n\n只能初始化一次，不能再修改。\n\npublic record test(string a) {}\n\n\n\n# jdk17 新特性\n\n\n# sealed类\n\nsealed 是个关键字。\n\npublic sealed class test1 permits test2,test3 {}\n\npublic non-sealed class test2 extends test1 {}\n\npublic final class test3 extends sealed {}\n\n\n痛点：类的继承难被管理，使用 sealed显示管理\n\n规则：\n\n * 父类如果是sealed类，则必须至少有一个子类。\n * sealed类的子类，必须是final，sealed，non-sealed 之一。\n\n\n# switch 增强\n\nobject a = "hello";\nswitch (a) {\n    case string b -> system.out.println(b);\n    case integer b -> system.out.println(b);\n    default -> system.out.println("default");\n}\n',charsets:{cjk:!0}},{title:"juc-all",frontmatter:{title:"juc-all",date:"2023-05-13T20:03:24.000Z",permalink:"/pages/7a6f3c/",article:!1},regularPath:"/temp/juc-all.html",relativePath:"temp/juc-all.md",key:"v-7ba276fa",path:"/pages/7a6f3c/",headers:[{level:2,title:"Base",slug:"base",normalizedTitle:"base",charIndex:2},{level:2,title:"Locks",slug:"locks",normalizedTitle:"locks",charIndex:290},{level:3,title:"ReentrantLock",slug:"reentrantlock",normalizedTitle:"reentrantlock",charIndex:300},{level:3,title:"ReentrantReadWriteLock",slug:"reentrantreadwritelock",normalizedTitle:"reentrantreadwritelock",charIndex:1053},{level:3,title:"StampedLock",slug:"stampedlock",normalizedTitle:"stampedlock",charIndex:2573},{level:3,title:"LockSupport",slug:"locksupport",normalizedTitle:"locksupport",charIndex:3962},{level:4,title:"Thread.sleep()和Object.wait()的区别",slug:"thread-sleep-和object-wait-的区别",normalizedTitle:"thread.sleep()和object.wait()的区别",charIndex:5255},{level:4,title:"Object.wait()和Condition.await()的区别",slug:"object-wait-和condition-await-的区别",normalizedTitle:"object.wait()和condition.await()的区别",charIndex:5701},{level:4,title:"Thread.sleep()和LockSupport.park()的区别",slug:"thread-sleep-和locksupport-park-的区别",normalizedTitle:"thread.sleep()和locksupport.park()的区别",charIndex:5934},{level:4,title:"Object.wait()和LockSupport.park()的区别",slug:"object-wait-和locksupport-park-的区别",normalizedTitle:"object.wait()和locksupport.park()的区别",charIndex:6403},{level:4,title:"如果在wait()之前执行了notify()会怎样?",slug:"如果在wait-之前执行了notify-会怎样",normalizedTitle:"如果在wait()之前执行了notify()会怎样?",charIndex:4250},{level:4,title:"如果在park()之前执行了unpark()会怎样?",slug:"如果在park-之前执行了unpark-会怎样",normalizedTitle:"如果在park()之前执行了unpark()会怎样?",charIndex:4280},{level:4,title:"LockSupport.park()会释放锁资源吗?",slug:"locksupport-park-会释放锁资源吗",normalizedTitle:"locksupport.park()会释放锁资源吗?",charIndex:4122},{level:2,title:"Tools",slug:"tools",normalizedTitle:"tools",charIndex:7131},{level:3,title:"CountDownLatch",slug:"countdownlatch",normalizedTitle:"countdownlatch",charIndex:7141},{level:3,title:"CyclicBarrier",slug:"cyclicbarrier",normalizedTitle:"cyclicbarrier",charIndex:8596},{level:3,title:"Phaser",slug:"phaser",normalizedTitle:"phaser",charIndex:10227},{level:3,title:"Semaphore",slug:"semaphore",normalizedTitle:"semaphore",charIndex:6774},{level:3,title:"Exchanger",slug:"exchanger",normalizedTitle:"exchanger",charIndex:11058},{level:2,title:"Collections",slug:"collections",normalizedTitle:"collections",charIndex:11072},{level:3,title:"Queue",slug:"queue",normalizedTitle:"queue",charIndex:768},{level:3,title:"List",slug:"list",normalizedTitle:"list",charIndex:11098},{level:3,title:"Set",slug:"set",normalizedTitle:"set",charIndex:11107},{level:3,title:"Map",slug:"map",normalizedTitle:"map",charIndex:11115},{level:2,title:"Atomic",slug:"atomic",normalizedTitle:"atomic",charIndex:11123},{level:3,title:"基础类型",slug:"基础类型",normalizedTitle:"基础类型",charIndex:11134},{level:3,title:"数组",slug:"数组",normalizedTitle:"数组",charIndex:11143},{level:3,title:"引用",slug:"引用",normalizedTitle:"引用",charIndex:11150},{level:2,title:"Executor",slug:"executor",normalizedTitle:"executor",charIndex:11157},{level:3,title:"接口：Executor",slug:"接口-executor",normalizedTitle:"接口：executor",charIndex:11170},{level:3,title:"ExecutorService",slug:"executorservice",normalizedTitle:"executorservice",charIndex:11186},{level:3,title:"ScheduledExecutorService",slug:"scheduledexecutorservice",normalizedTitle:"scheduledexecutorservice",charIndex:11206},{level:3,title:"AbstractExecutorService",slug:"abstractexecutorservice",normalizedTitle:"abstractexecutorservice",charIndex:11235},{level:3,title:"FutureTask",slug:"futuretask",normalizedTitle:"futuretask",charIndex:11263},{level:3,title:"ThreadPoolExecutor",slug:"threadpoolexecutor",normalizedTitle:"threadpoolexecutor",charIndex:11278},{level:3,title:"ScheduledThreadPoolExecutor",slug:"scheduledthreadpoolexecutor",normalizedTitle:"scheduledthreadpoolexecutor",charIndex:11301},{level:3,title:"Fork/Join Framework",slug:"fork-join-framework",normalizedTitle:"fork/join framework",charIndex:11333},{level:3,title:"Executors",slug:"executors",normalizedTitle:"executors",charIndex:11357},{level:2,title:"Reference",slug:"reference",normalizedTitle:"reference",charIndex:11371}],headersStr:"Base Locks ReentrantLock ReentrantReadWriteLock StampedLock LockSupport Thread.sleep()和Object.wait()的区别 Object.wait()和Condition.await()的区别 Thread.sleep()和LockSupport.park()的区别 Object.wait()和LockSupport.park()的区别 如果在wait()之前执行了notify()会怎样? 如果在park()之前执行了unpark()会怎样? LockSupport.park()会释放锁资源吗? Tools CountDownLatch CyclicBarrier Phaser Semaphore Exchanger Collections Queue List Set Map Atomic 基础类型 数组 引用 Executor 接口：Executor ExecutorService ScheduledExecutorService AbstractExecutorService FutureTask ThreadPoolExecutor ScheduledThreadPoolExecutor Fork/Join Framework Executors Reference",content:"# Base\n\n\n\n接口：Condition\n\nCondition为接口类型，它将 Object 监视器方法(wait、notify 和 notifyAll)分解成截然不同的对象，以便通过将这些对象与任意 Lock 实现组合使用，为每个对象提供多个等待 set (wait-set)。其中，Lock 替代了 synchronized 方法和语句的使用，Condition 替代了 Object 监视器方法的使用。可以通过await(),signal()来休眠/唤醒线程。\n\nCondition 的实现类是 AQS 和AQLS 的内部类 ConditionObject 。\n\n\n# Locks\n\n\n# ReentrantLock\n\nQuestion：\n\n * 什么是可重入，什么是可重入锁? 它用来解决什么问题?\n * ReentrantLock的核心是AQS，那么它怎么来实现的，继承吗? 说说其类内部结构关系。\n * ReentrantLock是如何实现公平锁的?\n * ReentrantLock是如何实现非公平锁的?\n * ReentrantLock默认实现的是公平还是非公平锁?\n * 使用ReentrantLock实现公平和非公平锁的示例?\n * ReentrantLock和Synchronized的对比?\n\nReentrantLock为常用类，它是一个可重入的互斥锁 Lock，它具有与使用 synchronized 方法和语句所访问的隐式监视器锁相同的一些基本行为和语义，但功能更强大。\n\nReentrantLock 中的内部类：ReentrantLock类内部总共存在Sync、NonfairSync、FairSync三个类，NonfairSync与FairSync类继承自Sync类，Sync类继承自AbstractQueuedSynchronizer抽象类。\n\n调用链：\n\n公平锁的调用成功的情况：lock:lock -> FairSync:lock ->AQS:acquire -> FairSync:tryAcquire -> AQS:hasQueuedPredecessors -> AQS:setExclusiveOwnerThread\n\nFairSync:lock 当资源被占用的情况：FairSync:lock -> AQS:acquire -> FairSync:tryAcquire -> AQS:addWaiter -> AQS:acquireQueued\n\n\n# ReentrantReadWriteLock\n\nQuestion：\n\n * 为了有了ReentrantLock还需要ReentrantReadWriteLock?\n * ReentrantReadWriteLock底层实现原理?\n * ReentrantReadWriteLock底层读写状态如何设计的? 高16位为读锁，低16位为写锁\n * 读锁和写锁的最大数量是多少?\n * 本地线程计数器ThreadLocalHoldCounter是用来做什么的?\n * 缓存计数器HoldCounter是用来做什么的?\n * 写锁的获取与释放是怎么实现的?\n * 读锁的获取与释放是怎么实现的?\n * 什么是锁的升降级? RentrantReadWriteLock为什么不支持锁升级?\n\nReentrantReadWriteLock是读写锁接口ReadWriteLock的实现类，它包括Lock子类ReadLock和WriteLock。ReadLock是共享锁，WriteLock是独占锁。\n\nReentrantReadWriteLock 允许多个线程同时持有读锁，但只允许一个线程持有写锁。\n\n * 读锁：当一个线程获取到读锁时，其他线程也可以获取读锁，但不能获取写锁。当最后一个持有读锁的线程释放读锁时，其他等待的写线程才有机会获取写锁。\n\n * 写锁：当一个线程获取到写锁时，其他线程无法获取读锁或写锁，直到写锁被释放。\n\n\n\n内部类：ReentrantReadWriteLock有五个内部类，Sync继承自AQS、NonfairSync继承自Sync类、FairSync继承自Sync类；ReadLock实现了Lock接口、WriteLock也实现了Lock接口。\n\nSync类内部存在两个内部类，分别为HoldCounter和ThreadLocalHoldCounter，其中HoldCounter主要与读锁配套使用。\n\nThreadLocalHoldCounter重写了ThreadLocal的initialValue方法，ThreadLocal类可以将线程与对象相关联。在没有进行set的情况下，get到的均是initialValue方法里面生成的那个HolderCounter对象。\n\n什么是锁升降级?\n\n锁降级指的是写锁降级成为读锁。如果当前线程拥有写锁，然后将其释放，最后再获取读锁，这种分段完成的过程不能称之为锁降级。锁降级是指把持住(当前拥有的)写锁，再获取到读锁，随后释放(先前拥有的)写锁的过程。\n\nRentrantReadWriteLock不支持锁升级(把持读锁、获取写锁，最后释放读锁的过程)。目的也是保证数据可见性，如果读锁已被多个线程获取，其中任意线程成功获取了写锁并更新了数据，则其更新对其他获取到读锁的线程是不可见的。\n\n应用场景：\n\n 1. 读多写少的情况：当读操作远远超过写操作时，使用读写锁可以提高并发性能，允许多个线程同时获取读锁，从而实现并发读取。\n 2. 缓存系统：在缓存系统中，读操作通常比写操作频繁。使用读写锁可以让多个线程同时读取缓存，提高读取性能，而在写入缓存时需要独占写锁以保证数据一致性。\n 3. 数据库操作：在数据库访问中，读操作往往比写操作频繁。使用读写锁可以提高并发度，允许多个线程同时读取数据库，而在写入时需要独占写锁以保证数据的完整性。\n 4. 任务调度器：在任务调度系统中，多个任务可能同时读取共享的任务列表，而在修改任务列表时需要独占写锁以保证数据的一致性。\n\n> todo: 写锁 tryAcquire 和读锁 tryAcquireShared 的具体实现。\n\n\n# StampedLock\n\n它是java8在java.util.concurrent.locks新增的一个API。\n\nReentrantReadWriteLock 在沒有任何读写锁时，才可以取得写入锁，这可用于实现了悲观读取(Pessimistic Reading)，即如果执行中进行读取时，经常可能有另一执行要写入的需求，为了保持同步，ReentrantReadWriteLock 的读取锁定就可派上用场。\n\n然而，如果读取执行情况很多，写入很少的情况下，使用 ReentrantReadWriteLock 可能会使写入线程遭遇饥饿(Starvation)问题，也就是写入线程迟迟无法竞争到锁定而一直处于等待状态。\n\nStampedLock控制锁有三种模式(写，读，乐观读)，一个StampedLock状态是由版本和模式两个部分组成，锁获取方法返回一个数字作为票据stamp，它用相应的锁状态表示并控制访问，数字0表示没有写锁被授权访问。在读锁上分为悲观锁和乐观锁。\n\n所谓的乐观读模式，也就是若读的操作很多，写的操作很少的情况下，你可以乐观地认为，写入与读取同时发生几率很少，因此不悲观地使用完全的读取锁定，程序可以查看读取资料之后，是否遭到写入执行的变更，再采取后续的措施(重新读取变更信息，或者抛出异常) ，这一个小小改进，可大幅度提高程序的吞吐量。\n\nStampedLock要比ReentrantReadWriteLock 消耗更小。\n\nStampedLock 同时支持乐观锁和悲观锁的特性。在 StampedLock 中，读操作使用乐观锁的方式进行，而写操作则使用悲观锁。\n\n乐观读取是通过调用 tryOptimisticRead 方法实现的，它返回一个标记（stamp），表示当前数据的版本号。在乐观读取过程中，如果没有发生写操作，读取的数据是有效的。然后可以通过调用 validate 方法来验证读取期间是否发生了写操作。\n\n对于写操作，StampedLock 使用悲观锁，即需要获取独占锁才能进行写操作。写操作会阻塞其他的读操作和乐观读取，以保证数据的一致性。\n\n应用场景：\n\n 1. 读多写少的情况：StampedLock 在读多写少的场景下表现出色。读操作不会阻塞其他读操作，提高了并发读取的性能。当写操作非常少时，可以考虑使用 StampedLock 来替代传统的读写锁。\n 2. 对读操作的顺序要求不严格的情况：StampedLock 允许乐观读取，即在没有写操作的情况下，读操作可以无需获取读锁直接进行。这使得读操作更快速，特别适用于对读操作的顺序要求不严格的场景。\n 3. 读写分离的数据结构：StampedLock 可以用于读写分离的数据结构，例如缓存、数据库等。通过使用乐观读取和悲观读取，可以实现高效的并发读写操作。\n 4. 自旋等待读取：StampedLock 提供了 tryOptimisticRead 方法，可以进行自旋等待读取的操作。这在对读操作持续时间短、读线程数目较多的情况下，可以提高性能。\n\n需要注意的是，StampedLock 并不适用于频繁的写操作，因为写操作需要获取独占锁，而其他读操作和乐观读取可能会被阻塞。在选择使用 StampedLock 时，需要根据具体场景和需求进行评估，并考虑读写比例、并发度等因素。\n\n\n# LockSupport\n\nQuestion:\n\n * 为什么LockSupport也是核心基础类? AQS框架借助于两个类：Unsafe(提供CAS操作)和LockSupport(提供park/unpark操作)\n * 写出分别通过wait/notify和LockSupport的park/unpark实现同步?\n * LockSupport.park()会释放锁资源吗? 那么Condition.await()呢?\n * Thread.sleep()、Object.wait()、Condition.await()、LockSupport.park()的区别? 重点\n * 如果在wait()之前执行了notify()会怎样?\n * 如果在park()之前执行了unpark()会怎样?\n\nThe LockSupport class in Java provides a set of low-level primitives for synchronizing threads. These primitives are designed to be used as tools for creating higher-level synchronization utilities, and are not in themselves useful for most concurrency control applications.\n\nLockSupport是Java并发编程中的一个工具类，用于实现线程的阻塞和唤醒操作。它提供了一种比传统的Object.wait()和Object.notify()更灵活和可靠的线程等待/通知机制。\n\nLockSupport类通过park()方法使线程进入阻塞状态，而unpark()方法则用于唤醒被阻塞的线程。相比于Object.wait()和Object.notify()，LockSupport不依赖于对象的监视器锁，而是直接和线程进行交互，因此可以在任意位置使用。\n\n与其他线程同步工具相比，LockSupport具有以下特点：\n\n 1. 可以在任意位置进行阻塞和唤醒操作，无需获得对象的锁。\n 2. 每个线程都拥有一个许可(permit)，permit的初始值为0，当permit为0时，调用park()方法会导致线程阻塞，permit为1时，调用park()方法不会阻塞。\n 3. unpark()方法可以提前给线程一个permit，使其不会被park()方法阻塞。\n 4. 调用park()方法的线程不会出现死锁情况，因为即使先调用unpark()再调用park()，线程也不会被阻塞。\n\nLockSupport是实现锁和其他同步工具的基础，常用于一些高级并发框架和工具的底层实现。它提供了一种灵活、可靠的线程等待/通知机制，避免了传统的wait()/notify()可能出现的一些问题，使线程的阻塞和唤醒操作更加可控。\n\nLockSupport.park();\nLockSupport.unpark(Thread);\n\n\n# Thread.sleep()和Object.wait()的区别\n\n首先，我们先来看看Thread.sleep()和Object.wait()的区别，这是一个烂大街的题目了，大家应该都能说上来两点。\n\n * Thread.sleep()不会释放占有的锁，Object.wait()会释放占有的锁；\n * Thread.sleep()必须传入时间，Object.wait()可传可不传，不传表示一直阻塞下去；\n * Thread.sleep()到时间了会自动唤醒，然后继续执行；\n * Object.wait()不带时间的，需要另一个线程使用Object.notify()唤醒；\n * Object.wait()带时间的，假如没有被notify，到时间了会自动唤醒，这时又分好两种情况，一是立即获取到了锁，线程自然会继续执行；二是没有立即获取锁，线程进入同步队列等待获取锁；\n\n其实，他们俩最大的区别就是Thread.sleep()不会释放锁资源，Object.wait()会释放锁资源。\n\n# Object.wait()和Condition.await()的区别\n\nObject.wait()和Condition.await()的原理是基本一致的，不同的是Condition.await()底层是调用LockSupport.park()来实现阻塞当前线程的。\n\n实际上，它在阻塞当前线程之前还干了两件事，一是把当前线程添加到条件队列中，二是“完全”释放锁，也就是让state状态变量变为0，然后才是调用LockSupport.park()阻塞当前线程。\n\n# Thread.sleep()和LockSupport.park()的区别\n\nLockSupport.park()还有几个兄弟方法——parkNanos()、parkUtil()等，我们这里说的park()方法统称这一类方法。\n\n * 从功能上来说，Thread.sleep()和LockSupport.park()方法类似，都是阻塞当前线程的执行，且都不会释放当前线程占有的锁资源；\n * Thread.sleep()没法从外部唤醒，只能自己醒过来；\n * LockSupport.park()方法可以被另一个线程调用LockSupport.unpark()方法唤醒；\n * Thread.sleep()方法声明上抛出了InterruptedException中断异常，所以调用者需要捕获这个异常或者再抛出；\n * LockSupport.park()方法不需要捕获中断异常；\n * Thread.sleep()本身就是一个native方法；\n * LockSupport.park()底层是调用的Unsafe的native方法；\n\n# Object.wait()和LockSupport.park()的区别\n\n二者都会阻塞当前线程的运行，他们有什么区别呢?\n\n * Object.wait()方法需要在synchronized块中执行；\n * LockSupport.park()可以在任意地方执行；\n * Object.wait()方法声明抛出了中断异常，调用者需要捕获或者再抛出；\n * LockSupport.park()不需要捕获中断异常；\n * Object.wait()不带超时的，需要另一个线程执行notify()来唤醒，但不一定继续执行后续内容；\n * LockSupport.park()不带超时的，需要另一个线程执行unpark()来唤醒，一定会继续执行后续内容；\n\npark()/unpark()底层的原理是“二元信号量”，你可以把它相像成只有一个许可证的Semaphore，只不过这个信号量在重复执行unpark()的时候也不会再增加许可证，最多只有一个许可证。\n\n# 如果在wait()之前执行了notify()会怎样?\n\n如果当前的线程不是此对象锁的所有者，却调用该对象的notify()或wait()方法时抛出IllegalMonitorStateException异常；\n\n如果当前线程是此对象锁的所有者，wait()将一直阻塞，因为后续将没有其它notify()唤醒它。\n\n# 如果在park()之前执行了unpark()会怎样?\n\n线程不会被阻塞，直接跳过park()，继续执行后续内容\n\n# LockSupport.park()会释放锁资源吗?\n\n不会，它只负责阻塞当前线程，释放锁资源实际上是在Condition的await()方法中实现的。\n\n\n# Tools\n\n\n# CountDownLatch\n\nquestion:\n\n * 什么是CountDownLatch?\n * CountDownLatch底层实现原理?\n * CountDownLatch一次可以唤醒几个任务? 多个\n * CountDownLatch有哪些主要方法? await(),countDown()\n * CountDownLatch适用于什么场景?\n\n一句话：CountDownLatch是Java并发编程中的一个同步工具类，它可以让一个或多个线程等待一组操作完成后再继续执行。\n\nCountDownLatch is a synchronization tool that allows one or more threads to wait until a set of operations has completed. It is initialized with a count, and each time the countDown() method is called, the count is decremented. When the count reaches zero, all threads that are waiting on the CountDownLatch are released.\n\nCountDownLatch can be used to solve a variety of synchronization problems. For example, it can be used to ensure that all threads in a group have finished executing before a certain task is started, or to ensure that a certain number of resources are available before a task is started.\n\nCountDownLatch latch = new CountDownLatch(5);\nlatch.countDown();\nlatch.await();\n\n\n应用场景：\n\n 1. 并发任务的协同：当一个任务需要等待其他多个任务完成后才能继续执行时，可以使用 CountDownLatch 来实现线程之间的协同。任务中的线程可以调用 CountDownLatch 的 await() 方法进入等待状态，而其他任务中的线程执行完自己的操作后可以调用 CountDownLatch 的 countDown() 方法来减少计数器，当计数器减至零时，等待中的线程就会被唤醒。\n 2. 等待资源初始化：当一个程序需要等待一些资源初始化完成后才能正常运行时，可以使用 CountDownLatch 来实现等待。主线程可以调用 await() 方法等待初始化任务完成，而初始化任务中的线程在完成初始化后调用 countDown() 方法来减少计数器，当计数器减至零时，主线程就会被唤醒，可以开始执行后续的逻辑。\n 3. 测试多线程性能：在性能测试中，可以使用 CountDownLatch 来模拟并发场景。主线程可以启动多个工作线程，这些工作线程会执行相同的任务，并在任务完成时调用 countDown() 方法。主线程可以调用 await() 方法等待所有工作线程完成，以便统计执行时间和性能指标。\n\n\n# CyclicBarrier\n\n * 什么是CyclicBarrier?\n * CyclicBarrier底层实现原理?\n * CountDownLatch和CyclicBarrier对比?\n * CyclicBarrier的核心函数有哪些?\n * CyclicBarrier适用于什么场景?\n\nCyclicBarrier（循环屏障）是Java并发编程中的一个同步工具类，它可以让一组线程在达到某个共同点之前互相等待，然后同时继续执行。\n\nCyclicBarrier 的特点如下：\n\n 1. 共同点：CyclicBarrier 可以设置一个共同点，当等待的线程数达到指定数量时，所有线程将同时被释放，继续执行后续操作。\n 2. 循环使用：CyclicBarrier 可以被多次使用。当所有线程都被释放后，CyclicBarrier 会被重置，并可以再次使用。\n 3. 等待与释放：线程通过调用 CyclicBarrier 的 await() 方法进入等待状态，当指定数量的线程都调用了 await() 方法后，所有线程会同时被释放，继续执行后续操作。\n\n// 构造方法\nCyclicBarrier(int, Runnable); // 指定关联该CyclicBarrier的线程数量，并且可以指定在所有线程都进入屏障后的执行动作，该执行动作由最后一个进行屏障的线程执行。\nCyclicBarrier(int);\n\ncb.await();\n\n\n在所有线程进入屏障后会调用 nextGeneration()，即生成下一个版本，所有线程又可以重新进入到屏障中。要注意barrier.await()方法的调用次数应该与创建CyclicBarrier时指定的线程数量相匹配，以确保正确的同步和等待行为。\n\nCyclicBarrier 和 CountDonwLatch 的对比\n\n * CountDownLatch减计数，CyclicBarrier加计数。\n\n * CountDownLatch是一次性的，CyclicBarrier可以重用。\n\n * CountDownLatch和CyclicBarrier都有让多个线程等待同步然后再开始下一步动作的意思，但是CountDownLatch的下一步的动作实施者是主线程，具有不可重复性；而CyclicBarrier的下一步动作实施者还是“其他线程”本身，具有往复多次实施动作的特点。\n\n * 对于CountDownLatch，其他线程为游戏玩家，比如英雄联盟，主线程为控制游戏开始的线程。在所有的玩家都准备好之前，主线程是处于等待状态的，也就是游戏不能开始。当所有的玩家准备好之后，下一步的动作实施者为主线程，即开始游戏。\n\n * 对于CyclicBarrier，假设有一家公司要全体员工进行团建活动，活动内容为翻越三个障碍物，每一个人翻越障碍物所用的时间是不一样的。但是公司要求所有人在翻越当前障碍物之后再开始翻越下一个障碍物，也就是所有人翻越第一个障碍物之后，才开始翻越第二个，以此类推。类比地，每一个员工都是一个“其他线程”。当所有人都翻越的所有的障碍物之后，程序才结束。而主线程可能早就结束了，这里我们不用管主线程。\n\nCyclicBarrier 的应用场景包括以下几个方面：\n\n 1. 并行计算任务的拆分与合并：当一个大型计算任务可以被拆分为多个子任务并行执行时，可以使用 CyclicBarrier 来等待所有子任务完成后再进行合并计算。\n 2. 多线程任务的阶段同步：当一个任务需要按照阶段进行多次并发操作，每个阶段需要等待所有线程都完成后才能继续下一阶段，可以使用 CyclicBarrier 来实现阶段间的同步。\n 3. 并发流水线的流程控制：当多个线程需要按照特定的流水线方式执行任务，每个线程在完成一定操作后需要等待其他线程才能继续，可以使用 CyclicBarrier 来实现线程之间的同步。\n\n\n# Phaser\n\n\n# Semaphore\n\nSemaphore（信号量）是Java并发编程中的一个同步工具类，它可以用于控制对共享资源的访问数量。Semaphore 维护了一个许可证数量，线程可以通过获取许可证来访问共享资源，而当许可证不可用时，线程需要等待其他线程释放许可证。\n\nSemaphore 的特点如下：\n\n 1. 许可证数量：Semaphore 通过一个整数来表示可用的许可证数量。线程可以通过 acquire() 方法获取一个许可证，表示占用了一个资源，而 release() 方法则释放一个许可证，表示释放了一个资源。\n 2. 公平性：Semaphore 可以选择是否公平地控制许可证的获取。公平性表示等待时间最长的线程将优先获取许可证，而非公平性则没有这个保证。\n\nSemaphore 的应用场景包括以下几个方面：\n\n 1. 有限资源的并发访问控制：当系统中存在有限的资源，如数据库连接、线程池等，可以使用 Semaphore 来控制对这些资源的并发访问数量，以避免资源过载。\n 2. 流量控制：当需要限制某个操作的并发数量，以控制流量或避免过度的请求压力时，可以使用 Semaphore 来实现限流。\n 3. 线程池管理：Semaphore 可以用于实现线程池中的工作线程数量控制，通过限制许可证数量，控制同时执行的任务数量。\n\n核心方法\n\npublic Semaphore(int permits);\npublic Semaphore(int permits, boolean fair);\n\nsemaphore.acquire();\nsemaphore.acquire(int);\nsemaphore.release();\nsemaphore.release(int);\n\n\nNote: 调用release()会添加令牌，并不会以初始化的大小为准。Semaphore中release方法的调用并没有限制要在acquire后调用。\n\n\n# Exchanger\n\n\n# Collections\n\n\n# Queue\n\n\n# List\n\n\n# Set\n\n\n# Map\n\n\n# Atomic\n\n\n# 基础类型\n\n\n# 数组\n\n\n# 引用\n\n\n# Executor\n\n\n# 接口：Executor\n\n\n# ExecutorService\n\n\n# ScheduledExecutorService\n\n\n# AbstractExecutorService\n\n\n# FutureTask\n\n\n# ThreadPoolExecutor\n\n\n# ScheduledThreadPoolExecutor\n\n\n# Fork/Join Framework\n\n\n# Executors\n\n\n# Reference\n\nhttps://pdai.tech/md/java/thread/java-thread-x-juc-overview.html#atomic-%E5%8E%9F%E5%AD%90%E7%B1%BB",normalizedContent:"# base\n\n\n\n接口：condition\n\ncondition为接口类型，它将 object 监视器方法(wait、notify 和 notifyall)分解成截然不同的对象，以便通过将这些对象与任意 lock 实现组合使用，为每个对象提供多个等待 set (wait-set)。其中，lock 替代了 synchronized 方法和语句的使用，condition 替代了 object 监视器方法的使用。可以通过await(),signal()来休眠/唤醒线程。\n\ncondition 的实现类是 aqs 和aqls 的内部类 conditionobject 。\n\n\n# locks\n\n\n# reentrantlock\n\nquestion：\n\n * 什么是可重入，什么是可重入锁? 它用来解决什么问题?\n * reentrantlock的核心是aqs，那么它怎么来实现的，继承吗? 说说其类内部结构关系。\n * reentrantlock是如何实现公平锁的?\n * reentrantlock是如何实现非公平锁的?\n * reentrantlock默认实现的是公平还是非公平锁?\n * 使用reentrantlock实现公平和非公平锁的示例?\n * reentrantlock和synchronized的对比?\n\nreentrantlock为常用类，它是一个可重入的互斥锁 lock，它具有与使用 synchronized 方法和语句所访问的隐式监视器锁相同的一些基本行为和语义，但功能更强大。\n\nreentrantlock 中的内部类：reentrantlock类内部总共存在sync、nonfairsync、fairsync三个类，nonfairsync与fairsync类继承自sync类，sync类继承自abstractqueuedsynchronizer抽象类。\n\n调用链：\n\n公平锁的调用成功的情况：lock:lock -> fairsync:lock ->aqs:acquire -> fairsync:tryacquire -> aqs:hasqueuedpredecessors -> aqs:setexclusiveownerthread\n\nfairsync:lock 当资源被占用的情况：fairsync:lock -> aqs:acquire -> fairsync:tryacquire -> aqs:addwaiter -> aqs:acquirequeued\n\n\n# reentrantreadwritelock\n\nquestion：\n\n * 为了有了reentrantlock还需要reentrantreadwritelock?\n * reentrantreadwritelock底层实现原理?\n * reentrantreadwritelock底层读写状态如何设计的? 高16位为读锁，低16位为写锁\n * 读锁和写锁的最大数量是多少?\n * 本地线程计数器threadlocalholdcounter是用来做什么的?\n * 缓存计数器holdcounter是用来做什么的?\n * 写锁的获取与释放是怎么实现的?\n * 读锁的获取与释放是怎么实现的?\n * 什么是锁的升降级? rentrantreadwritelock为什么不支持锁升级?\n\nreentrantreadwritelock是读写锁接口readwritelock的实现类，它包括lock子类readlock和writelock。readlock是共享锁，writelock是独占锁。\n\nreentrantreadwritelock 允许多个线程同时持有读锁，但只允许一个线程持有写锁。\n\n * 读锁：当一个线程获取到读锁时，其他线程也可以获取读锁，但不能获取写锁。当最后一个持有读锁的线程释放读锁时，其他等待的写线程才有机会获取写锁。\n\n * 写锁：当一个线程获取到写锁时，其他线程无法获取读锁或写锁，直到写锁被释放。\n\n\n\n内部类：reentrantreadwritelock有五个内部类，sync继承自aqs、nonfairsync继承自sync类、fairsync继承自sync类；readlock实现了lock接口、writelock也实现了lock接口。\n\nsync类内部存在两个内部类，分别为holdcounter和threadlocalholdcounter，其中holdcounter主要与读锁配套使用。\n\nthreadlocalholdcounter重写了threadlocal的initialvalue方法，threadlocal类可以将线程与对象相关联。在没有进行set的情况下，get到的均是initialvalue方法里面生成的那个holdercounter对象。\n\n什么是锁升降级?\n\n锁降级指的是写锁降级成为读锁。如果当前线程拥有写锁，然后将其释放，最后再获取读锁，这种分段完成的过程不能称之为锁降级。锁降级是指把持住(当前拥有的)写锁，再获取到读锁，随后释放(先前拥有的)写锁的过程。\n\nrentrantreadwritelock不支持锁升级(把持读锁、获取写锁，最后释放读锁的过程)。目的也是保证数据可见性，如果读锁已被多个线程获取，其中任意线程成功获取了写锁并更新了数据，则其更新对其他获取到读锁的线程是不可见的。\n\n应用场景：\n\n 1. 读多写少的情况：当读操作远远超过写操作时，使用读写锁可以提高并发性能，允许多个线程同时获取读锁，从而实现并发读取。\n 2. 缓存系统：在缓存系统中，读操作通常比写操作频繁。使用读写锁可以让多个线程同时读取缓存，提高读取性能，而在写入缓存时需要独占写锁以保证数据一致性。\n 3. 数据库操作：在数据库访问中，读操作往往比写操作频繁。使用读写锁可以提高并发度，允许多个线程同时读取数据库，而在写入时需要独占写锁以保证数据的完整性。\n 4. 任务调度器：在任务调度系统中，多个任务可能同时读取共享的任务列表，而在修改任务列表时需要独占写锁以保证数据的一致性。\n\n> todo: 写锁 tryacquire 和读锁 tryacquireshared 的具体实现。\n\n\n# stampedlock\n\n它是java8在java.util.concurrent.locks新增的一个api。\n\nreentrantreadwritelock 在沒有任何读写锁时，才可以取得写入锁，这可用于实现了悲观读取(pessimistic reading)，即如果执行中进行读取时，经常可能有另一执行要写入的需求，为了保持同步，reentrantreadwritelock 的读取锁定就可派上用场。\n\n然而，如果读取执行情况很多，写入很少的情况下，使用 reentrantreadwritelock 可能会使写入线程遭遇饥饿(starvation)问题，也就是写入线程迟迟无法竞争到锁定而一直处于等待状态。\n\nstampedlock控制锁有三种模式(写，读，乐观读)，一个stampedlock状态是由版本和模式两个部分组成，锁获取方法返回一个数字作为票据stamp，它用相应的锁状态表示并控制访问，数字0表示没有写锁被授权访问。在读锁上分为悲观锁和乐观锁。\n\n所谓的乐观读模式，也就是若读的操作很多，写的操作很少的情况下，你可以乐观地认为，写入与读取同时发生几率很少，因此不悲观地使用完全的读取锁定，程序可以查看读取资料之后，是否遭到写入执行的变更，再采取后续的措施(重新读取变更信息，或者抛出异常) ，这一个小小改进，可大幅度提高程序的吞吐量。\n\nstampedlock要比reentrantreadwritelock 消耗更小。\n\nstampedlock 同时支持乐观锁和悲观锁的特性。在 stampedlock 中，读操作使用乐观锁的方式进行，而写操作则使用悲观锁。\n\n乐观读取是通过调用 tryoptimisticread 方法实现的，它返回一个标记（stamp），表示当前数据的版本号。在乐观读取过程中，如果没有发生写操作，读取的数据是有效的。然后可以通过调用 validate 方法来验证读取期间是否发生了写操作。\n\n对于写操作，stampedlock 使用悲观锁，即需要获取独占锁才能进行写操作。写操作会阻塞其他的读操作和乐观读取，以保证数据的一致性。\n\n应用场景：\n\n 1. 读多写少的情况：stampedlock 在读多写少的场景下表现出色。读操作不会阻塞其他读操作，提高了并发读取的性能。当写操作非常少时，可以考虑使用 stampedlock 来替代传统的读写锁。\n 2. 对读操作的顺序要求不严格的情况：stampedlock 允许乐观读取，即在没有写操作的情况下，读操作可以无需获取读锁直接进行。这使得读操作更快速，特别适用于对读操作的顺序要求不严格的场景。\n 3. 读写分离的数据结构：stampedlock 可以用于读写分离的数据结构，例如缓存、数据库等。通过使用乐观读取和悲观读取，可以实现高效的并发读写操作。\n 4. 自旋等待读取：stampedlock 提供了 tryoptimisticread 方法，可以进行自旋等待读取的操作。这在对读操作持续时间短、读线程数目较多的情况下，可以提高性能。\n\n需要注意的是，stampedlock 并不适用于频繁的写操作，因为写操作需要获取独占锁，而其他读操作和乐观读取可能会被阻塞。在选择使用 stampedlock 时，需要根据具体场景和需求进行评估，并考虑读写比例、并发度等因素。\n\n\n# locksupport\n\nquestion:\n\n * 为什么locksupport也是核心基础类? aqs框架借助于两个类：unsafe(提供cas操作)和locksupport(提供park/unpark操作)\n * 写出分别通过wait/notify和locksupport的park/unpark实现同步?\n * locksupport.park()会释放锁资源吗? 那么condition.await()呢?\n * thread.sleep()、object.wait()、condition.await()、locksupport.park()的区别? 重点\n * 如果在wait()之前执行了notify()会怎样?\n * 如果在park()之前执行了unpark()会怎样?\n\nthe locksupport class in java provides a set of low-level primitives for synchronizing threads. these primitives are designed to be used as tools for creating higher-level synchronization utilities, and are not in themselves useful for most concurrency control applications.\n\nlocksupport是java并发编程中的一个工具类，用于实现线程的阻塞和唤醒操作。它提供了一种比传统的object.wait()和object.notify()更灵活和可靠的线程等待/通知机制。\n\nlocksupport类通过park()方法使线程进入阻塞状态，而unpark()方法则用于唤醒被阻塞的线程。相比于object.wait()和object.notify()，locksupport不依赖于对象的监视器锁，而是直接和线程进行交互，因此可以在任意位置使用。\n\n与其他线程同步工具相比，locksupport具有以下特点：\n\n 1. 可以在任意位置进行阻塞和唤醒操作，无需获得对象的锁。\n 2. 每个线程都拥有一个许可(permit)，permit的初始值为0，当permit为0时，调用park()方法会导致线程阻塞，permit为1时，调用park()方法不会阻塞。\n 3. unpark()方法可以提前给线程一个permit，使其不会被park()方法阻塞。\n 4. 调用park()方法的线程不会出现死锁情况，因为即使先调用unpark()再调用park()，线程也不会被阻塞。\n\nlocksupport是实现锁和其他同步工具的基础，常用于一些高级并发框架和工具的底层实现。它提供了一种灵活、可靠的线程等待/通知机制，避免了传统的wait()/notify()可能出现的一些问题，使线程的阻塞和唤醒操作更加可控。\n\nlocksupport.park();\nlocksupport.unpark(thread);\n\n\n# thread.sleep()和object.wait()的区别\n\n首先，我们先来看看thread.sleep()和object.wait()的区别，这是一个烂大街的题目了，大家应该都能说上来两点。\n\n * thread.sleep()不会释放占有的锁，object.wait()会释放占有的锁；\n * thread.sleep()必须传入时间，object.wait()可传可不传，不传表示一直阻塞下去；\n * thread.sleep()到时间了会自动唤醒，然后继续执行；\n * object.wait()不带时间的，需要另一个线程使用object.notify()唤醒；\n * object.wait()带时间的，假如没有被notify，到时间了会自动唤醒，这时又分好两种情况，一是立即获取到了锁，线程自然会继续执行；二是没有立即获取锁，线程进入同步队列等待获取锁；\n\n其实，他们俩最大的区别就是thread.sleep()不会释放锁资源，object.wait()会释放锁资源。\n\n# object.wait()和condition.await()的区别\n\nobject.wait()和condition.await()的原理是基本一致的，不同的是condition.await()底层是调用locksupport.park()来实现阻塞当前线程的。\n\n实际上，它在阻塞当前线程之前还干了两件事，一是把当前线程添加到条件队列中，二是“完全”释放锁，也就是让state状态变量变为0，然后才是调用locksupport.park()阻塞当前线程。\n\n# thread.sleep()和locksupport.park()的区别\n\nlocksupport.park()还有几个兄弟方法——parknanos()、parkutil()等，我们这里说的park()方法统称这一类方法。\n\n * 从功能上来说，thread.sleep()和locksupport.park()方法类似，都是阻塞当前线程的执行，且都不会释放当前线程占有的锁资源；\n * thread.sleep()没法从外部唤醒，只能自己醒过来；\n * locksupport.park()方法可以被另一个线程调用locksupport.unpark()方法唤醒；\n * thread.sleep()方法声明上抛出了interruptedexception中断异常，所以调用者需要捕获这个异常或者再抛出；\n * locksupport.park()方法不需要捕获中断异常；\n * thread.sleep()本身就是一个native方法；\n * locksupport.park()底层是调用的unsafe的native方法；\n\n# object.wait()和locksupport.park()的区别\n\n二者都会阻塞当前线程的运行，他们有什么区别呢?\n\n * object.wait()方法需要在synchronized块中执行；\n * locksupport.park()可以在任意地方执行；\n * object.wait()方法声明抛出了中断异常，调用者需要捕获或者再抛出；\n * locksupport.park()不需要捕获中断异常；\n * object.wait()不带超时的，需要另一个线程执行notify()来唤醒，但不一定继续执行后续内容；\n * locksupport.park()不带超时的，需要另一个线程执行unpark()来唤醒，一定会继续执行后续内容；\n\npark()/unpark()底层的原理是“二元信号量”，你可以把它相像成只有一个许可证的semaphore，只不过这个信号量在重复执行unpark()的时候也不会再增加许可证，最多只有一个许可证。\n\n# 如果在wait()之前执行了notify()会怎样?\n\n如果当前的线程不是此对象锁的所有者，却调用该对象的notify()或wait()方法时抛出illegalmonitorstateexception异常；\n\n如果当前线程是此对象锁的所有者，wait()将一直阻塞，因为后续将没有其它notify()唤醒它。\n\n# 如果在park()之前执行了unpark()会怎样?\n\n线程不会被阻塞，直接跳过park()，继续执行后续内容\n\n# locksupport.park()会释放锁资源吗?\n\n不会，它只负责阻塞当前线程，释放锁资源实际上是在condition的await()方法中实现的。\n\n\n# tools\n\n\n# countdownlatch\n\nquestion:\n\n * 什么是countdownlatch?\n * countdownlatch底层实现原理?\n * countdownlatch一次可以唤醒几个任务? 多个\n * countdownlatch有哪些主要方法? await(),countdown()\n * countdownlatch适用于什么场景?\n\n一句话：countdownlatch是java并发编程中的一个同步工具类，它可以让一个或多个线程等待一组操作完成后再继续执行。\n\ncountdownlatch is a synchronization tool that allows one or more threads to wait until a set of operations has completed. it is initialized with a count, and each time the countdown() method is called, the count is decremented. when the count reaches zero, all threads that are waiting on the countdownlatch are released.\n\ncountdownlatch can be used to solve a variety of synchronization problems. for example, it can be used to ensure that all threads in a group have finished executing before a certain task is started, or to ensure that a certain number of resources are available before a task is started.\n\ncountdownlatch latch = new countdownlatch(5);\nlatch.countdown();\nlatch.await();\n\n\n应用场景：\n\n 1. 并发任务的协同：当一个任务需要等待其他多个任务完成后才能继续执行时，可以使用 countdownlatch 来实现线程之间的协同。任务中的线程可以调用 countdownlatch 的 await() 方法进入等待状态，而其他任务中的线程执行完自己的操作后可以调用 countdownlatch 的 countdown() 方法来减少计数器，当计数器减至零时，等待中的线程就会被唤醒。\n 2. 等待资源初始化：当一个程序需要等待一些资源初始化完成后才能正常运行时，可以使用 countdownlatch 来实现等待。主线程可以调用 await() 方法等待初始化任务完成，而初始化任务中的线程在完成初始化后调用 countdown() 方法来减少计数器，当计数器减至零时，主线程就会被唤醒，可以开始执行后续的逻辑。\n 3. 测试多线程性能：在性能测试中，可以使用 countdownlatch 来模拟并发场景。主线程可以启动多个工作线程，这些工作线程会执行相同的任务，并在任务完成时调用 countdown() 方法。主线程可以调用 await() 方法等待所有工作线程完成，以便统计执行时间和性能指标。\n\n\n# cyclicbarrier\n\n * 什么是cyclicbarrier?\n * cyclicbarrier底层实现原理?\n * countdownlatch和cyclicbarrier对比?\n * cyclicbarrier的核心函数有哪些?\n * cyclicbarrier适用于什么场景?\n\ncyclicbarrier（循环屏障）是java并发编程中的一个同步工具类，它可以让一组线程在达到某个共同点之前互相等待，然后同时继续执行。\n\ncyclicbarrier 的特点如下：\n\n 1. 共同点：cyclicbarrier 可以设置一个共同点，当等待的线程数达到指定数量时，所有线程将同时被释放，继续执行后续操作。\n 2. 循环使用：cyclicbarrier 可以被多次使用。当所有线程都被释放后，cyclicbarrier 会被重置，并可以再次使用。\n 3. 等待与释放：线程通过调用 cyclicbarrier 的 await() 方法进入等待状态，当指定数量的线程都调用了 await() 方法后，所有线程会同时被释放，继续执行后续操作。\n\n// 构造方法\ncyclicbarrier(int, runnable); // 指定关联该cyclicbarrier的线程数量，并且可以指定在所有线程都进入屏障后的执行动作，该执行动作由最后一个进行屏障的线程执行。\ncyclicbarrier(int);\n\ncb.await();\n\n\n在所有线程进入屏障后会调用 nextgeneration()，即生成下一个版本，所有线程又可以重新进入到屏障中。要注意barrier.await()方法的调用次数应该与创建cyclicbarrier时指定的线程数量相匹配，以确保正确的同步和等待行为。\n\ncyclicbarrier 和 countdonwlatch 的对比\n\n * countdownlatch减计数，cyclicbarrier加计数。\n\n * countdownlatch是一次性的，cyclicbarrier可以重用。\n\n * countdownlatch和cyclicbarrier都有让多个线程等待同步然后再开始下一步动作的意思，但是countdownlatch的下一步的动作实施者是主线程，具有不可重复性；而cyclicbarrier的下一步动作实施者还是“其他线程”本身，具有往复多次实施动作的特点。\n\n * 对于countdownlatch，其他线程为游戏玩家，比如英雄联盟，主线程为控制游戏开始的线程。在所有的玩家都准备好之前，主线程是处于等待状态的，也就是游戏不能开始。当所有的玩家准备好之后，下一步的动作实施者为主线程，即开始游戏。\n\n * 对于cyclicbarrier，假设有一家公司要全体员工进行团建活动，活动内容为翻越三个障碍物，每一个人翻越障碍物所用的时间是不一样的。但是公司要求所有人在翻越当前障碍物之后再开始翻越下一个障碍物，也就是所有人翻越第一个障碍物之后，才开始翻越第二个，以此类推。类比地，每一个员工都是一个“其他线程”。当所有人都翻越的所有的障碍物之后，程序才结束。而主线程可能早就结束了，这里我们不用管主线程。\n\ncyclicbarrier 的应用场景包括以下几个方面：\n\n 1. 并行计算任务的拆分与合并：当一个大型计算任务可以被拆分为多个子任务并行执行时，可以使用 cyclicbarrier 来等待所有子任务完成后再进行合并计算。\n 2. 多线程任务的阶段同步：当一个任务需要按照阶段进行多次并发操作，每个阶段需要等待所有线程都完成后才能继续下一阶段，可以使用 cyclicbarrier 来实现阶段间的同步。\n 3. 并发流水线的流程控制：当多个线程需要按照特定的流水线方式执行任务，每个线程在完成一定操作后需要等待其他线程才能继续，可以使用 cyclicbarrier 来实现线程之间的同步。\n\n\n# phaser\n\n\n# semaphore\n\nsemaphore（信号量）是java并发编程中的一个同步工具类，它可以用于控制对共享资源的访问数量。semaphore 维护了一个许可证数量，线程可以通过获取许可证来访问共享资源，而当许可证不可用时，线程需要等待其他线程释放许可证。\n\nsemaphore 的特点如下：\n\n 1. 许可证数量：semaphore 通过一个整数来表示可用的许可证数量。线程可以通过 acquire() 方法获取一个许可证，表示占用了一个资源，而 release() 方法则释放一个许可证，表示释放了一个资源。\n 2. 公平性：semaphore 可以选择是否公平地控制许可证的获取。公平性表示等待时间最长的线程将优先获取许可证，而非公平性则没有这个保证。\n\nsemaphore 的应用场景包括以下几个方面：\n\n 1. 有限资源的并发访问控制：当系统中存在有限的资源，如数据库连接、线程池等，可以使用 semaphore 来控制对这些资源的并发访问数量，以避免资源过载。\n 2. 流量控制：当需要限制某个操作的并发数量，以控制流量或避免过度的请求压力时，可以使用 semaphore 来实现限流。\n 3. 线程池管理：semaphore 可以用于实现线程池中的工作线程数量控制，通过限制许可证数量，控制同时执行的任务数量。\n\n核心方法\n\npublic semaphore(int permits);\npublic semaphore(int permits, boolean fair);\n\nsemaphore.acquire();\nsemaphore.acquire(int);\nsemaphore.release();\nsemaphore.release(int);\n\n\nnote: 调用release()会添加令牌，并不会以初始化的大小为准。semaphore中release方法的调用并没有限制要在acquire后调用。\n\n\n# exchanger\n\n\n# collections\n\n\n# queue\n\n\n# list\n\n\n# set\n\n\n# map\n\n\n# atomic\n\n\n# 基础类型\n\n\n# 数组\n\n\n# 引用\n\n\n# executor\n\n\n# 接口：executor\n\n\n# executorservice\n\n\n# scheduledexecutorservice\n\n\n# abstractexecutorservice\n\n\n# futuretask\n\n\n# threadpoolexecutor\n\n\n# scheduledthreadpoolexecutor\n\n\n# fork/join framework\n\n\n# executors\n\n\n# reference\n\nhttps://pdai.tech/md/java/thread/java-thread-x-juc-overview.html#atomic-%e5%8e%9f%e5%ad%90%e7%b1%bb",charsets:{cjk:!0}},{title:"lombok的实现原理",frontmatter:{title:"lombok的实现原理",date:"2023-05-26T20:45:27.000Z",permalink:"/pages/cf4cda/",article:!1},regularPath:"/temp/lombok%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86.html",relativePath:"temp/lombok的实现原理.md",key:"v-b0095412",path:"/pages/cf4cda/",headers:[{level:2,title:"lombok 的用法",slug:"lombok-的用法",normalizedTitle:"lombok 的用法",charIndex:2},{level:2,title:"lombok 的实现原理",slug:"lombok-的实现原理",normalizedTitle:"lombok 的实现原理",charIndex:49},{level:2,title:"注解的处理时机：",slug:"注解的处理时机",normalizedTitle:"注解的处理时机：",charIndex:1324},{level:2,title:"为什么lombok要在编译器时处理注解，而不采用反射的方式去生成代码？",slug:"为什么lombok要在编译器时处理注解-而不采用反射的方式去生成代码",normalizedTitle:"为什么lombok要在编译器时处理注解，而不采用反射的方式去生成代码？",charIndex:1721}],headersStr:"lombok 的用法 lombok 的实现原理 注解的处理时机： 为什么lombok要在编译器时处理注解，而不采用反射的方式去生成代码？",content:"# lombok 的用法\n\n 1. 安装插件\n 2. pom 加入依赖\n 3. 使用注解\n\n\n# lombok 的实现原理\n\nlombok 是在编译阶段处理注解。在编译阶段，当 Java 源码被抽象成语法树 (AST) 之后，Lombok 会根据自己的注解处理器动态的修改 AST，增加新的代码 (节点)，在这一切执行之后，再通过分析生成了最终的字节码 (.class) 文件。\n\nJava 的编译过程大致可以分为三个阶段：\n\n 1. 解析与填充符号表\n 2. 注解处理\n 3. 分析与字节码生成\n\nJava 的编译过程主要包括以下几个步骤：（详细版）\n\n 1. 词法分析（Lexical Analysis）：将源代码分解为基本的词法单元（Tokens），如关键字、标识符、运算符、分隔符等。\n 2. 语法分析（Syntax Analysis）：将词法单元组织成语法结构，并根据语法规则进行验证。这个过程构建了抽象语法树（Abstract Syntax Tree，AST）。\n 3. 语义分析（Semantic Analysis）：对语法结构进行语义检查，包括类型检查、作用域检查等。此步骤确保代码的合法性和正确性。\n 4. 中间代码生成（Intermediate Code Generation）：根据语法结构和语义信息生成中间代码。中间代码可以是一种抽象表示形式，如字节码、中间语言（例如Java字节码或LLVM IR）。\n 5. 优化（Optimization）：对生成的中间代码进行优化，以提高程序的性能和效率。这包括常量折叠、无用代码消除、循环展开等优化技术。\n 6. 目标代码生成（Code Generation）：根据优化后的中间代码生成目标平台特定的机器代码或可执行文件。这个过程将中间代码翻译为可以在目标平台上执行的机器指令。\n 7. 编译器链接（Compiler Linking）：如果代码依赖于其他类或库，编译器会进行链接操作，以将编译的代码与所需的类和库进行关联。\n\n这些步骤中的大部分工作由 Java 编译器（如javac）完成。编译过程的最终输出是可执行的目标代码或可部署的字节码文件，可以在相应的运行时环境中执行。\n\n编译时的注解处理是在 Java 编译过程的语义分析阶段之后的特定阶段进行的。该阶段称为注解处理器处理阶段（Annotation Processing Phase）。\n\n在语义分析阶段后，编译器会检查源代码中的注解信息，并将这些注解信息传递给相应的注解处理器进行处理。注解处理器是开发人员编写的特殊类，实现了 javax.annotation.processing.Processor 接口，用于处理特定注解的逻辑。\n\n在注解处理器处理阶段，编译器会调用相应的注解处理器，传递源代码中的注解信息给它们。注解处理器可以读取注解信息、检查和修改抽象语法树（AST），生成额外的代码或进行其他自定义的操作。\n\n注解处理器处理阶段的输出结果通常是生成的代码或其他相关的元数据信息。这些生成的代码可以是为了提供额外的功能、减少样板代码或与注解相关的逻辑。生成的代码会与原始源代码一起参与后续的编译过程。\n\n\n# 注解的处理时机：\n\n注解的处理方式取决于注解的元注解（meta-annotation）和注解处理器（annotation processor）的定义。\n\n在 Java 中，有三种主要类型的注解处理方式：\n\n 1. 编译时处理：一些注解在编译时会被特定的注解处理器处理。这些注解处理器会读取源代码中的注解信息，并生成相应的代码或进行其他处理操作。Lombok 就是一个使用编译时处理的注解库。\n 2. 运行时反射处理：某些注解在运行时使用反射机制进行处理。这意味着注解在编译时不会产生特定的代码生成，而是在运行时通过反射读取注解信息并执行相应的操作。例如，JUnit 中的测试注解 @Test 就是在运行时通过反射机制来运行测试方法。\n 3. 无处理：一些注解在编译和运行时都没有特定的处理。这些注解可能仅用于提供额外的元数据信息，供其他工具或框架使用，而不会直接影响代码的生成或行为。\n\n\n# 为什么lombok要在编译器时处理注解，而不采用反射的方式去生成代码？\n\nLombok 之所以选择在编译器时处理注解，而不是采用运行时反射的方式去生成代码，主要是出于性能的考虑。\n\nLombok 在编译器时直接生成代码，避免了运行时反射的开销。使用反射生成代码可能会导致运行时的性能损耗，特别是在大型项目中或频繁使用的地方。通过在编译器阶段生成代码，Lombok 可以确保生成的代码是原生的、高效的，并且与手写的代码一样性能良好。\n\nhttps://www.cnblogs.com/vipstone/p/12597756.html",normalizedContent:"# lombok 的用法\n\n 1. 安装插件\n 2. pom 加入依赖\n 3. 使用注解\n\n\n# lombok 的实现原理\n\nlombok 是在编译阶段处理注解。在编译阶段，当 java 源码被抽象成语法树 (ast) 之后，lombok 会根据自己的注解处理器动态的修改 ast，增加新的代码 (节点)，在这一切执行之后，再通过分析生成了最终的字节码 (.class) 文件。\n\njava 的编译过程大致可以分为三个阶段：\n\n 1. 解析与填充符号表\n 2. 注解处理\n 3. 分析与字节码生成\n\njava 的编译过程主要包括以下几个步骤：（详细版）\n\n 1. 词法分析（lexical analysis）：将源代码分解为基本的词法单元（tokens），如关键字、标识符、运算符、分隔符等。\n 2. 语法分析（syntax analysis）：将词法单元组织成语法结构，并根据语法规则进行验证。这个过程构建了抽象语法树（abstract syntax tree，ast）。\n 3. 语义分析（semantic analysis）：对语法结构进行语义检查，包括类型检查、作用域检查等。此步骤确保代码的合法性和正确性。\n 4. 中间代码生成（intermediate code generation）：根据语法结构和语义信息生成中间代码。中间代码可以是一种抽象表示形式，如字节码、中间语言（例如java字节码或llvm ir）。\n 5. 优化（optimization）：对生成的中间代码进行优化，以提高程序的性能和效率。这包括常量折叠、无用代码消除、循环展开等优化技术。\n 6. 目标代码生成（code generation）：根据优化后的中间代码生成目标平台特定的机器代码或可执行文件。这个过程将中间代码翻译为可以在目标平台上执行的机器指令。\n 7. 编译器链接（compiler linking）：如果代码依赖于其他类或库，编译器会进行链接操作，以将编译的代码与所需的类和库进行关联。\n\n这些步骤中的大部分工作由 java 编译器（如javac）完成。编译过程的最终输出是可执行的目标代码或可部署的字节码文件，可以在相应的运行时环境中执行。\n\n编译时的注解处理是在 java 编译过程的语义分析阶段之后的特定阶段进行的。该阶段称为注解处理器处理阶段（annotation processing phase）。\n\n在语义分析阶段后，编译器会检查源代码中的注解信息，并将这些注解信息传递给相应的注解处理器进行处理。注解处理器是开发人员编写的特殊类，实现了 javax.annotation.processing.processor 接口，用于处理特定注解的逻辑。\n\n在注解处理器处理阶段，编译器会调用相应的注解处理器，传递源代码中的注解信息给它们。注解处理器可以读取注解信息、检查和修改抽象语法树（ast），生成额外的代码或进行其他自定义的操作。\n\n注解处理器处理阶段的输出结果通常是生成的代码或其他相关的元数据信息。这些生成的代码可以是为了提供额外的功能、减少样板代码或与注解相关的逻辑。生成的代码会与原始源代码一起参与后续的编译过程。\n\n\n# 注解的处理时机：\n\n注解的处理方式取决于注解的元注解（meta-annotation）和注解处理器（annotation processor）的定义。\n\n在 java 中，有三种主要类型的注解处理方式：\n\n 1. 编译时处理：一些注解在编译时会被特定的注解处理器处理。这些注解处理器会读取源代码中的注解信息，并生成相应的代码或进行其他处理操作。lombok 就是一个使用编译时处理的注解库。\n 2. 运行时反射处理：某些注解在运行时使用反射机制进行处理。这意味着注解在编译时不会产生特定的代码生成，而是在运行时通过反射读取注解信息并执行相应的操作。例如，junit 中的测试注解 @test 就是在运行时通过反射机制来运行测试方法。\n 3. 无处理：一些注解在编译和运行时都没有特定的处理。这些注解可能仅用于提供额外的元数据信息，供其他工具或框架使用，而不会直接影响代码的生成或行为。\n\n\n# 为什么lombok要在编译器时处理注解，而不采用反射的方式去生成代码？\n\nlombok 之所以选择在编译器时处理注解，而不是采用运行时反射的方式去生成代码，主要是出于性能的考虑。\n\nlombok 在编译器时直接生成代码，避免了运行时反射的开销。使用反射生成代码可能会导致运行时的性能损耗，特别是在大型项目中或频繁使用的地方。通过在编译器阶段生成代码，lombok 可以确保生成的代码是原生的、高效的，并且与手写的代码一样性能良好。\n\nhttps://www.cnblogs.com/vipstone/p/12597756.html",charsets:{cjk:!0}},{title:"prompt record",frontmatter:{title:"prompt record",date:"2023-06-07T16:50:23.000Z",permalink:"/pages/252ef5/"},regularPath:"/temp/prompt%20record.html",relativePath:"temp/prompt record.md",key:"v-1689eec4",path:"/pages/252ef5/",headersStr:null,content:"good prompt for learning English:\n\n * please give a speaking prompts for practice\n * please give me 3 tongue twisters for learning",normalizedContent:"good prompt for learning english:\n\n * please give a speaking prompts for practice\n * please give me 3 tongue twisters for learning",charsets:{}},{title:"sentinel",frontmatter:{title:"sentinel",date:"2023-05-11T16:53:31.000Z",permalink:"/pages/144ecf/",article:!1},regularPath:"/temp/sentinel.html",relativePath:"temp/sentinel.md",key:"v-5aaf6e59",path:"/pages/144ecf/",headers:[{level:2,title:"Base",slug:"base",normalizedTitle:"base",charIndex:2},{level:2,title:"持久化",slug:"持久化",normalizedTitle:"持久化",charIndex:1193},{level:2,title:"our project stratage",slug:"our-project-stratage",normalizedTitle:"our project stratage",charIndex:1692},{level:2,title:"注意",slug:"注意",normalizedTitle:"注意",charIndex:2219},{level:2,title:"todo",slug:"todo",normalizedTitle:"todo",charIndex:2633}],headersStr:"Base 持久化 our project stratage 注意 todo",content:'# Base\n\nSentinel 以流量为切入点，从流量控制、熔断降级、系统负载保护等多个维度保护服务的稳定性。\n\n随着微服务的流行，服务与服务之间的调用稳定性变得越来越重要；\n\n1、当服务访问量达到一定程度，流量扛不住的时候，该如何处理？（限流）\n\n2、服务之间相互依赖，当服务B出现响应时间过长，影响到服务A的响应（A调用B），进而产生连锁反应，直至影响整个依赖链上的所有服务（雪崩），该如何处理？（熔断降级）\n\nSentinel 分为两个部分:\n\n * 核心库（Java 客户端）不依赖任何框架/库，能够运行于所有 Java 运行时环境，同时对 Dubbo / Spring Cloud 等框架也有较好的支持。\n * 控制台（Dashboard）基于 Spring Boot 开发，打包后可以直接运行，不需要额外的 Tomcat 等应用容器。\n   * java -Dserver.port=9091 -jar sentinel-dashboard-1.8.5.jar\n\n限流埋点：\n\n * http埋点：sentinel starter默认为所有的http接口提供了限流埋点\n * 自定义埋点：通过 @SentinelResource 定义资源埋点\n\n流控效果：\n\n * 快速失败\n * warm up：通过"冷启动"，让通过的流量缓慢增加，在一定时间内逐渐增加到阈值上限，给冷系统一个预热的时间，避免冷系统被压垮。底层是令牌桶算法的实现\n * 排队等待：匀速排队方式会严格控制请求通过的间隔时间，也即是让请求以均匀的速度通过，对应的是漏桶算法。\n\n流控模式：\n\n * 直接拒绝\n * 关联：当关联的资源达到阈值时，限流自己\n * 链路：只记录指定链路上的流量（指定资源从入口资源进来的流量，如果达到阈值，就可以限流）\n\n两种统计类型：\n\n * QPS\n * 并发线程数\n\n熔断降级：\n\n三种熔断策略：\n\n * 平均响应时间\n * 异常比例\n * 异常数\n\n熔断和降级（GPT）：\n\n熔断和降级是相关的概念，但它们并不完全相同。\n\n降级是指当系统出现异常、故障、高负载等情况时，为了保证系统的稳定性和可用性，通过一定的手段降低系统的服务能力，提高系统的容错能力，避免系统崩溃或者雪崩。\n\n熔断是指当服务调用失败率超过一定的阈值时，通过断路器的机制，将对该服务的请求熔断或者限制其访问，防止请求继续调用失败，从而保证服务的可用性和稳定性。熔断机制可以减轻系统的负载，避免故障扩散，同时也可以加速故障的恢复。\n\n因此，熔断和降级都是为了保证系统的稳定性和可用性，但它们的实现机制和应用场景不同。降级主要是为了保证整体系统的稳定性和可用性，避免雪崩效应，而熔断主要是为了保护被调用服务的稳定性和可用性，避免错误的请求继续发生，导致服务的负载过高、性能下降或者故障扩散等问题。\n\n\n# 持久化\n\n默认情况下，sentinel-dashboard 中的规则是存储在微服务（不是dashboard的，是实际是使用它的）内存中，重启后就会丢失。\n\n * 本地文件持久化：在Sentinel的启动参数中，通过-Dcsp.sentinel.dashboard.file=filepath指定配置文件的路径\n\n * 用 nacos 当配置中心：需要引入sentinel-datasource-nacos的依赖，并在应用配置文件中配置Nacos的地址和认证信息。Sentinel会自动从Nacos加载规则配置信息。\n\n * 编程方式加载和持久化：可以通过编程方式加载和持久化规则配置信息。可以使用com.alibaba.csp.sentinel.datasource.Converter接口实现自定义的数据源和规则配置信息的转换逻辑。然后使用com.alibaba.csp.sentinel.datasource.ReadableDataSource和com.alibaba.csp.sentinel.datasource.WritableDataSource接口来加载和持久化规则配置。\n\n\n# our project stratage\n\n * 用 sentinel做实时监控。\n\n * 同时在 gateway 网关进行限流\n\n * 限流参数应该设定，目前为简单模拟，具体参数需要根据实际情况进行调研。\n\n当前的规则：（感觉有点奇怪GPT）\n\n 1. 针对预订火车票的API接口进行限流：\n    * 设置每分钟允许通过的请求数量，例如：500个请求。\n    * 设置一个平均响应时间阈值，例如：200毫秒。\n    * 设置一个最大并发数，例如：50个并发请求。\n 2. 针对用户注册的API接口进行限流：\n    * 设置每小时允许通过的请求数量，例如：100个请求。\n    * 设置一个平均响应时间阈值，例如：500毫秒。\n    * 设置一个最大并发数，例如：10个并发请求。\n 3. 针对火车票查询的API接口进行限流：\n    * 设置每秒允许通过的请求数量，例如：200个请求。\n    * 设置一个平均响应时间阈值，例如：100毫秒。\n    * 设置一个最大并发数，例如：20个并发请求。\n\n总而言之，针对预定车票接口设定了单机 QPS = 500，然后就快速失败。针对 route id = member 进行限流。\n\n\n# 注意\n\n版本对应：\n\ncom.alibaba.cloud 的版本就包括了它包下面的starter。或许引入 alibaba 的包都需要手动指定版本。\n\n如果这种情况maven无法下到包，就先指定版本号让它去下载\n<dependency>\n    <groupId>com.alibaba.cloud</groupId>\n    <artifactId>spring-cloud-starter-alibaba-sentinel</artifactId>\n</dependency>\n\n<dependency>\n  <groupId>com.alibaba.cloud</groupId>\n  <artifactId>spring-cloud-starter-alibaba-sentinel</artifactId>\n  <version>2022.0.0.0-RC1</version>\n</dependency>\n\n\n\n# todo\n\n需要搞明白：网关限流和具体微服务限流使用上的区别\n\n网关限流可针对 route id 进行统一限流。\n\n具体微服务的限流，更多是对具体的某个api进行限流。\n\nreference:\n\n * https://www.cnblogs.com/gagaxiang/p/17014134.html\n\n * https://juejin.cn/post/7018406221120045087#heading-38 more useful 面经\n\n * https://github.com/alibaba/spring-cloud-alibaba/wiki/%E7%89%88%E6%9C%AC%E8%AF%B4%E6%98%8E 版本说明',normalizedContent:'# base\n\nsentinel 以流量为切入点，从流量控制、熔断降级、系统负载保护等多个维度保护服务的稳定性。\n\n随着微服务的流行，服务与服务之间的调用稳定性变得越来越重要；\n\n1、当服务访问量达到一定程度，流量扛不住的时候，该如何处理？（限流）\n\n2、服务之间相互依赖，当服务b出现响应时间过长，影响到服务a的响应（a调用b），进而产生连锁反应，直至影响整个依赖链上的所有服务（雪崩），该如何处理？（熔断降级）\n\nsentinel 分为两个部分:\n\n * 核心库（java 客户端）不依赖任何框架/库，能够运行于所有 java 运行时环境，同时对 dubbo / spring cloud 等框架也有较好的支持。\n * 控制台（dashboard）基于 spring boot 开发，打包后可以直接运行，不需要额外的 tomcat 等应用容器。\n   * java -dserver.port=9091 -jar sentinel-dashboard-1.8.5.jar\n\n限流埋点：\n\n * http埋点：sentinel starter默认为所有的http接口提供了限流埋点\n * 自定义埋点：通过 @sentinelresource 定义资源埋点\n\n流控效果：\n\n * 快速失败\n * warm up：通过"冷启动"，让通过的流量缓慢增加，在一定时间内逐渐增加到阈值上限，给冷系统一个预热的时间，避免冷系统被压垮。底层是令牌桶算法的实现\n * 排队等待：匀速排队方式会严格控制请求通过的间隔时间，也即是让请求以均匀的速度通过，对应的是漏桶算法。\n\n流控模式：\n\n * 直接拒绝\n * 关联：当关联的资源达到阈值时，限流自己\n * 链路：只记录指定链路上的流量（指定资源从入口资源进来的流量，如果达到阈值，就可以限流）\n\n两种统计类型：\n\n * qps\n * 并发线程数\n\n熔断降级：\n\n三种熔断策略：\n\n * 平均响应时间\n * 异常比例\n * 异常数\n\n熔断和降级（gpt）：\n\n熔断和降级是相关的概念，但它们并不完全相同。\n\n降级是指当系统出现异常、故障、高负载等情况时，为了保证系统的稳定性和可用性，通过一定的手段降低系统的服务能力，提高系统的容错能力，避免系统崩溃或者雪崩。\n\n熔断是指当服务调用失败率超过一定的阈值时，通过断路器的机制，将对该服务的请求熔断或者限制其访问，防止请求继续调用失败，从而保证服务的可用性和稳定性。熔断机制可以减轻系统的负载，避免故障扩散，同时也可以加速故障的恢复。\n\n因此，熔断和降级都是为了保证系统的稳定性和可用性，但它们的实现机制和应用场景不同。降级主要是为了保证整体系统的稳定性和可用性，避免雪崩效应，而熔断主要是为了保护被调用服务的稳定性和可用性，避免错误的请求继续发生，导致服务的负载过高、性能下降或者故障扩散等问题。\n\n\n# 持久化\n\n默认情况下，sentinel-dashboard 中的规则是存储在微服务（不是dashboard的，是实际是使用它的）内存中，重启后就会丢失。\n\n * 本地文件持久化：在sentinel的启动参数中，通过-dcsp.sentinel.dashboard.file=filepath指定配置文件的路径\n\n * 用 nacos 当配置中心：需要引入sentinel-datasource-nacos的依赖，并在应用配置文件中配置nacos的地址和认证信息。sentinel会自动从nacos加载规则配置信息。\n\n * 编程方式加载和持久化：可以通过编程方式加载和持久化规则配置信息。可以使用com.alibaba.csp.sentinel.datasource.converter接口实现自定义的数据源和规则配置信息的转换逻辑。然后使用com.alibaba.csp.sentinel.datasource.readabledatasource和com.alibaba.csp.sentinel.datasource.writabledatasource接口来加载和持久化规则配置。\n\n\n# our project stratage\n\n * 用 sentinel做实时监控。\n\n * 同时在 gateway 网关进行限流\n\n * 限流参数应该设定，目前为简单模拟，具体参数需要根据实际情况进行调研。\n\n当前的规则：（感觉有点奇怪gpt）\n\n 1. 针对预订火车票的api接口进行限流：\n    * 设置每分钟允许通过的请求数量，例如：500个请求。\n    * 设置一个平均响应时间阈值，例如：200毫秒。\n    * 设置一个最大并发数，例如：50个并发请求。\n 2. 针对用户注册的api接口进行限流：\n    * 设置每小时允许通过的请求数量，例如：100个请求。\n    * 设置一个平均响应时间阈值，例如：500毫秒。\n    * 设置一个最大并发数，例如：10个并发请求。\n 3. 针对火车票查询的api接口进行限流：\n    * 设置每秒允许通过的请求数量，例如：200个请求。\n    * 设置一个平均响应时间阈值，例如：100毫秒。\n    * 设置一个最大并发数，例如：20个并发请求。\n\n总而言之，针对预定车票接口设定了单机 qps = 500，然后就快速失败。针对 route id = member 进行限流。\n\n\n# 注意\n\n版本对应：\n\ncom.alibaba.cloud 的版本就包括了它包下面的starter。或许引入 alibaba 的包都需要手动指定版本。\n\n如果这种情况maven无法下到包，就先指定版本号让它去下载\n<dependency>\n    <groupid>com.alibaba.cloud</groupid>\n    <artifactid>spring-cloud-starter-alibaba-sentinel</artifactid>\n</dependency>\n\n<dependency>\n  <groupid>com.alibaba.cloud</groupid>\n  <artifactid>spring-cloud-starter-alibaba-sentinel</artifactid>\n  <version>2022.0.0.0-rc1</version>\n</dependency>\n\n\n\n# todo\n\n需要搞明白：网关限流和具体微服务限流使用上的区别\n\n网关限流可针对 route id 进行统一限流。\n\n具体微服务的限流，更多是对具体的某个api进行限流。\n\nreference:\n\n * https://www.cnblogs.com/gagaxiang/p/17014134.html\n\n * https://juejin.cn/post/7018406221120045087#heading-38 more useful 面经\n\n * https://github.com/alibaba/spring-cloud-alibaba/wiki/%e7%89%88%e6%9c%ac%e8%af%b4%e6%98%8e 版本说明',charsets:{cjk:!0}},{title:"Untitled",frontmatter:{title:"Untitled",date:"2023-04-19T17:04:09.000Z",permalink:"/pages/d16eb4/",article:!1},regularPath:"/temp/spring%20data%20rest.html",relativePath:"temp/spring data rest.md",key:"v-42d727d9",path:"/pages/d16eb4/",headersStr:null,content:"Spring Data REST是基于Spring Data的repository之上，可以把 repository 自动输出为REST资源，目前支持Spring Data JPA、Spring Data MongoDB、Spring Data Neo4j、Spring Data GemFire、Spring Data Cassandra的 repository 自动转换成REST服务。简单点说，Spring Data REST把我们需要编写的大量REST模版接口做了自动化实现。\n\nhttps://cloud.tencent.com/developer/article/1172353",normalizedContent:"spring data rest是基于spring data的repository之上，可以把 repository 自动输出为rest资源，目前支持spring data jpa、spring data mongodb、spring data neo4j、spring data gemfire、spring data cassandra的 repository 自动转换成rest服务。简单点说，spring data rest把我们需要编写的大量rest模版接口做了自动化实现。\n\nhttps://cloud.tencent.com/developer/article/1172353",charsets:{cjk:!0}},{title:"spring-temp",frontmatter:{title:"spring-temp",date:"2023-06-07T10:58:15.000Z",permalink:"/pages/cfda81/"},regularPath:"/temp/spring-temp.html",relativePath:"temp/spring-temp.md",key:"v-91d0c51a",path:"/pages/cfda81/",headersStr:null,content:"spring all temp\n\nbase spring 5.x, current[2023.06.06] is spring 6.0.9\n\nSpringboot实际上通过约定大于配置的方式，使用xx-starter统一的对Bean进行默认初始化，用户只需要很少的配置就可以进行开发了。",normalizedContent:"spring all temp\n\nbase spring 5.x, current[2023.06.06] is spring 6.0.9\n\nspringboot实际上通过约定大于配置的方式，使用xx-starter统一的对bean进行默认初始化，用户只需要很少的配置就可以进行开发了。",charsets:{cjk:!0}},{title:"Untitled",frontmatter:{title:"Untitled",date:"2023-04-16T15:38:03.000Z",permalink:"/pages/9a2825/",article:!1},regularPath:"/temp/springboot3.html",relativePath:"temp/springboot3.md",key:"v-5bbea173",path:"/pages/9a2825/",headers:[{level:2,title:"Springboot3新特性：支持AOT",slug:"springboot3新特性-支持aot",normalizedTitle:"springboot3新特性：支持aot",charIndex:2},{level:2,title:"AOT与JIT",slug:"aot与jit",normalizedTitle:"aot与jit",charIndex:27},{level:2,title:"JIT在高并发场景中的生产问题",slug:"jit在高并发场景中的生产问题",normalizedTitle:"jit在高并发场景中的生产问题",charIndex:279},{level:2,title:"Springboot3下使用GraalVM代替JDK实现AOT",slug:"springboot3下使用graalvm代替jdk实现aot",normalizedTitle:"springboot3下使用graalvm代替jdk实现aot",charIndex:688}],headersStr:"Springboot3新特性：支持AOT AOT与JIT JIT在高并发场景中的生产问题 Springboot3下使用GraalVM代替JDK实现AOT",content:"# Springboot3新特性：支持AOT\n\n\n# AOT与JIT\n\nJIT（Just-in-Time，即时编译），Java 跨平台的基础\n\nAOT（Ahead-of-Time，预编译或提前编译），无法跨平台\n\nAOT 的优点\n\n * 启动和运行速度快。传统springboot空项目启动时间大概是2秒，AOT 的启动时间大概是100毫秒。\n * 打包体积小。 （不用安装 jdk，在 Windows 直接生成 exe 文件）。为云原生。\n\nAOT 的缺点\n\n * 编译后的程序不支持跨平台\n * 不支持动态功能，如AOP。因为不会生成字节码了。\n\n\n# JIT在高并发场景中的生产问题\n\n现象：热点应用重启后，出现业务超时，几分钟后恢复正常。\n\ngraph TD;\n\t开始--\x3ejava文件;\n\tjava文件--编译--\x3eclazz文件;\n\tclazz文件--正常--\x3e解释器;\n\tclazz文件--热点--\x3eJIT编译;\n\t解释器--\x3e系统/硬件;\n\tJIT编译--\x3e系统/硬件;\n\t\n\n\n原因：\n\nJVM混合执行模式，初期以解释方式执行，执行效率慢。当执行次数/频次叨叨制定阈值后，触发JIT编译，编译后，以机器指令码方式执行，执行效率提高。\n\n细节：\n\n启动初期：应用以解释执行，执行效率低，CPU有所上升。\n\n触发JIT编译：CPU&load飙高，请求堆积线程池满，出现请求超时情况。\n\nJIT编译后：CPU降低，请求处理快，服务逐渐恢复。\n\n解决方法：\n\n预热：初试让程序自动执行热点代码几百次。\n\n流量控制：启动时小流量，运行几分钟后再放到正常流量。\n\n\n# Springboot3下使用GraalVM代替JDK实现AOT\n\nGraalVM 也是 oracle 的。\n\n步骤：\n\n 1. GrallVM 安装\n 2. GrallVM 环境变量配置，代替jdk\n 3. 安装 native-image：gu install native-image\n 4. 查看安装结果 gu list\n 5. GrallVM AOT打包：执行 mvn -Pnative native:compile\n 6. 在 target 下会有执行文件",normalizedContent:"# springboot3新特性：支持aot\n\n\n# aot与jit\n\njit（just-in-time，即时编译），java 跨平台的基础\n\naot（ahead-of-time，预编译或提前编译），无法跨平台\n\naot 的优点\n\n * 启动和运行速度快。传统springboot空项目启动时间大概是2秒，aot 的启动时间大概是100毫秒。\n * 打包体积小。 （不用安装 jdk，在 windows 直接生成 exe 文件）。为云原生。\n\naot 的缺点\n\n * 编译后的程序不支持跨平台\n * 不支持动态功能，如aop。因为不会生成字节码了。\n\n\n# jit在高并发场景中的生产问题\n\n现象：热点应用重启后，出现业务超时，几分钟后恢复正常。\n\ngraph td;\n\t开始--\x3ejava文件;\n\tjava文件--编译--\x3eclazz文件;\n\tclazz文件--正常--\x3e解释器;\n\tclazz文件--热点--\x3ejit编译;\n\t解释器--\x3e系统/硬件;\n\tjit编译--\x3e系统/硬件;\n\t\n\n\n原因：\n\njvm混合执行模式，初期以解释方式执行，执行效率慢。当执行次数/频次叨叨制定阈值后，触发jit编译，编译后，以机器指令码方式执行，执行效率提高。\n\n细节：\n\n启动初期：应用以解释执行，执行效率低，cpu有所上升。\n\n触发jit编译：cpu&load飙高，请求堆积线程池满，出现请求超时情况。\n\njit编译后：cpu降低，请求处理快，服务逐渐恢复。\n\n解决方法：\n\n预热：初试让程序自动执行热点代码几百次。\n\n流量控制：启动时小流量，运行几分钟后再放到正常流量。\n\n\n# springboot3下使用graalvm代替jdk实现aot\n\ngraalvm 也是 oracle 的。\n\n步骤：\n\n 1. grallvm 安装\n 2. grallvm 环境变量配置，代替jdk\n 3. 安装 native-image：gu install native-image\n 4. 查看安装结果 gu list\n 5. grallvm aot打包：执行 mvn -pnative native:compile\n 6. 在 target 下会有执行文件",charsets:{cjk:!0}},{title:"project oriented learning",frontmatter:{title:"project oriented learning",date:"2023-05-14T17:11:09.000Z",permalink:"/pages/22b30f/",article:!1},regularPath:"/temp/tip:%20project%20oriented%20learning.html",relativePath:"temp/tip: project oriented learning.md",key:"v-372121bc",path:"/pages/22b30f/",headersStr:null,content:"project oriented learning rather than learning from textbook or course\n\nbig project in mind, break it down into smaller projects smaller goals until eventually you have these thing that feel manageable. if you don't slove, go to a resource like google, stackoverflow, chat gpt, and query ask question until you can figure it out.\n\nstep:\n\n 1. pick a project\n 2. pick a language\n 3. set up your tools\n 4. make sure your tools are working. (hello world)\n 5. iterative refinement\n 6. fall in love~",normalizedContent:"project oriented learning rather than learning from textbook or course\n\nbig project in mind, break it down into smaller projects smaller goals until eventually you have these thing that feel manageable. if you don't slove, go to a resource like google, stackoverflow, chat gpt, and query ask question until you can figure it out.\n\nstep:\n\n 1. pick a project\n 2. pick a language\n 3. set up your tools\n 4. make sure your tools are working. (hello world)\n 5. iterative refinement\n 6. fall in love~",charsets:{}},{title:"Untitled 1",frontmatter:{title:"Untitled 1",date:"2023-05-31T22:45:06.000Z",permalink:"/pages/6796b2/",article:!1},regularPath:"/temp/%E5%85%AB%E8%82%A1-mysql.html",relativePath:"temp/八股-mysql.md",key:"v-4452d00c",path:"/pages/6796b2/",headers:[{level:2,title:"排他锁和共享锁就是写锁和读锁吗？读锁可以是排他锁吗？",slug:"排他锁和共享锁就是写锁和读锁吗-读锁可以是排他锁吗",normalizedTitle:"排他锁和共享锁就是写锁和读锁吗？读锁可以是排他锁吗？",charIndex:2},{level:2,title:"快照读和当前读的区别？什么是当前读，读的是什么时候的数据？",slug:"快照读和当前读的区别-什么是当前读-读的是什么时候的数据",normalizedTitle:"快照读和当前读的区别？什么是当前读，读的是什么时候的数据？",charIndex:552},{level:2,title:"mvcc 和锁的关系？",slug:"mvcc-和锁的关系",normalizedTitle:"mvcc 和锁的关系？",charIndex:1432},{level:2,title:"序列化的隔离级别是怎么实现的？加的锁是什么锁？是临间锁吗？",slug:"序列化的隔离级别是怎么实现的-加的锁是什么锁-是临间锁吗",normalizedTitle:"序列化的隔离级别是怎么实现的？加的锁是什么锁？是临间锁吗？",charIndex:2163},{level:2,title:"innodb 可重复读隔离级别下还会发生幻读吗？",slug:"innodb-可重复读隔离级别下还会发生幻读吗",normalizedTitle:"innodb 可重复读隔离级别下还会发生幻读吗？",charIndex:2424}],headersStr:"排他锁和共享锁就是写锁和读锁吗？读锁可以是排他锁吗？ 快照读和当前读的区别？什么是当前读，读的是什么时候的数据？ mvcc 和锁的关系？ 序列化的隔离级别是怎么实现的？加的锁是什么锁？是临间锁吗？ innodb 可重复读隔离级别下还会发生幻读吗？",content:"# 排他锁和共享锁就是写锁和读锁吗？读锁可以是排他锁吗？\n\n总的来说，排他锁（Exclusive Lock）是写锁，用于保护数据对象的一致性和完整性，而共享锁（Shared Lock）通常是读锁，用于允许多个事务并发读取数据对象。在某些数据库系统中，排他锁也可以被用作读锁。\n\n**共享锁 Shared Lock，**又称为读锁，获得共享锁之后，可以查看但无法修改和删除数据。\n\n**排他锁 Exclusive Lock，**又称为写锁、独占锁，获得排他锁之后，既能读数据，又能修改数据。\n\n使用共享锁：SELECT ... LOCK IN SHARE MODE;\n\n当没有其他线程对查询结果集中的任何一行使用排他锁时，可以成功申请共享锁，否则会被阻塞。其他线程也可以读取使用了共享锁的表，而且这些线程读取的是同一个版本的数据。\n\n使用排他锁：SELECT ... FOR UPDATE;\n\n当没有其他线程对查询结果集中的任何一行使用排他锁时，可以成功申请排他锁，否则会被阻塞。\n\nMySql的InnoDB引擎来说，对于insert、update、delete等操作。会自动给涉及的数据加排他锁；对于一般的select语句，InnoDB不会加任何锁，事务可以通过以下语句给显示加共享锁或排他锁。\n\n\n# 快照读和当前读的区别？什么是当前读，读的是什么时候的数据？\n\n快照读（Snapshot Read），也称为当前读，是基于数据库的一致性视图来读取数据。它读取的是事务开始时数据库中的数据快照，即某个特定时刻的数据。这意味着无论其他事务是否正在修改数据，快照读始终读取的是一致的、静态的数据快照。快照读不会受到其他并发事务的修改操作的影响，因此可以提供较高的并发性能。\n\n快照读读取的是记录数据的可见版本，不加锁，不加锁的普通select语句都是快照读，即不加锁的非阻塞读。\n\n快照读的执行方式是生成 ReadView，直接利用 MVCC 机制来进行读取，并不会对记录进行加锁。\n\n当前读（Current Read），也称为锁定读，是基于当前事务的最新数据来读取数据。它读取的是其他事务已经提交的最新数据。当前读会获取最新的数据，这包括了其他并发事务已经提交的修改。当前读可以读取其他事务所做的更改，因此可以提供实时的数据，但同时也可能会受到其他并发事务的影响。如果其他事务正在修改被当前读操作所涉及的数据，可能会导致读取到不一致的数据或者读取操作被阻塞。\n\n当前读读取的是记录数据的最新版本，并且需要先获取对应记录的锁。\n\nSELECT * FROM student LOCK IN SHARE MODE;  # 共享锁\nSELECT * FROM student FOR UPDATE; # 排他锁\nINSERT INTO student values ...  # 排他锁\nDELETE FROM student WHERE ...  # 排他锁\nUPDATE student SET ...  # 排他锁\n\n\n总结起来，快照读是基于事务开始时的数据快照进行读取，而当前读是基于当前事务的最新数据进行读取。当前读可以提供实时的数据，但可能受到并发事务的影响。\n\nMVCC在快照读的情况下可以解决幻读问题，但是在当前读的情况下是不能解决幻读的。\n\nhttps://cloud.tencent.com/developer/article/2123130\n\n\n# mvcc 和锁的关系？\n\nMVCC（Multi-Version Concurrency Control）和锁是数据库中并发控制的两种不同机制。\n\n在MySQL数据库的InnoDB存储引擎中，MVCC和锁机制是相互配合使用的并发控制策略。\n\nInnoDB使用MVCC来实现读操作的并发性。每个事务在开始时会创建一个事务私有的数据快照（也称为读视图），读操作只会读取该数据快照中的数据。这意味着并发事务可以同时读取同一数据对象，而不会互相干扰。MVCC使用了版本号和回滚段（undo log）的机制来管理数据版本和回滚操作，以确保事务读取的是一致性的数据视图。\n\n同时，InnoDB也使用锁机制来管理并发写操作。在写操作中，InnoDB会根据需要使用行级别的锁来保护数据的一致性。读操作不会加锁，允许并发读取，但写操作可能会涉及锁的获取和释放。InnoDB提供了两种类型的锁：共享锁（Shared Lock）和排他锁（Exclusive Lock）。共享锁允许多个事务同时读取同一数据对象，而排他锁在写操作时会阻止其他事务读取或写入该数据对象。\n\nMVCC和锁机制在InnoDB存储引擎中协同工作，以实现数据的一致性和并发性。MVCC机制用于读操作，提供了高度的并发性能，允许多个事务同时读取数据。锁机制用于写操作，通过锁定行级别的资源来保护数据的一致性，避免并发事务的冲突。\n\n需要注意的是，MVCC和锁的具体行为和使用方式在不同的隔离级别下可能会有所不同。MySQL提供了多个隔离级别（如读未提交、读已提交、可重复读和串行化），每个隔离级别对于MVCC和锁的使用方式和粒度可能会有所调整。\n\n（confuse，读操作都用MVCC了，那共享锁用在哪呢？）\n\n\n# 序列化的隔离级别是怎么实现的？加的锁是什么锁？是临间锁吗？\n\n为了实现序列化隔离级别，MySQL使用了两种类型的锁：临键锁（Next-Key Locks）和间隙锁（Gap Locks）。（还需要间隙锁吗？）\n\n临键锁用于保护索引键值和范围，防止其他事务对相同的键值范围进行插入、更新或删除操作。当一个事务获取了临键锁时，其他事务无法对相同的索引键值范围进行修改，从而实现了串行化的效果。\n\n间隙锁用于保护索引键值之间的间隙（即不存在的键值范围）。它防止其他事务在这个间隙中插入新的索引键值，从而避免了幻读的问题。\n\n\n# innodb 可重复读隔离级别下还会发生幻读吗？",normalizedContent:"# 排他锁和共享锁就是写锁和读锁吗？读锁可以是排他锁吗？\n\n总的来说，排他锁（exclusive lock）是写锁，用于保护数据对象的一致性和完整性，而共享锁（shared lock）通常是读锁，用于允许多个事务并发读取数据对象。在某些数据库系统中，排他锁也可以被用作读锁。\n\n**共享锁 shared lock，**又称为读锁，获得共享锁之后，可以查看但无法修改和删除数据。\n\n**排他锁 exclusive lock，**又称为写锁、独占锁，获得排他锁之后，既能读数据，又能修改数据。\n\n使用共享锁：select ... lock in share mode;\n\n当没有其他线程对查询结果集中的任何一行使用排他锁时，可以成功申请共享锁，否则会被阻塞。其他线程也可以读取使用了共享锁的表，而且这些线程读取的是同一个版本的数据。\n\n使用排他锁：select ... for update;\n\n当没有其他线程对查询结果集中的任何一行使用排他锁时，可以成功申请排他锁，否则会被阻塞。\n\nmysql的innodb引擎来说，对于insert、update、delete等操作。会自动给涉及的数据加排他锁；对于一般的select语句，innodb不会加任何锁，事务可以通过以下语句给显示加共享锁或排他锁。\n\n\n# 快照读和当前读的区别？什么是当前读，读的是什么时候的数据？\n\n快照读（snapshot read），也称为当前读，是基于数据库的一致性视图来读取数据。它读取的是事务开始时数据库中的数据快照，即某个特定时刻的数据。这意味着无论其他事务是否正在修改数据，快照读始终读取的是一致的、静态的数据快照。快照读不会受到其他并发事务的修改操作的影响，因此可以提供较高的并发性能。\n\n快照读读取的是记录数据的可见版本，不加锁，不加锁的普通select语句都是快照读，即不加锁的非阻塞读。\n\n快照读的执行方式是生成 readview，直接利用 mvcc 机制来进行读取，并不会对记录进行加锁。\n\n当前读（current read），也称为锁定读，是基于当前事务的最新数据来读取数据。它读取的是其他事务已经提交的最新数据。当前读会获取最新的数据，这包括了其他并发事务已经提交的修改。当前读可以读取其他事务所做的更改，因此可以提供实时的数据，但同时也可能会受到其他并发事务的影响。如果其他事务正在修改被当前读操作所涉及的数据，可能会导致读取到不一致的数据或者读取操作被阻塞。\n\n当前读读取的是记录数据的最新版本，并且需要先获取对应记录的锁。\n\nselect * from student lock in share mode;  # 共享锁\nselect * from student for update; # 排他锁\ninsert into student values ...  # 排他锁\ndelete from student where ...  # 排他锁\nupdate student set ...  # 排他锁\n\n\n总结起来，快照读是基于事务开始时的数据快照进行读取，而当前读是基于当前事务的最新数据进行读取。当前读可以提供实时的数据，但可能受到并发事务的影响。\n\nmvcc在快照读的情况下可以解决幻读问题，但是在当前读的情况下是不能解决幻读的。\n\nhttps://cloud.tencent.com/developer/article/2123130\n\n\n# mvcc 和锁的关系？\n\nmvcc（multi-version concurrency control）和锁是数据库中并发控制的两种不同机制。\n\n在mysql数据库的innodb存储引擎中，mvcc和锁机制是相互配合使用的并发控制策略。\n\ninnodb使用mvcc来实现读操作的并发性。每个事务在开始时会创建一个事务私有的数据快照（也称为读视图），读操作只会读取该数据快照中的数据。这意味着并发事务可以同时读取同一数据对象，而不会互相干扰。mvcc使用了版本号和回滚段（undo log）的机制来管理数据版本和回滚操作，以确保事务读取的是一致性的数据视图。\n\n同时，innodb也使用锁机制来管理并发写操作。在写操作中，innodb会根据需要使用行级别的锁来保护数据的一致性。读操作不会加锁，允许并发读取，但写操作可能会涉及锁的获取和释放。innodb提供了两种类型的锁：共享锁（shared lock）和排他锁（exclusive lock）。共享锁允许多个事务同时读取同一数据对象，而排他锁在写操作时会阻止其他事务读取或写入该数据对象。\n\nmvcc和锁机制在innodb存储引擎中协同工作，以实现数据的一致性和并发性。mvcc机制用于读操作，提供了高度的并发性能，允许多个事务同时读取数据。锁机制用于写操作，通过锁定行级别的资源来保护数据的一致性，避免并发事务的冲突。\n\n需要注意的是，mvcc和锁的具体行为和使用方式在不同的隔离级别下可能会有所不同。mysql提供了多个隔离级别（如读未提交、读已提交、可重复读和串行化），每个隔离级别对于mvcc和锁的使用方式和粒度可能会有所调整。\n\n（confuse，读操作都用mvcc了，那共享锁用在哪呢？）\n\n\n# 序列化的隔离级别是怎么实现的？加的锁是什么锁？是临间锁吗？\n\n为了实现序列化隔离级别，mysql使用了两种类型的锁：临键锁（next-key locks）和间隙锁（gap locks）。（还需要间隙锁吗？）\n\n临键锁用于保护索引键值和范围，防止其他事务对相同的键值范围进行插入、更新或删除操作。当一个事务获取了临键锁时，其他事务无法对相同的索引键值范围进行修改，从而实现了串行化的效果。\n\n间隙锁用于保护索引键值之间的间隙（即不存在的键值范围）。它防止其他事务在这个间隙中插入新的索引键值，从而避免了幻读的问题。\n\n\n# innodb 可重复读隔离级别下还会发生幻读吗？",charsets:{cjk:!0}},{title:"小知识",frontmatter:{title:"小知识",date:"2023-05-13T16:15:31.000Z",permalink:"/pages/7c006d/",article:!1},regularPath:"/temp/%E5%B0%8F%E7%9F%A5%E8%AF%86.html",relativePath:"temp/小知识.md",key:"v-5c5b6663",path:"/pages/7c006d/",headersStr:null,content:'java 的配置文件，一般除了使用 xml, yaml, properties，还可以使用 java class 的方式。一般框架会提供对应的类让你注入配置。\n\n如 dubbo: 下面这个配置类class就等价于写在配置文件中配置 dubbo 参数。\n\n@Configuration\n@DubboComponentScan(basePackages = "com.alibaba.csp.sentinel.demo.service")\npublic class ProviderConfig {\n    @Bean\n    public ApplicationConfig applicationConfig() {\n        ApplicationConfig applicationConfig = new ApplicationConfig();\n        applicationConfig.setName("demo-provider");\n        return applicationConfig;\n    }\n\n    @Bean\n    public RegistryConfig registryConfig() {\n        RegistryConfig registryConfig = new RegistryConfig();\n        registryConfig.setAddress("multicast://224.5.6.7:1234");\n        return registryConfig;\n    }\n\n    @Bean\n    public ProtocolConfig protocolConfig() {\n        ProtocolConfig protocolConfig = new ProtocolConfig();\n        protocolConfig.setName("dubbo");\n        protocolConfig.setPort(25758);\n        return protocolConfig;\n    }\n}\n\n\ndubbo:\n  application:\n    name: demo-provider\n  protocol:\n    name: dubbo\n    port: 25758\n  registry:\n    address: multicast://224.5.6.7:1234\n',normalizedContent:'java 的配置文件，一般除了使用 xml, yaml, properties，还可以使用 java class 的方式。一般框架会提供对应的类让你注入配置。\n\n如 dubbo: 下面这个配置类class就等价于写在配置文件中配置 dubbo 参数。\n\n@configuration\n@dubbocomponentscan(basepackages = "com.alibaba.csp.sentinel.demo.service")\npublic class providerconfig {\n    @bean\n    public applicationconfig applicationconfig() {\n        applicationconfig applicationconfig = new applicationconfig();\n        applicationconfig.setname("demo-provider");\n        return applicationconfig;\n    }\n\n    @bean\n    public registryconfig registryconfig() {\n        registryconfig registryconfig = new registryconfig();\n        registryconfig.setaddress("multicast://224.5.6.7:1234");\n        return registryconfig;\n    }\n\n    @bean\n    public protocolconfig protocolconfig() {\n        protocolconfig protocolconfig = new protocolconfig();\n        protocolconfig.setname("dubbo");\n        protocolconfig.setport(25758);\n        return protocolconfig;\n    }\n}\n\n\ndubbo:\n  application:\n    name: demo-provider\n  protocol:\n    name: dubbo\n    port: 25758\n  registry:\n    address: multicast://224.5.6.7:1234\n',charsets:{cjk:!0}},{title:"日语-promt",frontmatter:{title:"日语-promt",date:"2023-05-11T16:54:32.000Z",permalink:"/pages/fba198/",article:!1},regularPath:"/temp/%E6%97%A5%E8%AF%AD-promt.html",relativePath:"temp/日语-promt.md",key:"v-c4807e92",path:"/pages/fba198/",headersStr:null,content:"你是一位优秀的日语老师，每当我输入一个句子，你需要完成以下任务：\n\ntask1：提取句子中存在的单词\n\nforeach task1'result\n\ntask1.1：标出单词词性、罗马音、中文释义、英文释义、词根词缀起源故事，如果是动词的话，标出单词的辞书型，以及当前是什么形态，一行一个\n\ntask1.2：用这个单词造三个工作场景日语例句附日文翻译\n\n将以上task1任务结果按以下Markdown格式排版循环输出：\n\n### 单词释义\n\n<task1.1 result>\n\n### 场景例句\n\n<task1.2 result>\n\n第一个句子是：無敵の笑顔で荒らすメディア",normalizedContent:"你是一位优秀的日语老师，每当我输入一个句子，你需要完成以下任务：\n\ntask1：提取句子中存在的单词\n\nforeach task1'result\n\ntask1.1：标出单词词性、罗马音、中文释义、英文释义、词根词缀起源故事，如果是动词的话，标出单词的辞书型，以及当前是什么形态，一行一个\n\ntask1.2：用这个单词造三个工作场景日语例句附日文翻译\n\n将以上task1任务结果按以下markdown格式排版循环输出：\n\n### 单词释义\n\n<task1.1 result>\n\n### 场景例句\n\n<task1.2 result>\n\n第一个句子是：無敵の笑顔で荒らすメディア",charsets:{cjk:!0}},{title:"Untitled",frontmatter:{title:"Untitled",date:"2023-04-16T14:14:25.000Z",permalink:"/pages/5da819/",article:!1},regularPath:"/temp/%E6%97%A5%E8%AF%AD%E5%8A%A8%E8%AF%8D.html",relativePath:"temp/日语动词.md",key:"v-3fb4f800",path:"/pages/5da819/",headers:[{level:2,title:"动词分类",slug:"动词分类",normalizedTitle:"动词分类",charIndex:2},{level:2,title:"五段动词和一段动词的对比（gpt答案有待改良）",slug:"五段动词和一段动词的对比-gpt答案有待改良",normalizedTitle:"五段动词和一段动词的对比（gpt答案有待改良）",charIndex:301},{level:2,title:"动词原型转ます型",slug:"动词原型转ます型",normalizedTitle:"动词原型转ます型",charIndex:679}],headersStr:"动词分类 五段动词和一段动词的对比（gpt答案有待改良） 动词原型转ます型",content:"# 动词分类\n\n * 一类动词（五段动词）：\n\n词干+u段词尾：以「る」结尾，「る」前假名不在「い」段或「え」段以及所有不是以「る」结尾的动词。\n\n有一些特殊的五段动词，形态上属于一段动词，但实际的词形变化是按照五段动词变化规律进行的，如：「帰（かえ）る」、「要（い）る」、「切（き）る」、「入（はい）る」、「走（はし）る」等。\n\n * 二类动词（一段动词）：\n\n词干+iru/eru：以「る」结尾，「る」前假名在「い」段或「え」段的动词。\n\n有十几个特殊的，其词干词尾是一体的，其实是五段动词。\n\n * 三类动词（サ、カ变动词）：\n\nサ变：する以及以「する」结尾的动词。\n\nカ变：来（く）る\n\n\n# 五段动词和一段动词的对比（gpt答案有待改良）\n\n五段动词的词干以五种不同的辅音结尾（k/g/s/t/n），如“飲む (nomu)”、“泳ぐ (oyogu)”、“書く (kaku)”、“死ぬ (shinu)”、“話す (hanasu)”等。\n\n这些动词在变形时，根据其词干的不同辅音，采用不同的变形规则，变形形式相对较多，但也更加规律化。例如，在五段动词中，现在时的词干是动词词干的最后一个音节，加上相应的后缀即可，如“書く”变为“書きます（kakimasu）”、“泳ぐ”变为“泳ぎます（oyogimasu）”。\n\n一段动词的词干以辅音结尾，比如“食べる (taberu)”、“見る (miru)”、“寝る (neru)”等。这些动词的变形比较简单，只需将词干后面的“る”去掉，再加上相应的后缀即可，例如变为否定形式时加上“ない”（nai）即可。\n\n\n# 动词原型转ます型\n\n一、二、三类动词原型转换为ます型的变形规则：\n\n类型     原型（辞书型）    变形规则                   ます型\n一类动词   書く（かく）     将词尾的う段变为い段，然后加上“-ます”   書きます\n二类动词   食べる（たべる）   去る加上“-ます”              食べます\n三类动词   する         将“する”变为“します”           します\n三类动词   （来る）くる     将くる变きます                来ます",normalizedContent:"# 动词分类\n\n * 一类动词（五段动词）：\n\n词干+u段词尾：以「る」结尾，「る」前假名不在「い」段或「え」段以及所有不是以「る」结尾的动词。\n\n有一些特殊的五段动词，形态上属于一段动词，但实际的词形变化是按照五段动词变化规律进行的，如：「帰（かえ）る」、「要（い）る」、「切（き）る」、「入（はい）る」、「走（はし）る」等。\n\n * 二类动词（一段动词）：\n\n词干+iru/eru：以「る」结尾，「る」前假名在「い」段或「え」段的动词。\n\n有十几个特殊的，其词干词尾是一体的，其实是五段动词。\n\n * 三类动词（サ、カ变动词）：\n\nサ变：する以及以「する」结尾的动词。\n\nカ变：来（く）る\n\n\n# 五段动词和一段动词的对比（gpt答案有待改良）\n\n五段动词的词干以五种不同的辅音结尾（k/g/s/t/n），如“飲む (nomu)”、“泳ぐ (oyogu)”、“書く (kaku)”、“死ぬ (shinu)”、“話す (hanasu)”等。\n\n这些动词在变形时，根据其词干的不同辅音，采用不同的变形规则，变形形式相对较多，但也更加规律化。例如，在五段动词中，现在时的词干是动词词干的最后一个音节，加上相应的后缀即可，如“書く”变为“書きます（kakimasu）”、“泳ぐ”变为“泳ぎます（oyogimasu）”。\n\n一段动词的词干以辅音结尾，比如“食べる (taberu)”、“見る (miru)”、“寝る (neru)”等。这些动词的变形比较简单，只需将词干后面的“る”去掉，再加上相应的后缀即可，例如变为否定形式时加上“ない”（nai）即可。\n\n\n# 动词原型转ます型\n\n一、二、三类动词原型转换为ます型的变形规则：\n\n类型     原型（辞书型）    变形规则                   ます型\n一类动词   書く（かく）     将词尾的う段变为い段，然后加上“-ます”   書きます\n二类动词   食べる（たべる）   去る加上“-ます”              食べます\n三类动词   する         将“する”变为“します”           します\n三类动词   （来る）くる     将くる变きます                来ます",charsets:{cjk:!0}},{title:"集群和分布式",frontmatter:{title:"集群和分布式",date:"2023-05-08T20:44:52.000Z",permalink:"/pages/263c98/",article:!1},regularPath:"/temp/%E9%9B%86%E7%BE%A4%E5%92%8C%E5%88%86%E5%B8%83%E5%BC%8F.html",relativePath:"temp/集群和分布式.md",key:"v-dbde7360",path:"/pages/263c98/",headersStr:null,content:"https://developer.aliyun.com/article/44562\n\n分布式是指将不同的业务分布在不同的地方；而集群指的是将几台服务器集中在一起，实现同一业务。\n\n分布式中的每一个节点，都可以做集群。 而集群并不一定就是分布式的。\n\n简单说，分布式是以缩短单个任务的执行时间来提升效率的，而集群则是通过提高单位时间内执行的任务数来提升效率。\n\n例如：如果一个任务由10个子任务组成，每个子任务单独执行需1小时，则在一台服务器上执行改任务需10小时。\n\n采用分布式方案，提供10台服务器，每台服务器只负责处理一个子任务，不考虑子任务间的依赖关系，执行完这个任务只需一个小时。(这种工作模式的一个典型代表就是Hadoop的Map/Reduce分布式计算模型）\n\n而采用集群方案，同样提供10台服务器，每台服务器都能独立处理这个任务。假设有10个任务同时到达，10个服务器将同时工作，10小后，10个任务同时完成，这样，整身来看，还是1小时内完成一个任务！\n\nredis sentinel 算分布式吗？\n\nRedis Sentinel并不是一个严格意义上的分布式系统，而是Redis提供的一个高可用性解决方案。Redis Sentinel通过运行多个Redis实例来提供故障转移和自动故障恢复功能，使Redis在发生主节点故障时能够自动切换到备用节点。\n\n在Redis Sentinel中，一个主节点可以有多个备用节点，每个备用节点都可以自动接管主节点的工作。当主节点发生故障时，Redis Sentinel会自动从备用节点中选举一个新的主节点，并将新的主节点信息广播给所有客户端。这样，客户端就可以无感知地继续使用Redis服务，而无需手动切换主节点。\n\n虽然Redis Sentinel本身不是一个分布式系统，但它可以通过运行多个Redis实例来提高Redis服务的可用性和容错能力，使得Redis集群更加健壮和可靠。因此，在某些场景下，Redis Sentinel也可以被看作是一种分布式解决方案。",normalizedContent:"https://developer.aliyun.com/article/44562\n\n分布式是指将不同的业务分布在不同的地方；而集群指的是将几台服务器集中在一起，实现同一业务。\n\n分布式中的每一个节点，都可以做集群。 而集群并不一定就是分布式的。\n\n简单说，分布式是以缩短单个任务的执行时间来提升效率的，而集群则是通过提高单位时间内执行的任务数来提升效率。\n\n例如：如果一个任务由10个子任务组成，每个子任务单独执行需1小时，则在一台服务器上执行改任务需10小时。\n\n采用分布式方案，提供10台服务器，每台服务器只负责处理一个子任务，不考虑子任务间的依赖关系，执行完这个任务只需一个小时。(这种工作模式的一个典型代表就是hadoop的map/reduce分布式计算模型）\n\n而采用集群方案，同样提供10台服务器，每台服务器都能独立处理这个任务。假设有10个任务同时到达，10个服务器将同时工作，10小后，10个任务同时完成，这样，整身来看，还是1小时内完成一个任务！\n\nredis sentinel 算分布式吗？\n\nredis sentinel并不是一个严格意义上的分布式系统，而是redis提供的一个高可用性解决方案。redis sentinel通过运行多个redis实例来提供故障转移和自动故障恢复功能，使redis在发生主节点故障时能够自动切换到备用节点。\n\n在redis sentinel中，一个主节点可以有多个备用节点，每个备用节点都可以自动接管主节点的工作。当主节点发生故障时，redis sentinel会自动从备用节点中选举一个新的主节点，并将新的主节点信息广播给所有客户端。这样，客户端就可以无感知地继续使用redis服务，而无需手动切换主节点。\n\n虽然redis sentinel本身不是一个分布式系统，但它可以通过运行多个redis实例来提高redis服务的可用性和容错能力，使得redis集群更加健壮和可靠。因此，在某些场景下，redis sentinel也可以被看作是一种分布式解决方案。",charsets:{cjk:!0}},{title:"归档",frontmatter:{archivesPage:!0,title:"归档",permalink:"/archives/",article:!1},regularPath:"/@pages/archivesPage.html",relativePath:"@pages/archivesPage.md",key:"v-61301819",path:"/archives/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2023/03/17, 19:41:31",lastUpdatedTimestamp:1679053291e3},{title:"Home",frontmatter:{home:!0,heroImage:"/img/logo.gif",heroText:"Boundless Wiki",tagline:"知识管理",actionText:"总览 →",actionLink:"/pages/home/",bannerBg:"none",features:null,postList:"detailed"},regularPath:"/",relativePath:"index.md",key:"v-262c459c",path:"/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2023/03/29, 21:03:43",lastUpdatedTimestamp:1680095023e3},{title:"知识体系总览",frontmatter:{title:"知识体系总览",date:"2023-03-16T23:01:35.000Z",permalink:"/pages/home/"},regularPath:"/%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E6%80%BB%E8%A7%88.html",relativePath:"知识体系总览.md",key:"v-36ff78c4",path:"/pages/home/",headers:[{level:2,title:"Java",slug:"java",normalizedTitle:"java",charIndex:2},{level:2,title:"Java框架",slug:"java框架",normalizedTitle:"java框架",charIndex:544},{level:2,title:"MySQL",slug:"mysql",normalizedTitle:"mysql",charIndex:722},{level:2,title:"Redis",slug:"redis",normalizedTitle:"redis",charIndex:759},{level:2,title:"中间件",slug:"中间件",normalizedTitle:"中间件",charIndex:922},{level:2,title:"计算机网络",slug:"计算机网络",normalizedTitle:"计算机网络",charIndex:1007},{level:2,title:"计算机组成原理",slug:"计算机组成原理",normalizedTitle:"计算机组成原理",charIndex:1049},{level:2,title:"工具",slug:"工具",normalizedTitle:"工具",charIndex:1061},{level:2,title:"Linux",slug:"linux",normalizedTitle:"linux",charIndex:1107},{level:2,title:"架构设计",slug:"架构设计",normalizedTitle:"架构设计",charIndex:1117},{level:2,title:"分布式",slug:"分布式",normalizedTitle:"分布式",charIndex:1126},{level:2,title:"前端",slug:"前端",normalizedTitle:"前端",charIndex:1134},{level:2,title:"大数据",slug:"大数据",normalizedTitle:"大数据",charIndex:1172}],headersStr:"Java Java框架 MySQL Redis 中间件 计算机网络 计算机组成原理 工具 Linux 架构设计 分布式 前端 大数据",content:"# Java\n\n * Java基础\n * Java集合\n   * ArrayList\n   * HashMap\n * JVM\n   * Java内存模型\n   * 类加载机制\n   * JVM垃圾回收\n   * Java内存区域（运行时数据区域）\n   * 虚拟机对象\n   * OutOfMemoryError\n   * 字节码增强技术\n * Java 并发\n   * synchronized 和 volatile\n   * ReentrantLock\n   * ReentrantReadWriteLock\n   * AQS\n   * ThreadLocal\n   * ThreadPoolExecutor\n   * Semaphore\n   * CountDownLatch\n   * CyclicBarrier\n   * Atomic\n   * 并发容器：\n     * ConcurrentHashMap：HashMap\n     * CopyOnWriteArrayList：List\n     * BlockingQueue\n     * ConcurrentSkipListMap\n     * ConcurrentLinkedQueue：LinkedList\n\n\n# Java框架\n\n * Spring\n * Spring MVC\n * Spring Boot\n * Mybatis\n * Spring Cloud\n   * nacos\n   * eruka\n   * spring cloud sentinel\n   * spring cloud gateway\n   * spring cloud config\n\n\n# MySQL\n\n * 索引\n * 优化\n * 事务\n * 分库分表\n\n\n# Redis\n\n * Redis数据类型\n\n * Redis数据结构\n\n * Redis 持久化\n\n * Redis高可用\n   \n   * 主从\n   \n   * sentinel\n   \n   * redis cluster\n\n * Redis删除策略及内存淘汰机制\n\n * 缓存场景问题\n\n * Redis场景题\n\n\n# 中间件\n\n * rocketmq\n\n * dubbo\n\n * zookeeper\n\n * MongoDB\n\n * kafka\n\n * ElasticSearch\n\n\n# 计算机网络\n\n * HTTP\n\n * TCP\n\n * IP\n\n * DNS\n\n\n# 计算机组成原理\n\n\n# 工具\n\n * maven\n\n * git\n\n * nginx\n\n * docker\n\n\n# Linux\n\n\n# 架构设计\n\n\n# 分布式\n\n\n# 前端\n\n * javaScript\n * react\n * vue\n\n\n# 大数据\n\n * haddop\n * hdfs\n * mapReduce\n * spark\n * hive\n * clickHouse",normalizedContent:"# java\n\n * java基础\n * java集合\n   * arraylist\n   * hashmap\n * jvm\n   * java内存模型\n   * 类加载机制\n   * jvm垃圾回收\n   * java内存区域（运行时数据区域）\n   * 虚拟机对象\n   * outofmemoryerror\n   * 字节码增强技术\n * java 并发\n   * synchronized 和 volatile\n   * reentrantlock\n   * reentrantreadwritelock\n   * aqs\n   * threadlocal\n   * threadpoolexecutor\n   * semaphore\n   * countdownlatch\n   * cyclicbarrier\n   * atomic\n   * 并发容器：\n     * concurrenthashmap：hashmap\n     * copyonwritearraylist：list\n     * blockingqueue\n     * concurrentskiplistmap\n     * concurrentlinkedqueue：linkedlist\n\n\n# java框架\n\n * spring\n * spring mvc\n * spring boot\n * mybatis\n * spring cloud\n   * nacos\n   * eruka\n   * spring cloud sentinel\n   * spring cloud gateway\n   * spring cloud config\n\n\n# mysql\n\n * 索引\n * 优化\n * 事务\n * 分库分表\n\n\n# redis\n\n * redis数据类型\n\n * redis数据结构\n\n * redis 持久化\n\n * redis高可用\n   \n   * 主从\n   \n   * sentinel\n   \n   * redis cluster\n\n * redis删除策略及内存淘汰机制\n\n * 缓存场景问题\n\n * redis场景题\n\n\n# 中间件\n\n * rocketmq\n\n * dubbo\n\n * zookeeper\n\n * mongodb\n\n * kafka\n\n * elasticsearch\n\n\n# 计算机网络\n\n * http\n\n * tcp\n\n * ip\n\n * dns\n\n\n# 计算机组成原理\n\n\n# 工具\n\n * maven\n\n * git\n\n * nginx\n\n * docker\n\n\n# linux\n\n\n# 架构设计\n\n\n# 分布式\n\n\n# 前端\n\n * javascript\n * react\n * vue\n\n\n# 大数据\n\n * haddop\n * hdfs\n * mapreduce\n * spark\n * hive\n * clickhouse",charsets:{cjk:!0},lastUpdated:"2023/03/29, 21:03:43",lastUpdatedTimestamp:1680095023e3}],themeConfig:{nav:[{text:"首页",link:"/"},{text:"知识体系总览",link:"/pages/home/"},{text:"Java",link:"/pages/java/",items:[{text:"Java 基础",link:"/pages/java/"},{text:"Java 集合",link:"/pages/collection/"},{text:"Java 虚拟机",link:"/pages/jvm/"},{text:"Java 并发",link:"/pages/concurrent/"},{text:"Java框架",link:"/pages/spring/",items:[{text:"Spring",link:"/pages/spring/"},{text:"Spring MVC",link:"/pages/springmvc/"},{text:"Spring Boot",link:"/pages/springboot/"},{text:"MyBatis",link:"/pages/mybatis/"}]}]},{text:"MySQL",link:"/pages/mysql/"},{text:"Redis",link:"/pages/redis/"},{text:"计算机基础",items:[{text:"计算机网络",link:"/pages/network/"},{text:"操作系统",link:"/pages/os/"}]},{text:"前端",items:[{text:"React",link:"/pages/redux/"}]},{text:"中间件",link:"/pages/mq/"},{text:"方案",link:"/pages/jwt/"},{text:"工具",items:[{text:"Git",link:"/pages/git/"},{text:"Linux",link:"/pages/linux/"},{text:"Docker",link:"/pages/docker/"}]},{text:"AI",link:"/pages/aitools/",items:[{text:"AI tools",link:"/pages/aitools/"}]},{text:"归档",link:"/archives/"}],sidebarDepth:2,logo:"/img/logo.gif",repo:"egoistsh",searchMaxSuggestions:10,lastUpdated:"上次更新",sidebar:{"/01.Java/":[{title:"Java基础",collapsable:!1,children:[["01.Java基础/01.Java汇总.md","Java 汇总","/pages/java/"],["01.Java基础/02.接口和抽象类的区别.md","接口和抽象类的区别","/pages/2ed256/"],["01.Java基础/03.反射相关.md","反射相关","/pages/66f85c/"],["01.Java基础/100.语法记录.md","语法记录","/pages/d95f75/"]]},{title:"Java集合",collapsable:!1,children:[["02.Java集合/01.ArrayList.md","ArrayList","/pages/collection/"],["02.Java集合/02.HashMap.md","HashMap","/pages/d249ac/"],["02.Java集合/03. BlockingQueue.md","BlockingQueue","/pages/86b6a3/"],["02.Java集合/04.LinkedList和ArrayDeque.md","LinkedList和ArrayDeque","/pages/cbcb60/"]]},{title:"JVM",collapsable:!1,children:[["03.JVM/01.Java内存模型.md","Java内存模型","/pages/jvm/"],["03.JVM/02.类加载机制.md","类加载机制","/pages/7d816e/"],["03.JVM/03.JVM垃圾回收.md","JVM垃圾回收","/pages/a934e8/"],["03.JVM/04.Java内存区域（运行时数据区）.md","Java内存区域（运行时数据区）","/pages/8ffeca/"],["03.JVM/05.虚拟机对象.md","虚拟机对象","/pages/376408/"],["03.JVM/06.OutOfMemoryError.md","OutOfMemoryError","/pages/9a5ae7/"],["03.JVM/07.如何快速排查问题.md","如何快速排查问题","/pages/1a4e69/"],["03.JVM/08.JIT逃逸分析.md","JIT逃逸分析","/pages/1ee611/"],["03.JVM/100.字节码增强技术.md","字节码增强技术","/pages/9a3179/"],["03.JVM/101.《深入理解Java虚拟机》.md","《深入理解Java虚拟机-第三版》","/pages/9cc971/"]]},{title:"Java并发",collapsable:!1,children:[["04.Java并发/01.synchronized和volatile.md","synchronized和volatile","/pages/concurrent/"],["04.Java并发/02.TreadLocal.md","ThreadLocal","/pages/41602c/"],["04.Java并发/03.ReentrantLock.md","ReentranLock","/pages/d1bd01/"],["04.Java并发/04.ConcurrentHashMap.md","ConcurrentHashMap","/pages/019d22/"],["04.Java并发/05.ThreadPoolExecutor.md","ThreadPoolExecutor","/pages/854033/"],["04.Java并发/06.Future & CompletableFuture.md","Future & CompletableFuture","/pages/9862ed/"],["04.Java并发/07.从线程到Java的锁机制.md","从线程到Java的锁机制","/pages/646254/"],["04.Java并发/08.CopyOnWriteArrayList.md","CopyOnWriteArrayList","/pages/9c98d8/"],["04.Java并发/10.CountDownLatch.md","CountDownLatch","/pages/7c31b2/"],["04.Java并发/11. CyclicBarrier.md","CyclicBarrier","/pages/fa1dea/"],["04.Java并发/12.AQS.md","AQS","/pages/109178/"],["04.Java并发/99.如何实现 ReentrantLock？.md","如何实现 ReentrantLock？","/pages/3c96b3/"],["04.Java并发/100.并发编程.md","并发编程","/pages/d5fcba/"]]}],catalogue:{},"/02.MySQL/":[["00.MySQL.md","MySQL","/pages/mysql/"],["01.MySQL存储引擎.md","MySQL存储引擎","/pages/26cff4/"],["02.索引.md","索引","/pages/7ece7e/"],["03.事务.md","事务","/pages/e88566/"],["04.MySQL中的log.md","MySQL中的log","/pages/1d1ed2/"],["05.MVCC解决幻读问题.md","MVCC解决幻读问题","/pages/43cd7b/"],["06.数据库三范式.md","数据库三范式","/pages/9ed061/"],["07.MySQL数据类型.md","Untitled","/pages/a4281a/"],["08.范围查询导致索引失效问题.md","范围查询导致索引失效问题","/pages/c10308/"],["09.Explain分析.md","Explain分析","/pages/b85e9d/"],["10.MySQL中的锁.md","MySQL中的锁","/pages/92d4ca/"],["99.MySQL实战45讲.md","MySQL实战45讲","/pages/4f8fa0/"],["100.SQL记录.md","SQL记录","/pages/1b8a9e/"]],"/03.Redis/":[["01.redis总.md","Redis总","/pages/redis/"],["02.redis数据类型.md","Redis数据类型","/pages/99d0e1/"],["03.redis命令.md","Redis命令","/pages/f706e8/"],["04.redis数据结构.md","Redis数据结构","/pages/d7a25d/"],["05.redis持久化.md","redis持久化","/pages/bc6be1/"],["06.redis高可用.md","Redis高可用","/pages/effbd9/"],["07.redis删除策略及内存淘汰机制.md","Redis删除策略及内存淘汰机制","/pages/428106/"],["08.缓存常见问题.md","缓存常见问题","/pages/87b330/"],["09.redis场景题.md","Redis场景题","/pages/c8420f/"],["10.redis分布式锁.md","Redis分布式锁","/pages/5f810a/"],["11.redis的rehash.md","redis的rehash","/pages/fafd87/"]],"/04.计算机网络/":[{title:"基础",collapsable:!1,children:[["01.基础/01.网络协议分层.md","网络协议分层","/pages/network/"],["01.基础/02.浏览器存储.md","浏览器存储","/pages/f1d55e/"],["01.基础/03.网络攻击.md","网络攻击","/pages/9ce3d9/"]]},{title:"应用层",collapsable:!1,children:[["02.应用层/01.http版本对比.md","HTTP版本对比","/pages/e1cd04/"],["02.应用层/02.http.md","HTTP","/pages/f502d9/"],["02.应用层/03.https.md","HTTPS","/pages/43e2c1/"],["02.应用层/04.dns.md","DNS","/pages/524e17/"]]},{title:"传输层",collapsable:!1,children:[["03.传输层/01.tcp.md","TCP","/pages/5e312c/"]]},{title:"网络层",collapsable:!1,children:[["04.网络层/01.IP.md","IP","/pages/42791d/"]]}],"/05.操作系统/":[["01.操作系统.md","操作系统","/pages/os/"],["02.Ctrl+C发生了什么.md","Ctrl+C发生了什么","/pages/0b3887/"],["03.内存管理.md","内存管理","/pages/ceeb3f/"]],"/06.数据结构和算法/":[["01.搜索效率为log的树.md","搜索效率为log的树","/pages/f45a99/"],["02.二分查找.md","二分查找","/pages/37ba80/"],["03.二叉树.md","二叉树","/pages/d2945b/"]],"/07.前端/":[["01.js异步编程.md","js异步编程","/pages/9ba4c3/"]],"/08.方案/":[["01.JWT.md","JWT","/pages/jwt/"],["02.OAuth2.md","OAuth2","/pages/8cac0f/"],["03.CORS的解决方案.md","CORS的解决方案","/pages/fcd0f1/"],["04.监控系统选型调研.md","监控系统选型调研","/pages/95c00f/"],["05.redis分布式锁实现.md","Redis分布式锁实现","/pages/165ba8/"]],"/09.Java框架/":[{title:"Spring",collapsable:!1,children:[["01.Spring/01.Spring.md","Spring","/pages/spring/"],["01.Spring/02.Spring boot 自动装配.md","Spring boot 自动装配","/pages/581456/"],["01.Spring/03.Spring IOC.md","Spring IOC","/pages/0bf668/"],["01.Spring/04. Spring AOP.md","Spring AOP","/pages/8c1a59/"],["01.Spring/05.Spring MVC.md","Spring MVC","/pages/c3ac4e/"],["01.Spring/06.Spring boot starter.md","Spring boot starter","/pages/e00296/"],["01.Spring/07.BeanFactory和FactoryBean.md","BeanFactory和FactoryBean","/pages/643d4f/"],["01.Spring/08.Spring三级缓存解决循环依赖.md","Spring三级缓存解决循环依赖","/pages/329b73/"]]}],"/10.中间件/":[["01.消息队列概述.md","消息队列概述","/pages/mq/"],["02.RocketMQ.md","RocketMQ","/pages/279572/"],["03.Flume快速上手.md","Flume快速上手","/pages/0cf9ab/"],["04. RocketMQ 和 Kafka 对比.md","RocketMQ 和 Kafka 对比","/pages/7c8ab7/"]],"/100.工具/":[{title:"Git",collapsable:!1,children:[["01.Git/01.Git commit message 规范.md","Git commit message 规范","/pages/git/"],["01.Git/02.合并提交-rebase.md","合并提交-rebase","/pages/6f9bb5/"],["01.Git/03.git pull和git fetch.md","git fetch与git pull","/pages/0974e8/"]]},{title:"Linux",collapsable:!1,children:[["02.Linux/01.Linux常用命令.md","Linux常用命令","/pages/linux/"],["02.Linux/02.Linux命令.md","Linux命令","/pages/d3d9ca/"]]},{title:"Docker",collapsable:!1,children:[["03.Docker/01.Docker命令.md","Docker命令","/pages/aa154b/"]]}],"/11. 设计模式/":[["01.单例模式.md","单例模式","/pages/c02964/"],["02.工厂模式.md","工厂模式","/pages/da6600/"]],"/12.AI/":[["01.AI  tools.md","AI tools","/pages/aitools/"]],"/13.系统设计/":[["01.集群搭建总思路.md","集群搭建总思路","/pages/e945bb/"]],"/99.Code Snippet/":[["01.QuickSort.md","QuickSort","/pages/27d05d/"],["02.HeapSort.md","HeapSort","/pages/dfcd0a/"],["03.Java实现生产者消费者模式.md","Java实现生产者消费者模式","/pages/c708a0/"]]},updateBar:{showToArticle:!1},pageStyle:"line",category:!1,tag:!1,author:{name:"Kaze",href:"https://github.com/egoistsh"},social:{icons:[{iconClass:"icon-youjian",title:"发邮件"},{iconClass:"icon-github",title:"GitHub",link:"https://github.com/egoistsh"},{iconClass:"icon-erji",title:"听音乐"}]},footer:{createYear:2023,copyrightInfo:"Kaze | MIT License"},htmlModules:{pageT:'\n    <div class="wwads-cn wwads-horizontal page-wwads" data-id="136"></div>\n    <style>\n      .page-wwads{\n        width:100%!important;\n        min-height: 0;\n        margin: 0;\n      }\n      .page-wwads .wwads-img img{\n        width:80px!important;\n      }\n      .page-wwads .wwads-poweredby{\n        width: 40px;\n        position: absolute;\n        right: 25px;\n        bottom: 3px;\n      }\n      .wwads-content .wwads-text, .page-wwads .wwads-text{\n        height: 100%;\n        padding-top: 5px;\n        display: block;\n      }\n  </style>\n  '},mdEnhance:{tasklist:!0,sub:!0,sup:!0,flowchart:!0,mermaid:!0,tex:!0}}};var xl=t(94),wl=t(95),Sl=t(11);var Tl={computed:{$filterPosts(){return this.$site.pages.filter(n=>{const{frontmatter:{pageComponent:e,article:t,home:a}}=n;return!(e||!1===t||!0===a)})},$sortPosts(){return(n=this.$filterPosts).sort((n,e)=>{const t=n.frontmatter.sticky,a=e.frontmatter.sticky;return t&&a?t==a?Object(Sl.a)(n,e):t-a:t&&!a?-1:!t&&a?1:Object(Sl.a)(n,e)}),n;var n},$sortPostsByDate(){return(n=this.$filterPosts).sort((n,e)=>Object(Sl.a)(n,e)),n;var n},$groupPosts(){return function(n){const e={},t={};for(let a=0,r=n.length;a<r;a++){const{frontmatter:{categories:r,tags:o}}=n[a];"array"===Object(Sl.n)(r)&&r.forEach(t=>{t&&(e[t]||(e[t]=[]),e[t].push(n[a]))}),"array"===Object(Sl.n)(o)&&o.forEach(e=>{e&&(t[e]||(t[e]=[]),t[e].push(n[a]))})}return{categories:e,tags:t}}(this.$sortPosts)},$categoriesAndTags(){return function(n){const e=[],t=[];for(let t in n.categories)e.push({key:t,length:n.categories[t].length});for(let e in n.tags)t.push({key:e,length:n.tags[e].length});return{categories:e,tags:t}}(this.$groupPosts)}}};$t.component(xl.default),$t.component(wl.default);function Cl(n){return n.toString().padStart(2,"0")}t(243);$t.component("Badge",()=>Promise.all([t.e(0),t.e(3)]).then(t.bind(null,455))),$t.component("CodeBlock",()=>Promise.resolve().then(t.bind(null,94))),$t.component("CodeGroup",()=>Promise.resolve().then(t.bind(null,95)));t(244);var jl=[({Vue:n,options:e,router:t,siteData:a,isServer:r})=>{r||t.afterEach(()=>{var n;n=function(){setTimeout((function(){void 0===window._AdBlockInit&&function(){const n=document.getElementsByClassName("wwads-cn"),e=document.querySelector(".wwads-content");n[0]&&!e&&(n[0].innerHTML="<style>.wwads-horizontal,.wwads-vertical{background-color:#f4f8fa;padding:5px;min-height:120px;margin-top:20px;box-sizing:border-box;border-radius:3px;font-family:sans-serif;display:flex;min-width:150px;position:relative;overflow:hidden;}.wwads-horizontal{flex-wrap:wrap;justify-content:center}.wwads-vertical{flex-direction:column;align-items:center;padding-bottom:32px}.wwads-horizontal a,.wwads-vertical a{text-decoration:none}.wwads-horizontal .wwads-img,.wwads-vertical .wwads-img{margin:5px}.wwads-horizontal .wwads-content,.wwads-vertical .wwads-content{margin:5px}.wwads-horizontal .wwads-content{flex:130px}.wwads-vertical .wwads-content{margin-top:10px}.wwads-horizontal .wwads-text,.wwads-content .wwads-text{font-size:14px;line-height:1.4;color:#0e1011;-webkit-font-smoothing:antialiased}.wwads-horizontal .wwads-poweredby,.wwads-vertical .wwads-poweredby{display:block;font-size:11px;color:#a6b7bf;margin-top:1em}.wwads-vertical .wwads-poweredby{position:absolute;left:10px;bottom:10px}.wwads-horizontal .wwads-poweredby span,.wwads-vertical .wwads-poweredby span{transition:all 0.2s ease-in-out;margin-left:-1em}.wwads-horizontal .wwads-poweredby span:first-child,.wwads-vertical .wwads-poweredby span:first-child{opacity:0}.wwads-horizontal:hover .wwads-poweredby span,.wwads-vertical:hover .wwads-poweredby span{opacity:1;margin-left:0}.wwads-horizontal .wwads-hide,.wwads-vertical .wwads-hide{position:absolute;right:-23px;bottom:-23px;width:46px;height:46px;border-radius:23px;transition:all 0.3s ease-in-out;cursor:pointer;}.wwads-horizontal .wwads-hide:hover,.wwads-vertical .wwads-hide:hover{background:rgb(0 0 0 /0.05)}.wwads-horizontal .wwads-hide svg,.wwads-vertical .wwads-hide svg{position:absolute;left:10px;top:10px;fill:#a6b7bf}.wwads-horizontal .wwads-hide:hover svg,.wwads-vertical .wwads-hide:hover svg{fill:#3E4546}</style><a href='https://wwads.cn/page/whitelist-wwads' class='wwads-img' target='_blank' rel='nofollow'><img src='https://fastly.jsdelivr.net/gh/xugaoyi/image_store@master/blog/wwads.2a3pidhlh4ys.webp' width='130'></a><div class='wwads-content'><a href='https://wwads.cn/page/whitelist-wwads' class='wwads-text' target='_blank' rel='nofollow'>为了本站的长期运营，请将我们的网站加入广告拦截器的白名单，感谢您的支持！<span style='color: #11a8cd'>如何添加白名单?</span></a><a href='https://wwads.cn/page/end-user-privacy' class='wwads-poweredby' title='万维广告 ～ 让广告更优雅，且有用' target='_blank'><span>广告</span></a></div><a class='wwads-hide' onclick='parentNode.remove()' title='隐藏广告'><svg xmlns='http://www.w3.org/2000/svg' width='6' height='7'><path d='M.879.672L3 2.793 5.121.672a.5.5 0 11.707.707L3.708 3.5l2.12 2.121a.5.5 0 11-.707.707l-2.12-2.12-2.122 2.12a.5.5 0 11-.707-.707l2.121-2.12L.172 1.378A.5.5 0 01.879.672z'></path></svg></a>")}()}),3e3)},"complete"===document.readyState||"interactive"===document.readyState?setTimeout(n,1):document.addEventListener("DOMContentLoaded",n),setTimeout(()=>{const n=document.querySelector(".page-wwads");if(!n)return;const e=n.querySelector(".wwads-hide");e&&(e.onclick=()=>{n.style.display="none"}),"none"===n.style.display&&(n.style.display="flex")},900)})},({Vue:n,options:e,router:t,siteData:a})=>{a.pages.map(n=>{const{frontmatter:{date:e,author:t}}=n;"string"==typeof e&&"Z"===e.charAt(e.length-1)&&(n.frontmatter.date=function(n){n instanceof Date||(n=new Date(n));return`${n.getUTCFullYear()}-${Cl(n.getUTCMonth()+1)}-${Cl(n.getUTCDate())} ${Cl(n.getUTCHours())}:${Cl(n.getUTCMinutes())}:${Cl(n.getUTCSeconds())}`}(e)),t?n.author=t:a.themeConfig.author&&(n.author=a.themeConfig.author)}),n.mixin(Tl)},{},({Vue:n})=>{n.mixin({computed:{$dataBlock(){return this.$options.__data__block__}}})},{},{},({router:n})=>{"undefined"!=typeof window&&(window._hmt=window._hmt||[],function(){var n=document.createElement("script");n.src="https://hm.baidu.com/hm.js?01293bffa6c3962016c08ba685c79d78";var e=document.getElementsByTagName("script")[0];e.parentNode.insertBefore(n,e)}(),n.afterEach((function(n){_hmt.push(["_trackPageview",n.fullPath])})))}],El=[];class Al extends class{constructor(){this.store=new $t({data:{state:{}}})}$get(n){return this.store.state[n]}$set(n,e){$t.set(this.store.state,n,e)}$emit(...n){this.store.$emit(...n)}$on(...n){this.store.$on(...n)}}{}Object.assign(Al.prototype,{getPageAsyncComponent:is,getLayoutAsyncComponent:ss,getAsyncComponent:ls,getVueComponent:cs});var Il={install(n){const e=new Al;n.$vuepress=e,n.prototype.$vuepress=e}};function _l(n,e){const t=e.toLowerCase();return n.options.routes.some(n=>n.path.toLowerCase()===t)}var Ll={props:{pageKey:String,slotKey:{type:String,default:"default"}},render(n){const e=this.pageKey||this.$parent.$page.key;return ps("pageKey",e),$t.component(e)||$t.component(e,is(e)),$t.component(e)?n(e):n("")}},zl={functional:!0,props:{slotKey:String,required:!0},render:(n,{props:e,slots:t})=>n("div",{class:["content__"+e.slotKey]},t()[e.slotKey])},Pl={computed:{openInNewWindowTitle(){return this.$themeLocaleConfig.openNewWindowText||"(opens new window)"}}},Bl=(t(245),t(246),Object(vl.a)(Pl,(function(){var n=this._self._c;return n("span",[n("svg",{staticClass:"icon outbound",attrs:{xmlns:"http://www.w3.org/2000/svg","aria-hidden":"true",focusable:"false",x:"0px",y:"0px",viewBox:"0 0 100 100",width:"15",height:"15"}},[n("path",{attrs:{fill:"currentColor",d:"M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"}}),this._v(" "),n("polygon",{attrs:{fill:"currentColor",points:"45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"}})]),this._v(" "),n("span",{staticClass:"sr-only"},[this._v(this._s(this.openInNewWindowTitle))])])}),[],!1,null,null,null).exports),Ml={functional:!0,render(n,{parent:e,children:t}){if(e._isMounted)return t;e.$once("hook:mounted",()=>{e.$forceUpdate()})}};$t.config.productionTip=!1,$t.use(Ui),$t.use(Il),$t.mixin(function(n,e,t=$t){!function(n){n.locales&&Object.keys(n.locales).forEach(e=>{n.locales[e].path=e});Object.freeze(n)}(e),t.$vuepress.$set("siteData",e);const a=new(n(t.$vuepress.$get("siteData"))),r=Object.getOwnPropertyDescriptors(Object.getPrototypeOf(a)),o={};return Object.keys(r).reduce((n,e)=>(e.startsWith("$")&&(n[e]=r[e].get),n),o),{computed:o}}(n=>class{setPage(n){this.__page=n}get $site(){return n}get $themeConfig(){return this.$site.themeConfig}get $frontmatter(){return this.$page.frontmatter}get $localeConfig(){const{locales:n={}}=this.$site;let e,t;for(const a in n)"/"===a?t=n[a]:0===this.$page.path.indexOf(a)&&(e=n[a]);return e||t||{}}get $siteTitle(){return this.$localeConfig.title||this.$site.title||""}get $canonicalUrl(){const{canonicalUrl:n}=this.$page.frontmatter;return"string"==typeof n&&n}get $title(){const n=this.$page,{metaTitle:e}=this.$page.frontmatter;if("string"==typeof e)return e;const t=this.$siteTitle,a=n.frontmatter.home?null:n.frontmatter.title||n.title;return t?a?a+" | "+t:t:a||"VuePress"}get $description(){const n=function(n){if(n){const e=n.filter(n=>"description"===n.name)[0];if(e)return e.content}}(this.$page.frontmatter.meta);return n||(this.$page.frontmatter.description||this.$localeConfig.description||this.$site.description||"")}get $lang(){return this.$page.frontmatter.lang||this.$localeConfig.lang||"en-US"}get $localePath(){return this.$localeConfig.path||"/"}get $themeLocaleConfig(){return(this.$site.themeConfig.locales||{})[this.$localePath]||{}}get $page(){return this.__page?this.__page:function(n,e){for(let t=0;t<n.length;t++){const a=n[t];if(a.path.toLowerCase()===e.toLowerCase())return a}return{path:"",frontmatter:{}}}(this.$site.pages,this.$route.path)}},kl)),$t.component("Content",Ll),$t.component("ContentSlotsDistributor",zl),$t.component("OutboundLink",Bl),$t.component("ClientOnly",Ml),$t.component("Layout",ss("Layout")),$t.component("NotFound",ss("NotFound")),$t.prototype.$withBase=function(n){const e=this.$site.base;return"/"===n.charAt(0)?e+n.slice(1):n},window.__VUEPRESS__={version:"1.9.2",hash:"85cdad2"},async function(n){const e="undefined"!=typeof window&&window.__VUEPRESS_ROUTER_BASE__?window.__VUEPRESS_ROUTER_BASE__:kl.routerBase||kl.base,t=new Ui({base:e,mode:"history",fallback:!1,routes:yl,scrollBehavior:(n,e,t)=>t||(n.hash?!$t.$vuepress.$get("disableScrollBehavior")&&{selector:decodeURIComponent(n.hash)}:{x:0,y:0})});!function(n){n.beforeEach((e,t,a)=>{if(_l(n,e.path))a();else if(/(\/|\.html)$/.test(e.path))if(/\/$/.test(e.path)){const t=e.path.replace(/\/$/,"")+".html";_l(n,t)?a(t):a()}else a();else{const t=e.path+"/",r=e.path+".html";_l(n,r)?a(r):_l(n,t)?a(t):a()}})}(t);const a={};try{await Promise.all(jl.filter(n=>"function"==typeof n).map(e=>e({Vue:$t,options:a,router:t,siteData:kl,isServer:n})))}catch(n){console.error(n)}return{app:new $t(Object.assign(a,{router:t,render:n=>n("div",{attrs:{id:"app"}},[n("RouterView",{ref:"layout"}),n("div",{class:"global-ui"},El.map(e=>n(e)))])})),router:t}}(!1).then(({app:n,router:e})=>{e.onReady(()=>{n.$mount("#app")})})}]);