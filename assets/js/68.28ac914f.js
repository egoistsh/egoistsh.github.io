(window.webpackJsonp=window.webpackJsonp||[]).push([[68],{392:function(_,v,t){"use strict";t.r(v);var r=t(7),s=Object(r.a)({},(function(){var _=this,v=_._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[v("h2",{attrs:{id:"tcp和udp的区别"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#tcp和udp的区别"}},[_._v("#")]),_._v(" TCP和UDP的区别")]),_._v(" "),v("p",[v("strong",[_._v("用户数据报协议UDP（User Datagram Protocol）：")])]),_._v(" "),v("p",[_._v("是无连接的；尽最大可能交付；不能保证数据顺序；没有拥塞控制；面向报文（对于应用程序传下来的报文不合并也不拆分，只是添加UDP首部）；支持一对一、一对多、多对一和多对多的交互通信。")]),_._v(" "),v("p",[v("strong",[_._v("传输控制协议TCP（Transmission Control Protocol）：")])]),_._v(" "),v("p",[_._v("是面向连接的；提供可靠交付；保证数据顺序（由于使用序号）；有流量控制；有拥塞控制；提供全双工通信；面向字节流（把应用层传下来的报文看成字节流，把字节流组织成大小不等的数据块）；仅支持一对一。")]),_._v(" "),v("br"),_._v(" "),v("ul",[v("li",[v("p",[_._v("tcp是面向连接的可靠传输协议，是面向字节流的，会发生粘包和拆包现象，有流量控制和拥塞控制保证可靠传输，适合要求对数据传输可靠性要求高的场景。")])]),_._v(" "),v("li",[v("p",[_._v("udp是无连接的，不可靠的传输协议，会尽最大努力进行交付，面向报文，不会进行拆分和合并，没有拥塞控制，适合允许数据小量丢失的场景，能够实现1对1，1对多，多对多的实时交互通信。")])]),_._v(" "),v("li",[v("p",[_._v("udp首部长度只有8B，比TCP小。")])]),_._v(" "),v("li",[v("p",[_._v("面向连接：一定是「一对一」才能连接，不能像 UDP 协议可以一个主机同时向多个主机发送消息，也就是一对多是无法做到的。")])]),_._v(" "),v("li",[v("p",[_._v("可靠交付：无论的网络链路中出现了怎样的链路变化，TCP 都可以保证一个报文一定能够到达接收端。")])]),_._v(" "),v("li",[v("p",[_._v("面向字节流：也就是说仅仅把上层协议传递过来的数据当成字节传输。")])])]),_._v(" "),v("h3",{attrs:{id:"tcp和udp应用"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#tcp和udp应用"}},[_._v("#")]),_._v(" TCP和UDP应用")]),_._v(" "),v("p",[_._v("TCP：要求通信数据的完整性和准确性较高（文件传输、邮件发送、重要状态的更新）")]),_._v(" "),v("p",[_._v("UDP：要求通信响应度高，对数据信息的安全性和完整性要求较低（网络电话、网络视频）")]),_._v(" "),v("h3",{attrs:{id:"字节流和报文段"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#字节流和报文段"}},[_._v("#")]),_._v(" 字节流和报文段")]),_._v(" "),v("p",[_._v("区分字节流和报文关键在于：对使用协议的用户而言，读数据的时候，是不是有“边界”，有边界就是报文，没有边界就是字节流")]),_._v(" "),v("p",[_._v("没有边界：上层协议读取数据的时候不知道读到了几个TCP数据包（因为有缓冲池，所以发送端发送数据和接收端处理数据的频率是可以不对等的）")]),_._v(" "),v("p",[_._v("有边界：上层协议每一次读取必定是一个数据包（没有缓冲池）")]),_._v(" "),v("h2",{attrs:{id:"tcp粘包、拆包问题"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#tcp粘包、拆包问题"}},[_._v("#")]),_._v(" TCP粘包、拆包问题")]),_._v(" "),v("p",[_._v("TCP 是以流的方式来处理数据，一个完整的包可能会被 TCP 拆分成多个包进行发送，也可能把小的封装成一个大的数据包发送。")]),_._v(" "),v("br"),_._v(" "),v("p",[_._v("发送方：关闭Nagle算法。接收方：没法处理，只能交给应用层来进行处理")]),_._v(" "),v("p",[_._v("应用层：")]),_._v(" "),v("ul",[v("li",[_._v("使用标准的应用层协议（http，https等）来封装要传输的不定长的数据包")]),_._v(" "),v("li",[_._v("在每条数据的尾部添加特殊字符，如果遇到特殊字符表明当条数据接受完毕")]),_._v(" "),v("li",[_._v("在发送数据前添加包头，数据格式为：数据头+数据块")])]),_._v(" "),v("br"),_._v(" "),v("p",[_._v("netty的解决方案：")]),_._v(" "),v("ul",[v("li",[_._v("消息定长：FixedLengthFrameDecoder")]),_._v(" "),v("li",[_._v("包尾增加特殊字符分割：\n"),v("ul",[v("li",[_._v("行分隔符类：LineBasedFrameDecoder")]),_._v(" "),v("li",[_._v("自定义分隔符类 ：DelimiterBasedFrameDecoder")])])]),_._v(" "),v("li",[_._v("将消息分为消息头和消息体：LengthFieldBasedFrameDecoder 类。分为有头部的拆包与粘包、长度字段在前且有头部的拆包与粘包、多扩展头部的拆包与粘包。")])]),_._v(" "),v("p",[_._v("也可以使用自定义协议，通过字段标明包长度。")]),_._v(" "),v("h2",{attrs:{id:"tcp三次握手"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#tcp三次握手"}},[_._v("#")]),_._v(" TCP三次握手")]),_._v(" "),v("p",[_._v("过程：")]),_._v(" "),v("ul",[v("li",[_._v("A 向 B 发送连接请求报文，"),v("strong",[_._v("SYN=1，ACK=0，seq=x")]),_._v("。")]),_._v(" "),v("li",[_._v("B 收到连接请求报文，如果同意建立连接，则向 A 发送连接确认报文，"),v("strong",[_._v("SYN=1，ACK=1，ack=x+1，seq= y")]),_._v("。")]),_._v(" "),v("li",[_._v("A 收到 B 的连接确认报文后，还要向 B 发出确认，"),v("strong",[_._v("ACK=1，ack= y+1，seq=x+1")]),_._v("。")])]),_._v(" "),v("p",[_._v("第二次握手完成后SYN将被置为0，第三次握手可以携带数据，前两次不可以携带数据。")]),_._v(" "),v("p",[_._v("为什么需要三次？")]),_._v(" "),v("ul",[v("li",[_._v("三次连接才能可靠的同步双方的初始序列号。【tcp的可靠传输是靠同步序列号实现：序列号能保证数据包不重复、不丢弃和按序传输】")]),_._v(" "),v("li",[_._v("防止重复的历史连接的建立，造成混乱。")]),_._v(" "),v("li",[_._v("避免资源浪费。【重传情况】")])]),_._v(" "),v("p",[_._v("重复历史连接建立的具体场景：客户端先发送了 SYN（seq = 90） 报文，然后客户端宕机了，而且这个 SYN 报文还被网络阻塞了，服务端并没有收到，接着客户端重启后，又重新向服务端建立连接，发送了 SYN（seq = 100） 报文（注意不是重传 SYN，重传的 SYN 的序列号是一样的）。")]),_._v(" "),v("p",[_._v("客户端连续发送多次 SYN 建立连接的报文，在"),v("strong",[_._v("网络拥堵")]),_._v("情况下：")]),_._v(" "),v("ul",[v("li",[_._v("一个「旧 SYN 报文」比「最新的 SYN 」 报文早到达了服务端；")]),_._v(" "),v("li",[_._v("那么此时服务端就会回一个 SYN + ACK 报文给客户端；")]),_._v(" "),v("li",[_._v("客户端收到后可以根据自身的上下文，判断这是一个历史连接（序列号过期或超时），那么客户端就会发送 RST 报文给服务端，表示中止这一次连接。")])]),_._v(" "),v("p",[_._v("**如果是两次握手连接，就无法阻止历史连接。**两次握手的情况下，「被动发起方」在收到 SYN 报文后，就进入 ESTABLISHED 状态，意味着这时可以给对方发送数据，但是「主动发起方」此时还没有进入 ESTABLISHED 状态，假设这次是历史连接，「主动发起方」判断到此次连接为历史连接，那么就会回 RST 报文来断开连接，而「被动发起方」在第一次握手的时候就进入 ESTABLISHED 状态，所以它可以发送数据的，但是它并不知道这个是历史连接，它只有在收到 RST 报文后，才会断开连接。")]),_._v(" "),v("p",[_._v("两次握手的话，当客户端连续发送多个建立连接的报文，在网络阻塞的情况下，由于服务端收到应答后就建立了连接，所以会造成服务端多个连接的建立，从而尝试混乱。")]),_._v(" "),v("h2",{attrs:{id:"tcp四次挥手"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#tcp四次挥手"}},[_._v("#")]),_._v(" TCP四次挥手")]),_._v(" "),v("ul",[v("li",[v("p",[_._v("过程：")]),_._v(" "),v("ul",[v("li",[_._v("客户端发出连接释放报文段（"),v("strong",[_._v("FIN=1，序号seq=u")]),_._v("），并停止再发送数据，主动关闭TCP连接，进入FIN_WAIT1（终止等待1）状态，等待服务端的确认。")]),_._v(" "),v("li",[_._v("服务端收到连接释放报文段后即发出确认报文段（"),v("strong",[_._v("ACK=1，确认号ack=u+1，序号seq=v")]),_._v("），服务端进入CLOSE_WAIT（关闭等待）状态，此时的TCP处于半关闭状态，客户端到服务端的连接释放。客户端收到服务端的确认后，进入FIN_WAIT2（终止等待2）状态，等待服务端发出的连接释放报文段。")]),_._v(" "),v("li",[_._v("服务端没有要向客户端发出的数据，服务端发出连接释放报文段（"),v("strong",[_._v("FIN=1，ACK=1，序号seq=w，确认号ack=u+1")]),_._v("），服务端进入LAST_ACK（最后确认）状态，等待客户端的确认。")]),_._v(" "),v("li",[_._v("客户端收到服务端的连接释放报文段后，对此发出确认报文段（"),v("strong",[_._v("ACK=1，seq=u+1，ack=w+1")]),_._v("），客户端进入TIME_WAIT（时间等待）状态。此时TCP未释放掉，需要经过时间等待计时器设置的时间2MSL后，客户端才进入CLOSED状态。")])]),_._v(" "),v("p",[v("img",{attrs:{src:"https://p.ipic.vip/5gyfdx.png",alt:"img"}})]),_._v(" "),v("p",[v("strong",[_._v("为什么是四次：")])]),_._v(" "),v("p",[_._v("这由TCP的半关闭（half-close）造成的。所谓的半关闭，其实就是TCP提供了连接的一端在结束它的发送后还能接收来自另一端数据的能力。")]),_._v(" "),v("p",[v("strong",[_._v("为什么需要等待2个MSL")])]),_._v(" "),v("p",[_._v("防止主动接受方发送的最后确认报文，被动接受方没能接受到，触发被动接受方的超时重传，一来一回刚好两个2MSL")]),_._v(" "),v("p",[v("strong",[_._v("MSL（"),v("strong",[v("strong",[_._v("Maximum Segment Lifetime")])]),_._v("）为报文最大生存时间")]),_._v("，他是任何报文在网络上存在的最长时间，超过这个时间报文将会被丢弃，被接收方处理后又向发送方发送响应，一来一回需要等待2倍的时间")]),_._v(" "),v("p",[v("strong",[_._v("为什么第二次挥手和第三次挥手不能合并成一次")])]),_._v(" "),v("p",[_._v("服务器需要先应答接受到了客户端需要断开的请求，但是服务器可能还有数据需要处理和发送，并且TCP具有一端在结束它发送后仍能接受数据的能力，因此服务器还能向客户端进行发送数据")])])]),_._v(" "),v("h2",{attrs:{id:"tcp可靠传输"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#tcp可靠传输"}},[_._v("#")]),_._v(" TCP可靠传输")]),_._v(" "),v("p",[_._v("TCP通过"),v("strong",[_._v("重传机制")]),_._v("、"),v("strong",[_._v("流量控制")]),_._v("、"),v("strong",[_._v("拥塞控制")]),_._v("来实现可靠传输")]),_._v(" "),v("h3",{attrs:{id:"重传机制"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#重传机制"}},[_._v("#")]),_._v(" 重传机制")]),_._v(" "),v("table",[v("thead",[v("tr",[v("th",[_._v("重传机制")]),_._v(" "),v("th",[_._v("描述")])])]),_._v(" "),v("tbody",[v("tr",[v("td",[_._v("超时重传")]),_._v(" "),v("td",[_._v("超出一定时间没有收到响应触发重传机制")])]),_._v(" "),v("tr",[v("td",[_._v("快速重传")]),_._v(" "),v("td",[_._v("连续收到三次相同的ACK触发重传机制")])]),_._v(" "),v("tr",[v("td",[_._v("SACK")]),_._v(" "),v("td",[_._v("TCP的字段中添加SACK，显示哪些数据被接收到")])]),_._v(" "),v("tr",[v("td",[_._v("D-SACK")]),_._v(" "),v("td",[_._v("用SACK字段表明哪些数据被重复接收，用ACK表明哪些字段丢失，可以用来检测是响应丢失还是请求丢失")])])])]),_._v(" "),v("p",[_._v("TCP超时重传和快速重传都是TCP协议在数据传输时使用的机制，用于提高数据传输的可靠性。它们的主要区别如下：")]),_._v(" "),v("ol",[v("li",[_._v("触发机制：TCP超时重传是在发送数据后等待一段时间，如果未收到确认应答，就会触发重传机制；而快速重传是在接收到重复确认应答时触发的，这意味着网络出现拥塞，导致数据包丢失。")]),_._v(" "),v("li",[_._v("重传次数：TCP超时重传会在每次超时后重传数据包，直到收到确认应答为止；而快速重传只会在接收到3个重复确认应答后立即重传数据包，避免了等待超时时间的延迟。")]),_._v(" "),v("li",[_._v("对网络性能的影响：TCP超时重传会导致网络出现更多的拥塞，因为每次重传都会重新发送所有数据包，而这些数据包可能会增加网络拥塞的程度。而快速重传通过减少数据包的重传次数，可以减轻网络拥塞的程度。")])]),_._v(" "),v("h3",{attrs:{id:"流量控制和拥塞控制的区别"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#流量控制和拥塞控制的区别"}},[_._v("#")]),_._v(" 流量控制和拥塞控制的区别")]),_._v(" "),v("p",[_._v("TCP流量控制和拥塞控制是TCP协议中两个重要的机制，它们的主要区别如下：")]),_._v(" "),v("ol",[v("li",[v("p",[_._v("目的不同：TCP流量控制的目的是确保"),v("strong",[_._v("发送方不会发送使接收方无法处理数据")]),_._v("，通过动态调整发送方发送的数据量，控制接收方的接收速率，以达到平衡发送方和接收方之间的数据流量。拥塞控制则是为了"),v("strong",[_._v("防止网络拥塞")]),_._v("而采取的一种机制。")])]),_._v(" "),v("li",[v("p",[_._v("控制对象不同：TCP流量控制是对单个连接的"),v("strong",[_._v("发送方和接收方之间的数据流量")]),_._v("进行控制，而拥塞控制是对"),v("strong",[_._v("整个网络的流量")]),_._v("进行控制。")])]),_._v(" "),v("li",[v("p",[_._v("触发机制不同：TCP流量控制是由接收方来触发的，当接收方处理不过来数据时，会发送窗口通告（Window Size），告诉发送方可以发送的数据量，从而控制发送方的发送速率。而拥塞控制则是由网络的拥塞情况来触发的，当网络拥塞时，发送方会收到拥塞信号（Congestion Signal），从而调整发送速率。")])]),_._v(" "),v("li",[v("p",[_._v("实现方法不同：TCP流量控制通过调整窗口大小来控制发送方的发送速率。窗口大小是发送方和接收方之间的一个参数，发送方可以根据窗口大小来确定可以发送的数据量。而拥塞控制则采用了多种算法，例如TCP Reno、TCP Vegas等，通过不同的算法来调整发送方的发送速率，以避免网络拥塞。")])])]),_._v(" "),v("h3",{attrs:{id:"流量控制"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#流量控制"}},[_._v("#")]),_._v(" 流量控制")]),_._v(" "),v("p",[_._v("通过使用"),v("strong",[_._v("滑动窗口")]),_._v("来进行流量控制")]),_._v(" "),v("ul",[v("li",[v("p",[_._v("滑动窗口的大小就是指发送方无需等待确认应答，而可以继续发送数据的最大值")])]),_._v(" "),v("li",[v("p",[v("strong",[_._v("滑动窗口的大小是由接收方的窗口大小决定")]),_._v("的：接收方告诉发送方自己有多少缓冲区可以接收数据，发送方根据这个接收端的处理能力来发送数据，而不会导致接收端处理不过来")])]),_._v(" "),v("li",[v("p",[_._v("初始滑动窗口的大小=缓存池中数据量+动态变动后的滑动窗口大小")])])]),_._v(" "),v("p",[_._v("注意事项：")]),_._v(" "),v("ul",[v("li",[_._v("接收方需要更改滑动窗口的大小时，需要先发送更改大小的请求，然后再变更大小")]),_._v(" "),v("li",[_._v("如果窗口大小为0的时，需要设置自动发送询问报文来询问接收方是否缓存池有可用大小（窗口关闭问题）")]),_._v(" "),v("li",[_._v("滑动窗口过小的时候，不进行数据发送，等窗口恢复到一定大小时再进行发送（糊涂窗口综合症）")])]),_._v(" "),v("h3",{attrs:{id:"拥塞控制"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#拥塞控制"}},[_._v("#")]),_._v(" 拥塞控制")]),_._v(" "),v("p",[_._v("根据网络环境（是否丢包）使用"),v("strong",[_._v("拥塞窗口")]),_._v("进行拥塞控制，拥塞控制算法如下")]),_._v(" "),v("ul",[v("li",[v("p",[_._v("慢启动")]),_._v(" "),v("p",[_._v("拥塞窗口<=慢启动门限：拥塞窗口呈指数型增长")])]),_._v(" "),v("li",[v("p",[_._v("拥塞避免算法")]),_._v(" "),v("p",[_._v("拥塞窗口>=慢启动门限：拥塞窗口呈线性增长")])]),_._v(" "),v("li",[v("p",[_._v("拥塞发生算法")]),_._v(" "),v("p",[_._v("出现丢包时：")]),_._v(" "),v("p",[_._v("使用"),v("strong",[_._v("超时重传")]),_._v("：慢启动门限=拥塞窗口/2｜拥塞窗口=1｜重新启动慢启动")]),_._v(" "),v("p",[_._v("使用"),v("strong",[_._v("快速重传")]),_._v("：拥塞窗口 = 拥塞窗口/2｜慢启动门限 = 拥塞窗口｜进入快速恢复算法")])]),_._v(" "),v("li",[v("p",[_._v("快速恢复")]),_._v(" "),v("p",[_._v("拥塞窗口 = 慢启动门限+3，通过重传一个包。")]),_._v(" "),v("p",[_._v("如果接收到重复的ACK的话，那么拥塞窗口+1，继续重传")]),_._v(" "),v("p",[_._v("如果是新的ACK，进入拥塞避免算法")])])]),_._v(" "),v("h2",{attrs:{id:"tcp-序列号的作用"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#tcp-序列号的作用"}},[_._v("#")]),_._v(" TCP 序列号的作用")]),_._v(" "),v("p",[_._v("TCP（传输控制协议）中的序列号用于标识"),v("a",{attrs:{href:"https://so.csdn.net/so/search?q=TCP%E6%8A%A5%E6%96%87&spm=1001.2101.3001.7020",target:"_blank",rel:"noopener noreferrer"}},[_._v("TCP报文"),v("OutboundLink")],1),_._v("段中的数据部分。每个TCP报文段都包含一个序列号字段，该字段指示了报文段中第一个字节的序号。在后续的报文段中，序列号将递增，以指示下一个字节的序号。")]),_._v(" "),v("p",[_._v("TCP序列号是一个32位的无符号整数。它是在"),v("a",{attrs:{href:"https://so.csdn.net/so/search?q=TCP%E8%BF%9E%E6%8E%A5&spm=1001.2101.3001.7020",target:"_blank",rel:"noopener noreferrer"}},[_._v("TCP连接"),v("OutboundLink")],1),_._v("建立阶段由发送方随机生成的。序列号的初始值可以是任意值，但通常情况下，它是随机生成的。序列号的随机性可以减少连接被攻击者猜测、重放或欺骗的风险。")]),_._v(" "),v("p",[_._v("在传输数据时，发送方将数据拆分成一个个TCP报文段，并将每个报文段中的数据部分按照序列号逐个发送。接收方在接收到报文段时，通过检查序列号字段来确定接收到的数据的顺序。如果接收到的报文段的序列号不是按照预期的顺序到达，则接收方可以丢弃该报文段并请求发送方重新发送该数据。")]),_._v(" "),v("p",[_._v("在TCP连接中，序列号不仅用于标识数据部分的顺序，还用于实现TCP的流量控制和拥塞控制机制。TCP连接的每个端点都维护一个发送窗口和一个接收窗口。发送方使用序列号和发送窗口来确定可以发送的数据量，以避免发送方过度发送导致接收方无法处理的情况。接收方使用序列号和接收窗口来确定可以接收的数据量，并通知发送方窗口大小以控制发送速率，以避免网络拥塞。")]),_._v(" "),v("p",[_._v("总之，TCP序列号是TCP连接中的重要组成部分，用于标识数据部分的顺序和实现TCP的流量控制和拥塞控制机制。它是由发送方随机生成的32位无符号整数。")]),_._v(" "),v("p",[_._v("TCP的序列号总结起来主要有以下几个作用：")]),_._v(" "),v("ol",[v("li",[v("strong",[_._v("数据分片与重组")]),_._v("：当一个大数据包被分割成多个小的TCP报文段进行传输时，序列号用于标识这些报文段中的每一个字节。接收端通过检查序列号，可以准确地将这些报文段重新组合成完整的数据包。")]),_._v(" "),v("li",[v("strong",[_._v("数据传输的可靠性")]),_._v("：序列号用于追踪和确认已发送和已接收的数据。接收端发送确认（ACK）报文给发送端时，将确认的序列号放入ACK字段。这样，发送端就知道接收端已经成功接收到了该序列号之前的所有数据。")]),_._v(" "),v("li",[v("strong",[_._v("流量控制")]),_._v("：TCP使用滑动窗口机制进行流量控制。序列号与接收窗口大小一起，帮助发送端确定可以发送的数据量，防止接收端被发送端的数据淹没。")]),_._v(" "),v("li",[v("strong",[_._v("防止旧报文段的干扰")]),_._v("：在网络中，报文可能会因为各种原因而延迟到达目的地。序列号可以帮助接收端区分新旧报文段，从而避免因旧报文段的重传而引发的数据错误。")])]),_._v(" "),v("h2",{attrs:{id:"滑动窗口和拥塞窗口"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#滑动窗口和拥塞窗口"}},[_._v("#")]),_._v(" 滑动窗口和拥塞窗口")]),_._v(" "),v("ul",[v("li",[v("p",[_._v("滑动窗口，接收方通过通告发送方自己的可以接受缓冲区大小（这个字段越大说明网络吞吐量越高），从而控制发送方的发送速度。")])]),_._v(" "),v("li",[v("p",[_._v("拥塞窗口：一个连接的TCP双端只是网络最边缘的两台主机，他们不知道整个网络是如何工作的，因此他们不知道彼此之间的有效吞吐量。因此，他们必须找到一种方法来确定它。我们称之为拥塞窗口 (CWND)。这是在我们必须停止并等待确认之前可以发送的字节数。拥塞窗口是决定任何时候可以发出的字节数的因素之一。拥塞窗口由发送方维护，是阻止发送方和接收方之间的链路因流量过多而过载的一种手段。这不应与发送方维护的滑动窗口相混淆，滑动窗口的存在是为了防止接收方过载。拥塞窗口是通过估计链路上有多少拥塞来计算的。")])])]),_._v(" "),v("p",[_._v("共同点：提高网络性能。")]),_._v(" "),v("p",[_._v("不同点：")]),_._v(" "),v("ul",[v("li",[_._v("流量控制：在TCP连接上实现对发送流量的控制，考虑点对点之间对通信量的控制，端到端，即：控制发送端的数据发送速率，使接收端可以来得及接收，保证网络高效稳定运行。")]),_._v(" "),v("li",[_._v("拥塞控制：处理网络拥塞现象，考虑网络能够承受现有的网络负荷，全局性变量，涉及所有的路由器、主机以及与降低网络传输性能有关的因素。防止过多的数据注入到网络，使网络中的路由器或链路不致过载，确保通信子网可以有效为主机传递分组。")])])])}),[],!1,null,null,null);v.default=s.exports}}]);