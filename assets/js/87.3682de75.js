(window.webpackJsonp=window.webpackJsonp||[]).push([[87],{411:function(a,t,s){"use strict";s.r(t);var n=s(7),e=Object(n.a)({},(function(){var a=this,t=a._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("h2",{attrs:{id:"什么是-spring-ioc"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#什么是-spring-ioc"}},[a._v("#")]),a._v(" 什么是 Spring IOC")]),a._v(" "),t("p",[a._v("IoC是设计思想，DI是实现方式。控制反转是通过依赖注入实现的。")]),a._v(" "),t("h2",{attrs:{id:"什么是-spring-bean"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#什么是-spring-bean"}},[a._v("#")]),a._v(" 什么是 Spring Bean")]),a._v(" "),t("p",[a._v("IoC Container管理的是Spring Bean， 那么Spring Bean是什么呢？")]),a._v(" "),t("p",[a._v("Spring里面的bean就类似是定义的一个组件，而这个组件的作用就是实现某个功能的，这里所定义的bean就相当于给了你一个更为简便的方法来调用这个组件去实现你要完成的功能。")]),a._v(" "),t("h2",{attrs:{id:"ioc的配置方式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#ioc的配置方式"}},[a._v("#")]),a._v(" IOC的配置方式")]),a._v(" "),t("p",[a._v("主流使用：Java 配置 + 注解配置")]),a._v(" "),t("p",[a._v("三种：")]),a._v(" "),t("ul",[t("li",[t("p",[a._v("xml 配置")])]),a._v(" "),t("li",[t("p",[a._v("Java 配置")]),a._v(" "),t("ol",[t("li",[t("p",[a._v("创建一个配置类， 添加@Configuration注解声明为配置类")])]),a._v(" "),t("li",[t("p",[a._v("创建方法，方法上加上@bean，该方法用于创建实例并返回，该实例创建后会交给spring管理，方法名建议与实例名相同（首字母小写）。注：实例类不需要加任何注解")])])])]),a._v(" "),t("li",[t("p",[a._v("注解配置")])])]),a._v(" "),t("h2",{attrs:{id:"依赖注入的方式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#依赖注入的方式"}},[a._v("#")]),a._v(" 依赖注入的方式")]),a._v(" "),t("p",[a._v("三种：")]),a._v(" "),t("ul",[t("li",[a._v("构造方法注入（在Spring4.x版本中推荐的注入方式）")]),a._v(" "),t("li",[a._v("setter注入")]),a._v(" "),t("li",[a._v("基于注解的属性注入")])]),a._v(" "),t("p",[a._v("为什么推荐构造器注入方式？")]),a._v(" "),t("p",[a._v("构造器注入的方式"),t("strong",[a._v("能够保证注入的组件不可变，并且确保需要的依赖不为空")]),a._v("。此外，构造器注入的依赖总是能够在返回客户端（组件）代码的时候保证完全初始化的状态。")]),a._v(" "),t("ul",[t("li",[t("strong",[a._v("依赖不可变")]),a._v("：其实说的就是final关键字。")]),a._v(" "),t("li",[t("strong",[a._v("依赖不为空")]),a._v("（省去了我们对其检查）：当要实例化UserServiceImpl的时候，由于自己实现了有参数的构造函数，所以不会调用默认构造函数，那么就需要Spring容器传入所需要的参数，所以就两种情况：1、有该类型的参数->传入，OK 。2：无该类型的参数->报错。")]),a._v(" "),t("li",[t("strong",[a._v("完全初始化的状态")]),a._v("：这个可以跟上面的依赖不为空结合起来，向构造器传参之前，要确保注入的内容不为空，那么肯定要调用依赖组件的构造方法完成实例化。而在Java类加载实例化的过程中，构造方法是最后一步（之前如果有父类先初始化父类，然后自己的成员变量，最后才是构造方法），所以返回来的都是初始化之后的状态。")])]),a._v(" "),t("div",{staticClass:"language-java extra-class"},[t("pre",{pre:!0,attrs:{class:"language-java"}},[t("code",[t("span",{pre:!0,attrs:{class:"token annotation punctuation"}},[a._v("@Service")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("public")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("class")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("UserServiceImpl")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n    "),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("/**\n     * user dao impl.\n     */")]),a._v("\n    "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("private")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("final")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("UserDaoImpl")]),a._v(" userDao"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n\n    "),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("/**\n     * init.\n     * @param userDaoImpl user dao impl\n     */")]),a._v("\n    "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("public")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("UserServiceImpl")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("final")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("UserDaoImpl")]),a._v(" userDaoImpl"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n        "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("this")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("userDao "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" userDaoImpl"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n    "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n")])])]),t("h2",{attrs:{id:"autowired和-resource以及-inject等注解注入有何区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#autowired和-resource以及-inject等注解注入有何区别"}},[a._v("#")]),a._v(" @Autowired和@Resource以及@Inject等注解注入有何区别？")]),a._v(" "),t("p",[a._v("三者对比：")]),a._v(" "),t("p",[a._v("1、@Autowired是Spring自带的，@Resource是JSR250规范实现的，@Inject是JSR330规范实现的")]),a._v(" "),t("p",[a._v("2、@Autowired、@Inject用法基本一样，不同的是@Inject没有required属性")]),a._v(" "),t("p",[a._v("3、@Autowired、@Inject是默认按照类型bytype匹配的，@Resource是按照名称byname匹配的")]),a._v(" "),t("p",[a._v("4、@Autowired如果需要按照名称匹配需要和@Qualifier一起使用，@Inject和@Named一起使用，@Resource则通过name进行指定")]),a._v(" "),t("p",[a._v("@Autowired")]),a._v(" "),t("p",[a._v("1、@Autowired是Spring自带的注解，通过AutowiredAnnotationBeanPostProcessor 类实现的依赖注入")]),a._v(" "),t("p",[a._v("2、@Autowired可以作用在CONSTRUCTOR、METHOD、PARAMETER、FIELD、ANNOTATION_TYPE")]),a._v(" "),t("p",[a._v("3、@Autowired默认是根据类型（byType ）进行自动装配的")]),a._v(" "),t("p",[a._v("4、如果有多个类型一样的Bean候选者，需要指定按照名称（byName ）进行装配，则需要配合@Qualifier。")]),a._v(" "),t("p",[a._v("指定名称后，如果Spring IOC容器中没有对应的组件bean抛出NoSuchBeanDefinitionException。也可以将@Autowired中required配置为false，如果配置为false之后，当没有找到相应bean的时候，系统不会抛异常")]),a._v(" "),t("p",[a._v("@Resource")]),a._v(" "),t("p",[a._v("1、@Resource是JSR250规范的实现，在javax.annotation包下")]),a._v(" "),t("p",[a._v("2、@Resource可以作用TYPE、FIELD、METHOD上")]),a._v(" "),t("p",[a._v("3、@Resource是默认根据属性名称进行自动装配的，如果有多个类型一样的Bean候选者，则可以通过name进行指定进行注入")]),a._v(" "),t("div",{staticClass:"language-java extra-class"},[t("pre",{pre:!0,attrs:{class:"language-java"}},[t("code",[t("span",{pre:!0,attrs:{class:"token annotation punctuation"}},[a._v("@Target")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("ElementType")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),t("span",{pre:!0,attrs:{class:"token constant"}},[a._v("TYPE")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" #接口、类、枚举、注解\n"),t("span",{pre:!0,attrs:{class:"token annotation punctuation"}},[a._v("@Target")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("ElementType")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),t("span",{pre:!0,attrs:{class:"token constant"}},[a._v("FIELD")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" #字段、枚举的常量\n"),t("span",{pre:!0,attrs:{class:"token annotation punctuation"}},[a._v("@Target")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("ElementType")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),t("span",{pre:!0,attrs:{class:"token constant"}},[a._v("METHOD")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" #方法\n")])])]),t("p",[a._v("@Inject")]),a._v(" "),t("p",[a._v("1、@Inject是JSR330 (Dependency Injection for Java)中的规范，需要导入javax.inject.Inject jar包 ，才能实现注入")]),a._v(" "),t("p",[a._v("2、@Inject可以作用CONSTRUCTOR、METHOD、FIELD上")]),a._v(" "),t("p",[a._v("3、@Inject是根据类型进行自动装配的，如果需要按名称进行装配，则需要配合@Named；")]),a._v(" "),t("h2",{attrs:{id:"ioc-的底层实现"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#ioc-的底层实现"}},[a._v("#")]),a._v(" IOC 的底层实现")]),a._v(" "),t("p",[a._v("顶层设计：")]),a._v(" "),t("p",[t("img",{attrs:{src:"https://p.ipic.vip/i7gjyf.png",alt:"img"}})]),a._v(" "),t("p",[t("img",{attrs:{src:"https://p.ipic.vip/hpfz0b.png",alt:"img"}})]),a._v(" "),t("h2",{attrs:{id:"spring-中-bean-的生命周期"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#spring-中-bean-的生命周期"}},[a._v("#")]),a._v(" Spring 中 Bean 的生命周期")]),a._v(" "),t("h2",{attrs:{id:"spring-如何解决循环依赖问题"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#spring-如何解决循环依赖问题"}},[a._v("#")]),a._v(" Spring 如何解决循环依赖问题")])])}),[],!1,null,null,null);t.default=e.exports}}]);