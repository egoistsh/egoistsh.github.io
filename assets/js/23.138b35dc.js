(window.webpackJsonp=window.webpackJsonp||[]).push([[23],{347:function(t,s,a){"use strict";a.r(s);var n=a(7),e=Object(n.a)({},(function(){var t=this,s=t._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h2",{attrs:{id:"synchronized的理解"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#synchronized的理解"}},[t._v("#")]),t._v(" synchronized的理解")]),t._v(" "),s("p",[t._v("synchronized关键字解决的是多个线程之间访问资源的同步性，synchronized 关键字可以保证被它修饰的方法或者代码块在任意时刻只能有一个线程执行。")]),t._v(" "),s("p",[t._v("在 Java 早期版本中，synchronized 属于重量级锁，效率低下，因为监视器锁（monitor）是依赖于底层的操作系统的 Mutex Lock 来实现的，Java 的线程是映射到操作系统的原生线程之上的。如果要挂起或者唤醒一个线程，都需要操作系统帮忙完成，而操作系统实现线程之间的切换时需要从用户态转换到内核态，这个状态之间的转换需要相对比较长的时间，时间成本相对较高。")]),t._v(" "),s("p",[t._v("在 JDK6 之后 Java 官方对从 JVM 层面对synchronized 较大优化，所以现在的 synchronized 锁效率也优化得很不错了。JDK6 对锁的实现引入了大量的优化，如自旋锁、适应性自旋锁、锁消除、锁粗化、偏向锁、轻量级锁等技术来减少锁操作的开销。")]),t._v(" "),s("h2",{attrs:{id:"synchronized的使用"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#synchronized的使用"}},[t._v("#")]),t._v(" synchronized的使用")]),t._v(" "),s("p",[t._v("根据修饰对象的分类：")]),t._v(" "),s("ul",[s("li",[t._v("修饰代码块\n"),s("ul",[s("li",[t._v("synchronized(this|object)")]),t._v(" "),s("li",[t._v("synchronized(类.class)")])])]),t._v(" "),s("li",[t._v("修饰方法\n"),s("ul",[s("li",[t._v("修饰非静态方法")]),t._v(" "),s("li",[t._v("修饰静态方法")])])])]),t._v(" "),s("p",[t._v("根据获取的锁来分类：")]),t._v(" "),s("ul",[s("li",[t._v("获取对象锁\n"),s("ul",[s("li",[t._v("synchronized(this|object)")]),t._v(" "),s("li",[t._v("修改非静态方法")])])]),t._v(" "),s("li",[t._v("获取类锁\n"),s("ul",[s("li",[t._v("synchronized(类.class)")]),t._v(" "),s("li",[t._v("修饰静态方法")])])])]),t._v(" "),s("p",[t._v("1、 修饰实例方法：作用于当前对象实例加锁，进入同步代码前要获得当前对象实例的锁；")]),t._v(" "),s("p",[t._v("2、修饰静态方法：作用于当前类对象加锁，进入同步代码前要获得当前类对象的锁 。也就是给当前类加锁，会作用于类的所有对象实例，因为静态成员不属于任何一个实例对象，是类成员。所以如果一个线程 A 调用一个实例对象的非静态 synchronized 方法，而线程 B 需要调用这个实例对象所属类的静态 synchronized 方法，是允许的，不会发生互斥现象，因为访问静态 synchronized 方法占用的锁是当前类的锁，而访问非静态 synchronized 方法占用的锁是当前实例对象锁；")]),t._v(" "),s("p",[t._v("3、 修饰代码块：指定加锁对象，对给定对象加锁，进入同步代码库前要获得给定对象的锁。和 synchronized 方法一样，synchronized(this) 代码块也是锁定当前对象的。synchronized 关键字加到 static 静态方法和 synchronized(class) 代码块上都是是给 Class 类上锁。尽量不要使用 synchronized(String a) 因为 JVM 中，字符串常量池具有缓冲功能。")]),t._v(" "),s("h3",{attrs:{id:"双重校验锁实现单例模式"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#双重校验锁实现单例模式"}},[t._v("#")]),t._v(" 双重校验锁实现单例模式")]),t._v(" "),s("p",[t._v("使用 synchronized 双重校验锁的方法实现单例模式：")]),t._v(" "),s("div",{staticClass:"language-java extra-class"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("class")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Singleton")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("private")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("volatile")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("static")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Singleton")]),t._v(" instance"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("private")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Singleton")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("static")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Singleton")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("getInstance")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("instance "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n      "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("synchronized")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Singleton")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("class")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("instance "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" instance "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Singleton")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n      "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" instance"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),s("p",[t._v("另外，需要注意 instance 采用 volatile 关键字修饰也是很有必要。 因为 instance = new Singleton(); 这段代码其实是分为三步执行：")]),t._v(" "),s("ol",[s("li",[t._v("为 instance 分配内存空间")]),t._v(" "),s("li",[t._v("初始化 instance")]),t._v(" "),s("li",[t._v("将 instance 指向分配的内存地址")])]),t._v(" "),s("p",[t._v("但是由于 JVM 具有指令重排的特性，执行顺序有可能变成 1 -> 3 -> 2。指令重排在单线程环境下不会出现问题，但是在多线程环境下会导致一个线程获得还没有初始化的实例。例如，线程 T1 执行了 1 和 3，此时 T2 调用 getInstance() 后发现 instance 不为空，因此返回 instance，但此时 instance 还未被初始化。")]),t._v(" "),s("p",[t._v("使用 volatile 可以禁止 JVM 的指令重排，保证在多线程环境下也能正常运行。")]),t._v(" "),s("h2",{attrs:{id:"synchronized-关键字底层原理"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#synchronized-关键字底层原理"}},[t._v("#")]),t._v(" synchronized 关键字底层原理")]),t._v(" "),s("p",[t._v("synchronized 关键字底层原理属于 JVM 层面。")]),t._v(" "),s("p",[t._v("synchronized 使用的锁对象是存储在Java对象头里的标记字段里。")]),t._v(" "),s("h3",{attrs:{id:"synchronized-同步语句块的底层实现"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#synchronized-同步语句块的底层实现"}},[t._v("#")]),t._v(" synchronized 同步语句块的底层实现")]),t._v(" "),s("p",[t._v("synchronized 同步语句块的实现使用的是 monitorenter 和 monitorexit 指令，其中 monitorenter 指令指向同步代码块的开始位置，monitorexit 指令则指明同步代码块的结束位置。")]),t._v(" "),s("p",[t._v("当执行 monitorenter 指令时，线程试图获取锁也就是获取 monitor的持有权。monitor 对象存在于每个 Java 对象的对象头中，synchronized 锁便是通过这种方式获取锁的，也是为什么 Java 中任意对象可以作为锁的原因。当计数器为 0 则可以成功获取，获取后将锁计数器设为 1 也就是加 1。相应的在执行 monitorexit 指令后，将锁计数器设为 0，表明锁被释放。如果获取对象锁失败，那当前线程就要阻塞等待，直到锁被另外一个线程释放为止。")]),t._v(" "),s("h3",{attrs:{id:"synchronized-修饰方法的底层实现"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#synchronized-修饰方法的底层实现"}},[t._v("#")]),t._v(" synchronized 修饰方法的底层实现")]),t._v(" "),s("p",[t._v("synchronized 修饰的方法并没有 monitorenter 指令和 monitorexit 指令，取得代之的确实是 "),s("strong",[t._v("ACC_SYNCHRONIZED 标识")]),t._v("，该标识指明了该方法是一个同步方法，JVM 通过该 ACC_SYNCHRONIZED 访问标志来辨别一个方法是否声明为同步方法，从而执行相应的同步调用。")]),t._v(" "),s("ul",[s("li",[t._v("ACC_SYNCHRONIZED标志表示方法为同步方法")]),t._v(" "),s("li",[t._v("无 ACC_STATIC标志 为普通同步方法")]),t._v(" "),s("li",[t._v("有 ACC_STATIC标志 为静态同步方法")])]),t._v(" "),s("p",[t._v("在java中，synchronized在编译后，会在同步块的前后分别形成一个monitorenter和monitorexit这两个字节码指令，这两个字节码都需要一个reference类型的参数来指明要锁定和解锁的对象，如果java程序中明确指定了对象，那就是这个对象的reference，如果没有指明，那么根据synchronized修饰的是实例方法还是类方法，去取对应的对象实例或者类Class对象来做锁对象。")]),t._v(" "),s("p",[t._v("在执行monitorenter时，首先会尝试获取对象的锁，如果这个对象没有锁，或者当前线程已经拥有了这个对象的锁，那个锁的计数器加1，相应的，在执行monitorexit时指令时，会将锁计数器减1，当计数器为0时，这个锁就被释放。如果获取对象锁失败，那当前线程就要阻塞等待，直到对象锁被另一个线程释放为止。")]),t._v(" "),s("h2",{attrs:{id:"synchronized-锁升级"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#synchronized-锁升级"}},[t._v("#")]),t._v(" synchronized 锁升级")]),t._v(" "),s("p",[t._v("锁升级的过程：")]),t._v(" "),s("ol",[s("li",[s("p",[t._v("一开始是处于无锁状态的")])]),t._v(" "),s("li",[s("p",[t._v("当有一个线程访问同步代码块时，升级成偏向锁（Mark Word 里存储锁偏向的线程 ID ，在线程进入和退出同步块时不再通过 CAS 操作来加锁和解锁，而是检测 Mark Word 里是否存储着指向当前线程的偏向锁）")])]),t._v(" "),s("li",[s("p",[t._v("有锁竞争时，升级为轻量级锁，自旋获取锁")])]),t._v(" "),s("li",[s("p",[t._v("自旋十次失败后，升级成重量级锁（线程阻塞）")])])]),t._v(" "),s("p",[t._v("锁的对比：")]),t._v(" "),s("table",[s("thead",[s("tr",[s("th",[t._v("锁")]),t._v(" "),s("th",[t._v("优点")]),t._v(" "),s("th",[t._v("缺点")]),t._v(" "),s("th",[t._v("适用场景")])])]),t._v(" "),s("tbody",[s("tr",[s("td",[t._v("偏向锁")]),t._v(" "),s("td",[t._v("加锁和解锁不需要额外的消耗，和执行非同步方法相比仅有纳秒级的差距")]),t._v(" "),s("td",[t._v("如果线程间存在锁竞争，会带来额外的锁撤销的消耗")]),t._v(" "),s("td",[t._v("适用于只有一个线程访问同步块的场景")])]),t._v(" "),s("tr",[s("td",[t._v("轻量级锁")]),t._v(" "),s("td",[t._v("竞争的线程不会阻塞，提高了程序的响应速度")]),t._v(" "),s("td",[t._v("如果竞争的线程始终得不到锁，是用自旋会消耗CPU")]),t._v(" "),s("td",[t._v("追求响应速度，痛不哭执行速度非常快")])]),t._v(" "),s("tr",[s("td",[t._v("重量级锁")]),t._v(" "),s("td",[t._v("线程竞争不使用自旋，不会消耗CPU")]),t._v(" "),s("td",[t._v("线程阻塞，响应时间缓慢")]),t._v(" "),s("td",[t._v("追求吞吐量，同步快执行速度较慢")])])])]),t._v(" "),s("p",[t._v("https://zhuanlan.zhihu.com/p/482639650")]),t._v(" "),s("h2",{attrs:{id:"volatile"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#volatile"}},[t._v("#")]),t._v(" volatile")]),t._v(" "),s("p",[t._v("volatile是Java虚拟机系统的轻量级同步机制。")]),t._v(" "),s("p",[t._v("其特点有：")]),t._v(" "),s("ul",[s("li",[t._v("保证可见性")]),t._v(" "),s("li",[t._v("不保证原子性")]),t._v(" "),s("li",[t._v("禁止指令重排序。\n"),s("ul",[s("li",[t._v("避免了多线程环境下程序出现乱序执行的现象。")]),t._v(" "),s("li",[t._v("指令重排只会保证串行语义的执行的一致性（单线程），但并不关心多线程间的语义一致性。")]),t._v(" "),s("li",[t._v("对 volatile 变量的读和写操作会在指令序列中插入内存屏障，保证了volatile变量的读写操作不会被指令重排序所影响。")])])])]),t._v(" "),s("p",[t._v("内存屏障（Memory Barrier）是一个 CPU 指令，作用有两个：")]),t._v(" "),s("ol",[s("li",[t._v("保证特定操作的执行顺序")]),t._v(" "),s("li",[t._v("保证某些变量的内存可见性（利用该特性实现 volatile 的可见性）")])]),t._v(" "),s("p",[t._v("应用场景：")]),t._v(" "),s("p",[t._v("单例模式下DCL不一定线程安全，由于指令重排，所以程序有小概率会出现 instance != null，但 instance 的引用对象可能还没完成初始化。所以当一个线程访问 instance != null时，instance未必已经初始化完成，造成了线程安全问题。")]),t._v(" "),s("p",[t._v("因为 instance = new Singleton();可以为被分为三步：")]),t._v(" "),s("div",{staticClass:"language-java extra-class"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[t._v("memory "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("allocate")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 1. 分配对象内存空间")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("instance")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("memory"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 2.初始化对象")]),t._v("\ninstance "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" memory"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 3. 设置 instance 执行刚分配的内存地址，此时 instance != null")]),t._v("\n")])])]),s("p",[t._v("解决方案可以在实例上加上 volatile："),s("code",[t._v("private static volatile Singleton instance = null;")])]),t._v(" "),s("h3",{attrs:{id:"如何实现可见性"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#如何实现可见性"}},[t._v("#")]),t._v(" 如何实现可见性")]),t._v(" "),s("p",[s("code",[t._v("volatile")]),t._v(" 关键字可以保证可见性的原因是，它会告诉 Java 编译器和运行时系统，每次读取该变量时都必须从主内存中重新获取最新的值，而不是使用本地缓存的副本。")]),t._v(" "),s("p",[t._v("具体来说，当一个线程修改一个 "),s("code",[t._v("volatile")]),t._v(" 变量的值时，这个值会立即被写回到主内存中，而不是被缓存在该线程的本地缓存中。同时，当其他线程需要读取这个变量的值时，它们也会从主内存中获取最新的值，而不是从本地缓存中获取旧值。")]),t._v(" "),s("p",[t._v("这种强制刷新内存的行为确保了变量的可见性，即使有多个线程同时对变量进行读取和修改，也能够看到最新的值。")]),t._v(" "),s("p",[t._v("volatile 变量的内存可见性是基于内存屏障(Memory Barrier)实现:")]),t._v(" "),s("ul",[s("li",[t._v("内存屏障，又称内存栅栏，是一个 CPU 指令。")]),t._v(" "),s("li",[t._v("在程序运行时，为了提高执行性能，编译器和处理器会对指令进行重排序，JMM 为了保证在不同的编译器和 CPU 上有相同的结果，通过插入特定类型的内存屏障来禁止+ 特定类型的编译器重排序和处理器重排序，插入一条内存屏障会告诉编译器和 CPU：不管什么指令都不能和这条 Memory Barrier 指令重排序。")])]),t._v(" "),s("h3",{attrs:{id:"为什么不能实现原子性"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#为什么不能实现原子性"}},[t._v("#")]),t._v(" 为什么不能实现原子性")]),t._v(" "),s("p",[t._v("（因为只保证可见性的情况下，是无法实现原子性的。。。所以不能实现原子性）")]),t._v(" "),s("p",[s("code",[t._v("volatile")]),t._v(" 关键字不能保证原子性的原因是，它只是保证变量的读写操作对所有线程的可见性，但并不能保证在多个线程同时访问同一个变量时，操作的顺序和正确性。")]),t._v(" "),s("p",[t._v("例如，在一个多线程程序中，如果有两个线程同时对一个 "),s("code",[t._v("volatile")]),t._v(" 变量进行自增操作")]),t._v(" "),s("div",{staticClass:"language-java extra-class"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("volatile")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" count "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("increment")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    count"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("++")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),s("p",[t._v("那么可能会发生以下情况：")]),t._v(" "),s("ol",[s("li",[t._v("线程 A 从内存中读取变量值为 0。")]),t._v(" "),s("li",[t._v("线程 B 从内存中读取变量值为 0。")]),t._v(" "),s("li",[t._v("线程 A 将变量值加 1 得到 1。")]),t._v(" "),s("li",[t._v("线程 B 将变量值加 1 得到 1。")]),t._v(" "),s("li",[t._v("线程 A 将变量值写回内存。")]),t._v(" "),s("li",[t._v("线程 B 将变量值写回内存。")])]),t._v(" "),s("p",[t._v("在这个例子中，虽然 "),s("code",[t._v("volatile")]),t._v(" 关键字保证了线程 A 和线程 B 都能够看到最新的变量值，但它无法保证操作的原子性，导致最终的变量值为 1 而不是 2。")]),t._v(" "),s("h2",{attrs:{id:"参考"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#参考"}},[t._v("#")]),t._v(" 参考")]),t._v(" "),s("ul",[s("li",[s("p",[t._v("https://segmentfault.com/a/1190000041268785")])]),t._v(" "),s("li",[s("p",[t._v("https://zhuanlan.zhihu.com/p/482639650")])])])])}),[],!1,null,null,null);s.default=e.exports}}]);