(window.webpackJsonp=window.webpackJsonp||[]).push([[46],{370:function(t,s,e){"use strict";e.r(s);var a=e(7),n=Object(a.a)({},(function(){var t=this,s=t._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("p",[t._v("从加锁的范围来区别，可以分为：")]),t._v(" "),s("ul",[s("li",[t._v("全局锁\n"),s("ul",[s("li",[t._v("应用场景：全库逻辑备份。但还是建议开启事务，借助可重复读的Read View 来备份。")])])]),t._v(" "),s("li",[t._v("表级锁\n"),s("ul",[s("li",[t._v("表锁")]),t._v(" "),s("li",[t._v("元数据锁（metadata lock，MDL）：我们不需要显示的使用 MDL，因为当我们对数据库表进行操作时，会自动给这个表加上 MDL。")]),t._v(" "),s("li",[t._v("意向锁：意向共享锁和意向独占锁是表级锁，不会和行级的共享锁和独占锁发生冲突，而且意向锁之间也不会发生冲突，只会和共享表锁（"),s("em",[t._v("lock tables ... read")]),t._v("）和独占表锁（"),s("em",[t._v("lock tables ... write")]),t._v("）发生冲突。")]),t._v(" "),s("li",[t._v("AUTO-INC 锁：AUTO-INC 锁是特殊的表锁机制，锁不是再一个事务提交后才释放，而是再执行完插入语句后就会立即释放。")])])]),t._v(" "),s("li",[t._v("行级锁\n"),s("ul",[s("li",[t._v("记录锁 Record Lock：仅把一条记录上锁")]),t._v(" "),s("li",[t._v("间隙锁 Gap Lock：锁定一个范围，但不包含记录本身\n"),s("ul",[s("li",[t._v("间隙锁虽然存在 X 型间隙锁和 S 型间隙锁，但是并没有什么区别，间隙锁之间是兼容的，即两个事务可以同时持有包含共同间隙范围的间隙锁，并不存在互斥关系，因为间隙锁的目的是防止插入幻影记录而提出的。")])])]),t._v(" "),s("li",[t._v("临键锁 Next-key Lock：=Record Lock + Gap Lock，锁定一个范围以及记录本身。")])])])]),t._v(" "),s("p",[t._v("表锁和行锁是满足读读共享、读写互斥、写写互斥的。")]),t._v(" "),s("p",[t._v("普通的 select 是不会加行级锁的，普通的 select 语句是利用 MVCC 实现一致性读，是无锁的。")]),t._v(" "),s("p",[t._v("在 InnoDB 事务中，对记录加锁带基本单位是 next-key 锁，但是会因为一些条件会退化成间隙锁，或者记录锁。"),s("strong",[t._v("加锁的位置准确的说，锁是加在索引上的而非行上。")])]),t._v(" "),s("div",{staticClass:"language-sql extra-class"},[s("pre",{pre:!0,attrs:{class:"language-sql"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 开启全局锁")]),t._v("\nflush "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("tables")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("with")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("read")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("lock")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 释放全局锁")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("unlock")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("tables")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 表级别的共享锁，也就是读锁")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("lock")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("tables")]),t._v(" t "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("read")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 表级别的排他锁，也就是写锁")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("lock")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("tables")]),t._v(" t "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("write")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 释放当前会话的所有表锁")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("unlock")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("tables")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 这两条语句必须在一个事务中，因为当事务提交了，锁就会被释放。")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 所以在使用这两条语句的时候，要加上 begin、start transaction 或者 set autocommit = 0。")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 先在表上加上意向共享锁，然后对读取的记录加共享锁（S锁）")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("select")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("lock")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("in")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("share")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("mode")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 先表上加上意向独占锁，然后对读取的记录加独占锁（X锁）")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("select")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("for")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("update")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),s("h2",{attrs:{id:"next-key-lock"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#next-key-lock"}},[t._v("#")]),t._v(" next-key lock")]),t._v(" "),s("p",[t._v("行锁 + "),s("strong",[t._v("该行之前的间隙锁")]),t._v("合称 next-key lock，每个 next-key lock 是前开后闭区间。")]),t._v(" "),s("h3",{attrs:{id:"间隙锁和next-key-lock的加锁规则"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#间隙锁和next-key-lock的加锁规则"}},[t._v("#")]),t._v(" 间隙锁和next-key lock的加锁规则")]),t._v(" "),s("p",[t._v("加锁规则里面，包含了两个“原则”、两个“优化”和一个“bug”。")]),t._v(" "),s("ol",[s("li",[t._v("原则 1：加锁的基本单位是 next-key lock。next-key lock 是前开后闭区间。")]),t._v(" "),s("li",[t._v("原则 2：查找过程中访问到的对象才会加锁。")]),t._v(" "),s("li",[t._v("优化 1：索引上的等值查询，给唯一索引加锁的时候，next-key lock 退化为行锁。")]),t._v(" "),s("li",[t._v("优化 2：索引上的等值查询，向右遍历时且最后一个值不满足等值条件的时候，next-key lock 退化为间隙锁。")]),t._v(" "),s("li",[t._v("一个 bug：唯一索引上的范围查询会访问到不满足条件的第一个值为止。（8.0.26 没有这个bug）")])]),t._v(" "),s("p",[t._v("https://www.jianshu.com/p/d1aba64b5c03")])])}),[],!1,null,null,null);s.default=n.exports}}]);