(window.webpackJsonp=window.webpackJsonp||[]).push([[70],{397:function(_,v,t){"use strict";t.r(v);var r=t(7),a=Object(r.a)({},(function(){var _=this,v=_._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[v("h2",{attrs:{id:"并行和并发"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#并行和并发"}},[_._v("#")]),_._v(" 并行和并发")]),_._v(" "),v("p",[_._v("并行是指两个或者多个事件在"),v("strong",[_._v("同一时刻")]),_._v("发生；而并发是指两个或多个事件在"),v("strong",[_._v("同一时间间隔")]),_._v("发生；")]),_._v(" "),v("p",[_._v("并行是在不同实体上的多个事件，并发是在同一实体上的多个事件；")]),_._v(" "),v("h2",{attrs:{id:"同步、异步、阻塞、非阻塞"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#同步、异步、阻塞、非阻塞"}},[_._v("#")]),_._v(" 同步、异步、阻塞、非阻塞")]),_._v(" "),v("p",[v("strong",[_._v("同步")]),_._v("：当一个同步调用发出后，调用者要一直等待返回结果。通知后，才能进行后续的执行。")]),_._v(" "),v("p",[v("strong",[_._v("异步")]),_._v("：当一个异步过程调用发出后，调用者不能立刻得到返回结果。实际处理这个调用的部件在完成后，通过状态、通知和回调来通知调用者。")]),_._v(" "),v("p",[v("strong",[_._v("阻塞")]),_._v("：是指调用结果返回前，当前线程会被挂起，即阻塞。")]),_._v(" "),v("p",[v("strong",[_._v("非阻塞")]),_._v("：是指即使调用结果没返回，也不会阻塞当前线程。")]),_._v(" "),v("h2",{attrs:{id:"进程和线程"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#进程和线程"}},[_._v("#")]),_._v(" 进程和线程")]),_._v(" "),v("p",[_._v("进程和线程是操作系统中的两个基本概念，它们都是程序运行的基本单位。")]),_._v(" "),v("p",[_._v("进程是指正在运行的一个程序实例。每个进程都有自己的地址空间、数据栈、文件句柄、系统资源等，可以独立地运行、停止和调度。操作系统为每个进程分配唯一的进程标识符PID，用于标识和管理进程。每个进程可以包含一个或多个线程。")]),_._v(" "),v("p",[_._v("线程是进程的一个执行单元。一个进程可以包含多个线程，每个线程共享相同的地址空间和系统资源，包括打开的文件、信号处理程序、用户ID和组ID等。线程与进程不同，线程没有独立的地址空间，一个进程中的所有线程共享相同的地址空间和系统资源，因此线程之间的通信和同步更加容易和高效。")]),_._v(" "),v("p",[_._v("与进程相比，线程的优点是更加轻量级和高效，线程之间的切换开销更小，可以更好地利用多核CPU，同时线程之间的通信和同步更加容易和高效。因此，在实际应用中，线程被广泛使用，例如在Web服务器、数据库服务器和操作系统等中。但是，线程之间的共享资源也会带来一些安全性和稳定性方面的问题，因此在使用时需要小心处理。")]),_._v(" "),v("p",[_._v("总结来说，进程是指正在运行的一个程序实例，拥有独立的地址空间和系统资源，而线程是进程的一个执行单元，多个线程共享相同的地址空间和系统资源，可以更加高效地执行任务。")]),_._v(" "),v("p",[_._v("区别：")]),_._v(" "),v("ol",[v("li",[_._v("资源占用：一个进程拥有独立的地址空间和系统资源，包括内存、文件句柄、设备和信号处理等，而线程是进程中的一条执行路径，它与同一进程内的其他线程共享相同的资源。")]),_._v(" "),v("li",[_._v("调度和切换：线程的切换比进程的切换更快，因为线程共享相同的地址空间和系统资源，上下文切换的开销比进程小。")]),_._v(" "),v("li",[_._v("通信和同步：由于线程共享相同的资源，线程之间通信和同步更加容易和高效。而进程之间通信和同步需要使用进程间通信(IPC)机制，如管道、信号、消息队列、共享内存等，它们比线程间通信的开销更大。")]),_._v(" "),v("li",[_._v("稳定性和安全性：由于线程共享相同的资源，一个线程的错误可能会导致整个进程崩溃，而一个进程的崩溃只会影响同一进程内的其他线程。因此，进程比线程更加稳定和安全。")]),_._v(" "),v("li",[_._v("并发性和多核利用：由于线程共享相同的地址空间和系统资源，多个线程可以并发地执行同一进程的不同任务，从而提高CPU的利用率。而进程之间的并发需要在多个CPU上运行，因此进程在利用多核CPU时更加有效。")])]),_._v(" "),v("h2",{attrs:{id:"有进程为什么还要有线程"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#有进程为什么还要有线程"}},[_._v("#")]),_._v(" 有进程为什么还要有线程")]),_._v(" "),v("p",[_._v("进程可以使多个程序并发执行，以提高资源的利用率和系统的吞吐量，但是其带来了一些缺点：")]),_._v(" "),v("ol",[v("li",[_._v("进程在同一时间只能干一件事情；")]),_._v(" "),v("li",[_._v("进程在执行的过程中如果阻塞，整个进程就会被挂起，即使进程中有些工作不依赖与等待的资源，仍然不会执行。")])]),_._v(" "),v("p",[_._v("基于以上的缺点，操作系统引入了比进程粒度更小的线程，作为并发执行的基本单位，从而减少程序在并发执行时所付出的时间和空间开销，提高并发性能。")]),_._v(" "),v("h2",{attrs:{id:"携程"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#携程"}},[_._v("#")]),_._v(" 携程")]),_._v(" "),v("p",[_._v("携程（Coroutine）是一种轻量级的线程，也称为协程。它与传统的操作系统线程（Thread）不同，操作系统线程由操作系统调度和管理，而携程则"),v("strong",[_._v("由程序本身控制")]),_._v("。")]),_._v(" "),v("p",[_._v("携程的特点是轻量级、高效、简单、易于使用。携程可以在一个线程中执行多个任务，通过在任务之间切换来实现并发和异步操作。与传统的多线程编程模型相比，携程的优点是更加高效、更加灵活、更加容易管理和调度，并且可以避免由于线程切换而带来的开销和竞争条件问题。")]),_._v(" "),v("p",[_._v("携程在编写异步代码、网络编程、协议解析、爬虫等领域中广泛应用。在Python中，携程通过协程库（Coroutine Library）来实现，其中最著名的是asyncio库。在其他编程语言中，例如Go、C++、Lua等，也都支持携程的实现。")]),_._v(" "),v("p",[_._v("总之，携程是一种轻量级的线程，具有高效、灵活、简单等特点，可以用于异步编程、网络编程、协议解析、爬虫等领域。")]),_._v(" "),v("h2",{attrs:{id:"进程的状态转换"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#进程的状态转换"}},[_._v("#")]),_._v(" 进程的状态转换")]),_._v(" "),v("p",[_._v("就绪态、运行态、阻塞态")]),_._v(" "),v("p",[_._v("就绪<--\x3e运行")]),_._v(" "),v("p",[_._v("运行--\x3e阻塞")]),_._v(" "),v("p",[_._v("阻塞--\x3e就绪")]),_._v(" "),v("h2",{attrs:{id:"进程间的通信方式"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#进程间的通信方式"}},[_._v("#")]),_._v(" 进程间的通信方式")]),_._v(" "),v("p",[_._v("进程间通信（IPC，InterProcess Communication）是指在不同进程之间传播或交换信息。IPC 的方式通常有管道（包括无名管道和命名管道）、消息队列、信号量、共享存储、Socket、Streams 等。其中 Socket 和 Streams 支持不同主机上的两个进程 IPC。")]),_._v(" "),v("p",[v("strong",[_._v("管道")])]),_._v(" "),v("ol",[v("li",[_._v("它是半双工的，具有固定的读端和写端；")]),_._v(" "),v("li",[_._v("它只能用于父子进程或者兄弟进程之间的进程的通信；")]),_._v(" "),v("li",[_._v("它可以看成是一种特殊的文件，对于它的读写也可以使用普通的 read、write 等函数。但是它不是普通的文件，并不属于其他任何文件系统，并且只存在于内存中。")])]),_._v(" "),v("p",[v("strong",[_._v("命名管道")])]),_._v(" "),v("ol",[v("li",[_._v("FIFO 可以在无关的进程之间交换数据，与无名管道不同；")]),_._v(" "),v("li",[_._v("FIFO 有路径名与之相关联，它以一种特殊设备文件形式存在于文件系统中。")])]),_._v(" "),v("p",[v("strong",[_._v("消息队列")])]),_._v(" "),v("ol",[v("li",[_._v("消息队列，是消息的链接表，存放在内核中。一个消息队列由一个标识符 ID 来标识；")]),_._v(" "),v("li",[_._v("消息队列是面向记录的，其中的消息具有特定的格式以及特定的优先级；")]),_._v(" "),v("li",[_._v("消息队列独立于发送与接收进程。进程终止时，消息队列及其内容并不会被删除；")]),_._v(" "),v("li",[_._v("消息队列可以实现消息的随机查询，消息不一定要以先进先出的次序读取，也可以按消息的类型读取。")])]),_._v(" "),v("p",[v("strong",[_._v("信号量")])]),_._v(" "),v("ol",[v("li",[_._v("信号量（semaphore）是一个计数器。用于实现进程间的互斥与同步，而不是用于存储进程间通信数据；")]),_._v(" "),v("li",[_._v("信号量用于进程间同步，若要在进程间传递数据需要结合共享内存；")]),_._v(" "),v("li",[v("strong",[_._v("信号量基于操作系统的 PV 操作")]),_._v("，程序对信号量的操作都是原子操作；")]),_._v(" "),v("li",[_._v("每次对信号量的 PV 操作不仅限于对信号量值加 1 或减 1，而且可以加减任意正整数；")]),_._v(" "),v("li",[_._v("支持信号量组。")])]),_._v(" "),v("p",[v("strong",[_._v("共享内存")])]),_._v(" "),v("ol",[v("li",[_._v("共享内存（Shared Memory），指两个或多个进程共享一个给定的存储区；")]),_._v(" "),v("li",[_._v("共享内存是最快的一种 IPC，因为进程是直接对内存进行存取。")])]),_._v(" "),v("h2",{attrs:{id:"进程调度算法"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#进程调度算法"}},[_._v("#")]),_._v(" 进程调度算法")]),_._v(" "),v("p",[_._v("调度算法是指：根据系统的资源分配策略所规定的资源分配算法。")]),_._v(" "),v("p",[_._v("常用的调度算法有：先来先服务调度算法、时间片轮转调度法、短作业优先调度算法、最短剩余时间优先、高响应比优先调度算法、优先级调度算法等等。")]),_._v(" "),v("h2",{attrs:{id:"用户态和内核态"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#用户态和内核态"}},[_._v("#")]),_._v(" 用户态和内核态")]),_._v(" "),v("p",[_._v("用户态和内核态是操作系统的两种运行状态。")]),_._v(" "),v("ul",[v("li",[_._v("内核态：处于内核态的 CPU 可以访问任意的数据，包括外围设备，比如网卡、硬盘等，处于内核态的 CPU 可以从一个程序切换到另外一个程序，并且占用 CPU 不会发生抢占情况，一般处于特权级 0 的状态我们称之为内核态。")]),_._v(" "),v("li",[_._v("用户态：处于用户态的 CPU 只能受限的访问内存，并且不允许访问外围设备，用户态下的 CPU 不允许独占，也就是说 CPU 能够被其他程序获取。")])]),_._v(" "),v("h2",{attrs:{id:"为什么要有用户态和内核态呢"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#为什么要有用户态和内核态呢"}},[_._v("#")]),_._v(" 为什么要有用户态和内核态呢？")]),_._v(" "),v("p",[_._v("这个主要是"),v("strong",[_._v("对访问能力的限制")]),_._v("，计算机中有一些比较危险的操作，比如设置时钟、内存清理，这些都需要在内核态下完成，如果随意进行这些操作，那你的系统得崩溃多少次。")]),_._v(" "),v("h2",{attrs:{id:"用户态和内核态是如何切换的"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#用户态和内核态是如何切换的"}},[_._v("#")]),_._v(" 用户态和内核态是如何切换的？")]),_._v(" "),v("p",[_._v("所有的用户进程都是运行在用户态的，但用户程序的访问能力有限，一些比较重要的比如从硬盘读取数据，从键盘获取数据的操作则是内核态才能做的事情，而这些数据却又对用户程序来说非常重要。所以就涉及到两种模式下的转换，即"),v("strong",[_._v("用户态 -> 内核态 -> 用户态")]),_._v("，而唯一能够做这些操作的只有"),v("strong",[_._v("系统调用")]),_._v("，而能够执行系统调用的就只有"),v("strong",[_._v("操作系统")]),_._v("。")]),_._v(" "),v("p",[v("img",{attrs:{src:"https://p.ipic.vip/lalttn.jpg",alt:"img"}})]),_._v(" "),v("ul",[v("li",[_._v("首先用户程序会调用 "),v("code",[_._v("glibc")]),_._v(" 库，glibc 是一个标准库，同时也是一套核心库，库中定义了很多关键 API。")]),_._v(" "),v("li",[_._v("glibc 库知道针对不同体系结构调用"),v("code",[_._v("系统调用")]),_._v("的正确方法，它会根据体系结构应用程序的二进制接口设置用户进程传递的参数，来准备系统调用。")]),_._v(" "),v("li",[_._v("然后，glibc 库调用"),v("code",[_._v("软件中断指令(SWI)")]),_._v(" ，这个指令通过更新 "),v("code",[_._v("CPSR")]),_._v(" 寄存器将模式改为超级用户模式，然后跳转到地址 "),v("code",[_._v("0x08")]),_._v(" 处。")]),_._v(" "),v("li",[_._v("到目前为止，整个过程仍处于用户态下，在执行 SWI 指令后，允许进程执行内核代码，MMU 现在允许内核虚拟内存访问")]),_._v(" "),v("li",[_._v("从地址 0x08 开始，进程执行加载并跳转到中断处理程序，这个程序就是 ARM 中的 "),v("code",[_._v("vector_swi()")]),_._v("。")]),_._v(" "),v("li",[_._v("在 vector_swi() 处，从 SWI 指令中提取系统调用号 SCNO，然后使用 SCNO 作为系统调用表 "),v("code",[_._v("sys_call_table")]),_._v(" 的索引，调转到系统调用函数。")]),_._v(" "),v("li",[_._v("执行系统调用完成后，将还原用户模式寄存器，然后再以用户模式执行。")])])])}),[],!1,null,null,null);v.default=a.exports}}]);