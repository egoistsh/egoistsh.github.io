(window.webpackJsonp=window.webpackJsonp||[]).push([[39],{363:function(t,s,a){"use strict";a.r(s);var _=a(7),v=Object(_.a)({},(function(){var t=this,s=t._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h2",{attrs:{id:"事务"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#事务"}},[t._v("#")]),t._v(" 事务")]),t._v(" "),s("p",[t._v("事务的通俗解释：事务是一组逻辑操作，要么都执行，要么都不执行。")]),t._v(" "),s("p",[t._v("经典例子：转账。")]),t._v(" "),s("h2",{attrs:{id:"事务的四大特性-acid"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#事务的四大特性-acid"}},[t._v("#")]),t._v(" 事务的四大特性（ACID）")]),t._v(" "),s("ul",[s("li",[t._v("原子性")]),t._v(" "),s("li",[t._v("一致性：执行事务前后，数据保持一致，多个事务对同一个数据读取的结果是相同的；")]),t._v(" "),s("li",[t._v("隔离性")]),t._v(" "),s("li",[t._v("持久性")])]),t._v(" "),s("h2",{attrs:{id:"事务的隔离级别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#事务的隔离级别"}},[t._v("#")]),t._v(" 事务的隔离级别")]),t._v(" "),s("p",[t._v("为了达到事务的四大特性，数据库定义了4种不同的事务隔离级别，由低到高依次为")]),t._v(" "),s("p",[t._v("Read uncommitted、Read committed、Repeatable read、Serializable，")]),t._v(" "),s("p",[t._v("这四个级别可以逐个解决脏读、不可重复读、幻读这几类问题。")]),t._v(" "),s("ul",[s("li",[s("p",[s("strong",[t._v("READ-UNCOMMITTED(读取未提交)：")]),t._v(" 最低的隔离级别，允许读取尚未提交的数据变更，"),s("strong",[t._v("可能会导致脏读、不可重复读、幻读问题")]),t._v("。")])]),t._v(" "),s("li",[s("p",[s("strong",[t._v("READ-COMMITTED(读取已提交)：")]),t._v(" 允许读取并发事务已经提交的数据，"),s("strong",[t._v("可以阻止脏读，但是幻读或不可重复读仍有可能发生")]),t._v("。")])]),t._v(" "),s("li",[s("p",[s("strong",[t._v("REPEATABLE-READ(可重复读)：")]),t._v(" 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，"),s("strong",[t._v("可以阻止脏读和不可重复读，但幻读仍有可能发生")]),t._v("。")])]),t._v(" "),s("li",[s("p",[s("strong",[t._v("SERIALIZABLE(可串行化)：")]),t._v(" 最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，"),s("strong",[t._v("该级别可以防止脏读、不可重复读以及幻读")]),t._v("。")])])]),t._v(" "),s("h3",{attrs:{id:"设置隔离级别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#设置隔离级别"}},[t._v("#")]),t._v(" 设置隔离级别")]),t._v(" "),s("p",[t._v("设置innodb的事务级别方法是：set 作用域 transaction isolation level 事务隔离级别，例如：")]),t._v(" "),s("div",{staticClass:"language-sql extra-class"},[s("pre",{pre:!0,attrs:{class:"language-sql"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("SET")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("SESSION")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("GLOBAL")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("TRANSACTION")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("ISOLATION")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("LEVEL")]),t._v(" {"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("READ")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("UNCOMMITTED")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("READ")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("COMMITTED")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("REPEATABLE")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("READ")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("SERIALIZABLE")]),t._v("}\n\nmysql"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("set")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("global")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("transaction")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("isolation")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("level")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("read")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("committed")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//全局的")]),t._v("\n\nmysql"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("set")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("session")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("transaction")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("isolation")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("level")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("read")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("committed")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//当前会话（一个cmd窗口）")]),t._v("\n")])])]),s("h3",{attrs:{id:"脏读、不可重复读、幻读"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#脏读、不可重复读、幻读"}},[t._v("#")]),t._v(" 脏读、不可重复读、幻读")]),t._v(" "),s("ul",[s("li",[t._v("脏读(Drity Read)：某个事务已更新一份数据，另一个事务在此时读取了同一份数据，由于某些原因，前一个RollBack了操作，则后一个事务所读取的数据就会是不正确的。")]),t._v(" "),s("li",[t._v("不可重复读(Non-repeatable read):在一个事务的两次查询之中数据不一致，这可能是两次查询过程中间插入了一个事务更新的原有的数据。")]),t._v(" "),s("li",[t._v("幻读(Phantom Read):在一个事务的两次查询中数据笔数不一致，例如有一个事务查询了几列(Row)数据，而另一个事务却在此时插入了新的几列数据，先前的事务在接下来的查询中，就会发现有几列数据是它先前所没有的。")])]),t._v(" "),s("h3",{attrs:{id:"注意"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#注意"}},[t._v("#")]),t._v(" 注意")]),t._v(" "),s("p",[t._v("Mysql 默认采用的 REPEATABLE_READ隔离级别 Oracle 默认采用的 READ_COMMITTED隔离级别")]),t._v(" "),s("p",[t._v("事务隔离机制的实现基于锁机制和并发调度。其中并发调度使用的是MVVC（多版本并发控制），通过保存修改的旧版本信息来支持并发一致性读和回滚等特性。")]),t._v(" "),s("p",[t._v("因为隔离级别越低，事务请求的锁越少，所以大部分数据库系统的隔离级别都是"),s("strong",[t._v("READ-COMMITTED(读取提交内容):")]),t._v("，但是你要知道的是InnoDB 存储引擎默认使用 **REPEATABLE-READ（可重读）**并不会有任何性能损失。")]),t._v(" "),s("p",[t._v("InnoDB 存储引擎在 "),s("strong",[t._v("分布式事务")]),t._v(" 的情况下一般会用到**SERIALIZABLE(可串行化)**隔离级别。")]),t._v(" "),s("h2",{attrs:{id:"数据库如何通过-acid-来实现事务"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#数据库如何通过-acid-来实现事务"}},[t._v("#")]),t._v(" 数据库如何通过 ACID 来实现事务")]),t._v(" "),s("p",[t._v("ACID：")]),t._v(" "),s("p",[t._v("AID是手段，C是目的。为了保证数据状态的一致性，需要通过原子性、隔离性、持久性来保障。")]),t._v(" "),s("p",[t._v("实现原子性：undo log")]),t._v(" "),s("p",[t._v("实现持久性：redo log")]),t._v(" "),s("p",[t._v("实现隔离性：加锁同步 + MVCC。")]),t._v(" "),s("p",[s("a",{attrs:{href:"https://www.51cto.com/article/683670.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("阿里面试官：MySQL是如何实现ACID的？-mysql怎么实现acid"),s("OutboundLink")],1)]),t._v(" "),s("p",[s("a",{attrs:{href:"https://www.cnblogs.com/kismetv/p/10331633.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("深入学习MySQL事务：ACID特性的实现原理 - 编程迷思 - 博客园"),s("OutboundLink")],1)]),t._v(" "),s("h2",{attrs:{id:"如何实现4种隔离级别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#如何实现4种隔离级别"}},[t._v("#")]),t._v(" 如何实现4种隔离级别")]),t._v(" "),s("p",[t._v("提供了3种锁：写锁、读锁、范围锁。")]),t._v(" "),s("p",[t._v("根据加锁的不同，提供了不同的隔离级别。")]),t._v(" "),s("p",[t._v("串行化：对事务所有读、写的数据全加上读锁、写锁和范围锁。")]),t._v(" "),s("p",[t._v("可重复读：对事务所涉及的数据加读锁和写锁，且直到事务结束，但不加范围锁。可能导致"),s("strong",[t._v("幻读")]),t._v("问题（事务执行过程中，两个完全相同的范围查询得到不同的结果）。")]),t._v(" "),s("p",[t._v("读已提交：对事务涉及的数据加的写锁一直持续到事务结束，加的读锁在查询操作结束后便马上释放。可能导致"),s("strong",[t._v("不可重复读")]),t._v("问题（事务执行过程中，对同一行数据的两次查询得到不同结果）。")]),t._v(" "),s("p",[t._v("读未提交：对事务涉及的数据只加写锁，且持续到事务结束。可能导致"),s("strong",[t._v("脏读")]),t._v("问题（在事务执行过程中，一个事务读取到另一个事务未提交的数据）。")]),t._v(" "),s("p",[t._v("MVCC（multi-version concurrency control）多版本并发控制")]),t._v(" "),s("p",[t._v("针对一个事务读+一个事务写的场景，可以进行MVCC的无锁优化方案。只针对“读+写”场景优化。")]),t._v(" "),s("p",[t._v("基本思路：对数据库的任何修改都不会覆盖之前的数据，而是产生一个新版副本与旧版本共存，以此达到读取时可以完全不用加锁的目的。版本可理解为数据库中每一行数据记录都存在2个看不见的字段：CREATE_VERSION和DELETE_VERSION，两个字段记录的都是事务ID。")]),t._v(" "),s("ul",[s("li",[t._v("插入数据时：CREATE_VERSION 记录插入数据的事务 ID，DELETE_VERSION 为空。")]),t._v(" "),s("li",[t._v("删除数据时：DELETE_VERSION 记录删除数据的事务 ID，CREATE_VERSION 为空。")]),t._v(" "),s("li",[t._v("修改数据时：将修改数据视为“删除旧数据，插入新数据”的组合，即先将原有数据复制一份，原有数据的 DELETE_VERSION 记录修改数据的事务 ID，CREATE_VERSION 为空。复制出来的新数据的 CREATE_VERSION 记录修改数据的事务 ID，DELETE_VERSION 为空。")])]),t._v(" "),s("p",[t._v("此时，如有另外一个事务要读取这些发生了变化的数据，将根据隔离级别来决定到底应该读取哪个版本的数据。")]),t._v(" "),s("ul",[s("li",[t._v("隔离级别是"),s("code",[t._v("可重复读")]),t._v("：总是读取 CREATE_VERSION 小于或等于当前事务 ID 的记录，在这个前提下，如果数据仍有多个版本，则取最新（事务 ID 最大）的。")]),t._v(" "),s("li",[t._v("隔离级别是"),s("code",[t._v("读已提交")]),t._v("：总是取最新的版本即可，即最近被 Commit 的那个版本的数据记录。")])]),t._v(" "),s("p",[t._v("另外两个隔离级别都没有必要用到 MVCC，因为"),s("code",[t._v("读未提交")]),t._v("直接修改原始数据即可，其他事务查看数据的时候立刻可以看到，根本无须版本字段。"),s("code",[t._v("可串行化")]),t._v("本来的语义就是要阻塞其他事务的读取操作，而 MVCC 是做读取时无锁优化的，自然就不会放到一起用。")])])}),[],!1,null,null,null);s.default=v.exports}}]);