(window.webpackJsonp=window.webpackJsonp||[]).push([[125],{447:function(t,s,a){"use strict";a.r(s);var e=a(7),n=Object(e.a)({},(function(){var t=this,s=t._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h2",{attrs:{id:"排他锁和共享锁就是写锁和读锁吗-读锁可以是排他锁吗"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#排他锁和共享锁就是写锁和读锁吗-读锁可以是排他锁吗"}},[t._v("#")]),t._v(" 排他锁和共享锁就是写锁和读锁吗？读锁可以是排他锁吗？")]),t._v(" "),s("p",[t._v("总的来说，排他锁（Exclusive Lock）是写锁，用于保护数据对象的一致性和完整性，而共享锁（Shared Lock）通常是读锁，用于允许多个事务并发读取数据对象。在某些数据库系统中，排他锁也可以被用作读锁。")]),t._v(" "),s("p",[t._v("**共享锁 Shared Lock，**又称为读锁，获得共享锁之后，可以查看但无法修改和删除数据。")]),t._v(" "),s("p",[t._v("**排他锁 Exclusive Lock，**又称为写锁、独占锁，获得排他锁之后，既能读数据，又能修改数据。")]),t._v(" "),s("p",[t._v("使用共享锁："),s("code",[t._v("SELECT ... LOCK IN SHARE MODE;")])]),t._v(" "),s("p",[t._v("当没有其他线程对查询结果集中的任何一行使用排他锁时，可以成功申请共享锁，否则会被阻塞。其他线程也可以读取使用了共享锁的表，而且这些线程读取的是同一个版本的数据。")]),t._v(" "),s("p",[t._v("使用排他锁："),s("code",[t._v("SELECT ... FOR UPDATE;")])]),t._v(" "),s("p",[t._v("当没有其他线程对查询结果集中的任何一行使用排他锁时，可以成功申请排他锁，否则会被阻塞。")]),t._v(" "),s("p",[t._v("MySql的InnoDB引擎来说，对于"),s("code",[t._v("insert")]),t._v("、"),s("code",[t._v("update")]),t._v("、"),s("code",[t._v("delete")]),t._v("等操作。会自动给涉及的数据加排他锁；对于一般的"),s("code",[t._v("select")]),t._v("语句，InnoDB不会加任何锁，事务可以通过以下语句给显示加共享锁或排他锁。")]),t._v(" "),s("h2",{attrs:{id:"快照读和当前读的区别-什么是当前读-读的是什么时候的数据"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#快照读和当前读的区别-什么是当前读-读的是什么时候的数据"}},[t._v("#")]),t._v(" 快照读和当前读的区别？什么是当前读，读的是什么时候的数据？")]),t._v(" "),s("p",[t._v("快照读（Snapshot Read），也称为当前读，是基于数据库的一致性视图来读取数据。它读取的是事务开始时数据库中的数据快照，即某个特定时刻的数据。这意味着无论其他事务是否正在修改数据，快照读始终读取的是一致的、静态的数据快照。快照读不会受到其他并发事务的修改操作的影响，因此可以提供较高的并发性能。")]),t._v(" "),s("p",[t._v("快照读读取的是记录数据的可见版本，不加锁，不加锁的普通select语句都是快照读，即不加锁的非阻塞读。")]),t._v(" "),s("p",[t._v("快照读的执行方式是生成 ReadView，直接利用 MVCC 机制来进行读取，并不会对记录进行加锁。")]),t._v(" "),s("p",[t._v("当前读（Current Read），也称为锁定读，是基于当前事务的最新数据来读取数据。它读取的是其他事务已经提交的最新数据。当前读会获取最新的数据，这包括了其他并发事务已经提交的修改。当前读可以读取其他事务所做的更改，因此可以提供实时的数据，但同时也可能会受到其他并发事务的影响。如果其他事务正在修改被当前读操作所涉及的数据，可能会导致读取到不一致的数据或者读取操作被阻塞。")]),t._v(" "),s("p",[t._v("当前读读取的是记录数据的最新版本，并且需要先获取对应记录的锁。")]),t._v(" "),s("div",{staticClass:"language-sql extra-class"},[s("pre",{pre:!0,attrs:{class:"language-sql"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("SELECT")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("FROM")]),t._v(" student "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("LOCK")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("IN")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("SHARE")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("MODE")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 共享锁")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("SELECT")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("FROM")]),t._v(" student "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("FOR")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("UPDATE")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 排他锁")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("INSERT")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("INTO")]),t._v(" student "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("values")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 排他锁")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("DELETE")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("FROM")]),t._v(" student "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("WHERE")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 排他锁")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("UPDATE")]),t._v(" student "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("SET")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 排他锁")]),t._v("\n")])])]),s("p",[t._v("总结起来，快照读是基于事务开始时的数据快照进行读取，而当前读是基于当前事务的最新数据进行读取。当前读可以提供实时的数据，但可能受到并发事务的影响。")]),t._v(" "),s("p",[t._v("MVCC在快照读的情况下可以解决幻读问题，但是在当前读的情况下是不能解决幻读的。")]),t._v(" "),s("p",[t._v("https://cloud.tencent.com/developer/article/2123130")]),t._v(" "),s("h2",{attrs:{id:"mvcc-和锁的关系"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#mvcc-和锁的关系"}},[t._v("#")]),t._v(" mvcc 和锁的关系？")]),t._v(" "),s("p",[t._v("MVCC（Multi-Version Concurrency Control）和锁是数据库中并发控制的两种不同机制。")]),t._v(" "),s("p",[t._v("在MySQL数据库的InnoDB存储引擎中，MVCC和锁机制是相互配合使用的并发控制策略。")]),t._v(" "),s("p",[t._v("InnoDB使用MVCC来实现读操作的并发性。每个事务在开始时会创建一个事务私有的数据快照（也称为读视图），读操作只会读取该数据快照中的数据。这意味着并发事务可以同时读取同一数据对象，而不会互相干扰。MVCC使用了版本号和回滚段（undo log）的机制来管理数据版本和回滚操作，以确保事务读取的是一致性的数据视图。")]),t._v(" "),s("p",[t._v("同时，InnoDB也使用锁机制来管理并发写操作。在写操作中，InnoDB会根据需要使用行级别的锁来保护数据的一致性。读操作不会加锁，允许并发读取，但写操作可能会涉及锁的获取和释放。InnoDB提供了两种类型的锁：共享锁（Shared Lock）和排他锁（Exclusive Lock）。共享锁允许多个事务同时读取同一数据对象，而排他锁在写操作时会阻止其他事务读取或写入该数据对象。")]),t._v(" "),s("p",[t._v("MVCC和锁机制在InnoDB存储引擎中协同工作，以实现数据的一致性和并发性。MVCC机制用于读操作，提供了高度的并发性能，允许多个事务同时读取数据。锁机制用于写操作，通过锁定行级别的资源来保护数据的一致性，避免并发事务的冲突。")]),t._v(" "),s("p",[t._v("需要注意的是，MVCC和锁的具体行为和使用方式在不同的隔离级别下可能会有所不同。MySQL提供了多个隔离级别（如读未提交、读已提交、可重复读和串行化），每个隔离级别对于MVCC和锁的使用方式和粒度可能会有所调整。")]),t._v(" "),s("p",[t._v("（confuse，读操作都用MVCC了，那共享锁用在哪呢？）")]),t._v(" "),s("h2",{attrs:{id:"序列化的隔离级别是怎么实现的-加的锁是什么锁-是临间锁吗"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#序列化的隔离级别是怎么实现的-加的锁是什么锁-是临间锁吗"}},[t._v("#")]),t._v(" 序列化的隔离级别是怎么实现的？加的锁是什么锁？是临间锁吗？")]),t._v(" "),s("p",[t._v("为了实现序列化隔离级别，MySQL使用了两种类型的锁：临键锁（Next-Key Locks）和间隙锁（Gap Locks）。（还需要间隙锁吗？）")]),t._v(" "),s("p",[t._v("临键锁用于保护索引键值和范围，防止其他事务对相同的键值范围进行插入、更新或删除操作。当一个事务获取了临键锁时，其他事务无法对相同的索引键值范围进行修改，从而实现了串行化的效果。")]),t._v(" "),s("p",[t._v("间隙锁用于保护索引键值之间的间隙（即不存在的键值范围）。它防止其他事务在这个间隙中插入新的索引键值，从而避免了幻读的问题。")]),t._v(" "),s("h2",{attrs:{id:"innodb-可重复读隔离级别下还会发生幻读吗"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#innodb-可重复读隔离级别下还会发生幻读吗"}},[t._v("#")]),t._v(" innodb 可重复读隔离级别下还会发生幻读吗？")])])}),[],!1,null,null,null);s.default=n.exports}}]);