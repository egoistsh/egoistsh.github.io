(window.webpackJsonp=window.webpackJsonp||[]).push([[85],{409:function(a,e,n){"use strict";n.r(e);var r=n(7),v=Object(r.a)({},(function(){var a=this,e=a._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[e("h2",{attrs:{id:"ioc的理解"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#ioc的理解"}},[a._v("#")]),a._v(" IOC的理解")]),a._v(" "),e("p",[a._v("IOC 是 Inversion of Control 控制反转。")]),a._v(" "),e("p",[a._v("软件系统在没有引入 IOC 容器之前，对象 A 依赖于对象 B，那么对象 A 在初始化或者运行到某一点的时候，自己必须主动去创建对象 B 或者使用已经创建的对象 B。无论是创建还是使用对象 B，控制权都在自己手上。")]),a._v(" "),e("p",[a._v("软件系统在引入 IOC 容器之后，这种情形就完全改变了，由于 IOC 容器的加入，对象 A 与对象 B 之间失去了直接联系，所以，当对象 A 运行到需要对象 B 的时候，IOC 容器会主动创建一个对象 B 注入到对象 A 需要的地方。")]),a._v(" "),e("p",[a._v("对象 A 获得依赖对象 B 的过程，由主动行为变为了被动行为，控制权颠倒过来了，这就是“控制反转”这个名称的由来。")]),a._v(" "),e("h2",{attrs:{id:"ioc的实现原理"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#ioc的实现原理"}},[a._v("#")]),a._v(" IOC的实现原理")]),a._v(" "),e("p",[a._v("Spring IOC (Inversion of Control) 的实现原理基于依赖注入 (Dependency Injection) 模式，它主要包括以下几个步骤：")]),a._v(" "),e("ol",[e("li",[a._v("配置：通过 XML 文件或 Java 配置类等方式，定义 Spring Bean 的配置信息，包括类名、构造函数参数、属性值等。")]),a._v(" "),e("li",[a._v("实例化：Spring 根据配置信息创建 Bean 的实例，通常使用 Java 反射机制来实现。")]),a._v(" "),e("li",[a._v("依赖注入：Spring 根据配置信息，将创建好的 Bean 实例注入到需要它的地方，包括构造函数注入、Setter 方法注入等。")]),a._v(" "),e("li",[a._v("生命周期管理：Spring 管理 Bean 的生命周期，包括初始化和销毁等阶段，可以在 Bean 中定义初始化方法和销毁方法，Spring 会在相应的阶段调用它们。")])]),a._v(" "),e("p",[a._v("具体实现上，Spring 使用了一个叫做 BeanFactory 的容器来管理所有的 Bean，这个容器在初始化时会读取配置文件或配置类，然后根据配置信息创建 Bean 实例，并将它们存储在一个 Map 中。当其他 Bean 需要依赖这些 Bean 时，Spring 会从 Map 中取出相应的 Bean 实例，并将它们注入到需要它们的地方。")]),a._v(" "),e("p",[a._v("Spring IOC 的实现原理使得开发者可以更加关注业务逻辑，而不需要过多关注 Bean 的创建和管理，从而提高了开发效率和代码的可维护性。")]),a._v(" "),e("h2",{attrs:{id:"aop的理解"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#aop的理解"}},[a._v("#")]),a._v(" AOP的理解")]),a._v(" "),e("p",[a._v("AOP（Aspect-Oriented Programming，面向切面编程），可以说是 OOP（Object-Oriented Programing，面向对象编程）的补充和完善。OOP 引入封装、继承和多态性等概念来建立一种对象层次结构，用以模拟公共行为的一个集合。当我们需要为分散的对象引入公共行为的时候，OOP 则显得无能为力。也就是说，OOP 允许你定义从上到下的关系，但并不适合定义从左到右的关系。例如日志功能。日志代码往往水平地散布在所有对象层次中，而与它所散布到的对象的核心功能毫无关系。对于其他类型的代码，如：安全性、异常处理和透明的持续性也是如此。这种散布在各处的无关的代码被称为横切（cross-cutting）代码，在 OOP 设计中，它导致了大量代码的重复，而不利于各个模块的重用。")]),a._v(" "),e("p",[a._v("而 AOP 技术则恰恰相反，它利用一种称为“横切”的技术，剖解开封装的对象内部，并将那些影响了多个类的公共行为封装到一个可重用模块，并将其名为“Aspect”，即切面。所谓“切面”，简单地说，就是将那些与业务无关，却为业务模块所共同调用的逻辑或责任封装起来，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可操作性和可维护性。AOP 代表的是一个横向的关系，如果说“对象”是一个空心的圆柱体，其中封装的是对象的属性和行为；那么面向方面编程的方法，就仿佛一把利刃，将这些空心圆柱体剖开，以获得其内部的消息。而剖开的切面，也就是所谓的“方面”了。然后它又以巧夺天功的妙手将这些剖开的切面复原，不留痕迹。")]),a._v(" "),e("p",[a._v("使用“横切”技术，AOP 把软件系统分为两个部分：核心关注点和横切关注点。业务处理的主要流程是核心关注点，与之关系不大的部分是横切关注点。横切关注点的一个特点是，它们经常发生在核心关注点的多处，而各处都基本相似。比如："),e("strong",[a._v("权限认证、日志、事务处理")]),a._v("。AOP 的作用在于分离系统中的各种关注点，将核心关注点和横切关注点分离开来。")]),a._v(" "),e("h2",{attrs:{id:"aop的实现原理"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#aop的实现原理"}},[a._v("#")]),a._v(" AOP的实现原理")]),a._v(" "),e("p",[a._v("AOP 思想的实现一般都是基于代理模式 ，在 Java 中一般采用 JDK 动态代理模式，但是我们都知道，JDK 动态代理模式只能代理接口而不能代理类。因此，Spring AOP 会按照下面两种情况进行切换，因为 Spring AOP 同时支持 CGLIB、ASPECTJ、JDK 动态代理。")]),a._v(" "),e("ol",[e("li",[a._v("如果目标对象的实现类实现了接口，Spring AOP 将会采用 JDK 动态代理来生成 AOP 代理类；")]),a._v(" "),e("li",[a._v("如果目标对象的实现类没有实现接口，Spring AOP 将会采用 CGLIB 来生成 AOP 代理类。不过这个选择过程对开发者完全透明、开发者也无需关心。")])]),a._v(" "),e("h2",{attrs:{id:"bean的生命周期"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#bean的生命周期"}},[a._v("#")]),a._v(" Bean的生命周期")]),a._v(" "),e("ol",[e("li",[a._v("实例化：Spring 根据配置信息创建 Bean 实例，通常使用 Java 反射机制来实现。")]),a._v(" "),e("li",[a._v("属性赋值：Spring 根据配置信息或注解将属性值注入到 Bean 中。")]),a._v(" "),e("li",[a._v("Aware 回调：Spring 调用实现了相应接口的 Bean 的回调方法，例如 BeanNameAware、BeanFactoryAware、ApplicationContextAware 等。")]),a._v(" "),e("li",[a._v("初始化：Spring 执行初始化方法，这个方法可以通过配置文件或注解来指定，一般用于 Bean 的初始化工作。")]),a._v(" "),e("li",[a._v("初始化后处理：Spring 执行实现了 BeanPostProcessor 接口的类的 postProcessBeforeInitialization 方法和 postProcessAfterInitialization 方法，这两个方法可以在 Bean 初始化前和初始化后进行一些操作。")]),a._v(" "),e("li",[a._v("使用：Bean 可以被使用了，执行相关的业务逻辑。")]),a._v(" "),e("li",[a._v("销毁：Spring 执行销毁方法，这个方法可以通过配置文件或注解来指定，一般用于释放资源等清理工作。")])]),a._v(" "),e("p",[a._v("需要注意的是，不是所有的 Bean 都需要实现所有阶段，可以根据具体需求来决定是否实现某个阶段的回调方法。而且，Bean 的生命周期也可以通过编写 BeanPostProcessor 的实现类来进行自定义，这可以让开发者在 Bean 初始化前或初始化后执行一些额外的操作。")]),a._v(" "),e("h2",{attrs:{id:"bean-的作用域"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#bean-的作用域"}},[a._v("#")]),a._v(" Bean 的作用域")]),a._v(" "),e("ol",[e("li",[a._v("singleton : 唯一 bean 实例，Spring 中的 bean 默认都是单例的；")]),a._v(" "),e("li",[a._v("prototype : 每次请求都会创建一个新的 bean 实例；")]),a._v(" "),e("li",[a._v("request：每一次 HTTP 请求都会产生一个新的 bean，该 bean 仅在当前 HTTP request 内有效；")]),a._v(" "),e("li",[a._v("session : 每一次 HTTP 请求都会产生一个新的 bean，该 bean 仅在当前 HTTP session 内有效；")]),a._v(" "),e("li",[a._v("global-session：全局 session 作用域，仅仅在基于 portlet 的 web 应用中才有意义，Spring5 已经没有了。Portlet 是能够生成语义代码(例如：HTML)片段的小型 Java Web 插件。它们基于 portlet 容器，可以像 servlet 一样处理 HTTP 请求。但是，与 servlet 不同，每个 portlet 都有不同的会话。")])]),a._v(" "),e("h2",{attrs:{id:"单例bean-的好处"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#单例bean-的好处"}},[a._v("#")]),a._v(" 单例Bean 的好处")]),a._v(" "),e("p",[a._v("单例 Bean 是 Spring 容器中最常见的一种 Bean，其主要好处包括：")]),a._v(" "),e("ol",[e("li",[a._v("节省资源：单例 Bean 在 Spring 容器中只会被创建一次，这可以减少创建和销毁 Bean 的开销，从而减少内存和 CPU 的使用，提高系统性能。")]),a._v(" "),e("li",[a._v("维护状态：单例 Bean 可以维护状态，因为它只会被创建一次，可以在整个应用程序的生命周期中保持状态的一致性。")]),a._v(" "),e("li",[a._v("便于管理：单例 Bean 在整个应用程序中都是唯一的，这使得它们易于管理和维护，因为在整个应用程序中只有一个实例。")]),a._v(" "),e("li",[a._v("提高性能：单例 Bean 的创建和销毁只会发生一次，这可以避免频繁地创建和销毁 Bean 所带来的性能损失。同时，由于单例 Bean 的实例只有一个，可以避免重复的对象创建和内存占用。")]),a._v(" "),e("li",[a._v("简化依赖注入：单例 Bean 在整个应用程序中都是唯一的，因此可以很方便地被注入到其他 Bean 中，从而简化了依赖注入的代码。")])]),a._v(" "),e("h2",{attrs:{id:"单例bean可能导致的线程问题"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#单例bean可能导致的线程问题"}},[a._v("#")]),a._v(" 单例bean可能导致的线程问题")]),a._v(" "),e("p",[a._v("单例 Bean 在 Spring 容器中只会创建一次，它会在容器初始化时被创建，之后会一直存在于容器中，直到容器被销毁。因为单例 Bean 只有一个实例，所以在多线程环境下，不同的线程可能会同时访问同一个单例 Bean 实例，从而可能导致线程安全问题。")]),a._v(" "),e("p",[a._v("如果单例 Bean 存在共享的可变状态，比如属性或静态变量，那么多线程访问这些状态时就会存在竞争条件（Race Condition）和数据不一致等问题。比如，在一个多线程的环境下，一个线程正在修改 Bean 的某个属性，而另一个线程同时也在访问该属性，那么就可能导致该属性值的不确定性和线程安全问题。")]),a._v(" "),e("p",[a._v("为了解决单例 Bean 的线程安全问题，可以采用以下几种方式：")]),a._v(" "),e("ol",[e("li",[a._v("避免在单例 Bean 中定义共享的可变状态，或者将共享的可变状态限制在方法局部变量中。")]),a._v(" "),e("li",[a._v("使用线程安全的数据结构，如 ConcurrentHashMap、ConcurrentLinkedQueue 等，来保证多线程访问时的线程安全。")]),a._v(" "),e("li",[a._v("在需要共享状态的情况下，使用 synchronized 关键字或者 ReentrantLock 等方式来保证线程安全。")]),a._v(" "),e("li",[a._v("将单例 Bean 替换成原型 Bean，即每次从容器中获取 Bean 时都会创建一个新的实例。这种方式可以保证 Bean 的线程安全，但会增加内存开销。")]),a._v(" "),e("li",[a._v("在类中定义一个 ThreadLocal 成员变量，将需要的可变成员变量保存在 ThreadLocal 中（推荐）。")])]),a._v(" "),e("h2",{attrs:{id:"spring-事务"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#spring-事务"}},[a._v("#")]),a._v(" Spring 事务")])])}),[],!1,null,null,null);e.default=v.exports}}]);