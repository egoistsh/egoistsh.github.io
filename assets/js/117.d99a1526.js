(window.webpackJsonp=window.webpackJsonp||[]).push([[117],{439:function(t,a,e){"use strict";e.r(a);var r=e(7),s=Object(r.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h2",{attrs:{id:"base"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#base"}},[t._v("#")]),t._v(" Base")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://p.ipic.vip/yf7puj.png",alt:"image-20230513201144904"}})]),t._v(" "),a("p",[t._v("接口：Condition")]),t._v(" "),a("p",[t._v("Condition为接口类型，它将 Object 监视器方法(wait、notify 和 notifyAll)分解成截然不同的对象，以便通过将这些对象与任意 Lock 实现组合使用，为每个对象提供多个等待 set (wait-set)。其中，Lock 替代了 synchronized 方法和语句的使用，Condition 替代了 Object 监视器方法的使用。可以通过await(),signal()来休眠/唤醒线程。")]),t._v(" "),a("p",[t._v("Condition 的实现类是 AQS 和AQLS 的内部类 ConditionObject 。")]),t._v(" "),a("h2",{attrs:{id:"locks"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#locks"}},[t._v("#")]),t._v(" Locks")]),t._v(" "),a("h3",{attrs:{id:"reentrantlock"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#reentrantlock"}},[t._v("#")]),t._v(" ReentrantLock")]),t._v(" "),a("p",[t._v("Question：")]),t._v(" "),a("ul",[a("li",[t._v("什么是可重入，什么是可重入锁? 它用来解决什么问题?")]),t._v(" "),a("li",[t._v("ReentrantLock的核心是AQS，那么它怎么来实现的，继承吗? 说说其类内部结构关系。")]),t._v(" "),a("li",[t._v("ReentrantLock是如何实现公平锁的?")]),t._v(" "),a("li",[t._v("ReentrantLock是如何实现非公平锁的?")]),t._v(" "),a("li",[t._v("ReentrantLock默认实现的是公平还是非公平锁?")]),t._v(" "),a("li",[t._v("使用ReentrantLock实现公平和非公平锁的示例?")]),t._v(" "),a("li",[t._v("ReentrantLock和Synchronized的对比?")])]),t._v(" "),a("p",[t._v("ReentrantLock为常用类，它是一个可重入的互斥锁 Lock，它具有与使用 synchronized 方法和语句所访问的隐式监视器锁相同的一些基本行为和语义，但功能更强大。")]),t._v(" "),a("p",[t._v("ReentrantLock 中的内部类：ReentrantLock类内部总共存在Sync、NonfairSync、FairSync三个类，NonfairSync与FairSync类继承自Sync类，Sync类继承自AbstractQueuedSynchronizer抽象类。")]),t._v(" "),a("p",[t._v("调用链：")]),t._v(" "),a("p",[t._v("公平锁的调用成功的情况：lock:lock -> FairSync:lock ->AQS:acquire -> FairSync:tryAcquire -> AQS:hasQueuedPredecessors -> AQS:setExclusiveOwnerThread")]),t._v(" "),a("p",[t._v("FairSync:lock 当资源被占用的情况：FairSync:lock -> AQS:acquire -> FairSync:tryAcquire -> AQS:addWaiter -> AQS:acquireQueued")]),t._v(" "),a("h3",{attrs:{id:"reentrantreadwritelock"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#reentrantreadwritelock"}},[t._v("#")]),t._v(" ReentrantReadWriteLock")]),t._v(" "),a("p",[t._v("Question：")]),t._v(" "),a("ul",[a("li",[t._v("为了有了ReentrantLock还需要ReentrantReadWriteLock?")]),t._v(" "),a("li",[t._v("ReentrantReadWriteLock底层实现原理?")]),t._v(" "),a("li",[t._v("ReentrantReadWriteLock底层读写状态如何设计的? 高16位为读锁，低16位为写锁")]),t._v(" "),a("li",[t._v("读锁和写锁的最大数量是多少?")]),t._v(" "),a("li",[t._v("本地线程计数器ThreadLocalHoldCounter是用来做什么的?")]),t._v(" "),a("li",[t._v("缓存计数器HoldCounter是用来做什么的?")]),t._v(" "),a("li",[t._v("写锁的获取与释放是怎么实现的?")]),t._v(" "),a("li",[t._v("读锁的获取与释放是怎么实现的?")]),t._v(" "),a("li",[t._v("什么是锁的升降级? RentrantReadWriteLock为什么不支持锁升级?")])]),t._v(" "),a("p",[t._v("ReentrantReadWriteLock是读写锁接口ReadWriteLock的实现类，它包括Lock子类ReadLock和WriteLock。ReadLock是共享锁，WriteLock是独占锁。")]),t._v(" "),a("p",[t._v("ReentrantReadWriteLock 允许多个线程同时持有读锁，但只允许一个线程持有写锁。")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("读锁：当一个线程获取到读锁时，其他线程也可以获取读锁，但不能获取写锁。当最后一个持有读锁的线程释放读锁时，其他等待的写线程才有机会获取写锁。")])]),t._v(" "),a("li",[a("p",[t._v("写锁：当一个线程获取到写锁时，其他线程无法获取读锁或写锁，直到写锁被释放。")])])]),t._v(" "),a("p",[a("img",{attrs:{src:"https://pdai.tech/images/thread/java-thread-x-readwritelock-1.png",alt:""}})]),t._v(" "),a("p",[t._v("内部类：ReentrantReadWriteLock有五个内部类，Sync继承自AQS、NonfairSync继承自Sync类、FairSync继承自Sync类；ReadLock实现了Lock接口、WriteLock也实现了Lock接口。")]),t._v(" "),a("p",[t._v("Sync类内部存在两个内部类，分别为HoldCounter和ThreadLocalHoldCounter，其中HoldCounter主要与读锁配套使用。")]),t._v(" "),a("p",[t._v("ThreadLocalHoldCounter重写了ThreadLocal的initialValue方法，ThreadLocal类可以将线程与对象相关联。在没有进行set的情况下，get到的均是initialValue方法里面生成的那个HolderCounter对象。")]),t._v(" "),a("p",[t._v("什么是锁升降级?")]),t._v(" "),a("p",[t._v("锁降级指的是写锁降级成为读锁。如果当前线程拥有写锁，然后将其释放，最后再获取读锁，这种分段完成的过程不能称之为锁降级。锁降级是指把持住(当前拥有的)写锁，再获取到读锁，随后释放(先前拥有的)写锁的过程。")]),t._v(" "),a("p",[t._v("RentrantReadWriteLock不支持锁升级(把持读锁、获取写锁，最后释放读锁的过程)。目的也是保证数据可见性，如果读锁已被多个线程获取，其中任意线程成功获取了写锁并更新了数据，则其更新对其他获取到读锁的线程是不可见的。")]),t._v(" "),a("p",[t._v("应用场景：")]),t._v(" "),a("ol",[a("li",[t._v("读多写少的情况：当读操作远远超过写操作时，使用读写锁可以提高并发性能，允许多个线程同时获取读锁，从而实现并发读取。")]),t._v(" "),a("li",[t._v("缓存系统：在缓存系统中，读操作通常比写操作频繁。使用读写锁可以让多个线程同时读取缓存，提高读取性能，而在写入缓存时需要独占写锁以保证数据一致性。")]),t._v(" "),a("li",[t._v("数据库操作：在数据库访问中，读操作往往比写操作频繁。使用读写锁可以提高并发度，允许多个线程同时读取数据库，而在写入时需要独占写锁以保证数据的完整性。")]),t._v(" "),a("li",[t._v("任务调度器：在任务调度系统中，多个任务可能同时读取共享的任务列表，而在修改任务列表时需要独占写锁以保证数据的一致性。")])]),t._v(" "),a("blockquote",[a("p",[t._v("todo: 写锁 tryAcquire 和读锁 tryAcquireShared 的具体实现。")])]),t._v(" "),a("h3",{attrs:{id:"stampedlock"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#stampedlock"}},[t._v("#")]),t._v(" StampedLock")]),t._v(" "),a("p",[t._v("它是java8在java.util.concurrent.locks新增的一个API。")]),t._v(" "),a("p",[t._v("ReentrantReadWriteLock 在沒有任何读写锁时，才可以取得写入锁，这可用于实现了悲观读取(Pessimistic Reading)，即如果执行中进行读取时，经常可能有另一执行要写入的需求，为了保持同步，ReentrantReadWriteLock 的读取锁定就可派上用场。")]),t._v(" "),a("p",[t._v("然而，如果读取执行情况很多，写入很少的情况下，使用 ReentrantReadWriteLock 可能会使写入线程遭遇饥饿(Starvation)问题，也就是写入线程迟迟无法竞争到锁定而一直处于等待状态。")]),t._v(" "),a("p",[t._v("StampedLock控制锁有三种模式(写，读，乐观读)，一个StampedLock状态是由版本和模式两个部分组成，锁获取方法返回一个数字作为票据stamp，它用相应的锁状态表示并控制访问，数字0表示没有写锁被授权访问。在读锁上分为悲观锁和乐观锁。")]),t._v(" "),a("p",[t._v("所谓的乐观读模式，也就是若读的操作很多，写的操作很少的情况下，你可以乐观地认为，写入与读取同时发生几率很少，因此不悲观地使用完全的读取锁定，程序可以查看读取资料之后，是否遭到写入执行的变更，再采取后续的措施(重新读取变更信息，或者抛出异常) ，这一个小小改进，可大幅度提高程序的吞吐量。")]),t._v(" "),a("p",[t._v("StampedLock要比ReentrantReadWriteLock 消耗更小。")]),t._v(" "),a("p",[a("code",[t._v("StampedLock")]),t._v(" 同时支持乐观锁和悲观锁的特性。在 "),a("code",[t._v("StampedLock")]),t._v(" 中，读操作使用乐观锁的方式进行，而写操作则使用悲观锁。")]),t._v(" "),a("p",[t._v("乐观读取是通过调用 "),a("code",[t._v("tryOptimisticRead")]),t._v(" 方法实现的，它返回一个标记（stamp），表示当前数据的版本号。在乐观读取过程中，如果没有发生写操作，读取的数据是有效的。然后可以通过调用 "),a("code",[t._v("validate")]),t._v(" 方法来验证读取期间是否发生了写操作。")]),t._v(" "),a("p",[t._v("对于写操作，"),a("code",[t._v("StampedLock")]),t._v(" 使用悲观锁，即需要获取独占锁才能进行写操作。写操作会阻塞其他的读操作和乐观读取，以保证数据的一致性。")]),t._v(" "),a("p",[t._v("应用场景：")]),t._v(" "),a("ol",[a("li",[t._v("读多写少的情况："),a("code",[t._v("StampedLock")]),t._v(" 在读多写少的场景下表现出色。读操作不会阻塞其他读操作，提高了并发读取的性能。当写操作非常少时，可以考虑使用 "),a("code",[t._v("StampedLock")]),t._v(" 来替代传统的读写锁。")]),t._v(" "),a("li",[t._v("对读操作的顺序要求不严格的情况："),a("code",[t._v("StampedLock")]),t._v(" 允许乐观读取，即在没有写操作的情况下，读操作可以无需获取读锁直接进行。这使得读操作更快速，特别适用于对读操作的顺序要求不严格的场景。")]),t._v(" "),a("li",[t._v("读写分离的数据结构："),a("code",[t._v("StampedLock")]),t._v(" 可以用于读写分离的数据结构，例如缓存、数据库等。通过使用乐观读取和悲观读取，可以实现高效的并发读写操作。")]),t._v(" "),a("li",[t._v("自旋等待读取："),a("code",[t._v("StampedLock")]),t._v(" 提供了 "),a("code",[t._v("tryOptimisticRead")]),t._v(" 方法，可以进行自旋等待读取的操作。这在对读操作持续时间短、读线程数目较多的情况下，可以提高性能。")])]),t._v(" "),a("p",[t._v("需要注意的是，"),a("code",[t._v("StampedLock")]),t._v(" 并不适用于频繁的写操作，因为写操作需要获取独占锁，而其他读操作和乐观读取可能会被阻塞。在选择使用 "),a("code",[t._v("StampedLock")]),t._v(" 时，需要根据具体场景和需求进行评估，并考虑读写比例、并发度等因素。")]),t._v(" "),a("h3",{attrs:{id:"locksupport"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#locksupport"}},[t._v("#")]),t._v(" LockSupport")]),t._v(" "),a("p",[t._v("Question:")]),t._v(" "),a("ul",[a("li",[t._v("为什么LockSupport也是核心基础类? AQS框架借助于两个类：Unsafe(提供CAS操作)和LockSupport(提供park/unpark操作)")]),t._v(" "),a("li",[t._v("写出分别通过wait/notify和LockSupport的park/unpark实现同步?")]),t._v(" "),a("li",[t._v("LockSupport.park()会释放锁资源吗? 那么Condition.await()呢?")]),t._v(" "),a("li",[t._v("Thread.sleep()、Object.wait()、Condition.await()、LockSupport.park()的区别? 重点")]),t._v(" "),a("li",[t._v("如果在wait()之前执行了notify()会怎样?")]),t._v(" "),a("li",[t._v("如果在park()之前执行了unpark()会怎样?")])]),t._v(" "),a("p",[t._v("The LockSupport class in Java provides a set of low-level primitives for synchronizing threads. These primitives are designed to be used as tools for creating higher-level synchronization utilities, and are not in themselves useful for most concurrency control applications.")]),t._v(" "),a("p",[t._v("LockSupport是Java并发编程中的一个工具类，用于实现线程的阻塞和唤醒操作。它提供了一种比传统的Object.wait()和Object.notify()更灵活和可靠的线程等待/通知机制。")]),t._v(" "),a("p",[t._v("LockSupport类通过park()方法使线程进入阻塞状态，而unpark()方法则用于唤醒被阻塞的线程。相比于Object.wait()和Object.notify()，LockSupport不依赖于对象的监视器锁，而是直接和线程进行交互，因此可以在任意位置使用。")]),t._v(" "),a("p",[t._v("与其他线程同步工具相比，LockSupport具有以下特点：")]),t._v(" "),a("ol",[a("li",[t._v("可以在任意位置进行阻塞和唤醒操作，无需获得对象的锁。")]),t._v(" "),a("li",[t._v("每个线程都拥有一个许可(permit)，permit的初始值为0，当permit为0时，调用park()方法会导致线程阻塞，permit为1时，调用park()方法不会阻塞。")]),t._v(" "),a("li",[t._v("unpark()方法可以提前给线程一个permit，使其不会被park()方法阻塞。")]),t._v(" "),a("li",[t._v("调用park()方法的线程不会出现死锁情况，因为即使先调用unpark()再调用park()，线程也不会被阻塞。")])]),t._v(" "),a("p",[t._v("LockSupport是实现锁和其他同步工具的基础，常用于一些高级并发框架和工具的底层实现。它提供了一种灵活、可靠的线程等待/通知机制，避免了传统的wait()/notify()可能出现的一些问题，使线程的阻塞和唤醒操作更加可控。")]),t._v(" "),a("div",{staticClass:"language-java extra-class"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("LockSupport")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("park")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("LockSupport")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("unpark")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Thread")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),a("h4",{attrs:{id:"thread-sleep-和object-wait-的区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#thread-sleep-和object-wait-的区别"}},[t._v("#")]),t._v(" Thread.sleep()和Object.wait()的区别")]),t._v(" "),a("p",[t._v("首先，我们先来看看Thread.sleep()和Object.wait()的区别，这是一个烂大街的题目了，大家应该都能说上来两点。")]),t._v(" "),a("ul",[a("li",[t._v("Thread.sleep()不会释放占有的锁，Object.wait()会释放占有的锁；")]),t._v(" "),a("li",[t._v("Thread.sleep()必须传入时间，Object.wait()可传可不传，不传表示一直阻塞下去；")]),t._v(" "),a("li",[t._v("Thread.sleep()到时间了会自动唤醒，然后继续执行；")]),t._v(" "),a("li",[t._v("Object.wait()不带时间的，需要另一个线程使用Object.notify()唤醒；")]),t._v(" "),a("li",[t._v("Object.wait()带时间的，假如没有被notify，到时间了会自动唤醒，这时又分好两种情况，一是立即获取到了锁，线程自然会继续执行；二是没有立即获取锁，线程进入同步队列等待获取锁；")])]),t._v(" "),a("p",[t._v("其实，他们俩最大的区别就是Thread.sleep()不会释放锁资源，Object.wait()会释放锁资源。")]),t._v(" "),a("h4",{attrs:{id:"object-wait-和condition-await-的区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#object-wait-和condition-await-的区别"}},[t._v("#")]),t._v(" Object.wait()和Condition.await()的区别")]),t._v(" "),a("p",[t._v("Object.wait()和Condition.await()的原理是基本一致的，不同的是Condition.await()底层是调用LockSupport.park()来实现阻塞当前线程的。")]),t._v(" "),a("p",[t._v("实际上，它在阻塞当前线程之前还干了两件事，一是把当前线程添加到条件队列中，二是“完全”释放锁，也就是让state状态变量变为0，然后才是调用LockSupport.park()阻塞当前线程。")]),t._v(" "),a("h4",{attrs:{id:"thread-sleep-和locksupport-park-的区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#thread-sleep-和locksupport-park-的区别"}},[t._v("#")]),t._v(" Thread.sleep()和LockSupport.park()的区别")]),t._v(" "),a("p",[t._v("LockSupport.park()还有几个兄弟方法——parkNanos()、parkUtil()等，我们这里说的park()方法统称这一类方法。")]),t._v(" "),a("ul",[a("li",[t._v("从功能上来说，Thread.sleep()和LockSupport.park()方法类似，都是阻塞当前线程的执行，且都不会释放当前线程占有的锁资源；")]),t._v(" "),a("li",[t._v("Thread.sleep()没法从外部唤醒，只能自己醒过来；")]),t._v(" "),a("li",[t._v("LockSupport.park()方法可以被另一个线程调用LockSupport.unpark()方法唤醒；")]),t._v(" "),a("li",[t._v("Thread.sleep()方法声明上抛出了InterruptedException中断异常，所以调用者需要捕获这个异常或者再抛出；")]),t._v(" "),a("li",[t._v("LockSupport.park()方法不需要捕获中断异常；")]),t._v(" "),a("li",[t._v("Thread.sleep()本身就是一个native方法；")]),t._v(" "),a("li",[t._v("LockSupport.park()底层是调用的Unsafe的native方法；")])]),t._v(" "),a("h4",{attrs:{id:"object-wait-和locksupport-park-的区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#object-wait-和locksupport-park-的区别"}},[t._v("#")]),t._v(" Object.wait()和LockSupport.park()的区别")]),t._v(" "),a("p",[t._v("二者都会阻塞当前线程的运行，他们有什么区别呢?")]),t._v(" "),a("ul",[a("li",[t._v("Object.wait()方法需要在synchronized块中执行；")]),t._v(" "),a("li",[t._v("LockSupport.park()可以在任意地方执行；")]),t._v(" "),a("li",[t._v("Object.wait()方法声明抛出了中断异常，调用者需要捕获或者再抛出；")]),t._v(" "),a("li",[t._v("LockSupport.park()不需要捕获中断异常；")]),t._v(" "),a("li",[t._v("Object.wait()不带超时的，需要另一个线程执行notify()来唤醒，但不一定继续执行后续内容；")]),t._v(" "),a("li",[t._v("LockSupport.park()不带超时的，需要另一个线程执行unpark()来唤醒，一定会继续执行后续内容；")])]),t._v(" "),a("p",[t._v("park()/unpark()底层的原理是“二元信号量”，你可以把它相像成只有一个许可证的Semaphore，只不过这个信号量在重复执行unpark()的时候也不会再增加许可证，最多只有一个许可证。")]),t._v(" "),a("h4",{attrs:{id:"如果在wait-之前执行了notify-会怎样"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#如果在wait-之前执行了notify-会怎样"}},[t._v("#")]),t._v(" 如果在wait()之前执行了notify()会怎样?")]),t._v(" "),a("p",[t._v("如果当前的线程不是此对象锁的所有者，却调用该对象的notify()或wait()方法时抛出IllegalMonitorStateException异常；")]),t._v(" "),a("p",[t._v("如果当前线程是此对象锁的所有者，wait()将一直阻塞，因为后续将没有其它notify()唤醒它。")]),t._v(" "),a("h4",{attrs:{id:"如果在park-之前执行了unpark-会怎样"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#如果在park-之前执行了unpark-会怎样"}},[t._v("#")]),t._v(" 如果在park()之前执行了unpark()会怎样?")]),t._v(" "),a("p",[t._v("线程不会被阻塞，直接跳过park()，继续执行后续内容")]),t._v(" "),a("h4",{attrs:{id:"locksupport-park-会释放锁资源吗"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#locksupport-park-会释放锁资源吗"}},[t._v("#")]),t._v(" LockSupport.park()会释放锁资源吗?")]),t._v(" "),a("p",[t._v("不会，它只负责阻塞当前线程，释放锁资源实际上是在Condition的await()方法中实现的。")]),t._v(" "),a("h2",{attrs:{id:"tools"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#tools"}},[t._v("#")]),t._v(" Tools")]),t._v(" "),a("h3",{attrs:{id:"countdownlatch"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#countdownlatch"}},[t._v("#")]),t._v(" CountDownLatch")]),t._v(" "),a("p",[t._v("question:")]),t._v(" "),a("ul",[a("li",[t._v("什么是CountDownLatch?")]),t._v(" "),a("li",[t._v("CountDownLatch底层实现原理?")]),t._v(" "),a("li",[t._v("CountDownLatch一次可以唤醒几个任务? 多个")]),t._v(" "),a("li",[t._v("CountDownLatch有哪些主要方法? await(),countDown()")]),t._v(" "),a("li",[t._v("CountDownLatch适用于什么场景?")])]),t._v(" "),a("p",[t._v("一句话："),a("code",[t._v("CountDownLatch")]),t._v("是Java并发编程中的一个同步工具类，它可以让一个或多个线程等待一组操作完成后再继续执行。")]),t._v(" "),a("p",[t._v("CountDownLatch is a synchronization tool that allows one or more threads to wait until a set of operations has completed. It is initialized with a count, and each time the "),a("code",[t._v("countDown()")]),t._v(" method is called, the count is decremented. When the count reaches zero, all threads that are waiting on the CountDownLatch are released.")]),t._v(" "),a("p",[t._v("CountDownLatch can be used to solve a variety of synchronization problems. For example, it can be used to ensure that all threads in a group have finished executing before a certain task is started, or to ensure that a certain number of resources are available before a task is started.")]),t._v(" "),a("div",{staticClass:"language-java extra-class"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("CountDownLatch")]),t._v(" latch "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("CountDownLatch")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("5")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\nlatch"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("countDown")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\nlatch"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("await")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),a("p",[t._v("应用场景：")]),t._v(" "),a("ol",[a("li",[t._v("并发任务的协同：当一个任务需要等待其他多个任务完成后才能继续执行时，可以使用 CountDownLatch 来实现线程之间的协同。任务中的线程可以调用 CountDownLatch 的 await() 方法进入等待状态，而其他任务中的线程执行完自己的操作后可以调用 CountDownLatch 的 countDown() 方法来减少计数器，当计数器减至零时，等待中的线程就会被唤醒。")]),t._v(" "),a("li",[t._v("等待资源初始化：当一个程序需要等待一些资源初始化完成后才能正常运行时，可以使用 CountDownLatch 来实现等待。主线程可以调用 await() 方法等待初始化任务完成，而初始化任务中的线程在完成初始化后调用 countDown() 方法来减少计数器，当计数器减至零时，主线程就会被唤醒，可以开始执行后续的逻辑。")]),t._v(" "),a("li",[t._v("测试多线程性能：在性能测试中，可以使用 CountDownLatch 来模拟并发场景。主线程可以启动多个工作线程，这些工作线程会执行相同的任务，并在任务完成时调用 countDown() 方法。主线程可以调用 await() 方法等待所有工作线程完成，以便统计执行时间和性能指标。")])]),t._v(" "),a("h3",{attrs:{id:"cyclicbarrier"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#cyclicbarrier"}},[t._v("#")]),t._v(" CyclicBarrier")]),t._v(" "),a("ul",[a("li",[t._v("什么是CyclicBarrier?")]),t._v(" "),a("li",[t._v("CyclicBarrier底层实现原理?")]),t._v(" "),a("li",[t._v("CountDownLatch和CyclicBarrier对比?")]),t._v(" "),a("li",[t._v("CyclicBarrier的核心函数有哪些?")]),t._v(" "),a("li",[t._v("CyclicBarrier适用于什么场景?")])]),t._v(" "),a("p",[t._v("CyclicBarrier（循环屏障）是Java并发编程中的一个同步工具类，它可以让一组线程在达到某个共同点之前互相等待，然后同时继续执行。")]),t._v(" "),a("p",[t._v("CyclicBarrier 的特点如下：")]),t._v(" "),a("ol",[a("li",[t._v("共同点：CyclicBarrier 可以设置一个共同点，当等待的线程数达到指定数量时，所有线程将同时被释放，继续执行后续操作。")]),t._v(" "),a("li",[t._v("循环使用：CyclicBarrier 可以被多次使用。当所有线程都被释放后，CyclicBarrier 会被重置，并可以再次使用。")]),t._v(" "),a("li",[t._v("等待与释放：线程通过调用 CyclicBarrier 的 await() 方法进入等待状态，当指定数量的线程都调用了 await() 方法后，所有线程会同时被释放，继续执行后续操作。")])]),t._v(" "),a("div",{staticClass:"language-java extra-class"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 构造方法")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("CyclicBarrier")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Runnable")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 指定关联该CyclicBarrier的线程数量，并且可以指定在所有线程都进入屏障后的执行动作，该执行动作由最后一个进行屏障的线程执行。")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("CyclicBarrier")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\ncb"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("await")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),a("p",[t._v("在所有线程进入屏障后会调用 nextGeneration()，即生成下一个版本，所有线程又可以重新进入到屏障中。要注意"),a("code",[t._v("barrier.await()")]),t._v("方法的调用次数应该与创建CyclicBarrier时指定的线程数量相匹配，以确保正确的同步和等待行为。")]),t._v(" "),a("p",[t._v("CyclicBarrier 和 CountDonwLatch 的对比")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("CountDownLatch减计数，CyclicBarrier加计数。")])]),t._v(" "),a("li",[a("p",[t._v("CountDownLatch是一次性的，CyclicBarrier可以重用。")])]),t._v(" "),a("li",[a("p",[t._v("CountDownLatch和CyclicBarrier都有让多个线程等待同步然后再开始下一步动作的意思，但是CountDownLatch的下一步的动作实施者是主线程，具有不可重复性；而CyclicBarrier的下一步动作实施者还是“其他线程”本身，具有往复多次实施动作的特点。")])]),t._v(" "),a("li",[a("p",[t._v("对于CountDownLatch，其他线程为游戏玩家，比如英雄联盟，主线程为控制游戏开始的线程。在所有的玩家都准备好之前，主线程是处于等待状态的，也就是游戏不能开始。当所有的玩家准备好之后，下一步的动作实施者为主线程，即开始游戏。")])]),t._v(" "),a("li",[a("p",[t._v("对于CyclicBarrier，假设有一家公司要全体员工进行团建活动，活动内容为翻越三个障碍物，每一个人翻越障碍物所用的时间是不一样的。但是公司要求所有人在翻越当前障碍物之后再开始翻越下一个障碍物，也就是所有人翻越第一个障碍物之后，才开始翻越第二个，以此类推。类比地，每一个员工都是一个“其他线程”。当所有人都翻越的所有的障碍物之后，程序才结束。而主线程可能早就结束了，这里我们不用管主线程。")])])]),t._v(" "),a("p",[t._v("CyclicBarrier 的应用场景包括以下几个方面：")]),t._v(" "),a("ol",[a("li",[t._v("并行计算任务的拆分与合并：当一个大型计算任务可以被拆分为多个子任务并行执行时，可以使用 CyclicBarrier 来等待所有子任务完成后再进行合并计算。")]),t._v(" "),a("li",[t._v("多线程任务的阶段同步：当一个任务需要按照阶段进行多次并发操作，每个阶段需要等待所有线程都完成后才能继续下一阶段，可以使用 CyclicBarrier 来实现阶段间的同步。")]),t._v(" "),a("li",[t._v("并发流水线的流程控制：当多个线程需要按照特定的流水线方式执行任务，每个线程在完成一定操作后需要等待其他线程才能继续，可以使用 CyclicBarrier 来实现线程之间的同步。")])]),t._v(" "),a("h3",{attrs:{id:"phaser"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#phaser"}},[t._v("#")]),t._v(" Phaser")]),t._v(" "),a("h3",{attrs:{id:"semaphore"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#semaphore"}},[t._v("#")]),t._v(" Semaphore")]),t._v(" "),a("p",[t._v("Semaphore（信号量）是Java并发编程中的一个同步工具类，它可以用于控制对共享资源的访问数量。Semaphore 维护了一个许可证数量，线程可以通过获取许可证来访问共享资源，而当许可证不可用时，线程需要等待其他线程释放许可证。")]),t._v(" "),a("p",[t._v("Semaphore 的特点如下：")]),t._v(" "),a("ol",[a("li",[t._v("许可证数量：Semaphore 通过一个整数来表示可用的许可证数量。线程可以通过 acquire() 方法获取一个许可证，表示占用了一个资源，而 release() 方法则释放一个许可证，表示释放了一个资源。")]),t._v(" "),a("li",[t._v("公平性：Semaphore 可以选择是否公平地控制许可证的获取。公平性表示等待时间最长的线程将优先获取许可证，而非公平性则没有这个保证。")])]),t._v(" "),a("p",[t._v("Semaphore 的应用场景包括以下几个方面：")]),t._v(" "),a("ol",[a("li",[t._v("有限资源的并发访问控制：当系统中存在有限的资源，如数据库连接、线程池等，可以使用 Semaphore 来控制对这些资源的并发访问数量，以避免资源过载。")]),t._v(" "),a("li",[t._v("流量控制：当需要限制某个操作的并发数量，以控制流量或避免过度的请求压力时，可以使用 Semaphore 来实现限流。")]),t._v(" "),a("li",[t._v("线程池管理：Semaphore 可以用于实现线程池中的工作线程数量控制，通过限制许可证数量，控制同时执行的任务数量。")])]),t._v(" "),a("p",[t._v("核心方法")]),t._v(" "),a("div",{staticClass:"language-java extra-class"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Semaphore")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("permits")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Semaphore")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("permits")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("boolean")]),t._v(" fair"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\nsemaphore"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("acquire")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\nsemaphore"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("acquire")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\nsemaphore"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("release")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\nsemaphore"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("release")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),a("p",[t._v("Note: 调用release()会添加令牌，并不会以初始化的大小为准。Semaphore中release方法的调用并没有限制要在acquire后调用。")]),t._v(" "),a("h3",{attrs:{id:"exchanger"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#exchanger"}},[t._v("#")]),t._v(" Exchanger")]),t._v(" "),a("h2",{attrs:{id:"collections"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#collections"}},[t._v("#")]),t._v(" Collections")]),t._v(" "),a("h3",{attrs:{id:"queue"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#queue"}},[t._v("#")]),t._v(" Queue")]),t._v(" "),a("h3",{attrs:{id:"list"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#list"}},[t._v("#")]),t._v(" List")]),t._v(" "),a("h3",{attrs:{id:"set"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#set"}},[t._v("#")]),t._v(" Set")]),t._v(" "),a("h3",{attrs:{id:"map"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#map"}},[t._v("#")]),t._v(" Map")]),t._v(" "),a("h2",{attrs:{id:"atomic"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#atomic"}},[t._v("#")]),t._v(" Atomic")]),t._v(" "),a("h3",{attrs:{id:"基础类型"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#基础类型"}},[t._v("#")]),t._v(" 基础类型")]),t._v(" "),a("h3",{attrs:{id:"数组"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#数组"}},[t._v("#")]),t._v(" 数组")]),t._v(" "),a("h3",{attrs:{id:"引用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#引用"}},[t._v("#")]),t._v(" 引用")]),t._v(" "),a("h2",{attrs:{id:"executor"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#executor"}},[t._v("#")]),t._v(" Executor")]),t._v(" "),a("h3",{attrs:{id:"接口-executor"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#接口-executor"}},[t._v("#")]),t._v(" 接口：Executor")]),t._v(" "),a("h3",{attrs:{id:"executorservice"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#executorservice"}},[t._v("#")]),t._v(" ExecutorService")]),t._v(" "),a("h3",{attrs:{id:"scheduledexecutorservice"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#scheduledexecutorservice"}},[t._v("#")]),t._v(" ScheduledExecutorService")]),t._v(" "),a("h3",{attrs:{id:"abstractexecutorservice"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#abstractexecutorservice"}},[t._v("#")]),t._v(" AbstractExecutorService")]),t._v(" "),a("h3",{attrs:{id:"futuretask"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#futuretask"}},[t._v("#")]),t._v(" FutureTask")]),t._v(" "),a("h3",{attrs:{id:"threadpoolexecutor"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#threadpoolexecutor"}},[t._v("#")]),t._v(" ThreadPoolExecutor")]),t._v(" "),a("h3",{attrs:{id:"scheduledthreadpoolexecutor"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#scheduledthreadpoolexecutor"}},[t._v("#")]),t._v(" ScheduledThreadPoolExecutor")]),t._v(" "),a("h3",{attrs:{id:"fork-join-framework"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#fork-join-framework"}},[t._v("#")]),t._v(" Fork/Join Framework")]),t._v(" "),a("h3",{attrs:{id:"executors"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#executors"}},[t._v("#")]),t._v(" Executors")]),t._v(" "),a("h2",{attrs:{id:"reference"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#reference"}},[t._v("#")]),t._v(" Reference")]),t._v(" "),a("p",[t._v("https://pdai.tech/md/java/thread/java-thread-x-juc-overview.html#atomic-%E5%8E%9F%E5%AD%90%E7%B1%BB")])])}),[],!1,null,null,null);a.default=s.exports}}]);