(window.webpackJsonp=window.webpackJsonp||[]).push([[54],{378:function(v,_,s){"use strict";s.r(_);var e=s(7),a=Object(e.a)({},(function(){var v=this,_=v._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("p",[v._v("Redis 支持两种持久化方式，一种是RDB，一种是AOF。前者会根据指定的规则定时将内存中的数据存储在硬盘上，而后者在每次执行完命令后将命令记录下来。一般将两者结合使用。")]),v._v(" "),_("h2",{attrs:{id:"rdb"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#rdb"}},[v._v("#")]),v._v(" RDB")]),v._v(" "),_("p",[v._v("RDB 是 Redis 默认的持久化方案。RDB持久化时会将内存中的数据写入到磁盘中，在指定目录下生成一个dump.rdb文件。Redis 重启会加载dump.rdb文件恢复数据。")]),v._v(" "),_("p",[v._v("RDB持久化的过程（即bgsave，执行SAVE命令除外）：")]),v._v(" "),_("ul",[_("li",[v._v("fork 创建一个子进程；")]),v._v(" "),_("li",[v._v("父进程继续接收并处理客户端的请求，而子进程开始将内存中的数据写进硬盘的临时文件；")]),v._v(" "),_("li",[v._v("当子进程写完所有数据后会用该临时文件替换旧的RDB文件。")])]),v._v(" "),_("p",[v._v("Redis启动时会读取RDB快照文件，将数据从硬盘载入内存。通过RDB方式的持久化，一旦Redis异常退出，就会丢失最近一次持久化以后更改的数据。")]),v._v(" "),_("p",[v._v("触发RDB快照：")]),v._v(" "),_("ol",[_("li",[v._v("手动触发：\n"),_("ul",[_("li",[v._v("用户执行SAVE或BGSAVE命令。SAVE命令执行快照的过程会阻塞所有来自客户端的请求，应避免在生产环境使用这个命令。BGSAVE命令可以在后台异步进行快照操作，快照的同时服务器还可以继续响应客户端的请求，因此需要手动执行快照时推荐使用BGSAVE命令；")])])]),v._v(" "),_("li",[v._v("被动触发：\n"),_("ul",[_("li",[v._v("根据配置规则进行自动快照，如"),_("code",[v._v("SAVE 300 10")]),v._v(",300秒内至少有10个键被修改则进行快照。")]),v._v(" "),_("li",[v._v("如果从节点执行全量复制操作，主节点自动执行bgsave生成RDB文件并发送给从节点。")]),v._v(" "),_("li",[v._v("默认情况下执行shutdown命令时，如果没有开启AOF持久化功能则自动执行bgsave。")]),v._v(" "),_("li",[v._v("执行debug reload命令重新加载Redis时，也会自动触发save操作。")])])])]),v._v(" "),_("p",[v._v("优点：Redis加载RDB"),_("strong",[v._v("恢复数据远远快于")]),v._v("AOF的方式。")]),v._v(" "),_("p",[v._v("缺点：")]),v._v(" "),_("ol",[_("li",[v._v("RDB方式数据没办法做到实时持久化/秒级持久化。因为bgsave每次运行都要执行fork操作创建子进程，属于重量级操作，频繁执行成本过高。")]),v._v(" "),_("li",[v._v("存在老版本Redis服务和新版本RDB格式兼容性问题。RDB文件使用特定二进制格式保存，Redis版本演进过程中有多个格式的RDB版本，存在老版本Redis服务无法兼容新版RDB格式的问题。")])]),v._v(" "),_("h2",{attrs:{id:"aof"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#aof"}},[v._v("#")]),v._v(" AOF")]),v._v(" "),_("p",[v._v("AOF（append only file）持久化：以独立日志的方式"),_("strong",[v._v("记录每次写命令")]),v._v("，Redis重启时会重新执行AOF文件中的命令达到恢复数据的目的。AOF的主要作用是"),_("strong",[v._v("解决了数据持久化的实时性")]),v._v("，目前已经是Redis持久化的"),_("strong",[v._v("主流方式")]),v._v("。")]),v._v(" "),_("p",[v._v("默认情况下Redis没有开启AOF方式的持久化，可以通过appendonly参数启用"),_("code",[v._v("appendonly yes")]),v._v("。开启AOF方式持久化后每执行一条写命令，"),_("strong",[v._v("Redis就会将该命令写进aof_buf缓冲区，AOF缓冲区根据对应的策略向硬盘做同步操作。")])]),v._v(" "),_("p",[v._v("默认情况下系统每30秒会执行一次同步操作。为了防止缓冲区数据丢失，可以在Redis写入AOF文件后主动要求系统将缓冲区数据同步到硬盘上。可以通过"),_("code",[v._v("appendfsync")]),v._v("参数设置同步的时机。")]),v._v(" "),_("div",{staticClass:"language-sh extra-class"},[_("pre",{pre:!0,attrs:{class:"language-sh"}},[_("code",[v._v("appendfsync always //每次写入aof文件都会执行同步，最安全最慢，只能支持几百TPS写入，不建议配置\nappendfsync everysec  //保证了性能也保证了安全，建议配置\nappendfsync no //由操作系统决定何时进行同步操作\n")])])]),_("p",[v._v("重写机制：")]),v._v(" "),_("p",[v._v("随着命令不断写入AOF，文件会越来越大，为了解决这个问题，Redis引入AOF重写机制压缩文件体积。AOF文件重写是把Redis进程内的数据转化为写命令同步到新AOF文件的过程。")]),v._v(" "),_("p",[v._v("优点：")]),v._v(" "),_("ol",[_("li",[v._v("AOF可以更好的保护数据不丢失，一般AOF会每秒去执行一次fsync操作，如果redis进程挂掉，最多丢失1秒的数据。")]),v._v(" "),_("li",[v._v("AOF以appen-only的模式写入，所以没有任何磁盘寻址的开销，写入性能非常高。")])]),v._v(" "),_("p",[v._v("缺点")]),v._v(" "),_("ol",[_("li",[v._v("对于同一份文件AOF文件比RDB数据快照要大。")]),v._v(" "),_("li",[v._v("不适合写多读少场景。")]),v._v(" "),_("li",[v._v("数据恢复比较慢。")])]),v._v(" "),_("h2",{attrs:{id:"混合持久化"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#混合持久化"}},[v._v("#")]),v._v(" 混合持久化")]),v._v(" "),_("p",[v._v("混合持久化并不是一种全新的持久化方式，而是对已有方式的优化。混合持久化只发生于 AOF 重写过程。使用了混合持久化，重写后的新 AOF 文件前半段是 RDB 格式的全量数据，后半段是 AOF 格式的增量数据。")]),v._v(" "),_("p",[v._v("开启：混合持久化的配置参数为 aof-use-rdb-preamble，配置为 yes 时开启混合持久化，在 redis 4 刚引入时，默认是关闭混合持久化的，但是在 redis 5 中默认已经打开了。")]),v._v(" "),_("p",[v._v("关闭：使用 aof-use-rdb-preamble no 配置即可关闭混合持久化。")]),v._v(" "),_("p",[v._v("混合持久化本质是通过 AOF 后台重写（bgrewriteaof 命令）完成的，不同的是当开启混合持久化时，fork 出的子进程先将当前全量数据以 RDB 方式写入新的 AOF 文件，然后再将 AOF 重写缓冲区（aof_rewrite_buf_blocks）的增量命令以 AOF 方式写入到文件，写入完成后通知主进程将新的含有 RDB 格式和 AOF 格式的 AOF 文件替换旧的的 AOF 文件。")]),v._v(" "),_("p",[v._v("优点：结合 RDB 和 AOF 的优点, 更快的重写和恢复。")]),v._v(" "),_("p",[v._v("缺点：AOF 文件里面的 RDB 部分不再是 AOF 格式，可读性差。")]),v._v(" "),_("h2",{attrs:{id:"rdb和aof如何选择"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#rdb和aof如何选择"}},[v._v("#")]),v._v(" RDB和AOF如何选择")]),v._v(" "),_("ul",[_("li",[v._v("仅使用RDB这样会丢失很多数据。")]),v._v(" "),_("li",[v._v("仅使用AOF，因为这一会有两个问题，第一通过AOF恢复速度慢；第二RDB每次简单粗暴生成数据快照，更加安全健壮。")]),v._v(" "),_("li",[v._v("一般来说， 如果想尽量保证数据安全性， 你应该同时使用 RDB 和 AOF 持久化功能，同时可以开启混合持久化。")]),v._v(" "),_("li",[v._v("综合AOF和RDB两种持久化方式，用AOF来保证数据不丢失，作为恢复数据的第一选择；用RDB来做不同程度的冷备，在AOF文件都丢失或损坏不可用的时候，可以使用RDB进行快速的数据恢复。")])]),v._v(" "),_("p",[_("img",{attrs:{src:"https://p.ipic.vip/rgjqv3.png",alt:"image-20230317212403230"}})])])}),[],!1,null,null,null);_.default=a.exports}}]);