(window.webpackJsonp=window.webpackJsonp||[]).push([[80],{404:function(e,s,a){"use strict";a.r(s);var t=a(7),v=Object(t.a)({},(function(){var e=this,s=e._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[s("h2",{attrs:{id:"jwt和session的区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#jwt和session的区别"}},[e._v("#")]),e._v(" JWT和session的区别")]),e._v(" "),s("ol",[s("li",[e._v("session 存储在服务端占用服务器资源，而 JWT 存储在客户端")]),e._v(" "),s("li",[e._v("session 存储在 Cookie 中，存在**伪造跨站请求伪造攻击（CSRF）**的风险")]),e._v(" "),s("li",[e._v("session 只存在一台服务器上，那么下次请求就必须请求这台服务器，不利于分布式应用")]),e._v(" "),s("li",[e._v("存储在客户端的 JWT 比存储在服务端的 session 更具有扩展性")])]),e._v(" "),s("h2",{attrs:{id:"jwt的组成"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#jwt的组成"}},[e._v("#")]),e._v(" JWT的组成")]),e._v(" "),s("p",[e._v("JWT由三部分组成：header.payload.signature")]),e._v(" "),s("p",[e._v("header 中承载了两部分信息：声明加密算法、声明类型")]),e._v(" "),s("p",[e._v("payload 是主体部分，意为载体，承载着有效的 JWT 数据包，它包含三个部分：标准声明、公共声明、私有声明")]),e._v(" "),s("p",[e._v("JWT 的 Token 相当是明文，是可以解密的，任何存在 payload 的东西，都没有秘密可言，所以隐私数据不能签发 token。")]),e._v(" "),s("p",[e._v("signature 是签证信息，该签证信息是通过"),s("code",[e._v("header")]),e._v("和"),s("code",[e._v("payload")]),e._v("，加上"),s("code",[e._v("secret")]),e._v("，通过算法加密生成。")]),e._v(" "),s("h2",{attrs:{id:"如何防止-token-被串改"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#如何防止-token-被串改"}},[e._v("#")]),e._v(" 如何防止 Token 被串改？")]),e._v(" "),s("p",[s("code",[e._v("signature")]),e._v("字段就是关键了，能被解密出明文的，只有"),s("code",[e._v("header")]),e._v("和"),s("code",[e._v("payload")])]),e._v(" "),s("p",[e._v("假如黑客/中间人串改了"),s("code",[e._v("payload")]),e._v("，那么服务器可以通过"),s("code",[e._v("signature")]),e._v("去验证是否被篡改过。")]),e._v(" "),s("p",[e._v("在服务端在执行一次 "),s("code",[e._v('signature = 加密算法(header + "." + payload, 密钥);')]),e._v(", 然后对比 signature 是否一致，如果一致则说明没有被篡改。")]),e._v(" "),s("p",[e._v("所以服务器的密钥不能被泄漏。")]),e._v(" "),s("p",[e._v("参考：https://cnodejs.org/topic/5b0c4a7b8a4f51e140d942fc")])])}),[],!1,null,null,null);s.default=v.exports}}]);