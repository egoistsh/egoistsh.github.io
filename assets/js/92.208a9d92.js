(window.webpackJsonp=window.webpackJsonp||[]).push([[92],{416:function(t,v,_){"use strict";_.r(v);var a=_(7),e=Object(a.a)({},(function(){var t=this,v=t._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("p",[t._v("在使用spring框架的日常开发中，bean之间的循环依赖太频繁了，spring已经帮我们去解决循环依赖问题，对我们开发者来说是无感知的，下面具体分析一下spring是如何解决bean之间循环依赖，为什么要使用到三级缓存，而不是二级缓存。")]),t._v(" "),v("p",[t._v("首先需要了解一下bean在spring中的生命周期，bean在spring的加载流程，才能够更加清晰知道spring是如何解决循环依赖的。")]),t._v(" "),v("p",[t._v("bean 的生命周期：")]),t._v(" "),v("ol",[v("li",[t._v("实例化bean，分配内存地址")]),t._v(" "),v("li",[t._v("属性注入")]),t._v(" "),v("li",[t._v("初始化bean，执行init方法")]),t._v(" "),v("li",[t._v("销毁 bean")])]),t._v(" "),v("p",[t._v("一级缓存：存放完全初始化好的 Bean，可以直接使用")]),t._v(" "),v("p",[t._v("二级缓存：存放原始的 Bean 对象，即还没进行赋值，没有被依赖注入")]),t._v(" "),v("p",[t._v("三级缓存：存放 Bean 工厂对象，该工厂对象负责生成原始 Bean 对象，并将其放入到二级缓存中。主要用于解决代理对象的循环依赖问题。")]),t._v(" "),v("p",[v("img",{attrs:{src:"https://p.ipic.vip/g1vq54.png",alt:"image-20230905153625788"}})]),t._v(" "),v("p",[t._v("其核心思想是将 Bean 的实例化和 Bean 中的属性依赖注入分离开。")]),t._v(" "),v("p",[t._v("Spring 本身只能解决单例存在的循环引用问题。")]),t._v(" "),v("h2",{attrs:{id:"为什么要三级缓存-二级不行吗"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#为什么要三级缓存-二级不行吗"}},[t._v("#")]),t._v(" 为什么要三级缓存，二级不行吗？")]),t._v(" "),v("p",[t._v("需要三级缓存而不是二级，是为了针对有代理的情况。")]),t._v(" "),v("p",[t._v("没有动态代理的情况，其实把二级缓存拿掉，在 B 尝试获取 A 的时候直接返回 A 的实例，也是可以的。")]),t._v(" "),v("p",[t._v("循环依赖下，有没有代理情况下的区别就在：")]),t._v(" "),v("div",{staticClass:"language-java extra-class"},[v("pre",{pre:!0,attrs:{class:"language-java"}},[v("code",[t._v("singletonObject "),v("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" singletonFactory"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),v("span",{pre:!0,attrs:{class:"token function"}},[t._v("getObject")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),v("p",[t._v("在循环依赖发生的情况下 B 中的 A 赋值时：")]),t._v(" "),v("ol",[v("li",[t._v("无代理：getObject 直接返回原来的 Bean")]),t._v(" "),v("li",[t._v("有代理：getObject 返回的是代理对象")])]),t._v(" "),v("p",[t._v("然后都放到二级缓存。")]),t._v(" "),v("p",[t._v("假设去掉三级缓存")]),t._v(" "),v("p",[t._v("去掉三级缓存之后，Bean 直接创建 "),v("code",[t._v("earlySingletonObjects")]),t._v("， 看着好像也可以。")]),t._v(" "),v("p",[t._v("如果有代理的时候，在 "),v("code",[t._v("earlySingletonObjects")]),t._v(" 直接放代理对象就行了。")]),t._v(" "),v("p",[t._v("但是会导致一个问题："),v("strong",[t._v("在实例化阶段就得执行后置处理器，判断有 AnnotationAwareAspectJAutoProxyCreator 并创建代理对象")]),t._v("。")]),t._v(" "),v("p",[t._v("这么一想，是不是会对 Bean 的生命周期有影响。")]),t._v(" "),v("p",[t._v("同样，先创建 "),v("code",[t._v("singletonFactory")]),t._v(" 的好处就是："),v("strong",[t._v("在真正需要实例化的时候，再使用 singletonFactory.getObject() 获取 Bean 或者 Bean 的代理")]),t._v("。相当于是延迟实例化。")]),t._v(" "),v("p",[t._v("假设去掉二级缓存")]),t._v(" "),v("p",[t._v("如果去掉了二级缓存，则需要直接在 "),v("code",[t._v("singletonFactory.getObject()")]),t._v(" 阶段初始化完毕，并放到一级缓存中。")]),t._v(" "),v("p",[t._v("那有这么一种场景，B 和 C 都依赖了 A。")]),t._v(" "),v("p",[t._v("要知道在有代理的情况下 "),v("code",[t._v("singletonFactory.getObject()")]),t._v(" 获取的是代理对象。")]),t._v(" "),v("p",[t._v("而多次调用 "),v("code",[t._v("singletonFactory.getObject()")]),t._v(" 返回的代理对象是不同的，就会导致 B 和 C 依赖了不同的 A。")]),t._v(" "),v("h2",{attrs:{id:"参考"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#参考"}},[t._v("#")]),t._v(" 参考")]),t._v(" "),v("ol",[v("li",[t._v("https://zhuanlan.zhihu.com/p/377878056")]),t._v(" "),v("li",[t._v("https://www.bilibili.com/video/BV1Sm4y1N7FD/?vd_source=56a32d67ac4f0ccac0c6360804c3cf67")]),t._v(" "),v("li",[t._v("https://www.pdai.tech/md/spring/spring-x-framework-ioc-source-3.html#spring%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E4%B8%8B%E7%9A%84%E5%B1%9E%E6%80%A7%E4%BE%9D%E8%B5%96")])])])}),[],!1,null,null,null);v.default=e.exports}}]);