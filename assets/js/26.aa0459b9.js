(window.webpackJsonp=window.webpackJsonp||[]).push([[26],{350:function(a,t,v){"use strict";v.r(t);var e=v(7),_=Object(e.a)({},(function(){var a=this,t=a._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("h2",{attrs:{id:"对比总结"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#对比总结"}},[a._v("#")]),a._v(" 对比总结")]),a._v(" "),t("ul",[t("li",[t("code",[a._v("HashTable")]),a._v(" : 使用了synchronized关键字对put等操作进行加锁;")]),a._v(" "),t("li",[t("code",[a._v("ConcurrentHashMap JDK1.7")]),a._v(": 使用分段锁机制实现;")]),a._v(" "),t("li",[t("code",[a._v("ConcurrentHashMap JDK1.8")]),a._v(": 则使用CAS + synchronized 实现;")])]),a._v(" "),t("h2",{attrs:{id:"jdk-1-5-1-7-concurrenthashmap-的实现"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#jdk-1-5-1-7-concurrenthashmap-的实现"}},[a._v("#")]),a._v(" JDK 1.5 ～ 1.7 ConcurrentHashMap 的实现")]),a._v(" "),t("p",[a._v("Java使用了分段锁机制实现ConcurrentHashMap。其最大并发度受Segment的个数限制。默认是有16个 segment，且初始化后不可扩容。")]),a._v(" "),t("p",[a._v("ConcurrentHashMap在对象中保存了一个Segment数组，即将整个Hash表划分为多个分段；而每个Segment元素，即每个分段则类似于一个Hashtable；这样，在执行put操作时首先根据hash算法定位到元素属于哪个Segment，然后对该Segment加锁即可。")]),a._v(" "),t("p",[t("img",{attrs:{src:"https://www.pdai.tech/images/thread/java-thread-x-concurrent-hashmap-1.png",alt:"img"}})]),a._v(" "),t("h3",{attrs:{id:"get"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#get"}},[a._v("#")]),a._v(" get")]),a._v(" "),t("ol",[t("li",[a._v("为输入的Key做Hash运算，得到hash值。")]),a._v(" "),t("li",[a._v("通过hash值，定位到对应的Segment对象")]),a._v(" "),t("li",[a._v("再次通过hash值，定位到Segment当中数组的具体位置。")])]),a._v(" "),t("h3",{attrs:{id:"put"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#put"}},[a._v("#")]),a._v(" put")]),a._v(" "),t("ol",[t("li",[a._v("为输入的Key做Hash运算，得到hash值。")]),a._v(" "),t("li",[a._v("通过hash值，定位到对应的Segment对象")]),a._v(" "),t("li",[a._v("调用 reentrantLock.tryLock() 方法尝试获取锁。获取失败的话，自旋再次获取"),t("code",[a._v("while(!tryLock()) {}")])]),a._v(" "),t("li",[a._v("再次通过hash值，定位到Segment当中数组的具体位置。")]),a._v(" "),t("li",[a._v("插入或覆盖HashEntry对象。")]),a._v(" "),t("li",[a._v("释放锁。")])]),a._v(" "),t("h2",{attrs:{id:"jdk-1-8-concurrenthashmap-的实现"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#jdk-1-8-concurrenthashmap-的实现"}},[a._v("#")]),a._v(" JDK 1.8 ConcurrentHashMap 的实现")]),a._v(" "),t("p",[a._v("使用CAS + synchronized 实现。")]),a._v(" "),t("p",[t("img",{attrs:{src:"https://pdai.tech/images/thread/java-thread-x-concurrent-hashmap-2.png",alt:"img"}})]),a._v(" "),t("h3",{attrs:{id:"get-2"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#get-2"}},[a._v("#")]),a._v(" get")]),a._v(" "),t("ol",[t("li",[a._v("计算 hash 值")]),a._v(" "),t("li",[a._v("根据 hash 值找到数组对应位置: (n - 1) & h")]),a._v(" "),t("li",[a._v("根据该位置处结点性质进行相应查找")])]),a._v(" "),t("ul",[t("li",[a._v("如果该位置为 null，那么直接返回 null 就可以了")]),a._v(" "),t("li",[a._v("如果该位置处的节点刚好就是我们需要的，返回该节点的值即可")]),a._v(" "),t("li",[a._v("如果该位置节点的 hash 值小于 0，说明正在扩容，或者是红黑树")]),a._v(" "),t("li",[a._v("如果以上 3 条都不满足，那就是链表，进行遍历比对即可")])]),a._v(" "),t("h3",{attrs:{id:"put-2"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#put-2"}},[a._v("#")]),a._v(" put")]),a._v(" "),t("ol",[t("li",[a._v("首先会判断 key、value是否为空，如果为空就抛异常；")]),a._v(" "),t("li",[a._v("接着会判断容器数组是否为空，如果为空就初始化数组；")]),a._v(" "),t("li",[a._v("获取 hash 值对应的数组下标，得到头节点 f。\n"),t("ol",[t("li",[a._v("如果 f 为空，代表当前数组下标是否第一次插入，如果是就通过 "),t("code",[a._v("CAS")]),a._v(" 方式插入；如果 CAS 失败，代表有并发操作，循环重试。")]),a._v(" "),t("li",[a._v("如果 f 的 hash 等于 MOVED，表示有其它线程正在扩容，则一起进行扩容操作（帮助数据迁移）。")]),a._v(" "),t("li",[a._v("其他的情况，即如果头节点 f 不为空，获取数组该位置的头节点的监视器锁 "),t("code",[a._v("synchronized(f) {}")]),a._v("，把新的"),t("code",[a._v("Node")]),a._v("节点按链表或红黑树的方式插入到合适的位置；")])])]),a._v(" "),t("li",[a._v("节点插入完成之后，接着判断链表长度是否超过"),t("code",[a._v("8")]),a._v("，如果超过"),t("code",[a._v("8")]),a._v("个，就将链表转化为红黑树结构；")]),a._v(" "),t("li",[a._v("最后，插入完成之后，进行扩容判断。")])]),a._v(" "),t("p",[a._v("其他细节")]),a._v(" "),t("ul",[t("li",[a._v("扩容: tryPresize")]),a._v(" "),t("li",[a._v("数据迁移: transfer")])]),a._v(" "),t("h2",{attrs:{id:"cas"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#cas"}},[a._v("#")]),a._v(" CAS")]),a._v(" "),t("p",[a._v("compare-and-swap。CAS需要有3个操作数：内存地址V，旧的预期值A，即将要更新的目标值B。")]),a._v(" "),t("p",[a._v("CAS指令执行时，当且仅当内存地址V的值与预期值A相等时，将内存地址V的值修改为 B ，并返回 true ；否则就什么都不做，并返回 false。整个比较并替换的操作是一个原子操作。")]),a._v(" "),t("p",[a._v("Java 中 CAS 的实现是调用了 Unsafe 的方法。 sun.misc.Unsafe 类，它可以提供硬件级别的原子操作，它可以获取某个属性在内存中的位置，也可以修改对象的字段值，只不过该类对一般开发而言，很少会用到，其底层是用 C/C++ 实现的，所以它的方式都是被 native 关键字修饰过的。")]),a._v(" "),t("p",[a._v("CAS虽然很高效的解决了原子操作问题，但是CAS仍然存在三大问题。")]),a._v(" "),t("ol",[t("li",[a._v("循环时间长开销很大：一般如果CAS失败，会一直进行尝试。如果CAS长时间一直不成功，可能会给CPU带来很大的开销。")]),a._v(" "),t("li",[a._v("只能保证一个共享变量的原子操作。")]),a._v(" "),t("li",[a._v("ABA问题：Java提供了一个带有标记的原子引用类 AtomicStampedReference，它可以通过控制变量值的版本来保证CAS的正确性。")])]),a._v(" "),t("h2",{attrs:{id:"参考"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#参考"}},[a._v("#")]),a._v(" 参考")]),a._v(" "),t("ul",[t("li",[a._v("https://pdai.tech/md/java/thread/java-thread-x-juc-collection-ConcurrentHashMap.html#concurrenthashmap-jdk-1-8")]),a._v(" "),t("li",[a._v("https://juejin.cn/post/7064061605185028110#heading-13")])])])}),[],!1,null,null,null);t.default=_.exports}}]);