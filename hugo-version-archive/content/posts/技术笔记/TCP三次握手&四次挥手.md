---
title: "TCP三次握手&四次挥手"
date: 2022-01-09T22:48:04+08:00
categories: ["技术笔记"]
tags: ["计算机网络"]
---

## TCP三次握手

![image-20220108193116497](https://tva1.sinaimg.cn/large/008i3skNly1gy6hqu1wvuj31040u0tbl.jpg)

三次握手建立连接。

0. 一开始客户端和服务端都处于`CLOSED`状态，服务端主动监听某个端口，处于`LISTEN`状态。
1. 第一次握手，客户端随机初始化序列号，然后将 `SYN`标志位置1，发送`SYN`报文。之后客户端处于 `SYN-SENT`状态。
2. 第二次握手，服务端收到 `SYN` 报文，初始化自己的序列号，然后将确认应答号设置为收到的序列号+1，将**SYN** 和 **ACK**标志位置位1，发送给客户端。之后服务端处于 `SYN-RCVD` 状态。
3. 第三次握手，客户端向服务端发送应答报文，将 `ACK`标志位设置为1，确认应答号设置为收到的序列号+1。之后客户端处于 `ESTABLISHED` 状态。
4. 服务端收到应答报文后，也进入 `ESTABLISHED` 状态。

其中，只有第三次握手是可以携带数据的，前两次不行。



### Linux如何看连接状态

`netstat -napt`

### 为什么是3次，不是2次、4次

为什么三次握⼿才可以初始化Socket、序列号和窗⼝⼤⼩并建⽴ TCP 连接。

原因在于：

- 三次握手可以防止旧的重复连接被初始化造成混乱（主要原因）
  - 当网络阻塞时，如果客户端连续发送了多次SYN建立连接的报文，当一个**旧的SYN报文**比**最新的SYN报文**早到了服务端，那此时服务端就会回一个 `SYN+ACK` 报文给客户端。客户端可以根据自身的上下文，判断你这是一个历史连接（序列号过期或超时），那么客户端就会发送 `RST` 报文给服务端，中止这一次连接。
  - 如果是两次握手连接，就不能判断当前连接是否是历史连接（是不是自己需要的），三次握手则可以再客户端（发送方）准备发送第三次报文时，去进行判断（发送ACK 或 RST）
- 三次握手可以同步双方的初始化序列
  - TCP协议通信的双方，都必须要维护一个序列号，序列号是可靠传输的关键因素，作用在于：
    - 接收方可以去除重复的数据。
    - 接收方可以根据数据包的序列号按序接收。
    - 可以标识发送出去的数据包中，哪些是已经被对方收到的。
  - 发送一个SYN报文，需要回一个ACK应答报文。四次握手服务端ACK报文和SYN报文可以合并成一步，故三次握手就够了。
- 三次握手可以避免资源浪费。
  - 如果只有两次握手，当客户端`SYN`请求连接网络阻塞时，客户端没有收到 `ACK`报文，就会重新发送`SYN`，但服务端并不清楚客户端是否接受到`ACK`，所以每收到一个`SYN`就只能先主动建立一个连接，会导致建立了多个冗余的无效连接，造成资源浪费。

总结：

TCP建立连接时，通过三次握手能防止历史连接的建立，能减少不必要的资源开销，能保证双方同步初始化序列号。

序列号能保证数据包不重复、不丢失和按序传输。

两次握手：无法阻止历史连接的建立，会造成双方资源的浪费，无法可靠的同步双方序列号。

四次握手：三次握手就可以建立可靠的连接，因此不需要更多的通信次数。

### 为什么初始序列号是不同的？

- 如果一个已经失效的连接被重用了，但就连接的历史报文还残留在网络中，如果序列号相同，就无法分辨是不是历史报文，如果历史报文被新连接接受了，会产生数据混乱。
- 为了安全性，防止黑客伪造相同的序列号的TCP报文被对方接收。

### 既然IP层会分片，为什么TCP层还需要MSS？

### 什么SYN攻击，如何避免？

SYN攻击是指伪造不同IP地址的SYN报文，当服务端接受到一个SYN报文时，会发送ACK+SYN报文，进入SYN_RCVD状态，然而得不到未知IP主机的ACK，会把服务端SYN接受队列（未连接队列）占满。

（应用程序处理过慢的话，则会导致Accept队列被占满）

![image-20220108210958620](https://tva1.sinaimg.cn/large/008i3skNly1gy6klhshlkj317p0u0ju1.jpg)

正常流程：

- 当服务端接收到客户端的 SYN 报⽂时，会将其加⼊到内核的「 SYN 队列」；
- 接着发送 SYN + ACK 给客户端，等待客户端回应 ACK 报⽂；
- 服务端接收到 ACK 报⽂后，从「 SYN 队列」移除放⼊到「 Accept 队列」；
- 应⽤通过调⽤ accpet() socket 接⼝，从「 Accept 队列」取出连接。

![image-20220108211252237](https://tva1.sinaimg.cn/large/008i3skNly1gy6koi8kzxj31310u0q5c.jpg)

避免方法：

- 修改linux内核参数，控制队列大小和队列满时应做什么操作。
- `tcp_syncookies`方式。但SYN队列满时，后序SYN包不进入队列，直接计算出一个SYN cookie返回客户端。

## TCP四次挥手

![image-20220108222757362](https://tva1.sinaimg.cn/large/008i3skNly1gy6mumkxylj30u00vt40v.jpg)

1. 客户端准备关闭连接，发送一个TCP首部 `FIN` 标记为为1的报文，即 `FIN` 报文，之后客户端进入 `FIN_WAIT_1` 状态。
2. 服务端收到报文后，向客户端发送 `ACK` 应答报文，之后服务端进入 `CLOSED_WAIT` 状态。
3. 客户端收到 `ACK` 报文，之后进入 `FIN_WAIT_2` 状态。
4. 服务端处理完数据后，向客户端发送 `FIN` 报文，之后服务端进入 `LAST_ACK` 状态。
5. 客户端收到 `FIN`报文后，回一个 `ACK` 报文，之后客户端进入 `TIME_WAIT` 状态。
6. 服务端收到`ACK`报文后，就进入了 `CLOSED`状态，服务端已经完成连接的关闭。
7. 客户端在经过 `2MSL` 时间后，进入 `CLOSED` 状态，客户端也完成连接的关闭。



每个方向都需要一个 FIN 和一个 ACK，因此称为四次挥手。

主动关闭连接的，才有 TIME_WAIT状态。

### 为什么是四次挥手？

- 关闭连接时，客户端发送FIN报文，仅表示客户端不再发送数据了，但还可以接受数据。
- 服务端收到 FIN，先回一个ACK，但服务端可能还有数据需要处理和发送，等服务端不再发送数据时，才发送FIN给客户端，表示开始关闭。

### 为什么要TIME_WAIT要等到2MSL？

MSL（Maximum Segment Lifetime），即报文最大生存时间，是任何报文在网络上存在的最长时间，超过这个时间的报文将被丢弃。

IP头有一个 `TTL`字段，表示IP数据报可以经过的最大路有数，每经过一个处理它的路由此值就减1，当此值为0时数据被丢弃，同时发送`ICMP`报文通知源主机。

TIME_WAIT等待2倍的MSL，是因为网络中可能存在来自发送方的数据包，当这些数据包被接收后又会收到响应，2MSL可以保证两个方向上的所有数据包都被处理或被丢弃。

比如被动关闭方没有收到断开连接的最后的ACK报文，就会触发超时重发FIN报文，另一方接收到FIN后，会重发ACK给被动关闭方，一来一回正好2MSL。

Linux里2MSL默认是60秒。

### TIME_WAIT状态的过多有什么危害？

- 占用内存资源
- 占用端口资源，一个TCP连接至少消耗一个本地端口。一般可以开启的端口为 32768~61000.

### 如何优化TIME_WAIT？

打开 net.ipv4.tcp_tw_reuse 和 net.ipv4.tcp_timestamps 选项；

可以复⽤处于 TIME_WAIT 的 socket 为新的连接所⽤。

### 已经建立了连接，但客户端突然故障了怎么办？

TCP 有⼀个机制是保活机制。原理如下：
定义⼀个时间段，在这个时间段内，如果没有任何连接相关的活动， TCP 保活机制会开始作⽤，每隔⼀个时间间
隔，发送⼀个探测报⽂，该探测报⽂包含的数据⾮常少，如果连续⼏个探测报⽂都没有得到响应，则认为当前的
TCP 连接已经死亡，系统内核将错误信息通知给上层应⽤程序。

```shell
net.ipv4.tcp_keepalive_time=7200 //表示保活时间是 7200 秒（2⼩时），也就 2 ⼩时内如果没有任何连接相关的活
动，则会启动保活机制
net.ipv4.tcp_keepalive_intvl=75 //表示每次检测间隔 75 秒
net.ipv4.tcp_keepalive_probes=9 //表示检测 9 次⽆响应，认为对⽅是不可达的，从⽽中断本次的连接。
```
