---
title: "《深入理解Java虚拟机-第三版》-note"
date: 2022-04-09T13:48:04+08:00
categories: ["技术笔记"]
tags: ["JVM"]
---

## 编译器和解释器

- 类型1：C、C++
- 类型2：JavaScript、Python、PHP
- 类型3：Java

对于类型1，我们一般称为编译型语言，也就是需要用到编译器进行编译。

对于类型2，我们一般称为解释型语言，或是脚本语言，也就是要用解释器进行解释。

编译器与解释器就类似于笔译工作者与口译工作者的区别，**编译器就是笔译工作者，而解释器就是口译工作者。**

-  编译器在编译的过程中，读入源程序文件，输出一份等价的二进制可执行文件，就和笔译工作者一样，他们都会输出一份翻译后的文件。
-  解释器在解释的过程中，读入源程序文件，输出的是执行的结果，就和口译工作者一样，他们输出的是已经完成翻译的结果。



解释器：

- 优点：跨平台、启动速度快、开发效率高

- 缺点：执行速度慢，执行效率低

编译器：

- 优点：执行速度快、执行效率高
- 缺点：平台相关性高，编译速度（启动速度）慢，开发效率低



Java既有编译器（不止一个）又有解释器。

Java中编译器比较多，它包含一个前端编译器，一个后端编译器（JIT）以及一个静态预编译器（AOT）。

-  前端编译器的功能是从源代码生成Java字节码，也就是中间代码；
- 后端编译器，也叫作即时编译器（JIT）它是包含在了JVM中，用于在执行的过程中，将热点代码（也就是执行次数比较多的代码）转化为本地机器码，并做一些优化，以加速执行效率。
- 静态预编译器（AOT）它是直接将java源代码编译成本地机器码，也就是传统意义上的编译器，但用的不多，因为这样会使java的一些特性丢失。

Java中的解释器与JIT一起打包，作为JVM中的执行引擎，解释器主要将字节码进行解释执行，同时配合JIT进行代码的优化操作。

java解释器就是把在java虚拟机上运行的目标代码（字节码）解释成为具体平台的机器码的程序。即jdk或jre目录下bin目录中的java.exe文件，而javac.exe是编译器。

运行java程序的过程是先用javac编译，然后用java解释。而一经编译成功后，就可以直接用java.exe随处解释运行了。

JVM负责运行字节码：JVM把每一条要执行的字节码交给解释器，翻译成对应的机器码，然后由解释器执行。JVM解释执行字节码文件就是JVM操作Java解释器进行解释执行字节码文件的过程。



# Java内存区域

Java把控制内存的权利交给了Java 虚拟机，一旦出现内存泄漏和溢出方面的问题，如果不了解虚拟机是怎样使用内存的，那排查错误、修正问题将成为一项艰难的工作。



## 运行时数据区

<img src="https://tva1.sinaimg.cn/large/008i3skNly1gxgwocrmwlj30zd0u077e.jpg" alt="image-20211217162311784" style="zoom:50%;" />



<img src="https://tva1.sinaimg.cn/large/008i3skNgy1gy0tu3ig7sj30u011244h.jpg" alt="image-20220103215608911" style="zoom:50%;" />

《Java虚拟机规范》 ：“概念模型”这个词会经常被提及， 它代表了所有虚拟机的统一外观， 但各款具体的Java虚拟机并不
一定要完全照着概念模型的定义来进行设计， 可能会通过一些更高效率的等价方式去实现它。



### 程序计数器

当前线程所执行的字节码的行号。字节码解释器就是通过改变这个计数器的值来选取下一条需要执行的字节码指令。

**程序计数器主要有两个作用：**

1. 字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。
2. 在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。

**注意：程序计数器是唯一一个不会出现 `OutOfMemoryError` 的内存区域，它的生命周期随着线程的创建而创建，随着线程的结束而死亡。**



### Java虚拟机栈

描述的是Java方法执行的线程内存模型，每个方法被执行时，Java虚拟机都会同步创建一个栈帧（Stack Frame）用于存储局部变量表、操作数栈、动态连接、方法出口等信息。每个方法从被调用到执行完毕的过程，就对应这一个栈帧在虚拟机栈的入栈和出栈过程。

**局部变量表主要存放了编译期可知的各种数据类型**（boolean、byte、char、short、int、float、long、double）、**对象引用**（reference 类型，它不同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）。

**Java 虚拟机栈会出现两种错误：`StackOverFlowError` 和 `OutOfMemoryError`。**

- **`StackOverFlowError`：** 若 Java 虚拟机栈的内存大小不允许动态扩展，那么当线程请求栈的深度超过当前 Java 虚拟机栈的最大深度的时候，就抛出 StackOverFlowError 错误。
- **`OutOfMemoryError`：** Java 虚拟机栈的内存大小可以动态扩展， 如果虚拟机在动态扩展栈时无法申请到足够的内存空间，则抛出`OutOfMemoryError`异常。

HotSpot虚拟机的栈容量是不可以动态扩展的， 以前的Classic虚拟机倒是可以。 所以在HotSpot虚拟机上是不会由于虚拟机栈无法扩展而导致OutOfMemoryError异常——只要线程申请栈空间成功了就不会有OOM， 但是如果申请时就失败， 仍然是会出现OOM异常的。

### 本地方法栈

本地方法栈（Native Method Stacks） 与虚拟机栈所发挥的作用是非常相似的， 其区别只是虚拟机栈为虚拟机执行Java方法（也就是字节码） 服务， 而本地方法栈则是为虚拟机使用到的本地（Native）方法服务。

在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。

### 堆

Java 虚拟机所管理的内存中最大的一块，Java 堆是所有线程共享的一块内存区域，在虚拟机启动时创建。**此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存。**

Java 世界中“几乎”所有的对象都在堆中分配，但是，随着 JIT 编译器的发展与逃逸分析技术逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化，所有的对象都分配到堆上也渐渐变得不那么“绝对”了。从 JDK 1.7 开始已经默认开启逃逸分析，如果某些方法中的对象引用没有被返回或者未被外面使用（也就是未逃逸出去），那么对象可以直接在栈上分配内存。

Java 堆是垃圾收集器管理的主要区域，因此也被称作**GC 堆（Garbage Collected Heap）**。从垃圾回收的角度，由于现在收集器基本都采用分代垃圾收集算法，所以 Java 堆还可以细分为：新生代和老年代；再细致一点有：Eden 空间、From Survivor、To Survivor 空间等。**进一步划分的目的是更好地回收内存，或者更快地分配内存。**

从回收内存的角度看， 由于现代垃圾收集器大部分都是基于分代收集理论设计的， 所以Java堆中经常会出现“新生代”“老年代”“永久代”“Eden空间”“From Survivor空间”“To Survivor空间”等名词， 这些区域划分仅仅是一部分垃圾收集器的共同特性或者说设计风格而已， 而非某个Java虚拟机具体实现的固有内存布局， 更不是《Java虚拟机规范》 里对Java堆的进一步细致划分。 不少资料上经常写着类似于“Java虚拟机的堆内存分为新生代、 老年代、 永久代、 Eden、 Survivor……”这样的内容。 在十年之前（以G1收集器的出现为分界） ， 作为业界绝对主流的HotSpot虚拟机， 它内部的垃圾收集器全部都基于“经典分代”[3]来设计， 需要新生代、 老年代收集器搭配才能工作， 但现在不可同日而语，也出现了不采用分代设计的垃圾回收器。

在 JDK 7 版本及 JDK 7 版本之前，堆内存被通常分为下面三部分：

1. 新生代内存(Young Generation)
2. 老生代(Old Generation)
3. 永生代(Permanent Generation)

<img src="https://tva1.sinaimg.cn/large/008i3skNly1gxgxj7rl90j30s60diq44.jpg" alt="image-20211217165250972" style="zoom: 50%;" />

JDK 8 版本之后方法区（HotSpot 的永久代）被彻底移除了（JDK1.7 就已经开始了），取而代之是元空间，元空间使用的是直接内存。

<img src="https://tva1.sinaimg.cn/large/008i3skNly1gxgxklao81j30v00e00ub.jpg" alt="image-20211217165410792" style="zoom:50%;" />

**上图所示的 Eden 区、两个 Survivor 区都属于新生代（为了区分，这两个 Survivor 区域按照顺序被命名为 from 和 to），中间一层属于老年代。**

大部分情况，对象都会首先在 Eden 区域分配，在一次新生代垃圾回收后，如果对象还存活，则会进入 s0 或者 s1，并且对象的年龄还会加 1(Eden 区->Survivor 区后对象的初始年龄变为 1)，当它的年龄增加到一定程度（默认为 15 岁），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 `-XX:MaxTenuringThreshold` 来设置。

Hotspot 遍历所有对象时，按照年龄从小到大对其所占用的大小进行累积，当累积的某个年龄大小超过了 survivor 区的一半时，取这个年龄和 MaxTenuringThreshold 中更小的一个值，作为新的晋升年龄阈值。

堆这里最容易出现的就是 OutOfMemoryError 错误，并且出现这种错误之后的表现形式还会有几种，比如：

1. **`java.lang.OutOfMemoryError: GC Overhead Limit Exceeded`** ： 当 JVM 花太多时间执行垃圾回收并且只能回收很少的堆空间时，就会发生此错误。
2. **`java.lang.OutOfMemoryError: Java heap space`** :假如在创建新的对象时, 堆内存中的空间不足以存放新创建的对象, 就会引发此错误。(和配置的最大堆内存有关，且受制于物理内存大小。最大堆内存可通过`-Xmx`参数配置，`-Xms`设置初始堆内存，若没有特别配置，将会使用默认值，详见：[Default Java 8 max heap size  (opens new window)](https://stackoverflow.com/questions/28272923/default-xmxsize-in-java-8-max-heap-size))

### 方法区

方法区与 Java 堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。虽然 **Java 虚拟机规范把方法区描述为堆的一个逻辑部分**，但是它却有一个别名叫做 **Non-Heap（非堆）**，目的应该是与 Java 堆区分开来。

说到方法区， 不得不提一下“永久代”这个概念， 尤其是在JDK 8以前， 许多Java程序员都习惯在HotSpot虚拟机上开发、 部署程序， 很多人都更愿意把方法区称呼为“永久代”（Permanent Generation） ， 或将两者混为一谈。 本质上这两者并不是等价的， 因为仅仅是当时的HotSpot虚拟机设计团队选择把收集器的分代设计扩展至方法区， 或者说**使用永久代来实现方法区**而已， 这样使得HotSpot的垃圾收集器能够像管理Java堆一样管理这部分内存， 省去专门为方法区编写内存管理代码的工作。 但是对于其他虚拟机实现， 譬如BEA JRockit、 IBM J9等来说， 是不存在永久代的概念的。 原则上如何实现方法区属于虚拟机实现细节， 不受《Java虚拟机规范》 管束， 并不要求统一。 但现在回头来看， 当年使用永久代来实现方法区的决定并不是一个好主意， 这种设计**导致了Java应用更容易遇到内存溢出的问题**（永久代有-XX： MaxPermSize的上限， **即使不设置也有默认大小**， 而J9和JRockit只要没有触碰到进程可用内存的上限， 例如32位系统中的4GB限制， 就不会出问题） ， 而且有极少数方法（例如String::intern()） 会因永久代的原因而导致不同虚拟机下有不同的表现。 当Oracle收购BEA获得了JRockit的所有权后， 准备把JRockit中的优秀功能， 譬如Java Mission Control管理工具， 移植到HotSpot虚拟机时， 但因为两者对方法区实现的差异而面临诸多困难。

考虑到HotSpot未来的发展， 在JDK 6的时候HotSpot开发团队就有放弃永久代， 逐步改为**采用本地内存（Native Memory） 来实现方法区**的计划了[1]， 到了JDK 7的HotSpot， 已经把原本放在永久代的字符串常量池、 静态变量等移出， 而到了JDK 8， 终于完全废弃了永久代的概念， 改用与JRockit、 J9一样在本地内存中实现的元空间（Metaspace） 来代替， 把JDK 7中永久代还剩余的内容（主要是类型信息） 全部移到元空间中。

```java
//JDK 1.8 之前永久代还没被彻底移除的时候通常通过下面这些参数来调节方法区大小
-XX:PermSize=N //方法区 (永久代) 初始大小
-XX:MaxPermSize=N //方法区 (永久代) 最大大小,超过这个值将会抛出 OutOfMemoryError 异常:java.lang.OutOfMemoryError: PermGen
```

JDK 1.8 的时候，方法区（HotSpot 的永久代）被彻底移除了（JDK1.7 就已经开始了），取而代之是元空间，**元空间使用的是直接内存**。

```java
//一些常用参数：
-XX:MetaspaceSize=N //设置 Metaspace 的初始（和最小大小）
-XX:MaxMetaspaceSize=N //设置 Metaspace 的最大大小
```

与永久代很大的不同就是，如果不指定大小的话，随着更多类的创建，虚拟机会耗尽所有可用的系统内存。



**运行时常量池**是方法区的一部分。Class 文件中除了有类的版本、字段、方法、接口等描述信息外，还有常量池表（用于存放编译期生成的各种字面量和符号引用）。既然运行时常量池是方法区的一部分，自然受到方法区内存的限制，当常量池无法再申请到内存时会抛出 OutOfMemoryError 错误。

JDK1.7 之前运行时常量池逻辑包含字符串常量池存放在**方法区**, 此时 hotspot 虚拟机对方法区的实现为永久代。

JDK1.7字符串常量池被从方法区拿到了堆中, 这里没有提到运行时常量池,也就是说字符串常量池被单独拿到堆,运行时常量池剩下的东西还在方法区, 也就是 hotspot 中的永久代。

JDK1.8 hotspot 移除了永久代用元空间(Metaspace)取而代之, 这时候**字符串常量池还在堆**, **运行时常量池还在方法区**, 只不过方法区的实现从永久代变成了元空间(Metaspace)。

### 直接内存

直接内存并不是虚拟机运行时数据区的一部分，也不是虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使用。而且也可能导致 OutOfMemoryError 错误出现。

JDK1.4 中新加入的 **NIO(New Input/Output) 类**，引入了一种基于通道（Channel）与缓存区（Buffer）的 I/O 方式，它可以直接使用 Native 函数库直接分配堆外内存，然后通过一个存储在 Java 堆中的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样就能在一些场景中显著提高性能，因为避免了在 Java 堆和 Native 堆之间来回复制数据。

本机直接内存的分配不会受到 Java 堆的限制，但是，既然是内存就会受到本机总内存大小以及处理器寻址空间的限制。

## Hotspot虚拟机对象探秘

> 基于实用优先的原则， 以最常用的虚拟机HotSpot和最常用的内存区域Java堆为例， 深入探讨一下HotSpot虚拟机在Java堆中对象分配、 布局和访问的全过程。

### 对象的创建

![image-20211219232212063](https://tva1.sinaimg.cn/large/008i3skNly1gxjk0xvmv0j30wk0840te.jpg)

1. 类加载检查：虚拟机遇到一条 new 指令时，首先将去检查这个指令的参数是否能在常量池中定位到这个类的符号引用，并且检查这个符号引用代表的类是否已被加载过、解析和初始化过。如果没有，那必须先执行相应的类加载过程。
2. 分配内存：
   1. 分配方式：有“指针碰撞”和“空闲列表”两种，取决于Java堆是否规整，这又由垃圾回收器是否带有压缩整理功能决定。
   2. 虚拟机保证线程安全：
      1. **CAS+失败重试：** CAS 是乐观锁的一种实现方式。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。**虚拟机采用 CAS 配上失败重试的方式保证更新操作的原子性。**
      2. **TLAB（本地线程分配缓存）：** 为每一个线程预先在 Eden 区分配一块儿内存，JVM 在给线程中的对象分配内存时，首先在 TLAB 分配，当对象大于 TLAB 中的剩余内存或 TLAB 的内存已用尽时，再采用上述的 CAS 进行内存分配。
3. 初始化零值
4. 设置对象头：例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息。 **这些信息存放在对象头中。** 另外，根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。
6. 执行init方法

### 对象的内存布局

在HotSpot虚拟机中，对象在堆内存中的存储布局可以分为三个部分：**对象头**、**实例数据**和**对齐填充**。

**Hotspot 虚拟机的对象头包括两部分信息**，**第一部分用于存储对象自身的运行时数据**（哈希码、GC 分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等等），官方称为“**Mark Word**”。**另一部分是类型指针**，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是那个类的实例。

**实例数据部分是对象真正存储的有效信息**，也是在程序中所定义的各种类型的字段内容。

**对齐填充部分不是必然存在的，也没有什么特别的含义，仅仅起占位作用。** 因为 Hotspot 虚拟机的自动内存管理系统要求对象起始地址必须是 8 字节的整数倍，换句话说就是对象的大小必须是 8 字节的整数倍。而对象头部分正好是 8 字节的倍数（1 倍或 2 倍），因此，当对象实例数据部分没有对齐时，就需要通过对齐填充来补全。

### 对象的访问定位

Java程序会通过栈上reference数据来操作堆上的具体对象。

对象的访问方式由虚拟机的实现决定：主流的访问方式主要有**使用句柄**和**直接指针**两种。

<img src="https://tva1.sinaimg.cn/large/008i3skNly1gxkavysabvj31h80s6djc.jpg" alt="image-20211220145133712" style="zoom: 33%;" />

<img src="https://tva1.sinaimg.cn/large/008i3skNly1gxkawmgzwbj31h80s6whq.jpg" alt="image-20211220145211594" style="zoom:33%;" />

**这两种对象访问方式各有优势。使用句柄来访问的最大好处是 reference 中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而 reference 本身不需要修改。使用直接指针访问方式最大的好处就是速度快，它节省了一次指针定位的时间开销。**



### 字符串问题

- 直接使用双引号声明出来的`String`对象会直接存储在常量池中。
- 如果不是用双引号声明的`String`对象，可以使用`String`提供的`intern`方法。intern 方法会从字符串常量池中查询当前字符串是否存在，若不存在就会将当前字符串放入常量池中。
- （`String.intern()` 是一个 Native 方法，它的作用是：如果运行时常量池中已经包含一个等于此 String 对象内容的字符串，则返回常量池中该字符串的引用；如果没有，JDK1.7 之前（不包含 1.7）的处理方式是在常量池中创建与此 `String` 内容相同的字符串，并返回常量池中创建的字符串的引用，JDK1.7 以及之后，字符串常量池被从方法区拿到了堆中，jvm 不会在常量池中创建该对象，而是将堆中这个对象的引用直接放到常量池中，减少不必要的内存开销。）



对于基本数据类型来说，比较的是值。对于引用数据类型来说，比较的是对象的内存地址。

在编译过程中，Javac 编译器会进行一个叫做 **常量折叠(Constant Folding)** 的代码优化。常量折叠会把常量表达式的值求出来作为常量嵌在最终生成的代码中，这是 Javac 编译器会对源代码做的极少量优化措施之一(代码优化几乎都在即时编译器中进行)。

一般来说，我们要尽量避免通过 new 的方式创建字符串。使用双引号声明的 `String` 对象（ `String s1 = "java"` ）更利于让编译器有机会优化我们的代码，同时也更易于阅读。

被 `final` 关键字修改之后的 `String` 会被编译器当做常量来处理，编译器程序编译期就可以确定它的值，其效果就想到于访问常量。

 

**String s1 = new String("abc");这句话创建了几个字符串对象？**

会创建 1 或 2 个字符串：

- 如果字符串常量池中已存在字符串常量“abc”，则只会在堆空间创建一个字符串常量“abc”。
- 如果字符串常量池中没有字符串常量“abc”，那么它将首先在字符串常量池中创建，然后在堆空间中创建，因此将创建总共 2 个字符串对象。



Java 基本类型的包装类的大部分都实现了常量池技术。

`Byte`,`Short`,`Integer`,`Long` 这 4 种包装类默认创建了数值 **[-128，127]** 的相应类型的缓存数据，`Character` 创建了数值在 **[0,127]** 范围的缓存数据，`Boolean` 直接返回 `True` Or `False`。

两种浮点数类型的包装类 `Float`,`Double` 并没有实现常量池技术。

记住：**所有整型包装类对象之间值的比较，全部使用 equals 方法比较**。

## OutOfMemoryError异常

### Java堆溢出

将堆的最小值`-Xms`参数与最大值`-Xmx`参数设置为一样的话可避免堆自动扩展，即设置为不可扩展。

要解决这个内存区域的异常， 常规的处理方法是首先通过内存映像分析工具（如Eclipse Memory Analyzer） 对Dump出来的堆转储快照进行分析。 第一步首先应确认内存中导致OOM的对象是否是必要的， 也就是要先分清楚到底是出现了内存泄漏（Memory Leak） 还是内存溢出（Memory Overflow） 。 

如果是内存泄漏， 可进一步通过工具查看泄漏对象到GC Roots的引用链， 找到泄漏对象是通过怎样的引用路径、 与哪些GC Roots相关联， 才导致垃圾收集器无法回收它们， 根据泄漏对象的类型信息以及它到GC Roots引用链的信息， 一般可以比较准确地定位到这些对象创建的位置， 进而找出产生内存泄漏的代码的具体位置。

如果不是内存泄漏， 换句话说就是内存中的对象确实都是必须存活的， 那就应当检查Java虚拟机的堆参数（-Xmx与-Xms） 设置， 与机器的内存对比， 看看是否还有向上调整的空间。 再从代码上检查是否存在某些对象生命周期过长、 持有状态时间过长、 存储结构设计不合理等情况， 尽量减少程序运行期的内存消耗。

### 虚拟机栈或本地方法栈溢出

由于HotSpot虚拟机并不区分虚拟机栈和本地方法栈，所以栈容量只由 `-Xss`参数决定。

关于虚拟机栈和本地方法栈， 在《Java虚拟机规范》 中描述了两种异常：

1. 如果线程请求的栈深度大于虚拟机所允许的最大深度， 将抛出StackOverflowError异常。
2. **如果虚拟机的栈内存允许动态扩展**， 当扩展栈容量无法申请到足够的内存时， 将抛出OutOfMemoryError异常。

《Java虚拟机规范》 明确允许Java虚拟机实现**自行选择是否支持栈的动态扩展**， 而HotSpot虚拟机的选择是不支持扩展， 所以除非在创建线程申请内存时就因无法获得足够内存而出现OutOfMemoryError异常， 否则在线程运行时是不会因为扩展而导致内存溢出的， 只会因为栈容量无法容纳新的栈帧而导致**StackOverflowError**异常。

出现StackOverflowError异常时， 会有明确错误堆栈可供分析， 相对而言比较容易定位到问题所在。 如果使用HotSpot虚拟机默认参数， 栈深度在大多数情况下（因为每个方法压入栈的帧大小并不是一样的， 所以只能说大多数情况下） 到达1000~2000是完全没有问题， 对于正常的方法调用（包括不能做尾递归优化的递归调用） ，这个深度应该完全够用了。 

但是， 如果是建立过多线程导致的内存溢出， 在不能减少线程数量或者更换64位虚拟机的情况下， 就只能通过减少最大堆和减少栈容量来换取更多的线程。 这种通过“减少内存”的手段来解决内存溢出的方式， 如果没有这方面处理经验， 一般比较难以想到， 这一点读者需要在开发32位系统的多线程应用时注意。 也是由于这种问题较为隐蔽， 从JDK 7起， 以上提示信息中“unable to create native thread”后面， 虚拟机会特别注明原因可能是“possiblyout of memory or process/resource limits reached”。

### 方法区和运行时常量池溢出

以下面的例子为例：

String::intern()是一个本地方法， 它的作用是如果字符串常量池中已经包含一个等于此String对象的字符串， 则返回代表池中这个字符串的String对象的引用； 否则， 会将此String对象包含的字符串添加到常量池中， 并且返回此String对象的引用。

自JDK 7起， 原本存放在永久代的字符串常量池被移至Java堆之中。

当前的很多主流框架， 如Spring、 Hibernate对类进行增强时， 都会使用到CGLib这类字节码技术， 当增强的类越多， 就需要越大的方法区以保证动态生成的新类型可以载入内存。 

方法区溢出也是一种常见的内存溢出异常， 一个类如果要被垃圾收集器回收， 要达成的条件是比较苛刻的。 

在JDK 8以后， 永久代便完全退出了历史舞台， 元空间作为其替代者登场。 在默认设置下， 正常的动态创建新类型已经很难再迫使虚拟机产生方法区的溢出异常了。 不过为了让使用者有预防实际应用里出现的破坏性的操作， HotSpot还是提供了一些参数作为元空间的防御措施， 主要包括：

- -XX：MaxMetaspaceSize： 设置元空间最大值， 默认是-1， 即不限制， 或者说只受限于本地内存大小。
- -XX：MetaspaceSize： 指定元空间的初始空间大小， 以字节为单位， 达到该值就会触发垃圾收集进行类型卸载， 同时收集器会对该值进行调整： 如果释放了大量的空间， 就适当降低该值； 如果释放了很少的空间， 那么在不超过-XX： MaxMetaspaceSize（如果设置了的话） 的情况下， 适当提高该值。
- -XX：MinMetaspaceFreeRatio： 作用是在垃圾收集之后控制最小的元空间剩余容量的百分比， 可减少因为元空间不足导致的垃圾收集的频率。 类似的还有-XX： Max-MetaspaceFreeRatio， 用于控制最大的元空间剩余容量的百分比。

### 本机直接内存溢出

直接内存（Direct Memory） 的容量大小可通过`-XX： MaxDirectMemorySize`参数来指定， 如果不去指定， 则默认与Java堆最大值（由-Xmx指定） 一致。

由直接内存导致的内存溢出， 一个明显的特征是在Heap Dump文件中不会看见有什么明显的异常情况， 如果读者发现内存溢出之后产生的Dump文件很小， 而程序中又直接或间接使用了DirectMemory（典型的间接使用就是NIO） ， 那就可以考虑重点检查一下直接内存方面的原因了。

# JVM垃圾回收

问题：

- 内存是如何分配和回收的？
- 哪些内存需要回收？
- 什么时候回收？
- 如何回收？
- parNew 和parallel scavenge 的区别是？



## 垃圾回收算法

- 标记-清除 Mark-Sweep
- 标记-复制：常用于新生代
- 标记-整理 Mark-Compact

分代回收：只是根据对象存活周期的不同将内存分为几块。一般将 java 堆分为新生代和老年代，这样我们就可以根据各个年代的特点选择合适的垃圾收集算法。



## 并行和并发

- **并行（Parallel）** ：指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态。
- **并发（Concurrent）**：指用户线程与垃圾收集线程同时执行（但不一定是并行，可能会交替执行），用户程序在继续运行，而垃圾收集器运行在另一个 CPU 上。

## 垃圾回收器图解



<img src="https://tva1.sinaimg.cn/large/008i3skNly1gxknq4l9o1j30uz0u076f.jpg" alt="image-20211220221546080" style="zoom:33%;" />

![image-20211220221837671](https://tva1.sinaimg.cn/large/008i3skNly1gxknt2ga16j31fo0e2mzi.jpg)

Serial 是单线程的收集器

ParNew 收集器实质上是Serial收集器的多线程并行版本。除了同时使用多条线程进行垃圾收集之外， 其余的行为包括Serial收集器可用的所有控制参数（例如： -XX： SurvivorRatio、 -XX：PretenureSizeThreshold、 -XX： HandlePromotionFailure等） 、 收集算法、 Stop The World、 对象分配规则、 回收策略等都与Serial收集器完全一致， 在实现上这两种收集器也共用了相当多的代码。

ParNew收集器除了支持多线程并行收集之外， 其他与Serial收集器相比并没有太多创新之处。

![image-20211220222205582](https://tva1.sinaimg.cn/large/008i3skNly1gxknwom8opj31h40e6acn.jpg)



![image-20211220223454125](https://tva1.sinaimg.cn/large/008i3skNly1gxkoa08d79j31fi0f0wh6.jpg)

![image-20211220223728691](https://tva1.sinaimg.cn/large/008i3skNly1gxkocp9dq0j31fy0e4adb.jpg)

![image-20211220224748802](https://tva1.sinaimg.cn/large/008i3skNly1gxkonfrgxsj310a0u0gnx.jpg)

![image-20211220225159744](https://tva1.sinaimg.cn/large/008i3skNly1gxkorsmn7nj31g40eqjuj.jpg)

![image-20211221222409725](https://tva1.sinaimg.cn/large/008i3skNly1gxltl62s82j31fs0j2q6h.jpg)

![image-20211221223401283](https://tva1.sinaimg.cn/large/008i3skNly1gxltvehs4kj31f60e0gnc.jpg)

## 垃圾回收器分类

- 经典垃圾回收器
  - 新生代
    - Serial：新生代采用标记-复制算法，老年代采用标记-整理算法。
    - ParNew：serial的多线程版
    - Parallel Scavenge：新生代采用标记-复制算法，老年代采用标记-整理算法。
      - **Parallel Scavenge 收集器关注点是吞吐量（高效率的利用 CPU）。CMS 等垃圾收集器的关注点更多的是用户线程的停顿时间（提高用户体验）。所谓吞吐量就是 CPU 中用于运行用户代码的时间与 CPU 总消耗时间的比值。** Parallel Scavenge 收集器提供了很多参数供用户找到最合适的停顿时间或最大吞吐量，如果对于收集器运作不太了解，手工优化存在困难的时候，使用 Parallel Scavenge 收集器配合自适应调节策略，把内存管理优化交给虚拟机去完成也是一个不错的选择。
  - 老年代：
    - Serial Old
    - Parallel Old：多线程+标记整理
    - CMS：Concurrent Mark Sweep，采用标记-清除算法。目标最短回收停顿时间。
  - G1：面向服务器的垃圾收集器,主要针对配备多颗处理器及大容量内存的机器. 以极高概率满足 GC 停顿时间要求的同时,还具备高吞吐量性能特征.（低停顿+高吞吐）。G1 从整体来看是基于“标记-整理”算法实现的收集器；从局部上来看是基于“标记-复制”算法实现的。
    - G1 收集器在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的 **Region**(这也就是它的名字 Garbage-First 的由来) 。
- 低延迟垃圾回收器
  - ZGC：基于Region 内存布局，不设分代，使用了读屏障、染色指针和内存多重映射等技术实现可并发的标记-整理算法，以低延迟为首要目标。
  - Shenandoah



CMS缺点：

- **对 CPU 资源敏感；**
- **无法处理浮动垃圾；**
- **它使用的回收算法-“标记-清除”算法会导致收集结束时会有大量空间碎片产生。**



Shenandoah与G1的3个明显不同：

- 支持并发的整理算法（最重要）。G1的回收阶段是可以多线程并行的，但不能与用户线程并发。
- 目前默认不使用分代回收
- 摒弃G1中耗费大量内存和计算资源去维护的记忆集，使用“连接矩阵”的全局数据结构来记录跨Region的引用关系。



## 默认垃圾回收器：

- JDK8 默认使用的是 Parallel Scavenge + Parallel Old。但一般不用这个。常用ParNew+CMS吧（因为是唯一搭配呀）
- JDK9~16 默认G1



在JVM中是+XX配置实现的搭配组合：

- -XX:+UseSerialGC，虚拟机运行在Client模式下的默认值，Serial+Serial Old。
- -XX:+UseParNewGC，ParNew+Serial Old，在JDK1.8被废弃，在JDK1.7还可以使用。
- -XX:+UseConcMarkSweepGC，ParNew+CMS+Serial Old。
- -XX:+UseParallelGC，虚拟机运行在Server模式下的默认值，Parallel Scavenge+Serial Old(PS Mark Sweep)。
- -XX:+UseParallelOldGC，Parallel Scavenge+Parallel Old。
- -XX:+UseG1GC，G1+G1。

![image-20211222232903949](https://tva1.sinaimg.cn/large/008i3skNly1gxn12zd7eaj314s0seagg.jpg)

![image-20211222222828422](https://tva1.sinaimg.cn/large/008i3skNgy1gxmzbzszs2j317o0judhp.jpg)

**堆内存常见分配策略：**

- 对象优先分配在eden区
- 大对象直接分配到老年代。大对象就是需要大量连续内存空间的对象（比如：字符串、数组）。
- 长期存活的对象进入老年代



**空间分配担保**：目的是确保Minor GC之前老年代有足够空间容纳新生代所有对象

JDK 6 Update 24 之前，在发生 Minor GC 之前，虚拟机必须先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果这个条件成立，那这一次 Minor GC 可以确保是安全的。如果不成立，则虚拟机会先查看 `-XX:HandlePromotionFailure` 参数的设置值是否允许担保失败(Handle Promotion Failure);如果允许，那会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试进行一次 Minor GC，尽管这次 Minor GC 是有风险的;如果小于，或者 `-XX: HandlePromotionFailure` 设置不允许冒险，那这时就要改为进行一次  Full GC。

JDK 6 Update 24之后的规则变为只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小，就会进行 Minor GC，否则将进行 Full GC。



动态对象年龄判定：Hotspot 遍历所有对象时，按照年龄从小到大对其所占用的大小进行累积，当累积的某个年龄大小超过了 survivor 区的 50% 时（默认值是 50%，可以通过 `-XX:TargetSurvivorRatio=percent` 来设置 ），取这个年龄和 `MaxTenuringThreshold`（默认15岁） 中更小的一个值，作为新的晋升年龄阈值”。



**GC分类**

- Partial GC:

  - Minor GC/Young GC

  - Major GC/Old GC
  - Mixed GC：对整个新生代和老年代进行垃圾回收

- Full GC：收集整个Java堆和方法区



## 如何判断一个对象已经无效？

- 引用计数法
  - 实现简单，效率高，但是目前主流的虚拟机中并没有选择这个算法来管理内存，其最主要的原因是它很难解决对象之间相互循环引用的问题。

- 可达性分析法
  - 通过一系列的称为 **“GC Roots”** 的对象作为起点，从这些节点开始向下搜索，节点所走过的路径称为引用链，当一个对象到 GC Roots 没有任何引用链相连的话，则证明此对象是不可用的。



## 可作为GC Roots的对象

- 虚拟机栈（栈帧中的本地变量表）中引用的对象
- 本地方法栈（Native方法）中引用的对象
- 方法区中类静态属性引用的对象
- 方法区中常量引用的对象
- 所有被同步锁持有的对象



## 引用

JDK1.2 之前，Java 中引用的定义很传统：如果 reference 类型的数据存储的数值代表的是另一块内存的起始地址，就称这块内存代表一个引用。

JDK1.2 以后，Java 对引用的概念进行了扩充，将引用分为强引用、软引用、弱引用、虚引用四种（引用强度逐渐减弱）



- 强引用（StrongReference）

  以前我们使用的大部分引用实际上都是强引用，这是使用最普遍的引用。如果一个对象具有强引用，那就类似于必不可少的生活用品，**垃圾回收器绝不会回收它**。当内存空间不足，Java 虚拟机宁愿抛出 OutOfMemoryError 错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足问题。

- 软引用（SoftReference）

  如果一个对象只具有软引用，那就类似于可有可无的生活用品。**如果内存空间足够，垃圾回收器就不会回收它，如果内存空间不足了，就会回收这些对象的内存。**只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存。

  软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收，JAVA 虚拟机就会把这个软引用加入到与之关联的引用队列中。

- 弱引用（WeakReference）

  如果一个对象只具有弱引用，那就类似于可有可无的生活用品。弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，**一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存**。不过，由于垃圾回收器是一个优先级很低的线程， 因此不一定会很快发现那些只具有弱引用的对象。

  弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java 虚拟机就会把这个弱引用加入到与之关联的引用队列中。

- 虚引用（PhantomReference）

  "虚引用"顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。**如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收。**

  **虚引用主要用来跟踪对象被垃圾回收的活动**。

  **虚引用与软引用和弱引用的一个区别在于：** 虚引用**必须**和引用队列（ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。程序如果发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。

  特别注意，在程序设计中一般很少使用弱引用与虚引用，使用软引用的情况较多，这是因为**软引用可以加速 JVM 对垃圾内存的回收速度，可以维护系统的运行安全，防止内存溢出（OutOfMemory）等问题的产生**。

[你会使用软引用和弱引用吗？](https://cloud.tencent.com/developer/article/1752779)软引用和弱引用的例子不错。



## **常量池的位置**

JDK1.7 之前运行时常量池逻辑包含字符串常量池存放在方法区, 此时 hotspot 虚拟机对方法区的实现为永久代。

JDK1.7 字符串常量池被从方法区拿到了堆中, 这里没有提到运行时常量池,也就是说字符串常量池被单独拿到堆,运行时常量池剩下的东西还在方法区, 也就是 hotspot 中的永久代 。

JDK1.8 hotspot 移除了永久代用元空间(Metaspace)取而代之, 这时候字符串常量池还在堆, 运行时常量池还在方法区, 只不过方法区的实现从永久代变成了元空间(Metaspace)

假如在字符串常量池中存在字符串 "abc"，如果当前没有任何 String 对象引用该字符串常量的话，就说明常量 "abc" 就是废弃常量，如果这时发生内存回收的话而且有必要的话，"abc" 就会被系统清理出常量池了。



## 如何判断一个类是无用的类

方法区主要回收的是无用的类，那么如何判断一个类是无用的类的呢？

判定一个常量是否是“废弃常量”比较简单，而要判定一个类是否是“无用的类”的条件则相对苛刻许多。类需要同时满足下面 3 个条件才能算是 **“无用的类”** ：

- 该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。
- 加载该类的 `ClassLoader` 已经被回收。
- 该类对应的 `java.lang.Class` 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。

虚拟机可以对满足上述 3 个条件的无用类进行回收，这里说的仅仅是“可以”，而并不是和对象一样不使用了就会必然被回收。



# 虚拟机性能监控、故障处理工具

## 6个常用的命令行工具：

| 工具   | 功能                                                         |
| ------ | ------------------------------------------------------------ |
| jps    | 虚拟机进程状况工具。可列出正在运行的虚拟机进程，并现实虚拟机执行主类。 |
| jstat  | 虚拟机统计信息监视工具。虚拟机信息主要有3类：类加载、垃圾收集、运行期编译状况 |
| jinfo  | Java配置信息工具。实时查看和调整虚拟机各项参数。             |
| jmap   | Java内存映像工具。用于生成堆转储快照（heap dump或dump文件）。 |
| jhat   | 虚拟机堆转储快照分析工具。搭配jmap使用，分析jmap生成的堆转储快照。一般不用，用VisualVM或其他。 |
| jstack | Java堆栈跟踪工具。用于生成虚拟机当前时刻的线程快照（threaddump或javacore文件）。线程快照就是当前虚拟机内每一条线程正在执行的方法的堆栈的集合。 |

其他工具：

| 工具  | 功能                                                         |
| ----- | ------------------------------------------------------------ |
| java  | 用于运行class文件或jar文件                                   |
| javac | 编译器，将.java文件编译成.class                              |
| javap | 用于分析字节码。反编译得到字节码指令。也可用其他工具将class文件转换成特定平台上的汇编代码。 |
|       |                                                              |







## 4个常用的可视化工具：

| 可视化工具           | 功能                     |
| -------------------- | ------------------------ |
| JHSDB                | 基于服务性代理的调试工具 |
| JConsole             | Java监视与管理控制台     |
| VisualVM             | 多合-故障处理工具        |
| Java Mission Control | 可持续在线的监控工具     |



## JMX

JMX（Java Management Extensions）， Java 管理扩展，用来管理和监测 Java 程序。最常用到的就是对于 JVM 的监测和管理，比如 JVM 内存、CPU 使用率、线程数、垃圾收集情况等等。另外，还可以用作日志级别的动态修改，比如 log4j 就支持 JMX 方式动态修改线上服务的日志级别。最主要的还是被用来做各种监控工具，比如 Spring Boot Actuator、JConsole、VisualVM 等。

JMX 既是 Java 管理系统的一个标准，一个规范，也是一个接口，一个框架。有标准、有规范是为了让开发者可以定制开发自己的扩展功能，而且作为一个框架来讲，JDK 已经帮我们实现了常用的功能，尤其是对 JVM 的监控和管理。

https://www.cnblogs.com/fengzheng/p/13431845.html

# 类加载机制

## 类文件结构

![image-20211230143210299](https://tva1.sinaimg.cn/large/008i3skNly1gxvuiyxif3j31ce0u0n07.jpg)

可用 `javap` 分析class文件。

## 虚拟机类加载机制

Java虚拟机把描述类的数据从class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这个过程被称作虚拟机的`类加载机制`。

与那些在编译器需要进行连接的语言不同，在Java语言里，`类型的加载、连接和初始化`都是在`程序运行期间`完成的。



一个类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期将会经历7个阶段。

![image-20211230150646970](https://tva1.sinaimg.cn/large/008i3skNly1gxvvitqum7j31fm0juq54.jpg)

加载、 验证、 准备、 初始化和卸载这五个阶段的顺序是确定的， 类型的加载过程必须按照这种顺序按部就班地开始， 而解析阶段则不一定： 它在某些情况下可以在初始化阶段之后再开始，这是为了支持Java语言的运行时绑定特性（也称为动态绑定或晚期绑定） 。 

对于什么时候开始类加载过程的第一个阶段“加载”，《Java虚拟机规范》没有强制约束。

但对于初始化阶段，则严格规定了`有且只有`以下六种情况必须对类进行“初始化”（而加载、验证、准备自然需要在此之前开始）：

1. 遇到 `new、getstatic、putstatic、invokestatic`这四条字节码指令时。能够生成这四条指令的典型Java代码场景有：
   - 使用new关键字实例化对象时。
   - 读取或设置一个类型的静态字段（被final修饰、已在编译器把结果放入常量池的静态字段除外）的时候。
   - 调用一个类型的静态方法时。
2. 使用 `java.lang.reflect`包的方法对类型进行反射调用时。
3. 当初始化类时，如果发现其父类还没进行过初始化，则需要先触发其父类的初始化。
4. 当虚拟机启动时，用户需要指定一个要执行的主类（包含main()的那个类），虚拟机会先初始化这个类。
5. 当使用JDK 7新加入的动态语言支持时， 如果一个java.lang.invoke.MethodHandle实例最后的解析结果为REF_getStatic、 REF_putStatic、 REF_invokeStatic、 REF_newInvokeSpecial四种类型的方法句柄， 并且这个方法句柄对应的类没有进行过初始化， 则需要先触发其初始化。
6. 当一个接口中定义了JDK 8加入的默认方法（被default修饰的接口方法）。



## 类加载的过程

类加载的全过程：加载、验证、准备、解析和初始化五个阶段。

### 加载

这里的加载（Loading）阶段是指整个类加载（Class Loading）过程中的一个阶段。

虚拟机需要完成三件事：

1. 通过一个类的全限定名来获取定义此类的二进制字节流。
2. 将这个字节流所代表的静态存储结构转换为**方法区**的运行时数据结构。
3. 在内存中生成一个代表这个类的 `java.lang.Class`对象，作为方法区这个类的各种数据的访问入口。



加载阶段结束后， Java虚拟机外部的二进制字节流就按照虚拟机所设定的格式存储在方法区之中了， 方法区中的数据存储格式完全由虚拟机实现自行定义， 《Java虚拟机规范》 未规定此区域的具体数据结构。 类型数据妥善安置在方法区之后， 会在Java堆内存中实例化一个java.lang.Class类的对象，这个对象将作为程序访问方法区中的类型数据的外部接口。

### 验证

验证是连接阶段的第一步， 这一阶段的目的是确保Class文件的字节流中包含的信息符合《Java虚拟机规范》 的全部约束要求， 保证这些信息被当作代码运行后不会危害虚拟机自身的安全。

从整体上看， 验证阶段大致上会完成下面四个阶段的检验动作： 文件格式验证、 元数据验证、 字节码验证和符号引用验证。

### 准备

准备阶段是正式为类中定义的变量（即静态变量， 被static修饰的变量） 分配内存并设置类变量初始值的阶段。

这时候进行内存分配的仅包括类变量， 而不包括实例变量， 实例变量将会在对象实例化时随着对象一起分配在Java堆中。

### 解析

解析阶段是Java虚拟机将常量池内的符号引用替换为直接引用的过程。

- 符号引用（Symbolic References） ： 符号引用以一组符号来描述所引用的目标， 符号可以是任何形式的字面量， 只要使用时能无歧义地定位到目标即可。 符号引用与虚拟机实现的内存布局无关， 引用的目标并不一定是已经加载到虚拟机内存当中的内容。 各种虚拟机实现的内存布局可以各不相同，但是它们能接受的符号引用必须都是一致的， 因为符号引用的字面量形式明确定义在《Java虚拟机规范》 的Class文件格式中。eg：在Class文件中 CONSTANT_Class_info、CONSTANT_Fieldref_info、 CONSTANT_Methodref_info等类型的常量出现。
- 直接引用（Direct References） ： 直接引用是可以直接指向目标的指针、 相对偏移量或者是一个能间接定位到目标的句柄。 直接引用是和虚拟机实现的内存布局直接相关的， 同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不会相同。 如果有了直接引用， 那引用的目标必定已经在虚拟机的内存中存在。



解析动作主要针对`类或接口、 字段、 类方法、 接口方法、 方法类型、 方法句柄和调用点限定符`这7类符号引用进行， 分别对应于常量池的CONSTANT_Class_info、 CON-STANT_Fieldref_info、CONSTANT_Methodref_info、 CONSTANT_InterfaceMethodref_info、CONSTANT_MethodType_info、 CONSTANT_MethodHandle_info、 CONSTANT_Dyna-mic_info和CONSTANT_InvokeDynamic_info 8种常量类型。

### 初始化

在之前类加载动作中，除了在加载阶段应用程序可以通过自定义类加载器的方式局部参与外，其余动作都完全由Java虚拟机来主导控制。直到初始化阶段，Java虚拟机才真正可是执行类中编写的Java程序代码，将主导权交给应用程序。

进行准备阶段时， 变量已经赋过一次系统要求的初始零值， 而在初始化阶段， 则会根据程序员通过程序编码制定的主观计划去初始化类变量和其他资源。 我们也可以从另外一种更直接的形式来表达： 初始化阶段就是执行类构造器`<clinit>()`方法的过程。 `<clinit>()`并不是程序员在Java代码中直接编写的方法， 它是Javac编译器的自动生成物。

## 类加载器

Java虚拟机设计团队有意把类加载阶段中的“通过一个类的全限定名来获取描述该类的二进制字节流”这个动作放到Java虚拟机外部去实现， 以便`让应用程序自己决定如何去获取所需的类`。 实现这个动作的代码被称为“类加载器”（Class Loader） 。

对于任意一个类，都必须由加载它的类加载器和这个类本身一起共同确立其在Java虚拟机中的唯一性。

每一个类加载器，都拥有一个独立的类名词空间。

比较两个类是否“相等”，只有在这两个类是由同一个类加载器加载的前提下才有意义。否则，即使这两个类来源于同一个Class文件，被同一个Java虚拟机加载，只要加载它们的类加载器不同，那这两个类就必定不相等。

这里所指的“相等”， 包括代表类的Class对象的equals()方法、 isAssignableFrom()方法、 isInstance()方法的返回结果， 也包括了使用instanceof关键字做对象所属关系判定等各种情况。 



从Java虚拟机的角度来看，只存在两种不同的类加载器：

1. 启动类加载器（Bootstrap ClassLoader）：这个类加载器是使用C++实现的，是虚拟机自身的一部分。
2. 其他所有的类加载器，这些类加载器都由Java实现的，独立于虚拟机外部，并且全部继承自抽象类 `java.lang.ClassLoader`

自JDK 1.2以来，Java一直保持着三层类加载器、双亲委派的类加载架构。（在Java模块化后有一些调整，但主体结构没变）。

### 三层类加载器

JDK 9 之前：

绝大多数Java程序都会使用到以下3个系统提供的类加载器来进行加载。

1. 启动类加载器 Bootstrap Class Loader：负责加载存放在 `<JAVA_HOME>\lib`目录，或被 `-Xbootclasspath`参数所指定的路径中存放的，并且是Java虚拟机能识别的类库加载到虚拟机的内存中。（eg：rt.jar、tools.jar）
2. 扩展类加载器 Extension Class Loader：负责加载 `<JAVA_HOME>\lib\ext`目录，或被 `java.ext.dirs`系统变量所指定的路径中所有的类库。
3. 应用程序类加载器/系统类加载器 Application Class Loader：负责加载用户类路径（ClassPath）上所有的类库。如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中**默认的类加载器**。

如果有需要，还可以自定义类加载器。eg：增加除了磁盘位置之外的Class文件来源， 或者通过类加载器实现类的隔离、 重载等功能。 



### 双亲委派模型（Parents Delegation Model）<img src="https://tva1.sinaimg.cn/large/008i3skNly1gxw1kjs40jj30ug0u0tb3.jpg" alt="image-20211230183558367" style="zoom:50%;" />

各种类加载器支给件的层次关系就被称为类加载器的双亲委派模型。

双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应有自己的父类加载器。不过这里类加载器之间的父子关系一般不是继承（inheritance）的关系来实现的，而是使用组合（composition）关系来复用父类加载器的代码。

**双亲委派模型的工作过程是：**如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到最顶层的启动类加载器中，只有当父类加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去完成加载。

使用双亲委派模型来组织类加载器之间的关系， 一个显而易见的好处就是Java中的类随着它的类加载器一起具备了一种带有优先级的层次关系。 例如类java.lang.Object， 它存放在rt.jar之中， 无论哪一个类加载器要加载这个类， 最终都是委派给处于模型最顶端的启动类加载器进行加载， 因此Object类在程序的各种类加载器环境中都能够保证是同一个类。



双亲委派模型的实现：

```java
//java.lang.ClassLoader的loadClass()
protected synchronized Class<?> loadClass(String name, boolean resolve) throws ClassNotFoundException
{
// 首先， 检查请求的类是否已经被加载过了
Class c = findLoadedClass(name);
if (c == null) {
try {
if (parent != null) {
c = parent.loadClass(name, false);
} else {
c = findBootstrapClassOrNull(name);
}}
catch (ClassNotFoundException e) {
// 如果父类加载器抛出ClassNotFoundException
// 说明父类加载器无法完成加载请求
}i
f (c == null) {
// 在父类加载器无法加载时
// 再调用本身的findClass方法来进行类加载
c = findClass(name);
}
}i
f (resolve) {
resolveClass(c);
}return c;
}
```

 先检查请求加载的类型是否已经被加载过， 若没有则调用父加载器的loadClass()方法， 若父加载器为空则默认使用启动类加载器作为父加载器。 假如父类加载器加载失败， 抛出ClassNotFoundException异常的话， 才调用自己的findClass()方法尝试进行加载。

### Java模块化系统

JDK 9 中引入了Java模块化系统（Java Platform Module System, JPMS）。

（模块化到底怎么样，没看懂）

为了保证兼容性， JDK 9并没有从根本上动摇从JDK 1.2以来运行了二十年之久的三层类加载器架构以及双亲委派模型。 但是为了模块化系统的顺利施行， 模块化下的类加载器仍然发生了一些应该被注意到变动， 主要包括以下几个方面：

1. 扩展类加载器（Extension Class Loader） 被平台类加载器（Platform Class Loader） 取代。
2. JDK 9中虽然仍然维持着三层类加载器和双亲委派的架构， 但类加载的委派关系也发生了变动。 当**平台及应用程序类**加载器收到类加载请求， 在委派给父加载器加载前， 要先判断该类是否能够归属到某一个系统模块中， 如果可以找到这样的归属关系， 就要优先委派给负责那个模块的加载器完成加载。

在Java模块化系统明确的规定了三个类加载器负责各自加载的模块。

<img src="https://tva1.sinaimg.cn/large/008i3skNly1gxw25l0accj30v30u0dia.jpg" alt="image-20211230185608470" style="zoom:50%;" />

​	

# Java内存模型

## 硬件的效率与一致性

![image-20211231223931345](https://tva1.sinaimg.cn/large/008i3skNly1gxxe87ji8ij31f80ocad5.jpg)

基于告诉缓存的存储交互很好的解决了处理器与内存速度之间的矛盾，但带来了一个新问题：缓存一致性（Cache Coherence）。为了解决一致性问题，需要各个处理器访问缓存时都遵循一些协议。这类协议有：MSI、MESI、MOSI。。。

Java虚拟机也有自己的内存模型，并且和这里的内存访问操作及硬件的缓存操作觉有高度的可类比性。

## Java内存模型

Java Memory Model，JMM

![image-20211231224647383](https://tva1.sinaimg.cn/large/008i3skNly1gxxefribo4j31fq0o0tby.jpg)

这里的主内存、工作内存与Java内存区域中的Java堆、栈、方法区等不是一个概念，没有关系。

- Java内存模型规定了所有的变量都存储在主内存中。

- 每条线程还有自己的工作内存，线程中的工作内存中保存了被该线程使用的变量的主内存副本，线程对变量的所有操作（读取、赋值等）都必须在工作内存中进行，而不能直接读写主内存中的数据。
- 不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量值的传递均需要通过主内存来完成。

这里说的变量与java编程中的变量有所区别，它包括了**实例字段、静态字段和构成数组对象的元素**，但是不包括局部变量与方法参数，因为是线程私有的，不会被共享，不会存在竞争问题。



对于主内存和工作内存之间的交互协议，Java内存模型中定义了8种操作来完成，Java虚拟机实现时必须保证这8种操作每一个都是原子的。后来，简化为 `read, write, lock, unlock` 四种。



`volatile` 可以说是Java虚拟机提供的最轻量级的同步机制。当一个变量被定为成 volatile 之后，它将具备两个特性：

1. 保证变量对所有线程的可见性。（并不保证原子性，即使编译出来只有一条字节码指令，也不意味着这条指令就是一个原子操作）
2. 禁止指令重排序优化。

大多数情况下 `volatile` 的总开下比锁要低，因此我们在 `volatile` 与锁的选择中，唯一判断依据便是 `volatile`的语义能否满足使用场景的需求。

对于 `volatile` 变量的特殊规则：

- 在工作内存中，每次使用前都必须先从主内存刷新最新的值，保证能看起其他线程对变量所做的修改。
- 在工作内存中，每次修改后都必须立刻同步回主内存中，保证其他线程可以看到自己对变量的修改。
- 修饰的变量不会被指令重排序优化，从而保证代码的执行顺序与程序的顺序相同。



**原子性：**

尽管虚拟机未把 `lock` 和 `unlock` 操作直接开放给用户使用，但是却提供了更高层次的字节码指令 `monitorenter` 和 `monitorexit` 来隐式的使用这两个操作。这两个字节码指令反映到java代码中就是同步快`synchronized`关键字。



**可见性：**

除了 `volatile` 之外，Java还有两个关键字可以实现可见性，`synchronized` 和 `final`。

`final` 的可见性是指：被`final`修饰的字段在构造器中一旦被初始化完成，并且构造没有把 `this` 的引用传递出去，那么在其他线程中就能看见 `final` 字段的值。



**有序性：**

如果在本线程内观察，所有操作都是有序的。

如果在一个线程观察另一个线程，所有的操作都是无序的。



## 先行发生（Happens-Before）原则

如果Java 内存模型中所有的有序性都只靠 volatile 和 synchronized 来完成，那么很多操作将会变得非常啰嗦。

而Java通过先行发生（Happens-Before）原则，对数据是否存在竞争，线程是否安全进行了判断。

先行发生是指：Java内存模型中定义的两项操作之间的偏序关系，如果操作A先行发生与操作B，那就是说在发送操作B之前，操作A产生的影响能被操作B观察到。影响包括修改了内存中共享变量的值、发送了消息、调用了方法等。

以下是Java内存模型中的先行发生关系：（如果两个操作之间的关系不在此列， 无法从下列规则推导出来， 则它们就没有顺序性保障， 虚拟机可以对它们随意地进行重排序。）

- 程序次序规则 Program Order Rule：在一个线程内，按照控制流程顺序，书写在前面的操作先行发生与书写在后面的操作
- 管程锁定规则 Monitor Lock Rule：一个unlock 操作先行发生与后面对**同一个锁**的lock操作。
- 线程启动规则 Thread Start Rule：Thread对象的start()方法先行发生与此线程的每一个动作。
- 线程终止规则 Thead Termination Rule：线程中的所有操作都先行发生于对此线程的终止检测，可以通过 `Thread::jion()` 方法是否结束、`Thread::isAlive()`的返回值等手段检测线程是否已经终止执行。
- 线程中断规则 Thread Interruption Rule：对线程`interrput()`方法的调用先行发生于被中断线程的代码检测到众中断事件的发生，可以通过 `Thread::interrupted()`方法检测到是否有中断发生。
- 对象终结规则 Finalize Rule：一个对象的初始化完成（构造函数执行结束）先行发生于它的finalize()方法的开始。
- 传递性 Transitivity：如果操作A先行发生与操作B，操作B先行发生与操作C，那么操作A先行发生于操作C。



## Java 与线程

线程是比进程更轻量级的调度执行单位，引入了线程，可以把一个进程的资源分配和执行调度分开，各个线程既可以共享进程资源（内存地址、文件I/O等），又可以独立调度。

目前线程是Java进行处理器资源调度的最基本单位。

主流Java虚拟机的线程模型都是基于操作系统原生线程模型来实现的，即采用1：1线程模型。



**阻塞和等待的区别：**

- 阻塞：在等待获取一个排他锁，这个事件将在另一个线程放弃这个锁的时候发生
- 等待：则是在等待一段时间，或者唤醒动作的发生。

![image-20220102231554144](https://tva1.sinaimg.cn/large/008i3skNly1gxzqiq3m1aj31ao0u0tb5.jpg)

## Java 与协程【不是很理解】

 1： 1的内核线程模型是如今Java虚拟机线程实现的主流选择， 但是这种映射到操作系统上的线程天然的缺陷是切换、 调度成本高昂， 系统能容纳的线程数量也很有限。 

传统的Java Web服务器的线程池的容量通常在**几十个到两百之间**， 当程序员把数以百万计的请求往线程池里面灌时， 系统即使能处理得过来， 但其中的切换损耗也是相当可观的。

内核线程的调度成本主要来自于用户态与核心态之间的状态转换， 而这两种状态转换的开销主要来自于**响应中断、 保护和恢复执行现场**的成本。 

后来， 操作系统开始提供多线程的支持， 靠应用自己模拟多线程的做法自然是变少了许多， 但也并没有完全消失， 而是演化为用户线程继续存在。 由于最初多数的用户线程是被设计成协同式调度（Cooperative Scheduling） 的， 所以它有了一个别名——“**协程**”（Coroutine） 。 又由于这时候的协程会完整地做调用栈的保护、 恢复工作， 所以今天也被称为“有栈协程”（Stackfull Coroutine） ， 起这样的名字是为了便于跟后来的“无栈协程”（Stackless Coroutine） 区分开。 无栈协程不是本节的主角， 不过还是可以简单提一下它的典型应用， 即各种语言中的await、 async、 yield这类关键字。 无栈协程本质上是一种有限状态机， 状态保存在闭包里， 自然比有栈协程恢复调用栈要轻量得多， 但功能也相对更有限。

对于有栈协程， 有一种特例实现名为**纤程**（Fiber）



## 线程安全

线程安全的实现方法：

### 互斥同步（阻塞同步）

互斥是手段，同步是目的。

临界区（critical section）、互斥量（mutex）、信号量（semaphore）都是常见的互斥实现方法。

在Java中，最基本的互斥同步手段就是 `synchronized` ，这是一种块结构（block structured）的同步语法。

synchronized 经过javac 编译后，会在同步块前后分别形成 `monitorenter` 和`monitorexit`两个字节码指令。这两个字节码指令都需要一个reference类型的参数来指明要锁定和解锁的对象。如果代码中synchronized明确指明了对象参数，那就以这个对象的引用作为reference（即获得的是你传入的，传入对象就是对象锁【this也是对象锁】，传入类就是类锁），如果没有明确指定，将根据synchronized修饰的方法类型（实例方法还是类方法），来决定是获取对象实例还是类型对应的Class对象来作为线程要持有的锁（即修饰实例方法获取的是对象锁，修饰静态方法获取的是类锁）。

被 synchronized 修饰的同步块对同一条线程来说是**可重入**的。这意味着同一线程反复进入同步块也不会出现把自己锁死的情况。

被 synchronized 修饰的同步块在持有锁的线程执行完毕并释放锁之前，会无条件的阻塞后面其他线程的进入。

JDK 5起，Java提供了`java.util.concurrent`包（J.U.T包），其中`java.util.concurrent.locks.Lock接口`便成了Java的另一种全新的互斥同步手段。基于Lock接口，用户能够以非块结构（Non-Block Structured）来实现互斥同步，从而摆脱语言特性的束缚，在类库层面去实现同步。

重入锁（`ReentrantLock`）是Lock接口最常见的一种实现。在基本用法上，ReentrantLock 和 synchronized相似，只是写法稍微不同，且 ReentrantLock 比 synchronized 多了一些高级功能，主要有3项：

1. 等待可中断
2. 可实现公平锁
3. 可绑定多个条件

JDK 6 开始对synchronized进行了锁优化，ReentrantLock 和 synchronized 的性能基本能持平，因此性能已不再是选择 ReentrantLock 或 synchronized 的判断因素。

推荐在 synchronized 和 ReentrantLock 都能满足的场景优先使用 synchronized，原因如下：

- synchronized 足够清晰，简单。
- Lock要确保在finally中释放锁。synchronized由Java虚拟机来保证。
- 从长远看，Java虚拟机更容易针对synchronized进行优化。因为Java虚拟机通过在线程和对象的元数据中记录synchronized中锁的相关信息，使用Lock的话，Java虚拟机很难得知具体哪些锁对象是由特定线程所持有的。

### 非阻塞同步

互斥同步面临的主要问题是进行线程阻塞和唤醒锁带来的性能开销，因此这种同步也被称为阻塞同步（Blocking Synchronization），属于悲观的并发策略。

非阻塞同步（Non-Blocking Synchronization）是基于冲突检测的乐观并发策略，冲突了再进行补偿，最常用的补偿措施是不断重试，直到没有竞争的共享数据位置。也称为无锁（Lock-Free）编程。

乐观并发策略需要依赖硬件指令集的发展，因为要保证操作和冲突检测这两个步骤具备原子性。

这类指令通常用：

- 测试并设置（Test and Set）
- 获取并增加（Fetch and Increment）
- 交换（Swap）
- 比较并交换（Compare and Swap，CAS）
- 加载链接/条件存储（Load Linked/Store Conditional，LL/SC）

Java里最终暴露出来的是CAS操作，CAS指令需要有3个操作数，分别是变量的内存地址V，旧的预期值A，准备设置的新值B。CAS指令执行时，当且仅当V符合A时，处理器才会用B更新V的值，否则不执行更新。但无论是否执行更新，都会返回V的旧值。

在JDK 5之后， Java类库中才开始使用CAS操作， 该操作由`sun.misc.Unsafe`类里面的`compareAndSwapInt()`和`compareAndSwapLong()`等几个方法包装提供。 HotSpot虚拟机在内部对这些方法做了特殊处理， 即时编译出来的结果就是一条平台相关的处理器CAS指令， 没有方法调用的过程。 不过由于Unsafe类在设计上就不是提供给用户程序调用的类（Unsafe::getUnsafe()的代码中限制了只有启动类加载器（Bootstrap ClassLoader） 加载的Class才能访问它） ， 因此在JDK 9之前只有Java类库可以使用CAS， 譬如J.U.C包里面的整数原子类， 其中的`compareAndSet()`和`getAndIncrement()`等方法都使用了Unsafe类的CAS操作来实现。 而如果用户程序也有使用CAS操作的需求， 那要么就采用反射手段突破Unsafe的访问限制， 要么就只能通过Java类库API来间接使用它。 直到JDK 9之后， Java类库才在`VarHandle`类里开放了面向用户程序使用的CAS操作。

为了解决CAS的ABA问题，J.U.C包提供了一个带有标记的原子引用类AtomicStampedReference，它可以通过控制变量值的版本来保证CAS的正确性。不管目前这个类相当鸡肋，大部分情况下ABA问题不会影响程序并发的正确性，如果需要解决ABA问题，采用传统的互斥同步可能会比原子类更高效。

### 无同步方案

线程本地存储（Thread Local Storage）：如果一段代码中所需要的数据必须与其他代码共享，那就看看这些共享数据的代码能否保证只在同一个线程中执行。如果能保证，就可以把共享数据的可见范围限制在同一个线程之内，这样无须同步也能保证线程之间不出现数据竞争的问题。

符合这种特点的应用并不少见，大部分使用消费队列的架构模式（eg：生产者-消费者模式）都会将产品的消费过程限制在一个线程中消费完，其中最重要的一种应用实例就是经典Web交互模型中的“一个请求对应一个服务器线程”（Thread-pre-Request）的处理方式，这种处理方式的广泛应用使得很多Web服务端应用都可以使用线程本地存储来解决线程安全问题。

Java中，如果一个变量要被多线程访问，可以使用 `volatile`将其声明为“易变的”。如果一个变量只要被某个线程独享，可以通过 `java.lang.ThreadLocal`类来实现线程本地存储的功能。每一个线程的Thread对象中都有一个`ThreadLocalMap`对象，这个对象存储了一组以`ThreadLocal.threadLocalHashCode`为键，以**本地线程变量为值**的键值对，`ThreadLocal`对象就是当前线程的`ThreadLocalMap`的访问入口，每一个`ThreadLocal`对象都包含了一个独一无二的`threadLocalHashCode`，这个值就可以在线程键值对中找到对应的本地线程变量。

## 锁优化

JDK 6，虚拟机团队锁进行了多种优化，有：

- 适应性自旋 Adaptive Spinning
- 锁消除 Lock Elimination
- 锁膨胀 Lock Coarsening
- 轻量级锁 Lightweight Locking
- 偏向锁 Biased Locking

### 自旋锁与自适应自旋

互斥同步对性能最大的影响是阻塞的实现， 挂起线程和恢复线程的操作都需要转入内核态中完成， 这些操作给Java虚拟机的并发性能带来了很大的压力。 同时， 我们注意到在许多应用上， 共享数据的锁定状态只会持续很短的一段时间， 为了这段时间去挂起和恢复线程并不值得。如果物理机器有一个以上的处理器或者处理器核心， 能让两个或以上的线程同时并行执行， 我们
就可以让后面请求锁的那个线程“稍等一会”， 但不放弃处理器的执行时间， 看看持有锁的线程是否很快就会释放锁。 为了让线程等待， 我们只须让线程执行一个忙循环（自旋） ， 这项技术就是所谓的自旋锁。

自旋锁在1.4.2中就引进了，不过默认是关闭的。JDK 6开始改为默认开启。默认自旋10次。

JDK 6 对自旋锁的优化，引入了自适应的自旋。自适应自旋意味着自旋次数不再是固定的了，由前一次在同一个锁上的自旋时间以及锁的拥有者的状态决定。如果同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也很有可能再次成功，进而允许自旋等待持续更长的时间。如果队友某个锁，自旋很少成功获得过锁，那以后要获取这个锁将可能直接省略自旋过程。

### 锁消除

锁消除是指虚拟机即时编译器在运行时，对一些代码要求同步，但是对被检测到不可能存在共享数据竞争的锁进行消除。

锁消除的主要判断依据来源于逃逸分析的数据支持。

如果判断到一段代码，在堆上的所有数据都不会逃逸出去被其他线程访问到，那就可以把他们当做栈上数据对待，认为他们是线程私有的，同步加锁自然就不用再进行了。

### 锁粗化

如果虚拟机检测到有一串零碎的操作都对同一个对象加锁，就会把加锁同步的范围粗化到整个操作序列的外部。

### 轻量级锁

轻量级锁并不是来替代重量级锁的，它的设计初衷是在没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量的性能消耗。

![image-20220104220758386](https://tva1.sinaimg.cn/large/008i3skNly1gy1zsn42i3j31hi0kg77h.jpg)

在代码即将进入同步块时，如果此同步对象没有被锁定（锁标志位为“01”状态），虚拟机首先将在当前线程的栈帧中简历一个名为锁记录（Lock Record）的空间，用于存储锁对象目前的Mark Word的拷贝。

然后虚拟机将使用 `CAS`操作尝试把对象的Mark Word更新为指向Lock Record 的指针。

如果更新动作成功了，代表该线程拥有了这个对象的锁，并且对象Mark Word的锁标志位（Mark Word的最后两个比特）将变为“00”，表示此对象正处于轻量级锁定状态。

如果更新操作失败了，意味着有线程与当前线程竞争该对象的锁。虚拟机首先会检查对象的Mark Word是否指向当前线程的栈帧，如果是，说明当前线程已经拥有了这个对象的锁，直接进入同步块。否则说明这个锁对象给其他线程抢占了，此时轻量级锁升级为重量级锁，锁标志位状态变为“10”。

轻量级锁能提升程序同步性能的依据是“对于绝大部分的锁，在整个同步周期内都是不存在竞争的”。如果没有竞争，轻量级锁便通过CAS操作成功避免了使用互斥量的开销。但如果确实存在锁竞争，除了互斥量本身的开销外，还额外发生了CAS的开销。因此在有竞争的情况下，轻量级锁反而会比传统的重量级锁更慢。

### 偏向锁

偏向锁的目的是消除数据在无竞争情况下的同步原语。如果说轻量级锁是在无竞争的情况下使用CAS操作去消除同步使用的互斥量，那偏向锁就是在无竞争情况下把整个同步都消除掉，连CAS操作都不做。

这个锁会偏向于第一个获得它的线程，如果在接下来的执行过程中，该锁一直没有被其他的线程获取，则持有偏向锁的线程将永远不需要再进行同步。

偏向锁默认是开启的。当锁对象第一次被线程获取时，虚拟机会把对象头中的标志位设置为“01”、把偏向模式设置为1，表示进入偏向模式。同时使用CAS操作把获取到这个锁的线程ID记录在对象的Mark Word中。果CAS操作成功， 持有偏向锁的线程以后每次进入这个锁相关的同步块时， 虚拟机都可以不再进行任何同步操作（例如加锁、 解锁及对Mark Word的更新操作等）。

一旦出现另外一个线程去尝试获取这个锁的情况， 偏向模式就马上宣告结束。 根据锁对象目前是否处于被锁定的状态决定是否撤销偏向（偏向模式设置为“0”） ， 撤销后标志位恢复到未锁定（标志位为“01”） 或轻量级锁定（标志位为“00”） 的状态， 后续的同步操作就按照上面介绍的轻量级锁那样去执行。 

![image-20220104222401948](https://tva1.sinaimg.cn/large/008i3skNly1gy209beeg9j31fa0rq0xw.jpg)

如果程序中大多数的锁都总是被多个不同的线程访问，那么偏向模式就是多余的。有时使用参数 `-XX:-UseBisedLocking=false`来禁止偏向锁优化反而可以提升性能。

（JDK 15 废弃偏向锁）
