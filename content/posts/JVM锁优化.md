---
title: "JVM锁优化"
date: 2021-12-06T23:28:22+08:00
categories: ["技术分享"]
tags: ["Java并发"]
draft: false
---



本文主要目的是理清 Java 的**偏向锁、轻量级锁、自选锁、锁消除**等概念。

JDK 6，虚拟机团队锁进行了多种优化。在JVM层面实现加锁逻辑，不用依赖底层操作系统，避免了切换的消耗。主要有：

- 适应性自旋 Adaptive Spinning
- 锁消除 Lock Elimination
- 锁膨胀 Lock Coarsening
- 轻量级锁 Lightweight Locking
- 偏向锁 Biased Locking

# 锁升级过程

**偏向锁：** 在锁对象的对象头中记录当前获取到该锁的线程ID，该线程下次如果还来获取该锁就可以直接获取到。

**轻量级锁：** 由偏向锁升级而来，当一个线程获取到锁后，此时这把锁是偏向锁。如果这时有第二个线程来竞争锁，偏向锁就会升级为轻量级锁。之所以叫轻量级锁，是为了和重量级锁区分开，轻量级锁底层是通过自旋实现的，不会阻塞线程。

**自旋：** 自选锁就是线程在获取锁的过程中，不会去阻塞线程，也就无所谓的唤醒线程，阻塞和唤醒这两个步骤都需要操作系统去执行，因此耗时，自旋锁是线程通过CAS获取预期的一个标记，如果没有获取到，就继续循环获取。如果获取到了则表示获得了该锁，这个过程线程一直在运行中，相对而言没有使用太多的操作系统资源，比较轻量。

**重量级锁：** 如果自旋次数过多仍然没有获取到锁，则会升级为重量级锁，重量级锁会导致线程阻塞。



1. 当JVM认为只有某个线程才会执行同步代码，即没有竞争时会使用偏向锁。在Mark Word 直接记录线程ID，当线程来执行代码，对比线程ID是否相等，相等则当前线程直接获得到锁，执行同步代码。如果不相等，CAS尝试修改当前线程ID，如果修改成功，还是能得到锁，执行同步代码，如果CAS失败，说明有竞争环境，此时偏向锁升级为轻量级锁。

2. 在轻量级锁的状态下，当前线程会在栈帧下创建一个锁记录Lock Record，Lock Record会把Mark Word的信息拷贝进去，而且有个owner指针指向加锁对象。线程执行同步代码时，则用CAS尝试将Mark Word 指向到栈帧的Lock Record，如果CAS修改成功，则获得到轻量级锁。如果修改失败，则自旋重试，自旋一定次数失败后，则升级为重量级锁。

3. 重量级锁用到monitor对象，依赖操作系统的mutex指令，需要用户态和内核态切换，消耗性能。



即：

只有一个线程进入临界区，偏向锁

多个线程交替进入临界区，轻量级锁

多线程同时进入临界区，重量级锁

|  锁状态  |             假定情况             |       竞争处理策略       |
| :------: | :------------------------------: | :----------------------: |
|  偏向锁  |  假定获取锁的一直都是同一个线程  |       升级为轻量锁       |
| 轻量级锁 | 假定锁被占用时不会有其他线程获取 |    自旋等待，超时升级    |
| 重量级锁 |      最坏情况，经常发生竞争      | 直接将要获取锁的线程挂起 |



# 偏向锁

偏向锁的相关信息是保存在Java对象的对象头中的。

在HotSpot虚拟机中，Java对象在内存中存储的布局分为3块区域：对象头、实例数据和对齐填充。

对象头包含：包含对象的HashCode、分代年龄、锁标志位、线程持有的锁、偏向线程ID等，这部分数据的长度在32位和64位的虚拟机中分别为32bit和64bit，官方称为Mark Word。

![image-20220104220758386](https://tva1.sinaimg.cn/large/008i3skNly1gy1zsn42i3j31hi0kg77h.jpg)

偏向锁的目的是消除数据在无竞争情况下的同步原语。如果说轻量级锁是在无竞争的情况下使用CAS操作去消除同步使用的互斥量，那偏向锁就是在无竞争情况下把整个同步都消除掉，连CAS操作都不做。

这个锁会偏向于第一个获得它的线程，如果在接下来的执行过程中，该锁一直没有被其他的线程获取，则持有偏向锁的线程将永远不需要再进行同步。

偏向锁默认是开启的。当锁对象第一次被线程获取时，虚拟机会把对象头中的标志位设置为“01”、把偏向模式设置为1，表示进入偏向模式。同时使用CAS操作把获取到这个锁的线程ID记录在对象的Mark Word中。果CAS操作成功， 持有偏向锁的线程以后每次进入这个锁相关的同步块时， 虚拟机都可以不再进行任何同步操作（例如加锁、 解锁及对Mark Word的更新操作等）。

一旦出现另外一个线程去尝试获取这个锁的情况， 偏向模式就马上宣告结束。 根据锁对象目前是否处于被锁定的状态决定是否撤销偏向（偏向模式设置为“0”） ， 撤销后标志位恢复到未锁定（标志位为“01”） 或轻量级锁定（标志位为“00”） 的状态， 后续的同步操作就按照上面介绍的轻量级锁那样去执行。 

![image-20220104222401948](https://tva1.sinaimg.cn/large/008i3skNly1gy209beeg9j31fa0rq0xw.jpg)

如果程序中大多数的锁都总是被多个不同的线程访问，那么偏向模式就是多余的。有时使用参数 `-XX:-UseBisedLocking=false`来禁止偏向锁优化反而可以提升性能。

（JDK 15 废弃偏向锁）

# 轻量级锁

轻量级锁并不是来替代重量级锁的，它的设计初衷是在没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量的性能消耗。

在代码即将进入同步块时，如果此同步对象没有被锁定（锁标志位为“01”状态），虚拟机首先将在当前线程的栈帧中简历一个名为锁记录（Lock Record）的空间，用于存储锁对象目前的Mark Word的拷贝。

然后虚拟机将使用 `CAS`操作尝试把对象的Mark Word更新为指向Lock Record 的指针。

如果更新动作成功了，代表该线程拥有了这个对象的锁，并且对象Mark Word的锁标志位（Mark Word的最后两个比特）将变为“00”，表示此对象正处于轻量级锁定状态。

如果更新操作失败了，意味着有线程与当前线程竞争该对象的锁。虚拟机首先会检查对象的Mark Word是否指向当前线程的栈帧，如果是，说明当前线程已经拥有了这个对象的锁，直接进入同步块。否则说明这个锁对象给其他线程抢占了，此时轻量级锁升级为重量级锁，锁标志位状态变为“10”。

轻量级锁能提升程序同步性能的依据是“对于绝大部分的锁，在整个同步周期内都是不存在竞争的”。如果没有竞争，轻量级锁便通过CAS操作成功避免了使用互斥量的开销。但如果确实存在锁竞争，除了互斥量本身的开销外，还额外发生了CAS的开销。因此在有竞争的情况下，轻量级锁反而会比传统的重量级锁更慢。

![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/7/27/164daacd8802c2e0~tplv-t2oaga2asx-watermark.awebp)

# 自旋锁与自适应自旋

引入自旋锁是为了节省线程挂起和恢复的开销。

互斥同步对性能最大的影响是阻塞的实现， 挂起线程和恢复线程的操作都需要转入内核态中完成， 这些操作给Java虚拟机的并发性能带来了很大的压力。 同时， 我们注意到在许多应用上， 共享数据的锁定状态只会持续很短的一段时间， 为了这段时间去挂起和恢复线程并不值得。如果物理机器有一个以上的处理器或者处理器核心， 能让两个或以上的线程同时并行执行， 我们
就可以让后面请求锁的那个线程“稍等一会”， 但不放弃处理器的执行时间， 看看持有锁的线程是否很快就会释放锁。 为了让线程等待， 我们只须让线程执行一个忙循环（自旋） ， 这项技术就是所谓的自旋锁。

自旋锁在1.4.2中就引进了，不过默认是关闭的。JDK 6开始改为默认开启。默认自旋10次。

JDK 6 对自旋锁的优化，引入了自适应的自旋。自适应自旋意味着自旋次数不再是固定的了，由前一次在同一个锁上的自旋时间以及锁的拥有者的状态决定。

如果同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也很有可能再次成功，进而允许自旋等待持续更长的时间。如果对于某个锁，自旋很少成功获得过锁，那以后要获取这个锁将可能直接省略自旋过程。

如果前面线程成功获取锁并且正常运行，那么本次获取锁的可能性很大，所以自旋的次数相对多一些；如果前面线程很少成功获取锁，那么本次获取锁的概率也很小，就可能不执行自旋了。

# 锁粗化

如果在一段代码中同一线程反复获取、释放同一个对象的锁，将会产生不必要的性能开销，所以要把获取锁的范围扩大，对同一个对象的锁操作只进行一次，在头部获取锁，在尾部释放锁。

如果虚拟机检测到有一串零碎的操作都对同一个对象加锁，就会把加锁同步的范围粗化到整个操作序列的外部。

# 锁消除

锁消除是指JIT（Just in time 即时编译器）在运行时分析到使用了锁的同步代码在实际运行中不可能存在竞争的情况，对锁进行消除。

锁消除的主要判断依据来源于逃逸分析的数据支持。

如果判断到一段代码，在堆上的所有数据都不会逃逸出去被其他线程访问到，那就可以把他们当做栈上数据对待，认为他们是线程私有的，同步加锁自然就不用再进行了。

# 参考

- https://segmentfault.com/a/1190000021220448
- https://www.jianshu.com/p/937a876372ff
- https://mp.weixin.qq.com/s/YilCUO-uUliXE4Bg6e_8Vg
- https://segmentfault.com/a/1190000040447521
- https://juejin.cn/post/6844903550586191885#heading-0
- https://juejin.cn/post/6844903647713689607
- 《深入理解Java虚拟机》
